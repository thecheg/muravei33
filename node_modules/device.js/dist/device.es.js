var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var hasClass_1 = createCommonjsModule(function (module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = hasClass;
function hasClass(element, className) {
  if (element.classList) { return !!className && element.classList.contains(className); }else { return (" " + element.className + " ").indexOf(" " + className + " ") !== -1; }
}
module.exports = exports["default"];
});

var addClass_1 = createCommonjsModule(function (module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addClass;



var _hasClass2 = _interopRequireDefault(hasClass_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function addClass(element, className) {
  if (element.classList) { element.classList.add(className); }else if (!(0, _hasClass2.default)(element)) { element.className = element.className + ' ' + className; }
}
module.exports = exports['default'];
});

var removeClass = function removeClass(element, className) {
  if (element.classList) { element.classList.remove(className); }else { element.className = element.className.replace(new RegExp('(^|\\s)' + className + '(?:\\s|$)', 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, ''); }
};

var index = createCommonjsModule(function (module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasClass = exports.removeClass = exports.addClass = undefined;



var _addClass2 = _interopRequireDefault(addClass_1);



var _removeClass2 = _interopRequireDefault(removeClass);



var _hasClass2 = _interopRequireDefault(hasClass_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.addClass = _addClass2.default;
exports.removeClass = _removeClass2.default;
exports.hasClass = _hasClass2.default;
exports.default = { addClass: _addClass2.default, removeClass: _removeClass2.default, hasClass: _hasClass2.default };
});

var index_2 = index.removeClass;
var index_3 = index.addClass;

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal || freeSelf || Function('return this')();

var _root = root;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return _root.Date.now();
};

var now_1 = now;

/** Built-in value references. */
var Symbol = _root.Symbol;

var _Symbol = Symbol;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

var _getRawTag = getRawTag;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

var _objectToString = objectToString;

/** `Object#toString` result references. */
var nullTag = '[object Null]';
var undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}

var _baseGetTag = baseGetTag;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
}

var isSymbol_1 = isSymbol;

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol_1(value)) {
    return NAN;
  }
  if (isObject_1(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject_1(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var toNumber_1 = toNumber;

/** Error message constants. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;
var nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber_1(wait) || 0;
  if (isObject_1(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber_1(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now_1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now_1());
  }

  function debounced() {
    var time = now_1(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

var debounce_1 = debounce;

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject_1(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce_1(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

var throttle_1 = throttle;

var documentTimeout = null;

var documentCallbacks = [];
var stopDocumentTimeout = function () {
  if (documentTimeout) {
    clearTimeout(documentTimeout);
    documentTimeout = null;
  }
};

var waitForDocument = function (callback) {
  if (callback) {
    documentCallbacks.push(callback);
  }
  if (typeof document !== 'undefined') {
    stopDocumentTimeout();
    for (var i = 0, l = documentCallbacks.length; i < l; i++) {
      documentCallbacks[i](document);
    }
    documentCallbacks.length = 0;
    return;
  }
  stopDocumentTimeout();
  setTimeout(function () {
    waitForDocument();
  }, 100);
};

var getUserAgent = function () {
  if (typeof document !== 'undefined') {
    return window.navigator.userAgent;
  }
  return '';
};


var isIE = function (v) {
  return RegExp('msie' + (!isNaN(v)?('\\s'+v):''), 'i').test(navigator.userAgent);
};

// const getDocumentElement = () => {
//   if (typeof document !== 'undefined') {
//     return document.documentElement;
//   }
//   return null;
// };

// Check if documentElement already has a given class.
// const hasClass = (domNode, className) => {
//   let regex;
//   regex = new RegExp(className, 'i');
//   return domNode.className.match(regex);
// };

// // Add one or more CSS classes to the <html> element.
// const addClass = (domNode, className) => {
//   let currentClassNames = null;
//   if (!hasClass(domNode, className)) {
//     currentClassNames = domNode.className.replace(/^\s+|\s+$/g, '');
//     domNode.className = currentClassNames + ' ' + className;
//   }
// };

// // Remove single CSS class from the <html> element.
// const removeClass = (domNode, className) => {
//   if (hasClass(domNode, className)) {
//     domNode.className = domNode.className.replace(' ' + className, '');
//   }
// };

var staticDevice = null;

var Device = function Device(userAgent) {
  var this$1 = this;
  if ( userAgent === void 0 ) userAgent = null;

  this.state = {
    addedClasses: false
  };

  this.matchCache = {};
  this.featureCache = {};
  this.classes = '';

  this.setUserAgent(userAgent);

  this.callback = null;

  if (typeof document === 'undefined' && !this.userAgent) {
    // console.log('document net defined');
    waitForDocument(function () {
      this$1.setUserAgent();
    });
  }
};

var prototypeAccessors = { features: {},deviceorientation: {},ie9: {},touchDevice: {},touch: {},ios: {},iphone: {},ipod: {},ipad: {},android: {},androidPhone: {},androidTablet: {},blackberry: {},blackberryPhone: {},blackberryTablet: {},windows: {},ie10: {},windowsPhone: {},windowsTablet: {},fxos: {},fxosPhone: {},fxosTablet: {},meego: {},cordova: {},nodeWebkit: {},mobile: {},tablet: {},desktop: {},television: {},portrait: {},landscape: {} };
var staticAccessors = { device: {} };

staticAccessors.device.get = function () {
  if (!staticDevice) {
    staticDevice = new Device();
  }
  return staticDevice;
};

Device.prototype.match = function match (needle) {
  if (!this.matchCache[needle]) {
    this.matchCache[needle] = this.userAgent.indexOf(needle) > -1;
  }
  return this.matchCache[needle];
};

Device.prototype.feature = function feature (key) {

  return this.featureCache[key];
};

Device.prototype.addFeature = function addFeature (key, value) {
  if (!this.featureCache[key]) {
    this.featureCache[key] = value;
  }
  return value;
};

Device.prototype.setUserAgent = function setUserAgent (userAgent) {
    if ( userAgent === void 0 ) userAgent = null;

  this.userAgent = userAgent || this.userAgent || getUserAgent();

  if (this.userAgent) {
    stopDocumentTimeout();
    this.matchCache = {};
    this.userAgent = this.userAgent.toLowerCase();
  }
};

Device.prototype.onOrientationChange = function onOrientationChange (orientation) {
  // console.log('orientation', orientation);
};

Device.prototype.getClasses = function getClasses () {
  if (this.classes) {
    return this.classes;
  }

  if (!this.userAgent) {
    this.setUserAgent();
  }

  if (this.landscape) {
    this.classes += 'landscape ';
  } else {
    this.classes += 'portrait ';
  }

  if (this.touch) {
    this.classes += 'touch ';
  }
  if (this.ios) {
    if (this.ipad) {
      this.classes += 'ios ipad tablet ';
    } else if (this.iphone) {
      this.classes += 'ios iphone mobile ';
    } else if (this.ipod) {
      this.classes += 'ios ipod mobile ';
    }
  } else if (this.android) {
    if (this.androidTablet) {
      this.classes += 'android tablet ';
    } else {
      this.classes += 'android mobile ';
    }
  } else if (this.blackberry) {
    if (this.blackberryTablet) {
      this.classes += 'blackberry tablet ';
    } else {
      this.classes += 'blackberry mobile ';
    }
  } else if (this.windows) {
    if (this.windowsTablet) {
      this.classes += 'windows tablet ';
    } else if (this.windowsPhone) {
      this.classes += 'windows mobile ';
    } else {
      this.classes += 'windows desktop ';
    }
  } else if (this.fxos) {
    if (this.fxosTablet) {
      this.classes += 'fxos tablet ';
    } else {
      this.classes += 'fxos mobile ';
    }
  } else if (this.meego) {
    this.classes += 'meego mobile ';
  } else if (this.nodeWebkit) {
    this.classes += 'node-webkit ';
  } else if (this.television) {
    this.classes += 'television ';
  } else if (this.desktop) {
    this.classes += 'desktop ';
  }

  if (this.cordova) {
    this.classes += 'cordova ';
  }

  if (!this.desktop && this.deviceorientation) {
    this.classes += 'deviceorientation ';
  }
  this.classes = this.classes.slice(0, -1);
  return this.classes;
};

Device.prototype.addClasses = function addClasses (targetNode) {
  if (!this.targetNode) {
    this.targetNode = targetNode;
    if (!targetNode && typeof document !== 'undefined') {
      this.targetNode = document.documentElement;
    }

    if (!this.targetNode) {
      // console.warn('addClasses to nothing?');
      return;
    }

    if (!this.userAgent) {
      this.setUserAgent();
    }

    this.commitClasses();

    this.addListener();
  }
};

Device.prototype.addListener = function addListener () {
    var this$1 = this;


  if (this.hasListener) {
    return;
  }

  this.hasListener = true;
  this.handleOrientation = this.handleOrientation.bind(this);
  this.onResize = throttle_1(this.handleOrientation, 200);

  var onOrientationChange = function () {
    setTimeout(function () {
      this$1.handleOrientation();
    }, 10);
  };

  if ('onorientationchange' in window) {
    window.addEventListener('orientationchange', onOrientationChange, false);
  } else {
    window.addEventListener('resize', this.onResize, false);
  }
  onOrientationChange();
};

Device.prototype.handleOrientation = function handleOrientation () {
  this.onOrientationChange(this.landscape);
  if (!this.targetNode){
    return;
  }
  if (this.landscape) {
    index_2(this.targetNode, 'portrait');
    index_3(this.targetNode, 'landscape');
  } else {
    index_2(this.targetNode, 'landscape');
    index_3(this.targetNode, 'portrait');
  }
};

Device.prototype.commitClasses = function commitClasses () {
  if (this.state.addedClasses || !this.targetNode) {
    return;
  }
  this.state.addedClasses = true;
  this.targetNode.className += this.getClasses();
};

prototypeAccessors.features.get = function () {

  return {
    wheelEvent: this.feature('wheelEvent') || this.addFeature('wheelEvent', ('onwheel' in document.createElement('div') ? 'wheel' : // Modern browsers support "wheel"
        document.onmousewheel !== undefined ? 'mousewheel' : // Webkit and IE support at least "mousewheel"
        'DOMMouseScroll')) // let's assume that remaining browsers are older Firefox
  };
  // detect available wheel event
  // support = 'onwheel' in document.createElement('div') ? 'wheel' : // Modern browsers support "wheel"
  // document.onmousewheel !== undefined ? 'mousewheel' : // Webkit and IE support at least "mousewheel"
  // 'DOMMouseScroll'; // let's assume that remaining browsers are older Firefox

};

prototypeAccessors.deviceorientation.get = function () {
  if (!this.canOrientate) {
    this.canOrientate =
      'ondeviceorientation' in window || 'deviceorientation' in window;
  }
  return !this.desktop && this.canOrientate;
};

prototypeAccessors.ie9.get = function (){
  if (!this.matchCache['ie9']) {
    if (typeof document !== 'undefined') {
      this.matchCache['ie9'] = this.windows && isIE(10);
    }
  }
  return this.matchCache['ie9'] || false;
};

prototypeAccessors.touchDevice.get = function () {
  if (!this.matchCache['touchDevice']) {
    if (typeof document !== 'undefined') {
      this.matchCache['touchDevice'] = !!(navigator && navigator.userAgent) && navigator.userAgent.match(/(iPhone|iPod|iPad|Android|playbook|silk|BlackBerry|BB10|Windows Phone|Tizen|Bada|webOS|IEMobile|Opera Mini)/);
    }
  }
  return this.matchCache['touchDevice'] || false;
};


prototypeAccessors.touch.get = function () {
  if (!this.matchCache['touch']) {
    if (typeof document !== 'undefined') {
      this.matchCache['touch'] = (('ontouchstart' in window) ||( window.DocumentTouch && document instanceof DocumentTouch) || (navigator && navigator.msMaxTouchPoints > 0) || (navigator && navigator.maxTouchPoints));
    }
  }
  return this.matchCache['touch'] || false;

};

prototypeAccessors.ios.get = function () {
  return this.iphone || this.ipod || this.ipad;
};

prototypeAccessors.iphone.get = function () {
  return !this.windows && this.match('iphone');
};

prototypeAccessors.ipod.get = function () {
  return this.match('ipod');
};

prototypeAccessors.ipad.get = function () {
  return this.match('ipad');
};

prototypeAccessors.android.get = function () {
  return !this.windows && this.match('android');
};

prototypeAccessors.androidPhone.get = function () {
  return this.android && this.match('mobile');
};

prototypeAccessors.androidTablet.get = function () {
  return this.android && !this.match('mobile');
};

prototypeAccessors.blackberry.get = function () {
  return this.match('blackberry') || this.match('bb10') || this.match('rim');
};

prototypeAccessors.blackberryPhone.get = function () {
  return this.blackberry && !this.match('tablet');
};

prototypeAccessors.blackberryTablet.get = function () {
  return this.blackberry && this.match('tablet');
};

prototypeAccessors.windows.get = function () {
  return this.match('windows');
};

prototypeAccessors.ie10.get = function (){
  if (!this.matchCache['ie10']) {
    if (typeof document !== 'undefined') {
      this.matchCache['ie10'] = this.windows && isIE(10);
    }
  }
  return this.matchCache['ie10'] || false;
};

prototypeAccessors.windowsPhone.get = function () {
  return this.windows && this.match('phone');
};

prototypeAccessors.windowsTablet.get = function () {
  return this.windows && (this.match('touch') && !this.windowsPhone);
};

prototypeAccessors.fxos.get = function () {
  return (
    (this.match('(mobile;') || this.match('(tablet;')) && this.match('; rv:')
  );
};

prototypeAccessors.fxosPhone.get = function () {
  return this.fxos && this.match('mobile');
};

prototypeAccessors.fxosTablet.get = function () {
  return this.fxos && this.match('tablet');
};

prototypeAccessors.meego.get = function () {
  return this.match('meego');
};

prototypeAccessors.cordova.get = function () {
  return window.cordova && location.protocol === 'file:';
};

prototypeAccessors.nodeWebkit.get = function () {
  return typeof window.process === 'object';
};

prototypeAccessors.mobile.get = function () {
  return (
    this.androidPhone ||
    this.iphone ||
    this.ipod ||
    this.windowsPhone ||
    this.blackberryPhone ||
    this.fxosPhone ||
    this.meego
  );
};

prototypeAccessors.tablet.get = function () {
  return (
    this.ipad ||
    this.androidTablet ||
    this.blackberryTablet ||
    this.windowsTablet ||
    this.fxosTablet
  );
};

prototypeAccessors.desktop.get = function () {
  return !this.tablet && !this.mobile;
};

prototypeAccessors.television.get = function () {
    var this$1 = this;

  var i,
    television = [
      'googletv',
      'viera',
      'smarttv',
      'internet.tv',
      'netcast',
      'nettv',
      'appletv',
      'boxee',
      'kylo',
      'roku',
      'dlnadoc',
      'roku',
      'pov_tv',
      'hbbtv',
      'ce-html'
    ];

  i = 0;
  while (i++ < television.length) {
    if (this$1.match(television[i])) {
      return true;
    }
  }
  return false;
};

prototypeAccessors.portrait.get = function () {
  if ('orientation' in window) {
    return window.orientation === 0;
  }
  if (typeof window !== 'undefined') {
    return window.innerHeight / window.innerWidth > 1;
  }
  return false;
};

prototypeAccessors.landscape.get = function () {
  if (typeof window !== 'undefined') {
    if ('orientation' in window) {
      return window.orientation !== 0;
    }
    return window.innerHeight / window.innerWidth < 1;
  }
  return false;
};

Object.defineProperties( Device.prototype, prototypeAccessors );
Object.defineProperties( Device, staticAccessors );
var device = new Device();

export { device };export default Device;
//# sourceMappingURL=device.es.js.map

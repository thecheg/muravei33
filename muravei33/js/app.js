/*!
 * jQuery JavaScript Library v3.6.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2021-03-02T17:08Z
 */
(function(global, factory) {
	"use strict";
	if (typeof module === "object" && typeof module.exports === "object") {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory(global, true) :
			function(w) {
				if (!w.document) {
					throw new Error("jQuery requires a window with a document");
				}
				return factory(w);
			};
	} else {
		factory(global);
	}
	// Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";
	var arr = [];
	var getProto = Object.getPrototypeOf;
	var slice = arr.slice;
	var flat = arr.flat ? function(array) {
		return arr.flat.call(array);
	} : function(array) {
		return arr.concat.apply([], array);
	};
	var push = arr.push;
	var indexOf = arr.indexOf;
	var class2type = {};
	var toString = class2type.toString;
	var hasOwn = class2type.hasOwnProperty;
	var fnToString = hasOwn.toString;
	var ObjectFunctionString = fnToString.call(Object);
	var support = {};
	var isFunction = function isFunction(obj) {
		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};
	var isWindow = function isWindow(obj) {
		return obj != null && obj === obj.window;
	};
	var document = window.document;
	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval(code, node, doc) {
		doc = doc || document;
		var i, val,
			script = doc.createElement("script");
		script.text = code;
		if (node) {
			for (i in preservedScriptAttributes) {
				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[i] || node.getAttribute && node.getAttribute(i);
				if (val) {
					script.setAttribute(i, val);
				}
			}
		}
		doc.head.appendChild(script).parentNode.removeChild(script);
	}

	function toType(obj) {
		if (obj == null) {
			return obj + "";
		}
		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[toString.call(obj)] || "object" :
			typeof obj;
	}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module
	var
		version = "3.6.0",
		// Define a local copy of jQuery
		jQuery = function(selector, context) {
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init(selector, context);
		};
	jQuery.fn = jQuery.prototype = {
		// The current version of jQuery being used
		jquery: version,
		constructor: jQuery,
		// The default length of a jQuery object is 0
		length: 0,
		toArray: function() {
			return slice.call(this);
		},
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function(num) {
			// Return all the elements in a clean array
			if (num == null) {
				return slice.call(this);
			}
			// Return just the one element from the set
			return num < 0 ? this[num + this.length] : this[num];
		},
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function(elems) {
			// Build a new jQuery matched element set
			var ret = jQuery.merge(this.constructor(), elems);
			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			// Return the newly-formed element set
			return ret;
		},
		// Execute a callback for every element in the matched set.
		each: function(callback) {
			return jQuery.each(this, callback);
		},
		map: function(callback) {
			return this.pushStack(jQuery.map(this, function(elem, i) {
				return callback.call(elem, i, elem);
			}));
		},
		slice: function() {
			return this.pushStack(slice.apply(this, arguments));
		},
		first: function() {
			return this.eq(0);
		},
		last: function() {
			return this.eq(-1);
		},
		even: function() {
			return this.pushStack(jQuery.grep(this, function(_elem, i) {
				return (i + 1) % 2;
			}));
		},
		odd: function() {
			return this.pushStack(jQuery.grep(this, function(_elem, i) {
				return i % 2;
			}));
		},
		eq: function(i) {
			var len = this.length,
				j = +i + (i < 0 ? len : 0);
			return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
		},
		end: function() {
			return this.prevObject || this.constructor();
		},
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};
	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;
		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;
			// Skip the boolean and the target
			target = arguments[i] || {};
			i++;
		}
		// Handle case when target is a string or something (possible in deep copy)
		if (typeof target !== "object" && !isFunction(target)) {
			target = {};
		}
		// Extend jQuery itself if only one argument is passed
		if (i === length) {
			target = this;
			i--;
		}
		for (; i < length; i++) {
			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {
				// Extend the base object
				for (name in options) {
					copy = options[name];
					// Prevent Object.prototype pollution
					// Prevent never-ending loop
					if (name === "__proto__" || target === copy) {
						continue;
					}
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (jQuery.isPlainObject(copy) ||
							(copyIsArray = Array.isArray(copy)))) {
						src = target[name];
						// Ensure proper type for the source value
						if (copyIsArray && !Array.isArray(src)) {
							clone = [];
						} else if (!copyIsArray && !jQuery.isPlainObject(src)) {
							clone = {};
						} else {
							clone = src;
						}
						copyIsArray = false;
						// Never move original objects, clone them
						target[name] = jQuery.extend(deep, clone, copy);
						// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}
		// Return the modified object
		return target;
	};
	jQuery.extend({
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
		// Assume jQuery is ready without the ready module
		isReady: true,
		error: function(msg) {
			throw new Error(msg);
		},
		noop: function() {},
		isPlainObject: function(obj) {
			var proto, Ctor;
			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if (!obj || toString.call(obj) !== "[object Object]") {
				return false;
			}
			proto = getProto(obj);
			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if (!proto) {
				return true;
			}
			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
			return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
		},
		isEmptyObject: function(obj) {
			var name;
			for (name in obj) {
				return false;
			}
			return true;
		},
		// Evaluates a script in a provided context; falls back to the global one
		// if not specified.
		globalEval: function(code, options, doc) {
			DOMEval(code, {
				nonce: options && options.nonce
			}, doc);
		},
		each: function(obj, callback) {
			var length, i = 0;
			if (isArrayLike(obj)) {
				length = obj.length;
				for (; i < length; i++) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			} else {
				for (i in obj) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			}
			return obj;
		},
		// results is for internal usage only
		makeArray: function(arr, results) {
			var ret = results || [];
			if (arr != null) {
				if (isArrayLike(Object(arr))) {
					jQuery.merge(ret,
						typeof arr === "string" ? [arr] : arr
					);
				} else {
					push.call(ret, arr);
				}
			}
			return ret;
		},
		inArray: function(elem, arr, i) {
			return arr == null ? -1 : indexOf.call(arr, elem, i);
		},
		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function(first, second) {
			var len = +second.length,
				j = 0,
				i = first.length;
			for (; j < len; j++) {
				first[i++] = second[j];
			}
			first.length = i;
			return first;
		},
		grep: function(elems, callback, invert) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;
			// Go through the array, only saving the items
			// that pass the validator function
			for (; i < length; i++) {
				callbackInverse = !callback(elems[i], i);
				if (callbackInverse !== callbackExpect) {
					matches.push(elems[i]);
				}
			}
			return matches;
		},
		// arg is for internal usage only
		map: function(elems, callback, arg) {
			var length, value,
				i = 0,
				ret = [];
			// Go through the array, translating each of the items to their new values
			if (isArrayLike(elems)) {
				length = elems.length;
				for (; i < length; i++) {
					value = callback(elems[i], i, arg);
					if (value != null) {
						ret.push(value);
					}
				}
				// Go through every key on the object,
			} else {
				for (i in elems) {
					value = callback(elems[i], i, arg);
					if (value != null) {
						ret.push(value);
					}
				}
			}
			// Flatten any nested arrays
			return flat(ret);
		},
		// A global GUID counter for objects
		guid: 1,
		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});
	if (typeof Symbol === "function") {
		jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
	}
	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
		function(_i, name) {
			class2type["[object " + name + "]"] = name.toLowerCase();
		});

	function isArrayLike(obj) {
		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = toType(obj);
		if (isFunction(obj) || isWindow(obj)) {
			return false;
		}
		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && (length - 1) in obj;
	}
	var Sizzle =
		/*!
		 * Sizzle CSS Selector Engine v2.3.6
		 * https://sizzlejs.com/
		 *
		 * Copyright JS Foundation and other contributors
		 * Released under the MIT license
		 * https://js.foundation/
		 *
		 * Date: 2021-02-16
		 */
		(function(window) {
			var i,
				support,
				Expr,
				getText,
				isXML,
				tokenize,
				compile,
				select,
				outermostContext,
				sortInput,
				hasDuplicate,
				// Local document vars
				setDocument,
				document,
				docElem,
				documentIsHTML,
				rbuggyQSA,
				rbuggyMatches,
				matches,
				contains,
				// Instance-specific data
				expando = "sizzle" + 1 * new Date(),
				preferredDoc = window.document,
				dirruns = 0,
				done = 0,
				classCache = createCache(),
				tokenCache = createCache(),
				compilerCache = createCache(),
				nonnativeSelectorCache = createCache(),
				sortOrder = function(a, b) {
					if (a === b) {
						hasDuplicate = true;
					}
					return 0;
				},
				// Instance methods
				hasOwn = ({}).hasOwnProperty,
				arr = [],
				pop = arr.pop,
				pushNative = arr.push,
				push = arr.push,
				slice = arr.slice,
				// Use a stripped-down indexOf as it's faster than native
				// https://jsperf.com/thor-indexof-vs-for/5
				indexOf = function(list, elem) {
					var i = 0,
						len = list.length;
					for (; i < len; i++) {
						if (list[i] === elem) {
							return i;
						}
					}
					return -1;
				},
				booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
				"ismap|loop|multiple|open|readonly|required|scoped",
				// Regular expressions
				// http://www.w3.org/TR/css3-selectors/#whitespace
				whitespace = "[\\x20\\t\\r\\n\\f]",
				// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
				identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
				"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
				// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
				attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
				// Operator (capture 2)
				"*([*^$|!~]?=)" + whitespace +
				// "Attribute values must be CSS identifiers [capture 5]
				// or strings [capture 3 or capture 4]"
				"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
				whitespace + "*\\]",
				pseudos = ":(" + identifier + ")(?:\\((" +
				// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
				// 1. quoted (capture 3; capture 4 or capture 5)
				"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
				// 2. simple (capture 6)
				"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
				// 3. anything else (capture 2)
				".*" +
				")\\)|)",
				// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
				rwhitespace = new RegExp(whitespace + "+", "g"),
				rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
					whitespace + "+$", "g"),
				rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
				rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
					"*"),
				rdescend = new RegExp(whitespace + "|>"),
				rpseudo = new RegExp(pseudos),
				ridentifier = new RegExp("^" + identifier + "$"),
				matchExpr = {
					"ID": new RegExp("^#(" + identifier + ")"),
					"CLASS": new RegExp("^\\.(" + identifier + ")"),
					"TAG": new RegExp("^(" + identifier + "|[*])"),
					"ATTR": new RegExp("^" + attributes),
					"PSEUDO": new RegExp("^" + pseudos),
					"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
						whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
						whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
					"bool": new RegExp("^(?:" + booleans + ")$", "i"),
					// For use in libraries implementing .is()
					// We use this for POS matching in `select`
					"needsContext": new RegExp("^" + whitespace +
						"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
						"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
				},
				rhtml = /HTML$/i,
				rinputs = /^(?:input|select|textarea|button)$/i,
				rheader = /^h\d$/i,
				rnative = /^[^{]+\{\s*\[native \w/,
				// Easily-parseable/retrievable ID or TAG or CLASS selectors
				rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
				rsibling = /[+~]/,
				// CSS escapes
				// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
				runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"),
				funescape = function(escape, nonHex) {
					var high = "0x" + escape.slice(1) - 0x10000;
					return nonHex ?
						// Strip the backslash prefix from a non-hex escape sequence
						nonHex :
						// Replace a hexadecimal escape sequence with the encoded Unicode code point
						// Support: IE <=11+
						// For values outside the Basic Multilingual Plane (BMP), manually construct a
						// surrogate pair
						high < 0 ?
						String.fromCharCode(high + 0x10000) :
						String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
				},
				// CSS string/identifier serialization
				// https://drafts.csswg.org/cssom/#common-serializing-idioms
				rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
				fcssescape = function(ch, asCodePoint) {
					if (asCodePoint) {
						// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
						if (ch === "\0") {
							return "\uFFFD";
						}
						// Control characters and (dependent upon position) numbers get escaped as code points
						return ch.slice(0, -1) + "\\" +
							ch.charCodeAt(ch.length - 1).toString(16) + " ";
					}
					// Other potentially-special ASCII characters get backslash-escaped
					return "\\" + ch;
				},
				// Used for iframes
				// See setDocument()
				// Removing the function wrapper causes a "Permission Denied"
				// error in IE
				unloadHandler = function() {
					setDocument();
				},
				inDisabledFieldset = addCombinator(
					function(elem) {
						return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
					}, {
						dir: "parentNode",
						next: "legend"
					}
				);
			// Optimize for push.apply( _, NodeList )
			try {
				push.apply(
					(arr = slice.call(preferredDoc.childNodes)),
					preferredDoc.childNodes
				);
				// Support: Android<4.0
				// Detect silently failing push.apply
				// eslint-disable-next-line no-unused-expressions
				arr[preferredDoc.childNodes.length].nodeType;
			} catch (e) {
				push = {
					apply: arr.length ?
						// Leverage slice if possible
						function(target, els) {
							pushNative.apply(target, slice.call(els));
						} :
						// Support: IE<9
						// Otherwise append directly
						function(target, els) {
							var j = target.length,
								i = 0;
							// Can't trust NodeList.length
							while ((target[j++] = els[i++])) {}
							target.length = j - 1;
						}
				};
			}

			function Sizzle(selector, context, results, seed) {
				var m, i, elem, nid, match, groups, newSelector,
					newContext = context && context.ownerDocument,
					// nodeType defaults to 9, since context defaults to document
					nodeType = context ? context.nodeType : 9;
				results = results || [];
				// Return early from calls with invalid selector or context
				if (typeof selector !== "string" || !selector ||
					nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
					return results;
				}
				// Try to shortcut find operations (as opposed to filters) in HTML documents
				if (!seed) {
					setDocument(context);
					context = context || document;
					if (documentIsHTML) {
						// If the selector is sufficiently simple, try using a "get*By*" DOM method
						// (excepting DocumentFragment context, where the methods don't exist)
						if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
							// ID selector
							if ((m = match[1])) {
								// Document context
								if (nodeType === 9) {
									if ((elem = context.getElementById(m))) {
										// Support: IE, Opera, Webkit
										// TODO: identify versions
										// getElementById can match elements by name instead of ID
										if (elem.id === m) {
											results.push(elem);
											return results;
										}
									} else {
										return results;
									}
									// Element context
								} else {
									// Support: IE, Opera, Webkit
									// TODO: identify versions
									// getElementById can match elements by name instead of ID
									if (newContext && (elem = newContext.getElementById(m)) &&
										contains(context, elem) &&
										elem.id === m) {
										results.push(elem);
										return results;
									}
								}
								// Type selector
							} else if (match[2]) {
								push.apply(results, context.getElementsByTagName(selector));
								return results;
								// Class selector
							} else if ((m = match[3]) && support.getElementsByClassName &&
								context.getElementsByClassName) {
								push.apply(results, context.getElementsByClassName(m));
								return results;
							}
						}
						// Take advantage of querySelectorAll
						if (support.qsa &&
							!nonnativeSelectorCache[selector + " "] &&
							(!rbuggyQSA || !rbuggyQSA.test(selector)) &&
							// Support: IE 8 only
							// Exclude object elements
							(nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
							newSelector = selector;
							newContext = context;
							// qSA considers elements outside a scoping root when evaluating child or
							// descendant combinators, which is not what we want.
							// In such cases, we work around the behavior by prefixing every selector in the
							// list with an ID selector referencing the scope context.
							// The technique has to be used as well when a leading combinator is used
							// as such selectors are not recognized by querySelectorAll.
							// Thanks to Andrew Dupont for this technique.
							if (nodeType === 1 &&
								(rdescend.test(selector) || rcombinators.test(selector))) {
								// Expand context for sibling selectors
								newContext = rsibling.test(selector) && testContext(context.parentNode) ||
									context;
								// We can use :scope instead of the ID hack if the browser
								// supports it & if we're not changing the context.
								if (newContext !== context || !support.scope) {
									// Capture the context ID, setting it first if necessary
									if ((nid = context.getAttribute("id"))) {
										nid = nid.replace(rcssescape, fcssescape);
									} else {
										context.setAttribute("id", (nid = expando));
									}
								}
								// Prefix every selector in the list
								groups = tokenize(selector);
								i = groups.length;
								while (i--) {
									groups[i] = (nid ? "#" + nid : ":scope") + " " +
										toSelector(groups[i]);
								}
								newSelector = groups.join(",");
							}
							try {
								push.apply(results,
									newContext.querySelectorAll(newSelector)
								);
								return results;
							} catch (qsaError) {
								nonnativeSelectorCache(selector, true);
							} finally {
								if (nid === expando) {
									context.removeAttribute("id");
								}
							}
						}
					}
				}
				// All others
				return select(selector.replace(rtrim, "$1"), context, results, seed);
			}
			/**
			 * Create key-value caches of limited size
			 * @returns {function(string, object)} Returns the Object data after storing it on itself with
			 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
			 *	deleting the oldest entry
			 */
			function createCache() {
				var keys = [];

				function cache(key, value) {
					// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
					if (keys.push(key + " ") > Expr.cacheLength) {
						// Only keep the most recent entries
						delete cache[keys.shift()];
					}
					return (cache[key + " "] = value);
				}
				return cache;
			}
			/**
			 * Mark a function for special use by Sizzle
			 * @param {Function} fn The function to mark
			 */
			function markFunction(fn) {
				fn[expando] = true;
				return fn;
			}
			/**
			 * Support testing using an element
			 * @param {Function} fn Passed the created element and returns a boolean result
			 */
			function assert(fn) {
				var el = document.createElement("fieldset");
				try {
					return !!fn(el);
				} catch (e) {
					return false;
				} finally {
					// Remove from its parent by default
					if (el.parentNode) {
						el.parentNode.removeChild(el);
					}
					// release memory in IE
					el = null;
				}
			}
			/**
			 * Adds the same handler for all of the specified attrs
			 * @param {String} attrs Pipe-separated list of attributes
			 * @param {Function} handler The method that will be applied
			 */
			function addHandle(attrs, handler) {
				var arr = attrs.split("|"),
					i = arr.length;
				while (i--) {
					Expr.attrHandle[arr[i]] = handler;
				}
			}
			/**
			 * Checks document order of two siblings
			 * @param {Element} a
			 * @param {Element} b
			 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
			 */
			function siblingCheck(a, b) {
				var cur = b && a,
					diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
					a.sourceIndex - b.sourceIndex;
				// Use IE sourceIndex if available on both nodes
				if (diff) {
					return diff;
				}
				// Check if b follows a
				if (cur) {
					while ((cur = cur.nextSibling)) {
						if (cur === b) {
							return -1;
						}
					}
				}
				return a ? 1 : -1;
			}
			/**
			 * Returns a function to use in pseudos for input types
			 * @param {String} type
			 */
			function createInputPseudo(type) {
				return function(elem) {
					var name = elem.nodeName.toLowerCase();
					return name === "input" && elem.type === type;
				};
			}
			/**
			 * Returns a function to use in pseudos for buttons
			 * @param {String} type
			 */
			function createButtonPseudo(type) {
				return function(elem) {
					var name = elem.nodeName.toLowerCase();
					return (name === "input" || name === "button") && elem.type === type;
				};
			}
			/**
			 * Returns a function to use in pseudos for :enabled/:disabled
			 * @param {Boolean} disabled true for :disabled; false for :enabled
			 */
			function createDisabledPseudo(disabled) {
				// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
				return function(elem) {
					// Only certain elements can match :enabled or :disabled
					// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
					// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
					if ("form" in elem) {
						// Check for inherited disabledness on relevant non-disabled elements:
						// * listed form-associated elements in a disabled fieldset
						//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
						//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
						// * option elements in a disabled optgroup
						//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
						// All such elements have a "form" property.
						if (elem.parentNode && elem.disabled === false) {
							// Option elements defer to a parent optgroup if present
							if ("label" in elem) {
								if ("label" in elem.parentNode) {
									return elem.parentNode.disabled === disabled;
								} else {
									return elem.disabled === disabled;
								}
							}
							// Support: IE 6 - 11
							// Use the isDisabled shortcut property to check for disabled fieldset ancestors
							return elem.isDisabled === disabled ||
								// Where there is no isDisabled, check manually
								/* jshint -W018 */
								elem.isDisabled !== !disabled &&
								inDisabledFieldset(elem) === disabled;
						}
						return elem.disabled === disabled;
						// Try to winnow out elements that can't be disabled before trusting the disabled property.
						// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
						// even exist on them, let alone have a boolean value.
					} else if ("label" in elem) {
						return elem.disabled === disabled;
					}
					// Remaining elements are neither :enabled nor :disabled
					return false;
				};
			}
			/**
			 * Returns a function to use in pseudos for positionals
			 * @param {Function} fn
			 */
			function createPositionalPseudo(fn) {
				return markFunction(function(argument) {
					argument = +argument;
					return markFunction(function(seed, matches) {
						var j,
							matchIndexes = fn([], seed.length, argument),
							i = matchIndexes.length;
						// Match elements found at the specified indexes
						while (i--) {
							if (seed[(j = matchIndexes[i])]) {
								seed[j] = !(matches[j] = seed[j]);
							}
						}
					});
				});
			}
			/**
			 * Checks a node for validity as a Sizzle context
			 * @param {Element|Object=} context
			 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
			 */
			function testContext(context) {
				return context && typeof context.getElementsByTagName !== "undefined" && context;
			}
			// Expose support vars for convenience
			support = Sizzle.support = {};
			/**
			 * Detects XML nodes
			 * @param {Element|Object} elem An element or a document
			 * @returns {Boolean} True iff elem is a non-HTML XML node
			 */
			isXML = Sizzle.isXML = function(elem) {
				var namespace = elem && elem.namespaceURI,
					docElem = elem && (elem.ownerDocument || elem).documentElement;
				// Support: IE <=8
				// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
				// https://bugs.jquery.com/ticket/4833
				return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
			};
			/**
			 * Sets document-related variables once based on the current document
			 * @param {Element|Object} [doc] An element or document object to use to set the document
			 * @returns {Object} Returns the current document
			 */
			setDocument = Sizzle.setDocument = function(node) {
				var hasCompare, subWindow,
					doc = node ? node.ownerDocument || node : preferredDoc;
				// Return early if doc is invalid or already selected
				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
					return document;
				}
				// Update global variables
				document = doc;
				docElem = document.documentElement;
				documentIsHTML = !isXML(document);
				// Support: IE 9 - 11+, Edge 12 - 18+
				// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				if (preferredDoc != document &&
					(subWindow = document.defaultView) && subWindow.top !== subWindow) {
					// Support: IE 11, Edge
					if (subWindow.addEventListener) {
						subWindow.addEventListener("unload", unloadHandler, false);
						// Support: IE 9 - 10 only
					} else if (subWindow.attachEvent) {
						subWindow.attachEvent("onunload", unloadHandler);
					}
				}
				// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
				// Safari 4 - 5 only, Opera <=11.6 - 12.x only
				// IE/Edge & older browsers don't support the :scope pseudo-class.
				// Support: Safari 6.0 only
				// Safari 6.0 supports :scope but it's an alias of :root there.
				support.scope = assert(function(el) {
					docElem.appendChild(el).appendChild(document.createElement("div"));
					return typeof el.querySelectorAll !== "undefined" &&
						!el.querySelectorAll(":scope fieldset div").length;
				});
				/* Attributes
				---------------------------------------------------------------------- */
				// Support: IE<8
				// Verify that getAttribute really returns attributes and not properties
				// (excepting IE8 booleans)
				support.attributes = assert(function(el) {
					el.className = "i";
					return !el.getAttribute("className");
				});
				/* getElement(s)By*
				---------------------------------------------------------------------- */
				// Check if getElementsByTagName("*") returns only elements
				support.getElementsByTagName = assert(function(el) {
					el.appendChild(document.createComment(""));
					return !el.getElementsByTagName("*").length;
				});
				// Support: IE<9
				support.getElementsByClassName = rnative.test(document.getElementsByClassName);
				// Support: IE<10
				// Check if getElementById returns elements by name
				// The broken getElementById methods don't pick up programmatically-set names,
				// so use a roundabout getElementsByName test
				support.getById = assert(function(el) {
					docElem.appendChild(el).id = expando;
					return !document.getElementsByName || !document.getElementsByName(expando).length;
				});
				// ID filter and find
				if (support.getById) {
					Expr.filter["ID"] = function(id) {
						var attrId = id.replace(runescape, funescape);
						return function(elem) {
							return elem.getAttribute("id") === attrId;
						};
					};
					Expr.find["ID"] = function(id, context) {
						if (typeof context.getElementById !== "undefined" && documentIsHTML) {
							var elem = context.getElementById(id);
							return elem ? [elem] : [];
						}
					};
				} else {
					Expr.filter["ID"] = function(id) {
						var attrId = id.replace(runescape, funescape);
						return function(elem) {
							var node = typeof elem.getAttributeNode !== "undefined" &&
								elem.getAttributeNode("id");
							return node && node.value === attrId;
						};
					};
					// Support: IE 6 - 7 only
					// getElementById is not reliable as a find shortcut
					Expr.find["ID"] = function(id, context) {
						if (typeof context.getElementById !== "undefined" && documentIsHTML) {
							var node, i, elems,
								elem = context.getElementById(id);
							if (elem) {
								// Verify the id attribute
								node = elem.getAttributeNode("id");
								if (node && node.value === id) {
									return [elem];
								}
								// Fall back on getElementsByName
								elems = context.getElementsByName(id);
								i = 0;
								while ((elem = elems[i++])) {
									node = elem.getAttributeNode("id");
									if (node && node.value === id) {
										return [elem];
									}
								}
							}
							return [];
						}
					};
				}
				// Tag
				Expr.find["TAG"] = support.getElementsByTagName ?
					function(tag, context) {
						if (typeof context.getElementsByTagName !== "undefined") {
							return context.getElementsByTagName(tag);
							// DocumentFragment nodes don't have gEBTN
						} else if (support.qsa) {
							return context.querySelectorAll(tag);
						}
					} :
					function(tag, context) {
						var elem,
							tmp = [],
							i = 0,
							// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
							results = context.getElementsByTagName(tag);
						// Filter out possible comments
						if (tag === "*") {
							while ((elem = results[i++])) {
								if (elem.nodeType === 1) {
									tmp.push(elem);
								}
							}
							return tmp;
						}
						return results;
					};
				// Class
				Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
					if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
						return context.getElementsByClassName(className);
					}
				};
				/* QSA/matchesSelector
				---------------------------------------------------------------------- */
				// QSA and matchesSelector support
				// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
				rbuggyMatches = [];
				// qSa(:focus) reports false when true (Chrome 21)
				// We allow this because of a bug in IE8/9 that throws an error
				// whenever `document.activeElement` is accessed on an iframe
				// So, we allow :focus to pass through QSA all the time to avoid the IE error
				// See https://bugs.jquery.com/ticket/13378
				rbuggyQSA = [];
				if ((support.qsa = rnative.test(document.querySelectorAll))) {
					// Build QSA regex
					// Regex strategy adopted from Diego Perini
					assert(function(el) {
						var input;
						// Select is set to empty string on purpose
						// This is to test IE's treatment of not explicitly
						// setting a boolean content attribute,
						// since its presence should be enough
						// https://bugs.jquery.com/ticket/12359
						docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" +
							"<select id='" + expando + "-\r\\' msallowcapture=''>" +
							"<option selected=''></option></select>";
						// Support: IE8, Opera 11-12.16
						// Nothing should be selected when empty strings follow ^= or $= or *=
						// The test attribute must be unknown in Opera but "safe" for WinRT
						// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
						if (el.querySelectorAll("[msallowcapture^='']").length) {
							rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
						}
						// Support: IE8
						// Boolean attributes and "value" are not treated correctly
						if (!el.querySelectorAll("[selected]").length) {
							rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
						}
						// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
						if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
							rbuggyQSA.push("~=");
						}
						// Support: IE 11+, Edge 15 - 18+
						// IE 11/Edge don't find elements on a `[name='']` query in some cases.
						// Adding a temporary attribute to the document before the selection works
						// around the issue.
						// Interestingly, IE 10 & older don't seem to have the issue.
						input = document.createElement("input");
						input.setAttribute("name", "");
						el.appendChild(input);
						if (!el.querySelectorAll("[name='']").length) {
							rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" +
								whitespace + "*(?:''|\"\")");
						}
						// Webkit/Opera - :checked should return selected option elements
						// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
						// IE8 throws error here and will not see later tests
						if (!el.querySelectorAll(":checked").length) {
							rbuggyQSA.push(":checked");
						}
						// Support: Safari 8+, iOS 8+
						// https://bugs.webkit.org/show_bug.cgi?id=136851
						// In-page `selector#id sibling-combinator selector` fails
						if (!el.querySelectorAll("a#" + expando + "+*").length) {
							rbuggyQSA.push(".#.+[+~]");
						}
						// Support: Firefox <=3.6 - 5 only
						// Old Firefox doesn't throw on a badly-escaped identifier.
						el.querySelectorAll("\\\f");
						rbuggyQSA.push("[\\r\\n\\f]");
					});
					assert(function(el) {
						el.innerHTML = "<a href='' disabled='disabled'></a>" +
							"<select disabled='disabled'><option/></select>";
						// Support: Windows 8 Native Apps
						// The type and name attributes are restricted during .innerHTML assignment
						var input = document.createElement("input");
						input.setAttribute("type", "hidden");
						el.appendChild(input).setAttribute("name", "D");
						// Support: IE8
						// Enforce case-sensitivity of name attribute
						if (el.querySelectorAll("[name=d]").length) {
							rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
						}
						// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
						// IE8 throws error here and will not see later tests
						if (el.querySelectorAll(":enabled").length !== 2) {
							rbuggyQSA.push(":enabled", ":disabled");
						}
						// Support: IE9-11+
						// IE's :disabled selector does not pick up the children of disabled fieldsets
						docElem.appendChild(el).disabled = true;
						if (el.querySelectorAll(":disabled").length !== 2) {
							rbuggyQSA.push(":enabled", ":disabled");
						}
						// Support: Opera 10 - 11 only
						// Opera 10-11 does not throw on post-comma invalid pseudos
						el.querySelectorAll("*,:x");
						rbuggyQSA.push(",.*:");
					});
				}
				if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
						docElem.webkitMatchesSelector ||
						docElem.mozMatchesSelector ||
						docElem.oMatchesSelector ||
						docElem.msMatchesSelector)))) {
					assert(function(el) {
						// Check to see if it's possible to do matchesSelector
						// on a disconnected node (IE 9)
						support.disconnectedMatch = matches.call(el, "*");
						// This should fail with an exception
						// Gecko does not error, returns false instead
						matches.call(el, "[s!='']:x");
						rbuggyMatches.push("!=", pseudos);
					});
				}
				rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
				rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
				/* Contains
				---------------------------------------------------------------------- */
				hasCompare = rnative.test(docElem.compareDocumentPosition);
				// Element contains another
				// Purposefully self-exclusive
				// As in, an element does not contain itself
				contains = hasCompare || rnative.test(docElem.contains) ?
					function(a, b) {
						var adown = a.nodeType === 9 ? a.documentElement : a,
							bup = b && b.parentNode;
						return a === bup || !!(bup && bup.nodeType === 1 && (
							adown.contains ?
							adown.contains(bup) :
							a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
						));
					} :
					function(a, b) {
						if (b) {
							while ((b = b.parentNode)) {
								if (b === a) {
									return true;
								}
							}
						}
						return false;
					};
				/* Sorting
				---------------------------------------------------------------------- */
				// Document order sorting
				sortOrder = hasCompare ?
					function(a, b) {
						// Flag for duplicate removal
						if (a === b) {
							hasDuplicate = true;
							return 0;
						}
						// Sort on method existence if only one input has compareDocumentPosition
						var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
						if (compare) {
							return compare;
						}
						// Calculate position if both inputs belong to the same document
						// Support: IE 11+, Edge 17 - 18+
						// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
						// two documents; shallow comparisons work.
						// eslint-disable-next-line eqeqeq
						compare = (a.ownerDocument || a) == (b.ownerDocument || b) ?
							a.compareDocumentPosition(b) :
							// Otherwise we know they are disconnected
							1;
						// Disconnected nodes
						if (compare & 1 ||
							(!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
							// Choose the first element that is related to our preferred document
							// Support: IE 11+, Edge 17 - 18+
							// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
							// two documents; shallow comparisons work.
							// eslint-disable-next-line eqeqeq
							if (a == document || a.ownerDocument == preferredDoc &&
								contains(preferredDoc, a)) {
								return -1;
							}
							// Support: IE 11+, Edge 17 - 18+
							// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
							// two documents; shallow comparisons work.
							// eslint-disable-next-line eqeqeq
							if (b == document || b.ownerDocument == preferredDoc &&
								contains(preferredDoc, b)) {
								return 1;
							}
							// Maintain original order
							return sortInput ?
								(indexOf(sortInput, a) - indexOf(sortInput, b)) :
								0;
						}
						return compare & 4 ? -1 : 1;
					} :
					function(a, b) {
						// Exit early if the nodes are identical
						if (a === b) {
							hasDuplicate = true;
							return 0;
						}
						var cur,
							i = 0,
							aup = a.parentNode,
							bup = b.parentNode,
							ap = [a],
							bp = [b];
						// Parentless nodes are either documents or disconnected
						if (!aup || !bup) {
							// Support: IE 11+, Edge 17 - 18+
							// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
							// two documents; shallow comparisons work.
							/* eslint-disable eqeqeq */
							return a == document ? -1 :
								b == document ? 1 :
								/* eslint-enable eqeqeq */
								aup ? -1 :
								bup ? 1 :
								sortInput ?
								(indexOf(sortInput, a) - indexOf(sortInput, b)) :
								0;
							// If the nodes are siblings, we can do a quick check
						} else if (aup === bup) {
							return siblingCheck(a, b);
						}
						// Otherwise we need full lists of their ancestors for comparison
						cur = a;
						while ((cur = cur.parentNode)) {
							ap.unshift(cur);
						}
						cur = b;
						while ((cur = cur.parentNode)) {
							bp.unshift(cur);
						}
						// Walk down the tree looking for a discrepancy
						while (ap[i] === bp[i]) {
							i++;
						}
						return i ?
							// Do a sibling check if the nodes have a common ancestor
							siblingCheck(ap[i], bp[i]) :
							// Otherwise nodes in our document sort first
							// Support: IE 11+, Edge 17 - 18+
							// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
							// two documents; shallow comparisons work.
							/* eslint-disable eqeqeq */
							ap[i] == preferredDoc ? -1 :
							bp[i] == preferredDoc ? 1 :
							/* eslint-enable eqeqeq */
							0;
					};
				return document;
			};
			Sizzle.matches = function(expr, elements) {
				return Sizzle(expr, null, null, elements);
			};
			Sizzle.matchesSelector = function(elem, expr) {
				setDocument(elem);
				if (support.matchesSelector && documentIsHTML &&
					!nonnativeSelectorCache[expr + " "] &&
					(!rbuggyMatches || !rbuggyMatches.test(expr)) &&
					(!rbuggyQSA || !rbuggyQSA.test(expr))) {
					try {
						var ret = matches.call(elem, expr);
						// IE 9's matchesSelector returns false on disconnected nodes
						if (ret || support.disconnectedMatch ||
							// As well, disconnected nodes are said to be in a document
							// fragment in IE 9
							elem.document && elem.document.nodeType !== 11) {
							return ret;
						}
					} catch (e) {
						nonnativeSelectorCache(expr, true);
					}
				}
				return Sizzle(expr, document, null, [elem]).length > 0;
			};
			Sizzle.contains = function(context, elem) {
				// Set document vars if needed
				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				if ((context.ownerDocument || context) != document) {
					setDocument(context);
				}
				return contains(context, elem);
			};
			Sizzle.attr = function(elem, name) {
				// Set document vars if needed
				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				if ((elem.ownerDocument || elem) != document) {
					setDocument(elem);
				}
				var fn = Expr.attrHandle[name.toLowerCase()],
					// Don't get fooled by Object.prototype properties (jQuery #13807)
					val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
					fn(elem, name, !documentIsHTML) :
					undefined;
				return val !== undefined ?
					val :
					support.attributes || !documentIsHTML ?
					elem.getAttribute(name) :
					(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
			};
			Sizzle.escape = function(sel) {
				return (sel + "").replace(rcssescape, fcssescape);
			};
			Sizzle.error = function(msg) {
				throw new Error("Syntax error, unrecognized expression: " + msg);
			};
			/**
			 * Document sorting and removing duplicates
			 * @param {ArrayLike} results
			 */
			Sizzle.uniqueSort = function(results) {
				var elem,
					duplicates = [],
					j = 0,
					i = 0;
				// Unless we *know* we can detect duplicates, assume their presence
				hasDuplicate = !support.detectDuplicates;
				sortInput = !support.sortStable && results.slice(0);
				results.sort(sortOrder);
				if (hasDuplicate) {
					while ((elem = results[i++])) {
						if (elem === results[i]) {
							j = duplicates.push(i);
						}
					}
					while (j--) {
						results.splice(duplicates[j], 1);
					}
				}
				// Clear input after sorting to release objects
				// See https://github.com/jquery/sizzle/pull/225
				sortInput = null;
				return results;
			};
			/**
			 * Utility function for retrieving the text value of an array of DOM nodes
			 * @param {Array|Element} elem
			 */
			getText = Sizzle.getText = function(elem) {
				var node,
					ret = "",
					i = 0,
					nodeType = elem.nodeType;
				if (!nodeType) {
					// If no nodeType, this is expected to be an array
					while ((node = elem[i++])) {
						// Do not traverse comment nodes
						ret += getText(node);
					}
				} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
					// Use textContent for elements
					// innerText usage removed for consistency of new lines (jQuery #11153)
					if (typeof elem.textContent === "string") {
						return elem.textContent;
					} else {
						// Traverse its children
						for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
							ret += getText(elem);
						}
					}
				} else if (nodeType === 3 || nodeType === 4) {
					return elem.nodeValue;
				}
				// Do not include comment or processing instruction nodes
				return ret;
			};
			Expr = Sizzle.selectors = {
				// Can be adjusted by the user
				cacheLength: 50,
				createPseudo: markFunction,
				match: matchExpr,
				attrHandle: {},
				find: {},
				relative: {
					">": {
						dir: "parentNode",
						first: true
					},
					" ": {
						dir: "parentNode"
					},
					"+": {
						dir: "previousSibling",
						first: true
					},
					"~": {
						dir: "previousSibling"
					}
				},
				preFilter: {
					"ATTR": function(match) {
						match[1] = match[1].replace(runescape, funescape);
						// Move the given value to match[3] whether quoted or unquoted
						match[3] = (match[3] || match[4] ||
							match[5] || "").replace(runescape, funescape);
						if (match[2] === "~=") {
							match[3] = " " + match[3] + " ";
						}
						return match.slice(0, 4);
					},
					"CHILD": function(match) {
						/* matches from matchExpr["CHILD"]
							1 type (only|nth|...)
							2 what (child|of-type)
							3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
							4 xn-component of xn+y argument ([+-]?\d*n|)
							5 sign of xn-component
							6 x of xn-component
							7 sign of y-component
							8 y of y-component
						*/
						match[1] = match[1].toLowerCase();
						if (match[1].slice(0, 3) === "nth") {
							// nth-* requires argument
							if (!match[3]) {
								Sizzle.error(match[0]);
							}
							// numeric x and y parameters for Expr.filter.CHILD
							// remember that false/true cast respectively to 0/1
							match[4] = +(match[4] ?
								match[5] + (match[6] || 1) :
								2 * (match[3] === "even" || match[3] === "odd"));
							match[5] = +((match[7] + match[8]) || match[3] === "odd");
							// other types prohibit arguments
						} else if (match[3]) {
							Sizzle.error(match[0]);
						}
						return match;
					},
					"PSEUDO": function(match) {
						var excess,
							unquoted = !match[6] && match[2];
						if (matchExpr["CHILD"].test(match[0])) {
							return null;
						}
						// Accept quoted arguments as-is
						if (match[3]) {
							match[2] = match[4] || match[5] || "";
							// Strip excess characters from unquoted arguments
						} else if (unquoted && rpseudo.test(unquoted) &&
							// Get excess from tokenize (recursively)
							(excess = tokenize(unquoted, true)) &&
							// advance to the next closing parenthesis
							(excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
							// excess is a negative index
							match[0] = match[0].slice(0, excess);
							match[2] = unquoted.slice(0, excess);
						}
						// Return only captures needed by the pseudo filter method (type and argument)
						return match.slice(0, 3);
					}
				},
				filter: {
					"TAG": function(nodeNameSelector) {
						var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
						return nodeNameSelector === "*" ?
							function() {
								return true;
							} :
							function(elem) {
								return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
							};
					},
					"CLASS": function(className) {
						var pattern = classCache[className + " "];
						return pattern ||
							(pattern = new RegExp("(^|" + whitespace +
								")" + className + "(" + whitespace + "|$)")) && classCache(
								className,
								function(elem) {
									return pattern.test(
										typeof elem.className === "string" && elem.className ||
										typeof elem.getAttribute !== "undefined" &&
										elem.getAttribute("class") ||
										""
									);
								});
					},
					"ATTR": function(name, operator, check) {
						return function(elem) {
							var result = Sizzle.attr(elem, name);
							if (result == null) {
								return operator === "!=";
							}
							if (!operator) {
								return true;
							}
							result += "";
							/* eslint-disable max-len */
							return operator === "=" ? result === check :
								operator === "!=" ? result !== check :
								operator === "^=" ? check && result.indexOf(check) === 0 :
								operator === "*=" ? check && result.indexOf(check) > -1 :
								operator === "$=" ? check && result.slice(-check.length) === check :
								operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 :
								operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
								false;
							/* eslint-enable max-len */
						};
					},
					"CHILD": function(type, what, _argument, first, last) {
						var simple = type.slice(0, 3) !== "nth",
							forward = type.slice(-4) !== "last",
							ofType = what === "of-type";
						return first === 1 && last === 0 ?
							// Shortcut for :nth-*(n)
							function(elem) {
								return !!elem.parentNode;
							} :
							function(elem, _context, xml) {
								var cache, uniqueCache, outerCache, node, nodeIndex, start,
									dir = simple !== forward ? "nextSibling" : "previousSibling",
									parent = elem.parentNode,
									name = ofType && elem.nodeName.toLowerCase(),
									useCache = !xml && !ofType,
									diff = false;
								if (parent) {
									// :(first|last|only)-(child|of-type)
									if (simple) {
										while (dir) {
											node = elem;
											while ((node = node[dir])) {
												if (ofType ?
													node.nodeName.toLowerCase() === name :
													node.nodeType === 1) {
													return false;
												}
											}
											// Reverse direction for :only-* (if we haven't yet done so)
											start = dir = type === "only" && !start && "nextSibling";
										}
										return true;
									}
									start = [forward ? parent.firstChild : parent.lastChild];
									// non-xml :nth-child(...) stores cache data on `parent`
									if (forward && useCache) {
										// Seek `elem` from a previously-cached index
										// ...in a gzip-friendly way
										node = parent;
										outerCache = node[expando] || (node[expando] = {});
										// Support: IE <9 only
										// Defend against cloned attroperties (jQuery gh-1709)
										uniqueCache = outerCache[node.uniqueID] ||
											(outerCache[node.uniqueID] = {});
										cache = uniqueCache[type] || [];
										nodeIndex = cache[0] === dirruns && cache[1];
										diff = nodeIndex && cache[2];
										node = nodeIndex && parent.childNodes[nodeIndex];
										while ((node = ++nodeIndex && node && node[dir] ||
												// Fallback to seeking `elem` from the start
												(diff = nodeIndex = 0) || start.pop())) {
											// When found, cache indexes on `parent` and break
											if (node.nodeType === 1 && ++diff && node === elem) {
												uniqueCache[type] = [dirruns, nodeIndex, diff];
												break;
											}
										}
									} else {
										// Use previously-cached element index if available
										if (useCache) {
											// ...in a gzip-friendly way
											node = elem;
											outerCache = node[expando] || (node[expando] = {});
											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[node.uniqueID] ||
												(outerCache[node.uniqueID] = {});
											cache = uniqueCache[type] || [];
											nodeIndex = cache[0] === dirruns && cache[1];
											diff = nodeIndex;
										}
										// xml :nth-child(...)
										// or :nth-last-child(...) or :nth(-last)?-of-type(...)
										if (diff === false) {
											// Use the same loop as above to seek `elem` from the start
											while ((node = ++nodeIndex && node && node[dir] ||
													(diff = nodeIndex = 0) || start.pop())) {
												if ((ofType ?
														node.nodeName.toLowerCase() === name :
														node.nodeType === 1) &&
													++diff) {
													// Cache the index of each encountered element
													if (useCache) {
														outerCache = node[expando] ||
															(node[expando] = {});
														// Support: IE <9 only
														// Defend against cloned attroperties (jQuery gh-1709)
														uniqueCache = outerCache[node.uniqueID] ||
															(outerCache[node.uniqueID] = {});
														uniqueCache[type] = [dirruns, diff];
													}
													if (node === elem) {
														break;
													}
												}
											}
										}
									}
									// Incorporate the offset, then check against cycle size
									diff -= last;
									return diff === first || (diff % first === 0 && diff / first >= 0);
								}
							};
					},
					"PSEUDO": function(pseudo, argument) {
						// pseudo-class names are case-insensitive
						// http://www.w3.org/TR/selectors/#pseudo-classes
						// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
						// Remember that setFilters inherits from pseudos
						var args,
							fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
							Sizzle.error("unsupported pseudo: " + pseudo);
						// The user may use createPseudo to indicate that
						// arguments are needed to create the filter function
						// just as Sizzle does
						if (fn[expando]) {
							return fn(argument);
						}
						// But maintain support for old signatures
						if (fn.length > 1) {
							args = [pseudo, pseudo, "", argument];
							return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
								markFunction(function(seed, matches) {
									var idx,
										matched = fn(seed, argument),
										i = matched.length;
									while (i--) {
										idx = indexOf(seed, matched[i]);
										seed[idx] = !(matches[idx] = matched[i]);
									}
								}) :
								function(elem) {
									return fn(elem, 0, args);
								};
						}
						return fn;
					}
				},
				pseudos: {
					// Potentially complex pseudos
					"not": markFunction(function(selector) {
						// Trim the selector passed to compile
						// to avoid treating leading and trailing
						// spaces as combinators
						var input = [],
							results = [],
							matcher = compile(selector.replace(rtrim, "$1"));
						return matcher[expando] ?
							markFunction(function(seed, matches, _context, xml) {
								var elem,
									unmatched = matcher(seed, null, xml, []),
									i = seed.length;
								// Match elements unmatched by `matcher`
								while (i--) {
									if ((elem = unmatched[i])) {
										seed[i] = !(matches[i] = elem);
									}
								}
							}) :
							function(elem, _context, xml) {
								input[0] = elem;
								matcher(input, null, xml, results);
								// Don't keep the element (issue #299)
								input[0] = null;
								return !results.pop();
							};
					}),
					"has": markFunction(function(selector) {
						return function(elem) {
							return Sizzle(selector, elem).length > 0;
						};
					}),
					"contains": markFunction(function(text) {
						text = text.replace(runescape, funescape);
						return function(elem) {
							return (elem.textContent || getText(elem)).indexOf(text) > -1;
						};
					}),
					// "Whether an element is represented by a :lang() selector
					// is based solely on the element's language value
					// being equal to the identifier C,
					// or beginning with the identifier C immediately followed by "-".
					// The matching of C against the element's language value is performed case-insensitively.
					// The identifier C does not have to be a valid language name."
					// http://www.w3.org/TR/selectors/#lang-pseudo
					"lang": markFunction(function(lang) {
						// lang value must be a valid identifier
						if (!ridentifier.test(lang || "")) {
							Sizzle.error("unsupported lang: " + lang);
						}
						lang = lang.replace(runescape, funescape).toLowerCase();
						return function(elem) {
							var elemLang;
							do {
								if ((elemLang = documentIsHTML ?
										elem.lang :
										elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
									elemLang = elemLang.toLowerCase();
									return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
								}
							} while ((elem = elem.parentNode) && elem.nodeType === 1);
							return false;
						};
					}),
					// Miscellaneous
					"target": function(elem) {
						var hash = window.location && window.location.hash;
						return hash && hash.slice(1) === elem.id;
					},
					"root": function(elem) {
						return elem === docElem;
					},
					"focus": function(elem) {
						return elem === document.activeElement &&
							(!document.hasFocus || document.hasFocus()) &&
							!!(elem.type || elem.href || ~elem.tabIndex);
					},
					// Boolean properties
					"enabled": createDisabledPseudo(false),
					"disabled": createDisabledPseudo(true),
					"checked": function(elem) {
						// In CSS3, :checked should return both checked and selected elements
						// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
						var nodeName = elem.nodeName.toLowerCase();
						return (nodeName === "input" && !!elem.checked) ||
							(nodeName === "option" && !!elem.selected);
					},
					"selected": function(elem) {
						// Accessing this property makes selected-by-default
						// options in Safari work properly
						if (elem.parentNode) {
							// eslint-disable-next-line no-unused-expressions
							elem.parentNode.selectedIndex;
						}
						return elem.selected === true;
					},
					// Contents
					"empty": function(elem) {
						// http://www.w3.org/TR/selectors/#empty-pseudo
						// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
						//   but not by others (comment: 8; processing instruction: 7; etc.)
						// nodeType < 6 works because attributes (2) do not appear as children
						for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
							if (elem.nodeType < 6) {
								return false;
							}
						}
						return true;
					},
					"parent": function(elem) {
						return !Expr.pseudos["empty"](elem);
					},
					// Element/input types
					"header": function(elem) {
						return rheader.test(elem.nodeName);
					},
					"input": function(elem) {
						return rinputs.test(elem.nodeName);
					},
					"button": function(elem) {
						var name = elem.nodeName.toLowerCase();
						return name === "input" && elem.type === "button" || name === "button";
					},
					"text": function(elem) {
						var attr;
						return elem.nodeName.toLowerCase() === "input" &&
							elem.type === "text" &&
							// Support: IE<8
							// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
							((attr = elem.getAttribute("type")) == null ||
								attr.toLowerCase() === "text");
					},
					// Position-in-collection
					"first": createPositionalPseudo(function() {
						return [0];
					}),
					"last": createPositionalPseudo(function(_matchIndexes, length) {
						return [length - 1];
					}),
					"eq": createPositionalPseudo(function(_matchIndexes, length, argument) {
						return [argument < 0 ? argument + length : argument];
					}),
					"even": createPositionalPseudo(function(matchIndexes, length) {
						var i = 0;
						for (; i < length; i += 2) {
							matchIndexes.push(i);
						}
						return matchIndexes;
					}),
					"odd": createPositionalPseudo(function(matchIndexes, length) {
						var i = 1;
						for (; i < length; i += 2) {
							matchIndexes.push(i);
						}
						return matchIndexes;
					}),
					"lt": createPositionalPseudo(function(matchIndexes, length, argument) {
						var i = argument < 0 ?
							argument + length :
							argument > length ?
							length :
							argument;
						for (; --i >= 0;) {
							matchIndexes.push(i);
						}
						return matchIndexes;
					}),
					"gt": createPositionalPseudo(function(matchIndexes, length, argument) {
						var i = argument < 0 ? argument + length : argument;
						for (; ++i < length;) {
							matchIndexes.push(i);
						}
						return matchIndexes;
					})
				}
			};
			Expr.pseudos["nth"] = Expr.pseudos["eq"];
			// Add button/input type pseudos
			for (i in {
					radio: true,
					checkbox: true,
					file: true,
					password: true,
					image: true
				}) {
				Expr.pseudos[i] = createInputPseudo(i);
			}
			for (i in {
					submit: true,
					reset: true
				}) {
				Expr.pseudos[i] = createButtonPseudo(i);
			}
			// Easy API for creating new setFilters
			function setFilters() {}
			setFilters.prototype = Expr.filters = Expr.pseudos;
			Expr.setFilters = new setFilters();
			tokenize = Sizzle.tokenize = function(selector, parseOnly) {
				var matched, match, tokens, type,
					soFar, groups, preFilters,
					cached = tokenCache[selector + " "];
				if (cached) {
					return parseOnly ? 0 : cached.slice(0);
				}
				soFar = selector;
				groups = [];
				preFilters = Expr.preFilter;
				while (soFar) {
					// Comma and first run
					if (!matched || (match = rcomma.exec(soFar))) {
						if (match) {
							// Don't consume trailing commas as valid
							soFar = soFar.slice(match[0].length) || soFar;
						}
						groups.push((tokens = []));
					}
					matched = false;
					// Combinators
					if ((match = rcombinators.exec(soFar))) {
						matched = match.shift();
						tokens.push({
							value: matched,
							// Cast descendant combinators to space
							type: match[0].replace(rtrim, " ")
						});
						soFar = soFar.slice(matched.length);
					}
					// Filters
					for (type in Expr.filter) {
						if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
								(match = preFilters[type](match)))) {
							matched = match.shift();
							tokens.push({
								value: matched,
								type: type,
								matches: match
							});
							soFar = soFar.slice(matched.length);
						}
					}
					if (!matched) {
						break;
					}
				}
				// Return the length of the invalid excess
				// if we're just parsing
				// Otherwise, throw an error or return tokens
				return parseOnly ?
					soFar.length :
					soFar ?
					Sizzle.error(selector) :
					// Cache the tokens
					tokenCache(selector, groups).slice(0);
			};

			function toSelector(tokens) {
				var i = 0,
					len = tokens.length,
					selector = "";
				for (; i < len; i++) {
					selector += tokens[i].value;
				}
				return selector;
			}

			function addCombinator(matcher, combinator, base) {
				var dir = combinator.dir,
					skip = combinator.next,
					key = skip || dir,
					checkNonElements = base && key === "parentNode",
					doneName = done++;
				return combinator.first ?
					// Check against closest ancestor/preceding element
					function(elem, context, xml) {
						while ((elem = elem[dir])) {
							if (elem.nodeType === 1 || checkNonElements) {
								return matcher(elem, context, xml);
							}
						}
						return false;
					} :
					// Check against all ancestor/preceding elements
					function(elem, context, xml) {
						var oldCache, uniqueCache, outerCache,
							newCache = [dirruns, doneName];
						// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
						if (xml) {
							while ((elem = elem[dir])) {
								if (elem.nodeType === 1 || checkNonElements) {
									if (matcher(elem, context, xml)) {
										return true;
									}
								}
							}
						} else {
							while ((elem = elem[dir])) {
								if (elem.nodeType === 1 || checkNonElements) {
									outerCache = elem[expando] || (elem[expando] = {});
									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[elem.uniqueID] ||
										(outerCache[elem.uniqueID] = {});
									if (skip && skip === elem.nodeName.toLowerCase()) {
										elem = elem[dir] || elem;
									} else if ((oldCache = uniqueCache[key]) &&
										oldCache[0] === dirruns && oldCache[1] === doneName) {
										// Assign to newCache so results back-propagate to previous elements
										return (newCache[2] = oldCache[2]);
									} else {
										// Reuse newcache so results back-propagate to previous elements
										uniqueCache[key] = newCache;
										// A match means we're done; a fail means we have to keep checking
										if ((newCache[2] = matcher(elem, context, xml))) {
											return true;
										}
									}
								}
							}
						}
						return false;
					};
			}

			function elementMatcher(matchers) {
				return matchers.length > 1 ?
					function(elem, context, xml) {
						var i = matchers.length;
						while (i--) {
							if (!matchers[i](elem, context, xml)) {
								return false;
							}
						}
						return true;
					} :
					matchers[0];
			}

			function multipleContexts(selector, contexts, results) {
				var i = 0,
					len = contexts.length;
				for (; i < len; i++) {
					Sizzle(selector, contexts[i], results);
				}
				return results;
			}

			function condense(unmatched, map, filter, context, xml) {
				var elem,
					newUnmatched = [],
					i = 0,
					len = unmatched.length,
					mapped = map != null;
				for (; i < len; i++) {
					if ((elem = unmatched[i])) {
						if (!filter || filter(elem, context, xml)) {
							newUnmatched.push(elem);
							if (mapped) {
								map.push(i);
							}
						}
					}
				}
				return newUnmatched;
			}

			function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
				if (postFilter && !postFilter[expando]) {
					postFilter = setMatcher(postFilter);
				}
				if (postFinder && !postFinder[expando]) {
					postFinder = setMatcher(postFinder, postSelector);
				}
				return markFunction(function(seed, results, context, xml) {
					var temp, i, elem,
						preMap = [],
						postMap = [],
						preexisting = results.length,
						// Get initial elements from seed or context
						elems = seed || multipleContexts(
							selector || "*",
							context.nodeType ? [context] : context,
							[]
						),
						// Prefilter to get matcher input, preserving a map for seed-results synchronization
						matcherIn = preFilter && (seed || !selector) ?
						condense(elems, preMap, preFilter, context, xml) :
						elems,
						matcherOut = matcher ?
						// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
						postFinder || (seed ? preFilter : preexisting || postFilter) ?
						// ...intermediate processing is necessary
						[] :
						// ...otherwise use results directly
						results :
						matcherIn;
					// Find primary matches
					if (matcher) {
						matcher(matcherIn, matcherOut, context, xml);
					}
					// Apply postFilter
					if (postFilter) {
						temp = condense(matcherOut, postMap);
						postFilter(temp, [], context, xml);
						// Un-match failing elements by moving them back to matcherIn
						i = temp.length;
						while (i--) {
							if ((elem = temp[i])) {
								matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
							}
						}
					}
					if (seed) {
						if (postFinder || preFilter) {
							if (postFinder) {
								// Get the final matcherOut by condensing this intermediate into postFinder contexts
								temp = [];
								i = matcherOut.length;
								while (i--) {
									if ((elem = matcherOut[i])) {
										// Restore matcherIn since elem is not yet a final match
										temp.push((matcherIn[i] = elem));
									}
								}
								postFinder(null, (matcherOut = []), temp, xml);
							}
							// Move matched elements from seed to results to keep them synchronized
							i = matcherOut.length;
							while (i--) {
								if ((elem = matcherOut[i]) &&
									(temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
									seed[temp] = !(results[temp] = elem);
								}
							}
						}
						// Add elements to results, through postFinder if defined
					} else {
						matcherOut = condense(
							matcherOut === results ?
							matcherOut.splice(preexisting, matcherOut.length) :
							matcherOut
						);
						if (postFinder) {
							postFinder(null, results, matcherOut, xml);
						} else {
							push.apply(results, matcherOut);
						}
					}
				});
			}

			function matcherFromTokens(tokens) {
				var checkContext, matcher, j,
					len = tokens.length,
					leadingRelative = Expr.relative[tokens[0].type],
					implicitRelative = leadingRelative || Expr.relative[" "],
					i = leadingRelative ? 1 : 0,
					// The foundational matcher ensures that elements are reachable from top-level context(s)
					matchContext = addCombinator(function(elem) {
						return elem === checkContext;
					}, implicitRelative, true),
					matchAnyContext = addCombinator(function(elem) {
						return indexOf(checkContext, elem) > -1;
					}, implicitRelative, true),
					matchers = [function(elem, context, xml) {
						var ret = (!leadingRelative && (xml || context !== outermostContext)) || (
							(checkContext = context).nodeType ?
							matchContext(elem, context, xml) :
							matchAnyContext(elem, context, xml));
						// Avoid hanging onto element (issue #299)
						checkContext = null;
						return ret;
					}];
				for (; i < len; i++) {
					if ((matcher = Expr.relative[tokens[i].type])) {
						matchers = [addCombinator(elementMatcher(matchers), matcher)];
					} else {
						matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
						// Return special upon seeing a positional matcher
						if (matcher[expando]) {
							// Find the next relative operator (if any) for proper handling
							j = ++i;
							for (; j < len; j++) {
								if (Expr.relative[tokens[j].type]) {
									break;
								}
							}
							return setMatcher(
								i > 1 && elementMatcher(matchers),
								i > 1 && toSelector(
									// If the preceding token was a descendant combinator, insert an implicit any-element `*`
									tokens
									.slice(0, i - 1)
									.concat({
										value: tokens[i - 2].type === " " ? "*" : ""
									})
								).replace(rtrim, "$1"),
								matcher,
								i < j && matcherFromTokens(tokens.slice(i, j)),
								j < len && matcherFromTokens((tokens = tokens.slice(j))),
								j < len && toSelector(tokens)
							);
						}
						matchers.push(matcher);
					}
				}
				return elementMatcher(matchers);
			}

			function matcherFromGroupMatchers(elementMatchers, setMatchers) {
				var bySet = setMatchers.length > 0,
					byElement = elementMatchers.length > 0,
					superMatcher = function(seed, context, xml, results, outermost) {
						var elem, j, matcher,
							matchedCount = 0,
							i = "0",
							unmatched = seed && [],
							setMatched = [],
							contextBackup = outermostContext,
							// We must always have either seed elements or outermost context
							elems = seed || byElement && Expr.find["TAG"]("*", outermost),
							// Use integer dirruns iff this is the outermost matcher
							dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
							len = elems.length;
						if (outermost) {
							// Support: IE 11+, Edge 17 - 18+
							// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
							// two documents; shallow comparisons work.
							// eslint-disable-next-line eqeqeq
							outermostContext = context == document || context || outermost;
						}
						// Add elements passing elementMatchers directly to results
						// Support: IE<9, Safari
						// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
						for (; i !== len && (elem = elems[i]) != null; i++) {
							if (byElement && elem) {
								j = 0;
								// Support: IE 11+, Edge 17 - 18+
								// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
								// two documents; shallow comparisons work.
								// eslint-disable-next-line eqeqeq
								if (!context && elem.ownerDocument != document) {
									setDocument(elem);
									xml = !documentIsHTML;
								}
								while ((matcher = elementMatchers[j++])) {
									if (matcher(elem, context || document, xml)) {
										results.push(elem);
										break;
									}
								}
								if (outermost) {
									dirruns = dirrunsUnique;
								}
							}
							// Track unmatched elements for set filters
							if (bySet) {
								// They will have gone through all possible matchers
								if ((elem = !matcher && elem)) {
									matchedCount--;
								}
								// Lengthen the array for every element, matched or not
								if (seed) {
									unmatched.push(elem);
								}
							}
						}
						// `i` is now the count of elements visited above, and adding it to `matchedCount`
						// makes the latter nonnegative.
						matchedCount += i;
						// Apply set filters to unmatched elements
						// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
						// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
						// no element matchers and no seed.
						// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
						// case, which will result in a "00" `matchedCount` that differs from `i` but is also
						// numerically zero.
						if (bySet && i !== matchedCount) {
							j = 0;
							while ((matcher = setMatchers[j++])) {
								matcher(unmatched, setMatched, context, xml);
							}
							if (seed) {
								// Reintegrate element matches to eliminate the need for sorting
								if (matchedCount > 0) {
									while (i--) {
										if (!(unmatched[i] || setMatched[i])) {
											setMatched[i] = pop.call(results);
										}
									}
								}
								// Discard index placeholder values to get only actual matches
								setMatched = condense(setMatched);
							}
							// Add matches to results
							push.apply(results, setMatched);
							// Seedless set matches succeeding multiple successful matchers stipulate sorting
							if (outermost && !seed && setMatched.length > 0 &&
								(matchedCount + setMatchers.length) > 1) {
								Sizzle.uniqueSort(results);
							}
						}
						// Override manipulation of globals by nested matchers
						if (outermost) {
							dirruns = dirrunsUnique;
							outermostContext = contextBackup;
						}
						return unmatched;
					};
				return bySet ?
					markFunction(superMatcher) :
					superMatcher;
			}
			compile = Sizzle.compile = function(selector, match /* Internal Use Only */ ) {
				var i,
					setMatchers = [],
					elementMatchers = [],
					cached = compilerCache[selector + " "];
				if (!cached) {
					// Generate a function of recursive functions that can be used to check each element
					if (!match) {
						match = tokenize(selector);
					}
					i = match.length;
					while (i--) {
						cached = matcherFromTokens(match[i]);
						if (cached[expando]) {
							setMatchers.push(cached);
						} else {
							elementMatchers.push(cached);
						}
					}
					// Cache the compiled function
					cached = compilerCache(
						selector,
						matcherFromGroupMatchers(elementMatchers, setMatchers)
					);
					// Save selector and tokenization
					cached.selector = selector;
				}
				return cached;
			};
			/**
			 * A low-level selection function that works with Sizzle's compiled
			 *  selector functions
			 * @param {String|Function} selector A selector or a pre-compiled
			 *  selector function built with Sizzle.compile
			 * @param {Element} context
			 * @param {Array} [results]
			 * @param {Array} [seed] A set of elements to match against
			 */
			select = Sizzle.select = function(selector, context, results, seed) {
				var i, tokens, token, type, find,
					compiled = typeof selector === "function" && selector,
					match = !seed && tokenize((selector = compiled.selector || selector));
				results = results || [];
				// Try to minimize operations if there is only one selector in the list and no seed
				// (the latter of which guarantees us context)
				if (match.length === 1) {
					// Reduce context if the leading compound selector is an ID
					tokens = match[0] = match[0].slice(0);
					if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
						context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
						context = (Expr.find["ID"](token.matches[0]
							.replace(runescape, funescape), context) || [])[0];
						if (!context) {
							return results;
							// Precompiled matchers will still verify ancestry, so step up a level
						} else if (compiled) {
							context = context.parentNode;
						}
						selector = selector.slice(tokens.shift().value.length);
					}
					// Fetch a seed set for right-to-left matching
					i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
					while (i--) {
						token = tokens[i];
						// Abort if we hit a combinator
						if (Expr.relative[(type = token.type)]) {
							break;
						}
						if ((find = Expr.find[type])) {
							// Search, expanding context for leading sibling combinators
							if ((seed = find(
									token.matches[0].replace(runescape, funescape),
									rsibling.test(tokens[0].type) && testContext(context.parentNode) ||
									context
								))) {
								// If seed is empty or no tokens remain, we can return early
								tokens.splice(i, 1);
								selector = seed.length && toSelector(tokens);
								if (!selector) {
									push.apply(results, seed);
									return results;
								}
								break;
							}
						}
					}
				}
				// Compile and execute a filtering function if one is not provided
				// Provide `match` to avoid retokenization if we modified the selector above
				(compiled || compile(selector, match))(
					seed,
					context,
					!documentIsHTML,
					results,
					!context || rsibling.test(selector) && testContext(context.parentNode) || context
				);
				return results;
			};
			// One-time assignments
			// Sort stability
			support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
			// Support: Chrome 14-35+
			// Always assume duplicates if they aren't passed to the comparison function
			support.detectDuplicates = !!hasDuplicate;
			// Initialize against the default document
			setDocument();
			// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
			// Detached nodes confoundingly follow *each other*
			support.sortDetached = assert(function(el) {
				// Should return 1, but returns 4 (following)
				return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
			});
			// Support: IE<8
			// Prevent attribute/property "interpolation"
			// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
			if (!assert(function(el) {
					el.innerHTML = "<a href='#'></a>";
					return el.firstChild.getAttribute("href") === "#";
				})) {
				addHandle("type|href|height|width", function(elem, name, isXML) {
					if (!isXML) {
						return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
					}
				});
			}
			// Support: IE<9
			// Use defaultValue in place of getAttribute("value")
			if (!support.attributes || !assert(function(el) {
					el.innerHTML = "<input/>";
					el.firstChild.setAttribute("value", "");
					return el.firstChild.getAttribute("value") === "";
				})) {
				addHandle("value", function(elem, _name, isXML) {
					if (!isXML && elem.nodeName.toLowerCase() === "input") {
						return elem.defaultValue;
					}
				});
			}
			// Support: IE<9
			// Use getAttributeNode to fetch booleans when getAttribute lies
			if (!assert(function(el) {
					return el.getAttribute("disabled") == null;
				})) {
				addHandle(booleans, function(elem, name, isXML) {
					var val;
					if (!isXML) {
						return elem[name] === true ? name.toLowerCase() :
							(val = elem.getAttributeNode(name)) && val.specified ?
							val.value :
							null;
					}
				});
			}
			return Sizzle;
		})(window);
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	// Deprecated
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;
	var dir = function(elem, dir, until) {
		var matched = [],
			truncate = until !== undefined;
		while ((elem = elem[dir]) && elem.nodeType !== 9) {
			if (elem.nodeType === 1) {
				if (truncate && jQuery(elem).is(until)) {
					break;
				}
				matched.push(elem);
			}
		}
		return matched;
	};
	var siblings = function(n, elem) {
		var matched = [];
		for (; n; n = n.nextSibling) {
			if (n.nodeType === 1 && n !== elem) {
				matched.push(n);
			}
		}
		return matched;
	};
	var rneedsContext = jQuery.expr.match.needsContext;

	function nodeName(elem, name) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	}
	var rsingleTag = (/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i);
	// Implement the identical functionality for filter and not
	function winnow(elements, qualifier, not) {
		if (isFunction(qualifier)) {
			return jQuery.grep(elements, function(elem, i) {
				return !!qualifier.call(elem, i, elem) !== not;
			});
		}
		// Single element
		if (qualifier.nodeType) {
			return jQuery.grep(elements, function(elem) {
				return (elem === qualifier) !== not;
			});
		}
		// Arraylike of elements (jQuery, arguments, Array)
		if (typeof qualifier !== "string") {
			return jQuery.grep(elements, function(elem) {
				return (indexOf.call(qualifier, elem) > -1) !== not;
			});
		}
		// Filtered directly for both simple and complex selectors
		return jQuery.filter(qualifier, elements, not);
	}
	jQuery.filter = function(expr, elems, not) {
		var elem = elems[0];
		if (not) {
			expr = ":not(" + expr + ")";
		}
		if (elems.length === 1 && elem.nodeType === 1) {
			return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
		}
		return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
			return elem.nodeType === 1;
		}));
	};
	jQuery.fn.extend({
		find: function(selector) {
			var i, ret,
				len = this.length,
				self = this;
			if (typeof selector !== "string") {
				return this.pushStack(jQuery(selector).filter(function() {
					for (i = 0; i < len; i++) {
						if (jQuery.contains(self[i], this)) {
							return true;
						}
					}
				}));
			}
			ret = this.pushStack([]);
			for (i = 0; i < len; i++) {
				jQuery.find(selector, self[i], ret);
			}
			return len > 1 ? jQuery.uniqueSort(ret) : ret;
		},
		filter: function(selector) {
			return this.pushStack(winnow(this, selector || [], false));
		},
		not: function(selector) {
			return this.pushStack(winnow(this, selector || [], true));
		},
		is: function(selector) {
			return !!winnow(
				this,
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test(selector) ?
				jQuery(selector) :
				selector || [],
				false
			).length;
		}
	});
	// Initialize a jQuery object
	// A central reference to the root jQuery(document)
	var rootjQuery,
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
		init = jQuery.fn.init = function(selector, context, root) {
			var match, elem;
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if (!selector) {
				return this;
			}
			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;
			// Handle HTML strings
			if (typeof selector === "string") {
				if (selector[0] === "<" &&
					selector[selector.length - 1] === ">" &&
					selector.length >= 3) {
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [null, selector, null];
				} else {
					match = rquickExpr.exec(selector);
				}
				// Match html or make sure no context is specified for #id
				if (match && (match[1] || !context)) {
					// HANDLE: $(html) -> $(array)
					if (match[1]) {
						context = context instanceof jQuery ? context[0] : context;
						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge(this, jQuery.parseHTML(
							match[1],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						));
						// HANDLE: $(html, props)
						if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
							for (match in context) {
								// Properties of context are called as methods if possible
								if (isFunction(this[match])) {
									this[match](context[match]);
									// ...and otherwise set as attributes
								} else {
									this.attr(match, context[match]);
								}
							}
						}
						return this;
						// HANDLE: $(#id)
					} else {
						elem = document.getElementById(match[2]);
						if (elem) {
							// Inject the element directly into the jQuery object
							this[0] = elem;
							this.length = 1;
						}
						return this;
					}
					// HANDLE: $(expr, $(...))
				} else if (!context || context.jquery) {
					return (context || root).find(selector);
					// HANDLE: $(expr, context)
					// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor(context).find(selector);
				}
				// HANDLE: $(DOMElement)
			} else if (selector.nodeType) {
				this[0] = selector;
				this.length = 1;
				return this;
				// HANDLE: $(function)
				// Shortcut for document ready
			} else if (isFunction(selector)) {
				return root.ready !== undefined ?
					root.ready(selector) :
					// Execute immediately if ready is not present
					selector(jQuery);
			}
			return jQuery.makeArray(selector, this);
		};
	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;
	// Initialize central reference
	rootjQuery = jQuery(document);
	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	jQuery.fn.extend({
		has: function(target) {
			var targets = jQuery(target, this),
				l = targets.length;
			return this.filter(function() {
				var i = 0;
				for (; i < l; i++) {
					if (jQuery.contains(this, targets[i])) {
						return true;
					}
				}
			});
		},
		closest: function(selectors, context) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery(selectors);
			// Positional selectors never match, since there's no _selection_ context
			if (!rneedsContext.test(selectors)) {
				for (; i < l; i++) {
					for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
						// Always skip document fragments
						if (cur.nodeType < 11 && (targets ?
								targets.index(cur) > -1 :
								// Don't pass non-elements to Sizzle
								cur.nodeType === 1 &&
								jQuery.find.matchesSelector(cur, selectors))) {
							matched.push(cur);
							break;
						}
					}
				}
			}
			return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
		},
		// Determine the position of an element within the set
		index: function(elem) {
			// No argument, return index in parent
			if (!elem) {
				return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
			}
			// Index in selector
			if (typeof elem === "string") {
				return indexOf.call(jQuery(elem), this[0]);
			}
			// Locate the position of the desired element
			return indexOf.call(this,
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[0] : elem
			);
		},
		add: function(selector, context) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge(this.get(), jQuery(selector, context))
				)
			);
		},
		addBack: function(selector) {
			return this.add(selector == null ?
				this.prevObject : this.prevObject.filter(selector)
			);
		}
	});

	function sibling(cur, dir) {
		while ((cur = cur[dir]) && cur.nodeType !== 1) {}
		return cur;
	}
	jQuery.each({
		parent: function(elem) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function(elem) {
			return dir(elem, "parentNode");
		},
		parentsUntil: function(elem, _i, until) {
			return dir(elem, "parentNode", until);
		},
		next: function(elem) {
			return sibling(elem, "nextSibling");
		},
		prev: function(elem) {
			return sibling(elem, "previousSibling");
		},
		nextAll: function(elem) {
			return dir(elem, "nextSibling");
		},
		prevAll: function(elem) {
			return dir(elem, "previousSibling");
		},
		nextUntil: function(elem, _i, until) {
			return dir(elem, "nextSibling", until);
		},
		prevUntil: function(elem, _i, until) {
			return dir(elem, "previousSibling", until);
		},
		siblings: function(elem) {
			return siblings((elem.parentNode || {}).firstChild, elem);
		},
		children: function(elem) {
			return siblings(elem.firstChild);
		},
		contents: function(elem) {
			if (elem.contentDocument != null &&
				// Support: IE 11+
				// <object> elements with no `data` attribute has an object
				// `contentDocument` with a `null` prototype.
				getProto(elem.contentDocument)) {
				return elem.contentDocument;
			}
			// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
			// Treat the template element as a regular one in browsers that
			// don't support it.
			if (nodeName(elem, "template")) {
				elem = elem.content || elem;
			}
			return jQuery.merge([], elem.childNodes);
		}
	}, function(name, fn) {
		jQuery.fn[name] = function(until, selector) {
			var matched = jQuery.map(this, fn, until);
			if (name.slice(-5) !== "Until") {
				selector = until;
			}
			if (selector && typeof selector === "string") {
				matched = jQuery.filter(selector, matched);
			}
			if (this.length > 1) {
				// Remove duplicates
				if (!guaranteedUnique[name]) {
					jQuery.uniqueSort(matched);
				}
				// Reverse order for parents* and prev-derivatives
				if (rparentsprev.test(name)) {
					matched.reverse();
				}
			}
			return this.pushStack(matched);
		};
	});
	var rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);
	// Convert String-formatted options into Object-formatted ones
	function createOptions(options) {
		var object = {};
		jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
			object[flag] = true;
		});
		return object;
	}
	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function(options) {
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions(options) :
			jQuery.extend({}, options);
		var // Flag to know if list is currently firing
			firing,
			// Last fire value for non-forgettable lists
			memory,
			// Flag to know if list was already fired
			fired,
			// Flag to prevent firing
			locked,
			// Actual callback list
			list = [],
			// Queue of execution data for repeatable lists
			queue = [],
			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,
			// Fire callbacks
			fire = function() {
				// Enforce single-firing
				locked = locked || options.once;
				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for (; queue.length; firingIndex = -1) {
					memory = queue.shift();
					while (++firingIndex < list.length) {
						// Run callback and check for early termination
						if (list[firingIndex].apply(memory[0], memory[1]) === false &&
							options.stopOnFalse) {
							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}
				// Forget the data if we're done with it
				if (!options.memory) {
					memory = false;
				}
				firing = false;
				// Clean up if we're done firing for good
				if (locked) {
					// Keep an empty list if we have data for future add calls
					if (memory) {
						list = [];
						// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},
			// Actual Callbacks object
			self = {
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if (list) {
						// If we have memory from a past run, we should fire after adding
						if (memory && !firing) {
							firingIndex = list.length - 1;
							queue.push(memory);
						}
						(function add(args) {
							jQuery.each(args, function(_, arg) {
								if (isFunction(arg)) {
									if (!options.unique || !self.has(arg)) {
										list.push(arg);
									}
								} else if (arg && arg.length && toType(arg) !== "string") {
									// Inspect recursively
									add(arg);
								}
							});
						})(arguments);
						if (memory && !firing) {
							fire();
						}
					}
					return this;
				},
				// Remove a callback from the list
				remove: function() {
					jQuery.each(arguments, function(_, arg) {
						var index;
						while ((index = jQuery.inArray(arg, list, index)) > -1) {
							list.splice(index, 1);
							// Handle firing indexes
							if (index <= firingIndex) {
								firingIndex--;
							}
						}
					});
					return this;
				},
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function(fn) {
					return fn ?
						jQuery.inArray(fn, list) > -1 :
						list.length > 0;
				},
				// Remove all callbacks from the list
				empty: function() {
					if (list) {
						list = [];
					}
					return this;
				},
				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},
				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if (!memory && !firing) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},
				// Call all callbacks with the given context and arguments
				fireWith: function(context, args) {
					if (!locked) {
						args = args || [];
						args = [context, args.slice ? args.slice() : args];
						queue.push(args);
						if (!firing) {
							fire();
						}
					}
					return this;
				},
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith(this, arguments);
					return this;
				},
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};
		return self;
	};

	function Identity(v) {
		return v;
	}

	function Thrower(ex) {
		throw ex;
	}

	function adoptValue(value, resolve, reject, noValue) {
		var method;
		try {
			// Check for promise aspect first to privilege synchronous behavior
			if (value && isFunction((method = value.promise))) {
				method.call(value).done(resolve).fail(reject);
				// Other thenables
			} else if (value && isFunction((method = value.then))) {
				method.call(value, resolve, reject);
				// Other non-thenables
			} else {
				// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
				// * false: [ value ].slice( 0 ) => resolve( value )
				// * true: [ value ].slice( 1 ) => resolve()
				resolve.apply(undefined, [value].slice(noValue));
			}
			// For Promises/A+, convert exceptions into rejections
			// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
			// Deferred#then to conditionally suppress rejection.
		} catch (value) {
			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.apply(undefined, [value]);
		}
	}
	jQuery.extend({
		Deferred: function(func) {
			var tuples = [
					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					["notify", "progress", jQuery.Callbacks("memory"),
						jQuery.Callbacks("memory"), 2
					],
					["resolve", "done", jQuery.Callbacks("once memory"),
						jQuery.Callbacks("once memory"), 0, "resolved"
					],
					["reject", "fail", jQuery.Callbacks("once memory"),
						jQuery.Callbacks("once memory"), 1, "rejected"
					]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done(arguments).fail(arguments);
						return this;
					},
					"catch": function(fn) {
						return promise.then(null, fn);
					},
					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred(function(newDefer) {
							jQuery.each(tuples, function(_i, tuple) {
								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[tuple[1]](function() {
									var returned = fn && fn.apply(this, arguments);
									if (returned && isFunction(returned.promise)) {
										returned.promise()
											.progress(newDefer.notify)
											.done(newDefer.resolve)
											.fail(newDefer.reject);
									} else {
										newDefer[tuple[0] + "With"](
											this,
											fn ? [returned] : arguments
										);
									}
								});
							});
							fns = null;
						}).promise();
					},
					then: function(onFulfilled, onRejected, onProgress) {
						var maxDepth = 0;

						function resolve(depth, deferred, handler, special) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;
										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if (depth < maxDepth) {
											return;
										}
										returned = handler.apply(that, args);
										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if (returned === deferred.promise()) {
											throw new TypeError("Thenable self-resolution");
										}
										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&
											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											(typeof returned === "object" ||
												typeof returned === "function") &&
											returned.then;
										// Handle a returned thenable
										if (isFunction(then)) {
											// Special processors (notify) just wait for resolution
											if (special) {
												then.call(
													returned,
													resolve(maxDepth, deferred, Identity, special),
													resolve(maxDepth, deferred, Thrower, special)
												);
												// Normal processors (resolve) also hook into progress
											} else {
												// ...and disregard older resolution values
												maxDepth++;
												then.call(
													returned,
													resolve(maxDepth, deferred, Identity, special),
													resolve(maxDepth, deferred, Thrower, special),
													resolve(maxDepth, deferred, Identity,
														deferred.notifyWith)
												);
											}
											// Handle all other returned values
										} else {
											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if (handler !== Identity) {
												that = undefined;
												args = [returned];
											}
											// Process the value(s)
											// Default process is resolve
											(special || deferred.resolveWith)(that, args);
										}
									},
									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch (e) {
											if (jQuery.Deferred.exceptionHook) {
												jQuery.Deferred.exceptionHook(e,
													process.stackTrace);
											}
											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if (depth + 1 >= maxDepth) {
												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if (handler !== Thrower) {
													that = undefined;
													args = [e];
												}
												deferred.rejectWith(that, args);
											}
										}
									};
								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if (depth) {
									process();
								} else {
									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if (jQuery.Deferred.getStackHook) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout(process);
								}
							};
						}
						return jQuery.Deferred(function(newDefer) {
							// progress_handlers.add( ... )
							tuples[0][3].add(
								resolve(
									0,
									newDefer,
									isFunction(onProgress) ?
									onProgress :
									Identity,
									newDefer.notifyWith
								)
							);
							// fulfilled_handlers.add( ... )
							tuples[1][3].add(
								resolve(
									0,
									newDefer,
									isFunction(onFulfilled) ?
									onFulfilled :
									Identity
								)
							);
							// rejected_handlers.add( ... )
							tuples[2][3].add(
								resolve(
									0,
									newDefer,
									isFunction(onRejected) ?
									onRejected :
									Thrower
								)
							);
						}).promise();
					},
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function(obj) {
						return obj != null ? jQuery.extend(obj, promise) : promise;
					}
				},
				deferred = {};
			// Add list-specific methods
			jQuery.each(tuples, function(i, tuple) {
				var list = tuple[2],
					stateString = tuple[5];
				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[tuple[1]] = list.add;
				// Handle state
				if (stateString) {
					list.add(
						function() {
							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},
						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[3 - i][2].disable,
						// rejected_handlers.disable
						// fulfilled_handlers.disable
						tuples[3 - i][3].disable,
						// progress_callbacks.lock
						tuples[0][2].lock,
						// progress_handlers.lock
						tuples[0][3].lock
					);
				}
				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add(tuple[3].fire);
				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[tuple[0]] = function() {
					deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
					return this;
				};
				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[tuple[0] + "With"] = list.fireWith;
			});
			// Make the deferred a promise
			promise.promise(deferred);
			// Call given func if any
			if (func) {
				func.call(deferred, deferred);
			}
			// All done!
			return deferred;
		},
		// Deferred helper
		when: function(singleValue) {
			var
				// count of uncompleted subordinates
				remaining = arguments.length,
				// count of unprocessed arguments
				i = remaining,
				// subordinate fulfillment data
				resolveContexts = Array(i),
				resolveValues = slice.call(arguments),
				// the primary Deferred
				primary = jQuery.Deferred(),
				// subordinate callback factory
				updateFunc = function(i) {
					return function(value) {
						resolveContexts[i] = this;
						resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
						if (!(--remaining)) {
							primary.resolveWith(resolveContexts, resolveValues);
						}
					};
				};
			// Single- and empty arguments are adopted like Promise.resolve
			if (remaining <= 1) {
				adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject,
					!remaining);
				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if (primary.state() === "pending" ||
					isFunction(resolveValues[i] && resolveValues[i].then)) {
					return primary.then();
				}
			}
			// Multiple arguments are aggregated like Promise.all array elements
			while (i--) {
				adoptValue(resolveValues[i], updateFunc(i), primary.reject);
			}
			return primary.promise();
		}
	});
	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
	jQuery.Deferred.exceptionHook = function(error, stack) {
		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
			window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
		}
	};
	jQuery.readyException = function(error) {
		window.setTimeout(function() {
			throw error;
		});
	};
	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();
	jQuery.fn.ready = function(fn) {
		readyList
			.then(fn)
			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch(function(error) {
				jQuery.readyException(error);
			});
		return this;
	};
	jQuery.extend({
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
		// Handle when the DOM is ready
		ready: function(wait) {
			// Abort if there are pending holds or we're already ready
			if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
				return;
			}
			// Remember that the DOM is ready
			jQuery.isReady = true;
			// If a normal DOM Ready event fired, decrement, and wait if need be
			if (wait !== true && --jQuery.readyWait > 0) {
				return;
			}
			// If there are functions bound, to execute
			readyList.resolveWith(document, [jQuery]);
		}
	});
	jQuery.ready.then = readyList.then;
	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener("DOMContentLoaded", completed);
		window.removeEventListener("load", completed);
		jQuery.ready();
	}
	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if (document.readyState === "complete" ||
		(document.readyState !== "loading" && !document.documentElement.doScroll)) {
		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout(jQuery.ready);
	} else {
		// Use the handy event callback
		document.addEventListener("DOMContentLoaded", completed);
		// A fallback to window.onload, that will always work
		window.addEventListener("load", completed);
	}
	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
		var i = 0,
			len = elems.length,
			bulk = key == null;
		// Sets many values
		if (toType(key) === "object") {
			chainable = true;
			for (i in key) {
				access(elems, fn, i, key[i], true, emptyGet, raw);
			}
			// Sets one value
		} else if (value !== undefined) {
			chainable = true;
			if (!isFunction(value)) {
				raw = true;
			}
			if (bulk) {
				// Bulk operations run against the entire set
				if (raw) {
					fn.call(elems, value);
					fn = null;
					// ...except when executing function values
				} else {
					bulk = fn;
					fn = function(elem, _key, value) {
						return bulk.call(jQuery(elem), value);
					};
				}
			}
			if (fn) {
				for (; i < len; i++) {
					fn(
						elems[i], key, raw ?
						value :
						value.call(elems[i], i, fn(elems[i], key))
					);
				}
			}
		}
		if (chainable) {
			return elems;
		}
		// Gets
		if (bulk) {
			return fn.call(elems);
		}
		return len ? fn(elems[0], key) : emptyGet;
	};
	// Matches dashed string for camelizing
	var rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g;
	// Used by camelCase as callback to replace()
	function fcamelCase(_all, letter) {
		return letter.toUpperCase();
	}
	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 15
	// Microsoft forgot to hump their vendor prefix (#9572)
	function camelCase(string) {
		return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
	}
	var acceptData = function(owner) {
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
	};

	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}
	Data.uid = 1;
	Data.prototype = {
		cache: function(owner) {
			// Check if the owner object already has a cache
			var value = owner[this.expando];
			// If not, create one
			if (!value) {
				value = {};
				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if (acceptData(owner)) {
					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if (owner.nodeType) {
						owner[this.expando] = value;
						// Otherwise secure it in a non-enumerable property
						// configurable must be true to allow the property to be
						// deleted when data is removed
					} else {
						Object.defineProperty(owner, this.expando, {
							value: value,
							configurable: true
						});
					}
				}
			}
			return value;
		},
		set: function(owner, data, value) {
			var prop,
				cache = this.cache(owner);
			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if (typeof data === "string") {
				cache[camelCase(data)] = value;
				// Handle: [ owner, { properties } ] args
			} else {
				// Copy the properties one-by-one to the cache object
				for (prop in data) {
					cache[camelCase(prop)] = data[prop];
				}
			}
			return cache;
		},
		get: function(owner, key) {
			return key === undefined ?
				this.cache(owner) :
				// Always use camelCase key (gh-2257)
				owner[this.expando] && owner[this.expando][camelCase(key)];
		},
		access: function(owner, key, value) {
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if (key === undefined ||
				((key && typeof key === "string") && value === undefined)) {
				return this.get(owner, key);
			}
			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set(owner, key, value);
			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function(owner, key) {
			var i,
				cache = owner[this.expando];
			if (cache === undefined) {
				return;
			}
			if (key !== undefined) {
				// Support array or space separated string of keys
				if (Array.isArray(key)) {
					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map(camelCase);
				} else {
					key = camelCase(key);
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ? [key] :
						(key.match(rnothtmlwhite) || []);
				}
				i = key.length;
				while (i--) {
					delete cache[key[i]];
				}
			}
			// Remove the expando if there's no more data
			if (key === undefined || jQuery.isEmptyObject(cache)) {
				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if (owner.nodeType) {
					owner[this.expando] = undefined;
				} else {
					delete owner[this.expando];
				}
			}
		},
		hasData: function(owner) {
			var cache = owner[this.expando];
			return cache !== undefined && !jQuery.isEmptyObject(cache);
		}
	};
	var dataPriv = new Data();
	var dataUser = new Data();
	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function getData(data) {
		if (data === "true") {
			return true;
		}
		if (data === "false") {
			return false;
		}
		if (data === "null") {
			return null;
		}
		// Only convert to a number if it doesn't change the string
		if (data === +data + "") {
			return +data;
		}
		if (rbrace.test(data)) {
			return JSON.parse(data);
		}
		return data;
	}

	function dataAttr(elem, key, data) {
		var name;
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if (data === undefined && elem.nodeType === 1) {
			name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
			data = elem.getAttribute(name);
			if (typeof data === "string") {
				try {
					data = getData(data);
				} catch (e) {}
				// Make sure we set the data so it isn't changed later
				dataUser.set(elem, key, data);
			} else {
				data = undefined;
			}
		}
		return data;
	}
	jQuery.extend({
		hasData: function(elem) {
			return dataUser.hasData(elem) || dataPriv.hasData(elem);
		},
		data: function(elem, name, data) {
			return dataUser.access(elem, name, data);
		},
		removeData: function(elem, name) {
			dataUser.remove(elem, name);
		},
		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function(elem, name, data) {
			return dataPriv.access(elem, name, data);
		},
		_removeData: function(elem, name) {
			dataPriv.remove(elem, name);
		}
	});
	jQuery.fn.extend({
		data: function(key, value) {
			var i, name, data,
				elem = this[0],
				attrs = elem && elem.attributes;
			// Gets all values
			if (key === undefined) {
				if (this.length) {
					data = dataUser.get(elem);
					if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
						i = attrs.length;
						while (i--) {
							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if (attrs[i]) {
								name = attrs[i].name;
								if (name.indexOf("data-") === 0) {
									name = camelCase(name.slice(5));
									dataAttr(elem, name, data[name]);
								}
							}
						}
						dataPriv.set(elem, "hasDataAttrs", true);
					}
				}
				return data;
			}
			// Sets multiple values
			if (typeof key === "object") {
				return this.each(function() {
					dataUser.set(this, key);
				});
			}
			return access(this, function(value) {
				var data;
				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if (elem && value === undefined) {
					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get(elem, key);
					if (data !== undefined) {
						return data;
					}
					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr(elem, key);
					if (data !== undefined) {
						return data;
					}
					// We tried really hard, but the data doesn't exist.
					return;
				}
				// Set the data...
				this.each(function() {
					// We always store the camelCased key
					dataUser.set(this, key, value);
				});
			}, null, value, arguments.length > 1, null, true);
		},
		removeData: function(key) {
			return this.each(function() {
				dataUser.remove(this, key);
			});
		}
	});
	jQuery.extend({
		queue: function(elem, type, data) {
			var queue;
			if (elem) {
				type = (type || "fx") + "queue";
				queue = dataPriv.get(elem, type);
				// Speed up dequeue by getting out quickly if this is just a lookup
				if (data) {
					if (!queue || Array.isArray(data)) {
						queue = dataPriv.access(elem, type, jQuery.makeArray(data));
					} else {
						queue.push(data);
					}
				}
				return queue || [];
			}
		},
		dequeue: function(elem, type) {
			type = type || "fx";
			var queue = jQuery.queue(elem, type),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks(elem, type),
				next = function() {
					jQuery.dequeue(elem, type);
				};
			// If the fx queue is dequeued, always remove the progress sentinel
			if (fn === "inprogress") {
				fn = queue.shift();
				startLength--;
			}
			if (fn) {
				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if (type === "fx") {
					queue.unshift("inprogress");
				}
				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call(elem, next, hooks);
			}
			if (!startLength && hooks) {
				hooks.empty.fire();
			}
		},
		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function(elem, type) {
			var key = type + "queueHooks";
			return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
				empty: jQuery.Callbacks("once memory").add(function() {
					dataPriv.remove(elem, [type + "queue", key]);
				})
			});
		}
	});
	jQuery.fn.extend({
		queue: function(type, data) {
			var setter = 2;
			if (typeof type !== "string") {
				data = type;
				type = "fx";
				setter--;
			}
			if (arguments.length < setter) {
				return jQuery.queue(this[0], type);
			}
			return data === undefined ?
				this :
				this.each(function() {
					var queue = jQuery.queue(this, type, data);
					// Ensure a hooks for this queue
					jQuery._queueHooks(this, type);
					if (type === "fx" && queue[0] !== "inprogress") {
						jQuery.dequeue(this, type);
					}
				});
		},
		dequeue: function(type) {
			return this.each(function() {
				jQuery.dequeue(this, type);
			});
		},
		clearQueue: function(type) {
			return this.queue(type || "fx", []);
		},
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function(type, obj) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if (!(--count)) {
						defer.resolveWith(elements, [elements]);
					}
				};
			if (typeof type !== "string") {
				obj = type;
				type = undefined;
			}
			type = type || "fx";
			while (i--) {
				tmp = dataPriv.get(elements[i], type + "queueHooks");
				if (tmp && tmp.empty) {
					count++;
					tmp.empty.add(resolve);
				}
			}
			resolve();
			return defer.promise(obj);
		}
	});
	var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
	var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
	var cssExpand = ["Top", "Right", "Bottom", "Left"];
	var documentElement = document.documentElement;
	var isAttached = function(elem) {
			return jQuery.contains(elem.ownerDocument, elem);
		},
		composed = {
			composed: true
		};
	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if (documentElement.getRootNode) {
		isAttached = function(elem) {
			return jQuery.contains(elem.ownerDocument, elem) ||
				elem.getRootNode(composed) === elem.ownerDocument;
		};
	}
	var isHiddenWithinTree = function(elem, el) {
		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&
			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached(elem) &&
			jQuery.css(elem, "display") === "none";
	};

	function adjustCSS(elem, prop, valueParts, tween) {
		var adjusted, scale,
			maxIterations = 20,
			currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css(elem, prop, "");
			},
			initial = currentValue(),
			unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
			// Starting value computation is required for potential unit mismatches
			initialInUnit = elem.nodeType &&
			(jQuery.cssNumber[prop] || unit !== "px" && +initial) &&
			rcssNum.exec(jQuery.css(elem, prop));
		if (initialInUnit && initialInUnit[3] !== unit) {
			// Support: Firefox <=54
			// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
			initial = initial / 2;
			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[3];
			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;
			while (maxIterations--) {
				// Evaluate and update our best guess (doubling guesses that zero out).
				// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
				jQuery.style(elem, prop, initialInUnit + unit);
				if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
					maxIterations = 0;
				}
				initialInUnit = initialInUnit / scale;
			}
			initialInUnit = initialInUnit * 2;
			jQuery.style(elem, prop, initialInUnit + unit);
			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
		}
		if (valueParts) {
			initialInUnit = +initialInUnit || +initial || 0;
			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[1] ?
				initialInUnit + (valueParts[1] + 1) * valueParts[2] :
				+valueParts[2];
			if (tween) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var defaultDisplayMap = {};

	function getDefaultDisplay(elem) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[nodeName];
		if (display) {
			return display;
		}
		temp = doc.body.appendChild(doc.createElement(nodeName));
		display = jQuery.css(temp, "display");
		temp.parentNode.removeChild(temp);
		if (display === "none") {
			display = "block";
		}
		defaultDisplayMap[nodeName] = display;
		return display;
	}

	function showHide(elements, show) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;
		// Determine new display value for elements that need to change
		for (; index < length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}
			display = elem.style.display;
			if (show) {
				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if (display === "none") {
					values[index] = dataPriv.get(elem, "display") || null;
					if (!values[index]) {
						elem.style.display = "";
					}
				}
				if (elem.style.display === "" && isHiddenWithinTree(elem)) {
					values[index] = getDefaultDisplay(elem);
				}
			} else {
				if (display !== "none") {
					values[index] = "none";
					// Remember what we're overwriting
					dataPriv.set(elem, "display", display);
				}
			}
		}
		// Set the display of the elements in a second loop to avoid constant reflow
		for (index = 0; index < length; index++) {
			if (values[index] != null) {
				elements[index].style.display = values[index];
			}
		}
		return elements;
	}
	jQuery.fn.extend({
		show: function() {
			return showHide(this, true);
		},
		hide: function() {
			return showHide(this);
		},
		toggle: function(state) {
			if (typeof state === "boolean") {
				return state ? this.show() : this.hide();
			}
			return this.each(function() {
				if (isHiddenWithinTree(this)) {
					jQuery(this).show();
				} else {
					jQuery(this).hide();
				}
			});
		}
	});
	var rcheckableType = (/^(?:checkbox|radio)$/i);
	var rtagName = (/<([a-z][^\/\0>\x20\t\r\n\f]*)/i);
	var rscriptType = (/^$|^module$|\/(?:java|ecma)script/i);
	(function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild(document.createElement("div")),
			input = document.createElement("input");
		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute("type", "radio");
		input.setAttribute("checked", "checked");
		input.setAttribute("name", "t");
		div.appendChild(input);
		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
		// Support: IE <=9 only
		// IE <=9 replaces <option> tags with their contents when inserted outside of
		// the select element.
		div.innerHTML = "<option></option>";
		support.option = !!div.lastChild;
	})();
	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {
		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [1, "<table>", "</table>"],
		col: [2, "<table><colgroup>", "</colgroup></table>"],
		tr: [2, "<table><tbody>", "</tbody></table>"],
		td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
		_default: [0, "", ""]
	};
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;
	// Support: IE <=9 only
	if (!support.option) {
		wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
	}

	function getAll(context, tag) {
		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;
		if (typeof context.getElementsByTagName !== "undefined") {
			ret = context.getElementsByTagName(tag || "*");
		} else if (typeof context.querySelectorAll !== "undefined") {
			ret = context.querySelectorAll(tag || "*");
		} else {
			ret = [];
		}
		if (tag === undefined || tag && nodeName(context, tag)) {
			return jQuery.merge([context], ret);
		}
		return ret;
	}
	// Mark scripts as having already been evaluated
	function setGlobalEval(elems, refElements) {
		var i = 0,
			l = elems.length;
		for (; i < l; i++) {
			dataPriv.set(
				elems[i],
				"globalEval",
				!refElements || dataPriv.get(refElements[i], "globalEval")
			);
		}
	}
	var rhtml = /<|&#?\w+;/;

	function buildFragment(elems, context, scripts, selection, ignored) {
		var elem, tmp, tag, wrap, attached, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;
		for (; i < l; i++) {
			elem = elems[i];
			if (elem || elem === 0) {
				// Add nodes directly
				if (toType(elem) === "object") {
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
					// Convert non-html into a text node
				} else if (!rhtml.test(elem)) {
					nodes.push(context.createTextNode(elem));
					// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild(context.createElement("div"));
					// Deserialize a standard representation
					tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
					wrap = wrapMap[tag] || wrapMap._default;
					tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
					// Descend through wrappers to the right content
					j = wrap[0];
					while (j--) {
						tmp = tmp.lastChild;
					}
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, tmp.childNodes);
					// Remember the top-level container
					tmp = fragment.firstChild;
					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}
		// Remove wrapper from fragment
		fragment.textContent = "";
		i = 0;
		while ((elem = nodes[i++])) {
			// Skip elements already in the context collection (trac-4087)
			if (selection && jQuery.inArray(elem, selection) > -1) {
				if (ignored) {
					ignored.push(elem);
				}
				continue;
			}
			attached = isAttached(elem);
			// Append to fragment
			tmp = getAll(fragment.appendChild(elem), "script");
			// Preserve script evaluation history
			if (attached) {
				setGlobalEval(tmp);
			}
			// Capture executables
			if (scripts) {
				j = 0;
				while ((elem = tmp[j++])) {
					if (rscriptType.test(elem.type || "")) {
						scripts.push(elem);
					}
				}
			}
		}
		return fragment;
	}
	var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}
	// Support: IE <=9 - 11+
	// focus() and blur() are asynchronous, except when they are no-op.
	// So expect focus to be synchronous when the element is already active,
	// and blur to be synchronous when the element is not already active.
	// (focus and blur are always synchronous in other supported browsers,
	// this just defines when we can count on it).
	function expectSync(elem, type) {
		return (elem === safeActiveElement()) === (type === "focus");
	}
	// Support: IE <=9 only
	// Accessing document.activeElement can throw unexpectedly
	// https://bugs.jquery.com/ticket/13393
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch (err) {}
	}

	function on(elem, types, selector, data, fn, one) {
		var origFn, type;
		// Types can be a map of types/handlers
		if (typeof types === "object") {
			// ( types-Object, selector, data )
			if (typeof selector !== "string") {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for (type in types) {
				on(elem, type, selector, data, types[type], one);
			}
			return elem;
		}
		if (data == null && fn == null) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if (fn == null) {
			if (typeof selector === "string") {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if (fn === false) {
			fn = returnFalse;
		} else if (!fn) {
			return elem;
		}
		if (one === 1) {
			origFn = fn;
			fn = function(event) {
				// Can use an empty set, since event contains the info
				jQuery().off(event);
				return origFn.apply(this, arguments);
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
		}
		return elem.each(function() {
			jQuery.event.add(this, types, fn, data, selector);
		});
	}
	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {
		global: {},
		add: function(elem, types, handler, data, selector) {
			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get(elem);
			// Only attach events to objects that accept data
			if (!acceptData(elem)) {
				return;
			}
			// Caller can pass in an object of custom data in lieu of the handler
			if (handler.handler) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}
			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if (selector) {
				jQuery.find.matchesSelector(documentElement, selector);
			}
			// Make sure that the handler has a unique ID, used to find/remove it later
			if (!handler.guid) {
				handler.guid = jQuery.guid++;
			}
			// Init the element's event structure and main handler, if this is the first
			if (!(events = elemData.events)) {
				events = elemData.events = Object.create(null);
			}
			if (!(eventHandle = elemData.handle)) {
				eventHandle = elemData.handle = function(e) {
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply(elem, arguments) : undefined;
				};
			}
			// Handle multiple events separated by a space
			types = (types || "").match(rnothtmlwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();
				// There *must* be a type, no attaching namespace-only handlers
				if (!type) {
					continue;
				}
				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[type] || {};
				// If selector defined, determine special event api type, otherwise given type
				type = (selector ? special.delegateType : special.bindType) || type;
				// Update special based on newly reset type
				special = jQuery.event.special[type] || {};
				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test(selector),
					namespace: namespaces.join(".")
				}, handleObjIn);
				// Init the event handler queue if we're the first
				if (!(handlers = events[type])) {
					handlers = events[type] = [];
					handlers.delegateCount = 0;
					// Only use addEventListener if the special events handler returns false
					if (!special.setup ||
						special.setup.call(elem, data, namespaces, eventHandle) === false) {
						if (elem.addEventListener) {
							elem.addEventListener(type, eventHandle);
						}
					}
				}
				if (special.add) {
					special.add.call(elem, handleObj);
					if (!handleObj.handler.guid) {
						handleObj.handler.guid = handler.guid;
					}
				}
				// Add to the element's handler list, delegates in front
				if (selector) {
					handlers.splice(handlers.delegateCount++, 0, handleObj);
				} else {
					handlers.push(handleObj);
				}
				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[type] = true;
			}
		},
		// Detach an event or set of events from an element
		remove: function(elem, types, handler, selector, mappedTypes) {
			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
			if (!elemData || !(events = elemData.events)) {
				return;
			}
			// Once for each type.namespace in types; type may be omitted
			types = (types || "").match(rnothtmlwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();
				// Unbind all events (on this namespace, if provided) for the element
				if (!type) {
					for (type in events) {
						jQuery.event.remove(elem, type + types[t], handler, selector, true);
					}
					continue;
				}
				special = jQuery.event.special[type] || {};
				type = (selector ? special.delegateType : special.bindType) || type;
				handlers = events[type] || [];
				tmp = tmp[2] &&
					new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
				// Remove matching events
				origCount = j = handlers.length;
				while (j--) {
					handleObj = handlers[j];
					if ((mappedTypes || origType === handleObj.origType) &&
						(!handler || handler.guid === handleObj.guid) &&
						(!tmp || tmp.test(handleObj.namespace)) &&
						(!selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector)) {
						handlers.splice(j, 1);
						if (handleObj.selector) {
							handlers.delegateCount--;
						}
						if (special.remove) {
							special.remove.call(elem, handleObj);
						}
					}
				}
				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if (origCount && !handlers.length) {
					if (!special.teardown ||
						special.teardown.call(elem, namespaces, elemData.handle) === false) {
						jQuery.removeEvent(elem, type, elemData.handle);
					}
					delete events[type];
				}
			}
			// Remove data and the expando if it's no longer used
			if (jQuery.isEmptyObject(events)) {
				dataPriv.remove(elem, "handle events");
			}
		},
		dispatch: function(nativeEvent) {
			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array(arguments.length),
				// Make a writable jQuery.Event from the native event object
				event = jQuery.event.fix(nativeEvent),
				handlers = (
					dataPriv.get(this, "events") || Object.create(null)
				)[event.type] || [],
				special = jQuery.event.special[event.type] || {};
			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			for (i = 1; i < arguments.length; i++) {
				args[i] = arguments[i];
			}
			event.delegateTarget = this;
			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if (special.preDispatch && special.preDispatch.call(this, event) === false) {
				return;
			}
			// Determine handlers
			handlerQueue = jQuery.event.handlers.call(this, event, handlers);
			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
				event.currentTarget = matched.elem;
				j = 0;
				while ((handleObj = matched.handlers[j++]) &&
					!event.isImmediatePropagationStopped()) {
					// If the event is namespaced, then each handler is only invoked if it is
					// specially universal or its namespaces are a superset of the event's.
					if (!event.rnamespace || handleObj.namespace === false ||
						event.rnamespace.test(handleObj.namespace)) {
						event.handleObj = handleObj;
						event.data = handleObj.data;
						ret = ((jQuery.event.special[handleObj.origType] || {}).handle ||
							handleObj.handler).apply(matched.elem, args);
						if (ret !== undefined) {
							if ((event.result = ret) === false) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}
			// Call the postDispatch hook for the mapped type
			if (special.postDispatch) {
				special.postDispatch.call(this, event);
			}
			return event.result;
		},
		handlers: function(event, handlers) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;
			// Find delegate handlers
			if (delegateCount &&
				// Support: IE <=9
				// Black-hole SVG <use> instance trees (trac-13180)
				cur.nodeType &&
				// Support: Firefox <=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!(event.type === "click" && event.button >= 1)) {
				for (; cur !== this; cur = cur.parentNode || this) {
					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
						matchedHandlers = [];
						matchedSelectors = {};
						for (i = 0; i < delegateCount; i++) {
							handleObj = handlers[i];
							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";
							if (matchedSelectors[sel] === undefined) {
								matchedSelectors[sel] = handleObj.needsContext ?
									jQuery(sel, this).index(cur) > -1 :
									jQuery.find(sel, this, null, [cur]).length;
							}
							if (matchedSelectors[sel]) {
								matchedHandlers.push(handleObj);
							}
						}
						if (matchedHandlers.length) {
							handlerQueue.push({
								elem: cur,
								handlers: matchedHandlers
							});
						}
					}
				}
			}
			// Add the remaining (directly-bound) handlers
			cur = this;
			if (delegateCount < handlers.length) {
				handlerQueue.push({
					elem: cur,
					handlers: handlers.slice(delegateCount)
				});
			}
			return handlerQueue;
		},
		addProp: function(name, hook) {
			Object.defineProperty(jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,
				get: isFunction(hook) ?
					function() {
						if (this.originalEvent) {
							return hook(this.originalEvent);
						}
					} : function() {
						if (this.originalEvent) {
							return this.originalEvent[name];
						}
					},
				set: function(value) {
					Object.defineProperty(this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					});
				}
			});
		},
		fix: function(originalEvent) {
			return originalEvent[jQuery.expando] ?
				originalEvent :
				new jQuery.Event(originalEvent);
		},
		special: {
			load: {
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			click: {
				// Utilize native event to ensure correct state for checkable inputs
				setup: function(data) {
					// For mutual compressibility with _default, replace `this` access with a local var.
					// `|| data` is dead code meant only to preserve the variable through minification.
					var el = this || data;
					// Claim the first handler
					if (rcheckableType.test(el.type) &&
						el.click && nodeName(el, "input")) {
						// dataPriv.set( el, "click", ... )
						leverageNative(el, "click", returnTrue);
					}
					// Return false to allow normal processing in the caller
					return false;
				},
				trigger: function(data) {
					// For mutual compressibility with _default, replace `this` access with a local var.
					// `|| data` is dead code meant only to preserve the variable through minification.
					var el = this || data;
					// Force setup before triggering a click
					if (rcheckableType.test(el.type) &&
						el.click && nodeName(el, "input")) {
						leverageNative(el, "click");
					}
					// Return non-false to allow normal event-path propagation
					return true;
				},
				// For cross-browser consistency, suppress native .click() on links
				// Also prevent it if we're currently inside a leveraged native-event stack
				_default: function(event) {
					var target = event.target;
					return rcheckableType.test(target.type) &&
						target.click && nodeName(target, "input") &&
						dataPriv.get(target, "click") ||
						nodeName(target, "a");
				}
			},
			beforeunload: {
				postDispatch: function(event) {
					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if (event.result !== undefined && event.originalEvent) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};
	// Ensure the presence of an event listener that handles manually-triggered
	// synthetic events by interrupting progress until reinvoked in response to
	// *native* events that it fires directly, ensuring that state changes have
	// already occurred before other listeners are invoked.
	function leverageNative(el, type, expectSync) {
		// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
		if (!expectSync) {
			if (dataPriv.get(el, type) === undefined) {
				jQuery.event.add(el, type, returnTrue);
			}
			return;
		}
		// Register the controller as a special universal handler for all event namespaces
		dataPriv.set(el, type, false);
		jQuery.event.add(el, type, {
			namespace: false,
			handler: function(event) {
				var notAsync, result,
					saved = dataPriv.get(this, type);
				if ((event.isTrigger & 1) && this[type]) {
					// Interrupt processing of the outer synthetic .trigger()ed event
					// Saved data should be false in such cases, but might be a leftover capture object
					// from an async native handler (gh-4350)
					if (!saved.length) {
						// Store arguments for use when handling the inner native event
						// There will always be at least one argument (an event object), so this array
						// will not be confused with a leftover capture object.
						saved = slice.call(arguments);
						dataPriv.set(this, type, saved);
						// Trigger the native event and capture its result
						// Support: IE <=9 - 11+
						// focus() and blur() are asynchronous
						notAsync = expectSync(this, type);
						this[type]();
						result = dataPriv.get(this, type);
						if (saved !== result || notAsync) {
							dataPriv.set(this, type, false);
						} else {
							result = {};
						}
						if (saved !== result) {
							// Cancel the outer synthetic event
							event.stopImmediatePropagation();
							event.preventDefault();
							// Support: Chrome 86+
							// In Chrome, if an element having a focusout handler is blurred by
							// clicking outside of it, it invokes the handler synchronously. If
							// that handler calls `.remove()` on the element, the data is cleared,
							// leaving `result` undefined. We need to guard against this.
							return result && result.value;
						}
						// If this is an inner synthetic event for an event with a bubbling surrogate
						// (focus or blur), assume that the surrogate already propagated from triggering the
						// native event and prevent that from happening again here.
						// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
						// bubbling surrogate propagates *after* the non-bubbling base), but that seems
						// less bad than duplication.
					} else if ((jQuery.event.special[type] || {}).delegateType) {
						event.stopPropagation();
					}
					// If this is a native event triggered above, everything is now in order
					// Fire an inner synthetic event with the original arguments
				} else if (saved.length) {
					// ...and capture the result
					dataPriv.set(this, type, {
						value: jQuery.event.trigger(
							// Support: IE <=9 - 11+
							// Extend with the prototype to reset the above stopImmediatePropagation()
							jQuery.extend(saved[0], jQuery.Event.prototype),
							saved.slice(1),
							this
						)
					});
					// Abort handling of the native event
					event.stopImmediatePropagation();
				}
			}
		});
	}
	jQuery.removeEvent = function(elem, type, handle) {
		// This "if" is needed for plain objects
		if (elem.removeEventListener) {
			elem.removeEventListener(type, handle);
		}
	};
	jQuery.Event = function(src, props) {
		// Allow instantiation without the 'new' keyword
		if (!(this instanceof jQuery.Event)) {
			return new jQuery.Event(src, props);
		}
		// Event object
		if (src && src.type) {
			this.originalEvent = src;
			this.type = src.type;
			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android <=2.3 only
				src.returnValue === false ?
				returnTrue :
				returnFalse;
			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = (src.target && src.target.nodeType === 3) ?
				src.target.parentNode :
				src.target;
			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;
			// Event type
		} else {
			this.type = src;
		}
		// Put explicitly provided properties onto the event object
		if (props) {
			jQuery.extend(this, props);
		}
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || Date.now();
		// Mark it as fixed
		this[jQuery.expando] = true;
	};
	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,
		preventDefault: function() {
			var e = this.originalEvent;
			this.isDefaultPrevented = returnTrue;
			if (e && !this.isSimulated) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;
			this.isPropagationStopped = returnTrue;
			if (e && !this.isSimulated) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;
			this.isImmediatePropagationStopped = returnTrue;
			if (e && !this.isSimulated) {
				e.stopImmediatePropagation();
			}
			this.stopPropagation();
		}
	};
	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each({
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		code: true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,
		which: true
	}, jQuery.event.addProp);
	jQuery.each({
		focus: "focusin",
		blur: "focusout"
	}, function(type, delegateType) {
		jQuery.event.special[type] = {
			// Utilize native event if possible so blur/focus sequence is correct
			setup: function() {
				// Claim the first handler
				// dataPriv.set( this, "focus", ... )
				// dataPriv.set( this, "blur", ... )
				leverageNative(this, type, expectSync);
				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function() {
				// Force setup before trigger
				leverageNative(this, type);
				// Return non-false to allow normal event-path propagation
				return true;
			},
			// Suppress native focus or blur as it's already being fired
			// in leverageNative.
			_default: function() {
				return true;
			},
			delegateType: delegateType
		};
	});
	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function(orig, fix) {
		jQuery.event.special[orig] = {
			delegateType: fix,
			bindType: fix,
			handle: function(event) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;
				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if (!related || (related !== target && !jQuery.contains(target, related))) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply(this, arguments);
					event.type = fix;
				}
				return ret;
			}
		};
	});
	jQuery.fn.extend({
		on: function(types, selector, data, fn) {
			return on(this, types, selector, data, fn);
		},
		one: function(types, selector, data, fn) {
			return on(this, types, selector, data, fn, 1);
		},
		off: function(types, selector, fn) {
			var handleObj, type;
			if (types && types.preventDefault && types.handleObj) {
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery(types.delegateTarget).off(
					handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if (typeof types === "object") {
				// ( types-object [, selector] )
				for (type in types) {
					this.off(type, selector, types[type]);
				}
				return this;
			}
			if (selector === false || typeof selector === "function") {
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if (fn === false) {
				fn = returnFalse;
			}
			return this.each(function() {
				jQuery.event.remove(this, types, fn, selector);
			});
		}
	});
	var
		// Support: IE <=10 - 11, Edge 12 - 13 only
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
	// Prefer a tbody over its parent table for containing new rows
	function manipulationTarget(elem, content) {
		if (nodeName(elem, "table") &&
			nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
			return jQuery(elem).children("tbody")[0] || elem;
		}
		return elem;
	}
	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript(elem) {
		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
		return elem;
	}

	function restoreScript(elem) {
		if ((elem.type || "").slice(0, 5) === "true/") {
			elem.type = elem.type.slice(5);
		} else {
			elem.removeAttribute("type");
		}
		return elem;
	}

	function cloneCopyEvent(src, dest) {
		var i, l, type, pdataOld, udataOld, udataCur, events;
		if (dest.nodeType !== 1) {
			return;
		}
		// 1. Copy private data: events, handlers, etc.
		if (dataPriv.hasData(src)) {
			pdataOld = dataPriv.get(src);
			events = pdataOld.events;
			if (events) {
				dataPriv.remove(dest, "handle events");
				for (type in events) {
					for (i = 0, l = events[type].length; i < l; i++) {
						jQuery.event.add(dest, type, events[type][i]);
					}
				}
			}
		}
		// 2. Copy user data
		if (dataUser.hasData(src)) {
			udataOld = dataUser.access(src);
			udataCur = jQuery.extend({}, udataOld);
			dataUser.set(dest, udataCur);
		}
	}
	// Fix IE bugs, see support tests
	function fixInput(src, dest) {
		var nodeName = dest.nodeName.toLowerCase();
		// Fails to persist the checked state of a cloned checkbox or radio button.
		if (nodeName === "input" && rcheckableType.test(src.type)) {
			dest.checked = src.checked;
			// Fails to return the selected option to the default selected state when cloning options
		} else if (nodeName === "input" || nodeName === "textarea") {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip(collection, args, callback, ignored) {
		// Flatten any nested arrays
		args = flat(args);
		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[0],
			valueIsFunction = isFunction(value);
		// We can't cloneNode fragments that contain checked, in WebKit
		if (valueIsFunction ||
			(l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test(value))) {
			return collection.each(function(index) {
				var self = collection.eq(index);
				if (valueIsFunction) {
					args[0] = value.call(this, index, self.html());
				}
				domManip(self, args, callback, ignored);
			});
		}
		if (l) {
			fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
			first = fragment.firstChild;
			if (fragment.childNodes.length === 1) {
				fragment = first;
			}
			// Require either new content or an interest in ignored elements to invoke the callback
			if (first || ignored) {
				scripts = jQuery.map(getAll(fragment, "script"), disableScript);
				hasScripts = scripts.length;
				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for (; i < l; i++) {
					node = fragment;
					if (i !== iNoClone) {
						node = jQuery.clone(node, true, true);
						// Keep references to cloned scripts for later restoration
						if (hasScripts) {
							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge(scripts, getAll(node, "script"));
						}
					}
					callback.call(collection[i], node, i);
				}
				if (hasScripts) {
					doc = scripts[scripts.length - 1].ownerDocument;
					// Reenable scripts
					jQuery.map(scripts, restoreScript);
					// Evaluate executable scripts on first document insertion
					for (i = 0; i < hasScripts; i++) {
						node = scripts[i];
						if (rscriptType.test(node.type || "") &&
							!dataPriv.access(node, "globalEval") &&
							jQuery.contains(doc, node)) {
							if (node.src && (node.type || "").toLowerCase() !== "module") {
								// Optional AJAX dependency, but won't run scripts if not present
								if (jQuery._evalUrl && !node.noModule) {
									jQuery._evalUrl(node.src, {
										nonce: node.nonce || node.getAttribute("nonce")
									}, doc);
								}
							} else {
								DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
							}
						}
					}
				}
			}
		}
		return collection;
	}

	function remove(elem, selector, keepData) {
		var node,
			nodes = selector ? jQuery.filter(selector, elem) : elem,
			i = 0;
		for (;
			(node = nodes[i]) != null; i++) {
			if (!keepData && node.nodeType === 1) {
				jQuery.cleanData(getAll(node));
			}
			if (node.parentNode) {
				if (keepData && isAttached(node)) {
					setGlobalEval(getAll(node, "script"));
				}
				node.parentNode.removeChild(node);
			}
		}
		return elem;
	}
	jQuery.extend({
		htmlPrefilter: function(html) {
			return html;
		},
		clone: function(elem, dataAndEvents, deepDataAndEvents) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode(true),
				inPage = isAttached(elem);
			// Fix IE cloning issues
			if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&
				!jQuery.isXMLDoc(elem)) {
				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll(clone);
				srcElements = getAll(elem);
				for (i = 0, l = srcElements.length; i < l; i++) {
					fixInput(srcElements[i], destElements[i]);
				}
			}
			// Copy the events from the original to the clone
			if (dataAndEvents) {
				if (deepDataAndEvents) {
					srcElements = srcElements || getAll(elem);
					destElements = destElements || getAll(clone);
					for (i = 0, l = srcElements.length; i < l; i++) {
						cloneCopyEvent(srcElements[i], destElements[i]);
					}
				} else {
					cloneCopyEvent(elem, clone);
				}
			}
			// Preserve script evaluation history
			destElements = getAll(clone, "script");
			if (destElements.length > 0) {
				setGlobalEval(destElements, !inPage && getAll(elem, "script"));
			}
			// Return the cloned set
			return clone;
		},
		cleanData: function(elems) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;
			for (;
				(elem = elems[i]) !== undefined; i++) {
				if (acceptData(elem)) {
					if ((data = elem[dataPriv.expando])) {
						if (data.events) {
							for (type in data.events) {
								if (special[type]) {
									jQuery.event.remove(elem, type);
									// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent(elem, type, data.handle);
								}
							}
						}
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataPriv.expando] = undefined;
					}
					if (elem[dataUser.expando]) {
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataUser.expando] = undefined;
					}
				}
			}
		}
	});
	jQuery.fn.extend({
		detach: function(selector) {
			return remove(this, selector, true);
		},
		remove: function(selector) {
			return remove(this, selector);
		},
		text: function(value) {
			return access(this, function(value) {
				return value === undefined ?
					jQuery.text(this) :
					this.empty().each(function() {
						if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
							this.textContent = value;
						}
					});
			}, null, value, arguments.length);
		},
		append: function() {
			return domManip(this, arguments, function(elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.appendChild(elem);
				}
			});
		},
		prepend: function() {
			return domManip(this, arguments, function(elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.insertBefore(elem, target.firstChild);
				}
			});
		},
		before: function() {
			return domManip(this, arguments, function(elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this);
				}
			});
		},
		after: function() {
			return domManip(this, arguments, function(elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this.nextSibling);
				}
			});
		},
		empty: function() {
			var elem,
				i = 0;
			for (;
				(elem = this[i]) != null; i++) {
				if (elem.nodeType === 1) {
					// Prevent memory leaks
					jQuery.cleanData(getAll(elem, false));
					// Remove any remaining nodes
					elem.textContent = "";
				}
			}
			return this;
		},
		clone: function(dataAndEvents, deepDataAndEvents) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
			return this.map(function() {
				return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
			});
		},
		html: function(value) {
			return access(this, function(value) {
				var elem = this[0] || {},
					i = 0,
					l = this.length;
				if (value === undefined && elem.nodeType === 1) {
					return elem.innerHTML;
				}
				// See if we can take a shortcut and just use innerHTML
				if (typeof value === "string" && !rnoInnerhtml.test(value) &&
					!wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
					value = jQuery.htmlPrefilter(value);
					try {
						for (; i < l; i++) {
							elem = this[i] || {};
							// Remove element nodes and prevent memory leaks
							if (elem.nodeType === 1) {
								jQuery.cleanData(getAll(elem, false));
								elem.innerHTML = value;
							}
						}
						elem = 0;
						// If using innerHTML throws an exception, use the fallback method
					} catch (e) {}
				}
				if (elem) {
					this.empty().append(value);
				}
			}, null, value, arguments.length);
		},
		replaceWith: function() {
			var ignored = [];
			// Make the changes, replacing each non-ignored context element with the new content
			return domManip(this, arguments, function(elem) {
				var parent = this.parentNode;
				if (jQuery.inArray(this, ignored) < 0) {
					jQuery.cleanData(getAll(this));
					if (parent) {
						parent.replaceChild(elem, this);
					}
				}
				// Force callback invocation
			}, ignored);
		}
	});
	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function(name, original) {
		jQuery.fn[name] = function(selector) {
			var elems,
				ret = [],
				insert = jQuery(selector),
				last = insert.length - 1,
				i = 0;
			for (; i <= last; i++) {
				elems = i === last ? this : this.clone(true);
				jQuery(insert[i])[original](elems);
				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply(ret, elems.get());
			}
			return this.pushStack(ret);
		};
	});
	var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
	var getStyles = function(elem) {
		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;
		if (!view || !view.opener) {
			view = window;
		}
		return view.getComputedStyle(elem);
	};
	var swap = function(elem, options, callback) {
		var ret, name,
			old = {};
		// Remember the old values, and insert the new ones
		for (name in options) {
			old[name] = elem.style[name];
			elem.style[name] = options[name];
		}
		ret = callback.call(elem);
		// Revert the old values
		for (name in options) {
			elem.style[name] = old[name];
		}
		return ret;
	};
	var rboxStyle = new RegExp(cssExpand.join("|"), "i");
	(function() {
		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			// This is a singleton, we need to execute it only once
			if (!div) {
				return;
			}
			container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
				"margin-top:1px;padding:0;border:0";
			div.style.cssText =
				"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
				"margin:auto;border:1px;padding:1px;" +
				"width:60%;top:1%";
			documentElement.appendChild(container).appendChild(div);
			var divStyle = window.getComputedStyle(div);
			pixelPositionVal = divStyle.top !== "1%";
			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
			// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
			// Some styles come back with percentage values, even though they shouldn't
			div.style.right = "60%";
			pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
			// Support: IE 9 - 11 only
			// Detect misreporting of content dimensions for box-sizing:border-box elements
			boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
			// Support: IE 9 only
			// Detect overflow:scroll screwiness (gh-3699)
			// Support: Chrome <=64
			// Don't get tricked when zoom affects offsetWidth (gh-4029)
			div.style.position = "absolute";
			scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
			documentElement.removeChild(container);
			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}

		function roundPixelMeasures(measure) {
			return Math.round(parseFloat(measure));
		}
		var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
			reliableTrDimensionsVal, reliableMarginLeftVal,
			container = document.createElement("div"),
			div = document.createElement("div");
		// Finish early in limited (non-browser) environments
		if (!div.style) {
			return;
		}
		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode(true).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";
		jQuery.extend(support, {
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelBoxStyles: function() {
				computeStyleTests();
				return pixelBoxStylesVal;
			},
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			},
			scrollboxSize: function() {
				computeStyleTests();
				return scrollboxSizeVal;
			},
			// Support: IE 9 - 11+, Edge 15 - 18+
			// IE/Edge misreport `getComputedStyle` of table rows with width/height
			// set in CSS while `offset*` properties report correct values.
			// Behavior in IE 9 is more subtle than in newer versions & it passes
			// some versions of this test; make sure not to make it pass there!
			//
			// Support: Firefox 70+
			// Only Firefox includes border widths
			// in computed dimensions. (gh-4529)
			reliableTrDimensions: function() {
				var table, tr, trChild, trStyle;
				if (reliableTrDimensionsVal == null) {
					table = document.createElement("table");
					tr = document.createElement("tr");
					trChild = document.createElement("div");
					table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
					tr.style.cssText = "border:1px solid";
					// Support: Chrome 86+
					// Height set through cssText does not get applied.
					// Computed height then comes back as 0.
					tr.style.height = "1px";
					trChild.style.height = "9px";
					// Support: Android 8 Chrome 86+
					// In our bodyBackground.html iframe,
					// display for all div elements is set to "inline",
					// which causes a problem only in Android 8 Chrome 86.
					// Ensuring the div is display: block
					// gets around this issue.
					trChild.style.display = "block";
					documentElement
						.appendChild(table)
						.appendChild(tr)
						.appendChild(trChild);
					trStyle = window.getComputedStyle(tr);
					reliableTrDimensionsVal = (parseInt(trStyle.height, 10) +
						parseInt(trStyle.borderTopWidth, 10) +
						parseInt(trStyle.borderBottomWidth, 10)) === tr.offsetHeight;
					documentElement.removeChild(table);
				}
				return reliableTrDimensionsVal;
			}
		});
	})();

	function curCSS(elem, name, computed) {
		var width, minWidth, maxWidth, ret,
			// Support: Firefox 51+
			// Retrieving style before computed somehow
			// fixes an issue with getting wrong values
			// on detached elements
			style = elem.style;
		computed = computed || getStyles(elem);
		// getPropertyValue is needed for:
		//   .css('filter') (IE 9 only, #12537)
		//   .css('--customProperty) (#3144)
		if (computed) {
			ret = computed.getPropertyValue(name) || computed[name];
			if (ret === "" && !isAttached(elem)) {
				ret = jQuery.style(elem, name);
			}
			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;
				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;
				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}
		return ret !== undefined ?
			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}

	function addGetHookIf(conditionFn, hookFn) {
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if (conditionFn()) {
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}
				// Hook needed; redefine it so that the support test is not executed again.
				return (this.get = hookFn).apply(this, arguments);
			}
		};
	}
	var cssPrefixes = ["Webkit", "Moz", "ms"],
		emptyStyle = document.createElement("div").style,
		vendorProps = {};
	// Return a vendor-prefixed property or undefined
	function vendorPropName(name) {
		// Check for vendor prefixed names
		var capName = name[0].toUpperCase() + name.slice(1),
			i = cssPrefixes.length;
		while (i--) {
			name = cssPrefixes[i] + capName;
			if (name in emptyStyle) {
				return name;
			}
		}
	}
	// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
	function finalPropName(name) {
		var final = jQuery.cssProps[name] || vendorProps[name];
		if (final) {
			return final;
		}
		if (name in emptyStyle) {
			return name;
		}
		return vendorProps[name] = vendorPropName(name) || name;
	}
	var
		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rcustomProp = /^--/,
		cssShow = {
			position: "absolute",
			visibility: "hidden",
			display: "block"
		},
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		};

	function setPositiveNumber(_elem, value, subtract) {
		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec(value);
		return matches ?
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") :
			value;
	}

	function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
		var i = dimension === "width" ? 1 : 0,
			extra = 0,
			delta = 0;
		// Adjustment may not be necessary
		if (box === (isBorderBox ? "border" : "content")) {
			return 0;
		}
		for (; i < 4; i += 2) {
			// Both box models exclude margin
			if (box === "margin") {
				delta += jQuery.css(elem, box + cssExpand[i], true, styles);
			}
			// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
			if (!isBorderBox) {
				// Add padding
				delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
				// For "border" or "margin", add border
				if (box !== "padding") {
					delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
					// But still keep track of it otherwise
				} else {
					extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
				// If we get here with a border-box (content + padding + border), we're seeking "content" or
				// "padding" or "margin"
			} else {
				// For "content", subtract padding
				if (box === "content") {
					delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
				}
				// For "content" or "padding", subtract border
				if (box !== "margin") {
					delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			}
		}
		// Account for positive content-box scroll gutter when requested by providing computedVal
		if (!isBorderBox && computedVal >= 0) {
			// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
			// Assuming integer scroll gutter, subtract the rest and round down
			delta += Math.max(0, Math.ceil(
				elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] -
				computedVal -
				delta -
				extra -
				0.5
				// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
				// Use an explicit zero to avoid NaN (gh-3964)
			)) || 0;
		}
		return delta;
	}

	function getWidthOrHeight(elem, dimension, extra) {
		// Start with computed style
		var styles = getStyles(elem),
			// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
			// Fake content-box until we know it's needed to know the true value.
			boxSizingNeeded = !support.boxSizingReliable() || extra,
			isBorderBox = boxSizingNeeded &&
			jQuery.css(elem, "boxSizing", false, styles) === "border-box",
			valueIsBorderBox = isBorderBox,
			val = curCSS(elem, dimension, styles),
			offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
		// Support: Firefox <=54
		// Return a confounding non-pixel value or feign ignorance, as appropriate.
		if (rnumnonpx.test(val)) {
			if (!extra) {
				return val;
			}
			val = "auto";
		}
		// Support: IE 9 - 11 only
		// Use offsetWidth/offsetHeight for when box sizing is unreliable.
		// In those cases, the computed value can be trusted to be border-box.
		if ((!support.boxSizingReliable() && isBorderBox ||
				// Support: IE 10 - 11+, Edge 15 - 18+
				// IE/Edge misreport `getComputedStyle` of table rows with width/height
				// set in CSS while `offset*` properties report correct values.
				// Interestingly, in some cases IE 9 doesn't suffer from this issue.
				!support.reliableTrDimensions() && nodeName(elem, "tr") ||
				// Fall back to offsetWidth/offsetHeight when value is "auto"
				// This happens for inline elements with no explicit setting (gh-3571)
				val === "auto" ||
				// Support: Android <=4.1 - 4.3 only
				// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
				!parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") &&
			// Make sure the element is visible & connected
			elem.getClientRects().length) {
			isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
			// Where available, offsetWidth/offsetHeight approximate border box dimensions.
			// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
			// retrieved value as a content box dimension.
			valueIsBorderBox = offsetProp in elem;
			if (valueIsBorderBox) {
				val = elem[offsetProp];
			}
		}
		// Normalize "" and auto
		val = parseFloat(val) || 0;
		// Adjust for the element's box model
		return (val +
			boxModelAdjustment(
				elem,
				dimension,
				extra || (isBorderBox ? "border" : "content"),
				valueIsBorderBox,
				styles,
				// Provide the current computed size to request scroll gutter calculation (gh-3589)
				val
			)
		) + "px";
	}
	jQuery.extend({
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function(elem, computed) {
					if (computed) {
						// We should always get a number back from opacity
						var ret = curCSS(elem, "opacity");
						return ret === "" ? "1" : ret;
					}
				}
			}
		},
		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"gridArea": true,
			"gridColumn": true,
			"gridColumnEnd": true,
			"gridColumnStart": true,
			"gridRow": true,
			"gridRowEnd": true,
			"gridRowStart": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},
		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {},
		// Get and set the style property on a DOM Node
		style: function(elem, name, value, extra) {
			// Don't set styles on text and comment nodes
			if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
				return;
			}
			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = camelCase(name),
				isCustomProp = rcustomProp.test(name),
				style = elem.style;
			// Make sure that we're working with the right name. We don't
			// want to query the value if it is a CSS custom property
			// since they are user-defined.
			if (!isCustomProp) {
				name = finalPropName(origName);
			}
			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
			// Check if we're setting a value
			if (value !== undefined) {
				type = typeof value;
				// Convert "+=" or "-=" to relative numbers (#7345)
				if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
					value = adjustCSS(elem, name, ret);
					// Fixes bug #9237
					type = "number";
				}
				// Make sure that null and NaN values aren't set (#7116)
				if (value == null || value !== value) {
					return;
				}
				// If a number was passed in, add the unit (except for certain CSS properties)
				// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
				// "px" to a few hardcoded values.
				if (type === "number" && !isCustomProp) {
					value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
				}
				// background-* props affect original clone's values
				if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
					style[name] = "inherit";
				}
				// If a hook was provided, use that value, otherwise just set the specified value
				if (!hooks || !("set" in hooks) ||
					(value = hooks.set(elem, value, extra)) !== undefined) {
					if (isCustomProp) {
						style.setProperty(name, value);
					} else {
						style[name] = value;
					}
				}
			} else {
				// If a hook was provided get the non-computed value from there
				if (hooks && "get" in hooks &&
					(ret = hooks.get(elem, false, extra)) !== undefined) {
					return ret;
				}
				// Otherwise just get the value from the style object
				return style[name];
			}
		},
		css: function(elem, name, extra, styles) {
			var val, num, hooks,
				origName = camelCase(name),
				isCustomProp = rcustomProp.test(name);
			// Make sure that we're working with the right name. We don't
			// want to modify the value if it is a CSS custom property
			// since they are user-defined.
			if (!isCustomProp) {
				name = finalPropName(origName);
			}
			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
			// If a hook was provided get the computed value from there
			if (hooks && "get" in hooks) {
				val = hooks.get(elem, true, extra);
			}
			// Otherwise, if a way to get the computed value exists, use that
			if (val === undefined) {
				val = curCSS(elem, name, styles);
			}
			// Convert "normal" to computed value
			if (val === "normal" && name in cssNormalTransform) {
				val = cssNormalTransform[name];
			}
			// Make numeric if forced or a qualifier was provided and val looks numeric
			if (extra === "" || extra) {
				num = parseFloat(val);
				return extra === true || isFinite(num) ? num || 0 : val;
			}
			return val;
		}
	});
	jQuery.each(["height", "width"], function(_i, dimension) {
		jQuery.cssHooks[dimension] = {
			get: function(elem, computed, extra) {
				if (computed) {
					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test(jQuery.css(elem, "display")) &&
						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						(!elem.getClientRects().length || !elem.getBoundingClientRect().width) ?
						swap(elem, cssShow, function() {
							return getWidthOrHeight(elem, dimension, extra);
						}) :
						getWidthOrHeight(elem, dimension, extra);
				}
			},
			set: function(elem, value, extra) {
				var matches,
					styles = getStyles(elem),
					// Only read styles.position if the test has a chance to fail
					// to avoid forcing a reflow.
					scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",
					// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
					boxSizingNeeded = scrollboxSizeBuggy || extra,
					isBorderBox = boxSizingNeeded &&
					jQuery.css(elem, "boxSizing", false, styles) === "border-box",
					subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;
				// Account for unreliable border-box dimensions by comparing offset* to computed and
				// faking a content-box to get border and padding (gh-3699)
				if (isBorderBox && scrollboxSizeBuggy) {
					subtract -= Math.ceil(
						elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] -
						parseFloat(styles[dimension]) -
						boxModelAdjustment(elem, dimension, "border", false, styles) -
						0.5
					);
				}
				// Convert to pixels if value adjustment is needed
				if (subtract && (matches = rcssNum.exec(value)) &&
					(matches[3] || "px") !== "px") {
					elem.style[dimension] = value;
					value = jQuery.css(elem, dimension);
				}
				return setPositiveNumber(elem, value, subtract);
			}
		};
	});
	jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft,
		function(elem, computed) {
			if (computed) {
				return (parseFloat(curCSS(elem, "marginLeft")) ||
					elem.getBoundingClientRect().left -
					swap(elem, {
						marginLeft: 0
					}, function() {
						return elem.getBoundingClientRect().left;
					})
				) + "px";
			}
		}
	);
	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function(prefix, suffix) {
		jQuery.cssHooks[prefix + suffix] = {
			expand: function(value) {
				var i = 0,
					expanded = {},
					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split(" ") : [value];
				for (; i < 4; i++) {
					expanded[prefix + cssExpand[i] + suffix] =
						parts[i] || parts[i - 2] || parts[0];
				}
				return expanded;
			}
		};
		if (prefix !== "margin") {
			jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
		}
	});
	jQuery.fn.extend({
		css: function(name, value) {
			return access(this, function(elem, name, value) {
				var styles, len,
					map = {},
					i = 0;
				if (Array.isArray(name)) {
					styles = getStyles(elem);
					len = name.length;
					for (; i < len; i++) {
						map[name[i]] = jQuery.css(elem, name[i], false, styles);
					}
					return map;
				}
				return value !== undefined ?
					jQuery.style(elem, name, value) :
					jQuery.css(elem, name);
			}, name, value, arguments.length > 1);
		}
	});

	function Tween(elem, options, prop, end, easing) {
		return new Tween.prototype.init(elem, options, prop, end, easing);
	}
	jQuery.Tween = Tween;
	Tween.prototype = {
		constructor: Tween,
		init: function(elem, options, prop, end, easing, unit) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
		},
		cur: function() {
			var hooks = Tween.propHooks[this.prop];
			return hooks && hooks.get ?
				hooks.get(this) :
				Tween.propHooks._default.get(this);
		},
		run: function(percent) {
			var eased,
				hooks = Tween.propHooks[this.prop];
			if (this.options.duration) {
				this.pos = eased = jQuery.easing[this.easing](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = (this.end - this.start) * eased + this.start;
			if (this.options.step) {
				this.options.step.call(this.elem, this.now, this);
			}
			if (hooks && hooks.set) {
				hooks.set(this);
			} else {
				Tween.propHooks._default.set(this);
			}
			return this;
		}
	};
	Tween.prototype.init.prototype = Tween.prototype;
	Tween.propHooks = {
		_default: {
			get: function(tween) {
				var result;
				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if (tween.elem.nodeType !== 1 ||
					tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
					return tween.elem[tween.prop];
				}
				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css(tween.elem, tween.prop, "");
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function(tween) {
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if (jQuery.fx.step[tween.prop]) {
					jQuery.fx.step[tween.prop](tween);
				} else if (tween.elem.nodeType === 1 && (
						jQuery.cssHooks[tween.prop] ||
						tween.elem.style[finalPropName(tween.prop)] != null)) {
					jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
				} else {
					tween.elem[tween.prop] = tween.now;
				}
			}
		}
	};
	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function(tween) {
			if (tween.elem.nodeType && tween.elem.parentNode) {
				tween.elem[tween.prop] = tween.now;
			}
		}
	};
	jQuery.easing = {
		linear: function(p) {
			return p;
		},
		swing: function(p) {
			return 0.5 - Math.cos(p * Math.PI) / 2;
		},
		_default: "swing"
	};
	jQuery.fx = Tween.prototype.init;
	// Back compat <1.8 extension point
	jQuery.fx.step = {};
	var
		fxNow, inProgress,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	function schedule() {
		if (inProgress) {
			if (document.hidden === false && window.requestAnimationFrame) {
				window.requestAnimationFrame(schedule);
			} else {
				window.setTimeout(schedule, jQuery.fx.interval);
			}
			jQuery.fx.tick();
		}
	}
	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout(function() {
			fxNow = undefined;
		});
		return (fxNow = Date.now());
	}
	// Generate parameters to create a standard animation
	function genFx(type, includeWidth) {
		var which,
			i = 0,
			attrs = {
				height: type
			};
		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for (; i < 4; i += 2 - includeWidth) {
			which = cssExpand[i];
			attrs["margin" + which] = attrs["padding" + which] = type;
		}
		if (includeWidth) {
			attrs.opacity = attrs.width = type;
		}
		return attrs;
	}

	function createTween(value, prop, animation) {
		var tween,
			collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
			index = 0,
			length = collection.length;
		for (; index < length; index++) {
			if ((tween = collection[index].call(animation, prop, value))) {
				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter(elem, props, opts) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree(elem),
			dataShow = dataPriv.get(elem, "fxshow");
		// Queue-skipping animations hijack the fx hooks
		if (!opts.queue) {
			hooks = jQuery._queueHooks(elem, "fx");
			if (hooks.unqueued == null) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if (!hooks.unqueued) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;
			anim.always(function() {
				// Ensure the complete handler is called before this completes
				anim.always(function() {
					hooks.unqueued--;
					if (!jQuery.queue(elem, "fx").length) {
						hooks.empty.fire();
					}
				});
			});
		}
		// Detect show/hide animations
		for (prop in props) {
			value = props[prop];
			if (rfxtypes.test(value)) {
				delete props[prop];
				toggle = toggle || value === "toggle";
				if (value === (hidden ? "hide" : "show")) {
					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if (value === "show" && dataShow && dataShow[prop] !== undefined) {
						hidden = true;
						// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
			}
		}
		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject(props);
		if (!propTween && jQuery.isEmptyObject(orig)) {
			return;
		}
		// Restrict "overflow" and "display" styles during box animations
		if (isBox && elem.nodeType === 1) {
			// Support: IE <=9 - 11, Edge 12 - 15
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY and Edge just mirrors
			// the overflowX value there.
			opts.overflow = [style.overflow, style.overflowX, style.overflowY];
			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if (restoreDisplay == null) {
				restoreDisplay = dataPriv.get(elem, "display");
			}
			display = jQuery.css(elem, "display");
			if (display === "none") {
				if (restoreDisplay) {
					display = restoreDisplay;
				} else {
					// Get nonempty value(s) by temporarily forcing visibility
					showHide([elem], true);
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css(elem, "display");
					showHide([elem]);
				}
			}
			// Animate inline elements as inline-block
			if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
				if (jQuery.css(elem, "float") === "none") {
					// Restore the original display value at the end of pure show/hide animations
					if (!propTween) {
						anim.done(function() {
							style.display = restoreDisplay;
						});
						if (restoreDisplay == null) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}
		if (opts.overflow) {
			style.overflow = "hidden";
			anim.always(function() {
				style.overflow = opts.overflow[0];
				style.overflowX = opts.overflow[1];
				style.overflowY = opts.overflow[2];
			});
		}
		// Implement show/hide animations
		propTween = false;
		for (prop in orig) {
			// General show/hide setup for this element animation
			if (!propTween) {
				if (dataShow) {
					if ("hidden" in dataShow) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access(elem, "fxshow", {
						display: restoreDisplay
					});
				}
				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if (toggle) {
					dataShow.hidden = !hidden;
				}
				// Show elements before animating them
				if (hidden) {
					showHide([elem], true);
				}
				/* eslint-disable no-loop-func */
				anim.done(function() {
					/* eslint-enable no-loop-func */
					// The final step of a "hide" animation is actually hiding the element
					if (!hidden) {
						showHide([elem]);
					}
					dataPriv.remove(elem, "fxshow");
					for (prop in orig) {
						jQuery.style(elem, prop, orig[prop]);
					}
				});
			}
			// Per-property setup
			propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
			if (!(prop in dataShow)) {
				dataShow[prop] = propTween.start;
				if (hidden) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter(props, specialEasing) {
		var index, name, easing, value, hooks;
		// camelCase, specialEasing and expand cssHook pass
		for (index in props) {
			name = camelCase(index);
			easing = specialEasing[name];
			value = props[index];
			if (Array.isArray(value)) {
				easing = value[1];
				value = props[index] = value[0];
			}
			if (index !== name) {
				props[name] = value;
				delete props[index];
			}
			hooks = jQuery.cssHooks[name];
			if (hooks && "expand" in hooks) {
				value = hooks.expand(value);
				delete props[name];
				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for (index in value) {
					if (!(index in props)) {
						props[index] = value[index];
						specialEasing[index] = easing;
					}
				}
			} else {
				specialEasing[name] = easing;
			}
		}
	}

	function Animation(elem, properties, options) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always(function() {
				// Don't match elem in the :animated selector
				delete tick.elem;
			}),
			tick = function() {
				if (stopped) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;
				for (; index < length; index++) {
					animation.tweens[index].run(percent);
				}
				deferred.notifyWith(elem, [animation, percent, remaining]);
				// If there's more to do, yield
				if (percent < 1 && length) {
					return remaining;
				}
				// If this was an empty animation, synthesize a final progress notification
				if (!length) {
					deferred.notifyWith(elem, [animation, 1, 0]);
				}
				// Resolve the animation and report its conclusion
				deferred.resolveWith(elem, [animation]);
				return false;
			},
			animation = deferred.promise({
				elem: elem,
				props: jQuery.extend({}, properties),
				opts: jQuery.extend(true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function(prop, end) {
					var tween = jQuery.Tween(elem, animation.opts, prop, end,
						animation.opts.specialEasing[prop] || animation.opts.easing);
					animation.tweens.push(tween);
					return tween;
				},
				stop: function(gotoEnd) {
					var index = 0,
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if (stopped) {
						return this;
					}
					stopped = true;
					for (; index < length; index++) {
						animation.tweens[index].run(1);
					}
					// Resolve when we played the last frame; otherwise, reject
					if (gotoEnd) {
						deferred.notifyWith(elem, [animation, 1, 0]);
						deferred.resolveWith(elem, [animation, gotoEnd]);
					} else {
						deferred.rejectWith(elem, [animation, gotoEnd]);
					}
					return this;
				}
			}),
			props = animation.props;
		propFilter(props, animation.opts.specialEasing);
		for (; index < length; index++) {
			result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
			if (result) {
				if (isFunction(result.stop)) {
					jQuery._queueHooks(animation.elem, animation.opts.queue).stop =
						result.stop.bind(result);
				}
				return result;
			}
		}
		jQuery.map(props, createTween, animation);
		if (isFunction(animation.opts.start)) {
			animation.opts.start.call(elem, animation);
		}
		// Attach callbacks from options
		animation
			.progress(animation.opts.progress)
			.done(animation.opts.done, animation.opts.complete)
			.fail(animation.opts.fail)
			.always(animation.opts.always);
		jQuery.fx.timer(
			jQuery.extend(tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			})
		);
		return animation;
	}
	jQuery.Animation = jQuery.extend(Animation, {
		tweeners: {
			"*": [function(prop, value) {
				var tween = this.createTween(prop, value);
				adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
				return tween;
			}]
		},
		tweener: function(props, callback) {
			if (isFunction(props)) {
				callback = props;
				props = ["*"];
			} else {
				props = props.match(rnothtmlwhite);
			}
			var prop,
				index = 0,
				length = props.length;
			for (; index < length; index++) {
				prop = props[index];
				Animation.tweeners[prop] = Animation.tweeners[prop] || [];
				Animation.tweeners[prop].unshift(callback);
			}
		},
		prefilters: [defaultPrefilter],
		prefilter: function(callback, prepend) {
			if (prepend) {
				Animation.prefilters.unshift(callback);
			} else {
				Animation.prefilters.push(callback);
			}
		}
	});
	jQuery.speed = function(speed, easing, fn) {
		var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
			complete: fn || !fn && easing ||
				isFunction(speed) && speed,
			duration: speed,
			easing: fn && easing || easing && !isFunction(easing) && easing
		};
		// Go to the end state if fx are off
		if (jQuery.fx.off) {
			opt.duration = 0;
		} else {
			if (typeof opt.duration !== "number") {
				if (opt.duration in jQuery.fx.speeds) {
					opt.duration = jQuery.fx.speeds[opt.duration];
				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}
		// Normalize opt.queue - true/undefined/null -> "fx"
		if (opt.queue == null || opt.queue === true) {
			opt.queue = "fx";
		}
		// Queueing
		opt.old = opt.complete;
		opt.complete = function() {
			if (isFunction(opt.old)) {
				opt.old.call(this);
			}
			if (opt.queue) {
				jQuery.dequeue(this, opt.queue);
			}
		};
		return opt;
	};
	jQuery.fn.extend({
		fadeTo: function(speed, to, easing, callback) {
			// Show any hidden elements after setting opacity to 0
			return this.filter(isHiddenWithinTree).css("opacity", 0).show()
				// Animate to the value specified
				.end().animate({
					opacity: to
				}, speed, easing, callback);
		},
		animate: function(prop, speed, easing, callback) {
			var empty = jQuery.isEmptyObject(prop),
				optall = jQuery.speed(speed, easing, callback),
				doAnimation = function() {
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation(this, jQuery.extend({}, prop), optall);
					// Empty animations, or finishing resolves immediately
					if (empty || dataPriv.get(this, "finish")) {
						anim.stop(true);
					}
				};
			doAnimation.finish = doAnimation;
			return empty || optall.queue === false ?
				this.each(doAnimation) :
				this.queue(optall.queue, doAnimation);
		},
		stop: function(type, clearQueue, gotoEnd) {
			var stopQueue = function(hooks) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop(gotoEnd);
			};
			if (typeof type !== "string") {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if (clearQueue) {
				this.queue(type || "fx", []);
			}
			return this.each(function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get(this);
				if (index) {
					if (data[index] && data[index].stop) {
						stopQueue(data[index]);
					}
				} else {
					for (index in data) {
						if (data[index] && data[index].stop && rrun.test(index)) {
							stopQueue(data[index]);
						}
					}
				}
				for (index = timers.length; index--;) {
					if (timers[index].elem === this &&
						(type == null || timers[index].queue === type)) {
						timers[index].anim.stop(gotoEnd);
						dequeue = false;
						timers.splice(index, 1);
					}
				}
				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if (dequeue || !gotoEnd) {
					jQuery.dequeue(this, type);
				}
			});
		},
		finish: function(type) {
			if (type !== false) {
				type = type || "fx";
			}
			return this.each(function() {
				var index,
					data = dataPriv.get(this),
					queue = data[type + "queue"],
					hooks = data[type + "queueHooks"],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;
				// Enable finishing flag on private data
				data.finish = true;
				// Empty the queue first
				jQuery.queue(this, type, []);
				if (hooks && hooks.stop) {
					hooks.stop.call(this, true);
				}
				// Look for any active animations, and finish them
				for (index = timers.length; index--;) {
					if (timers[index].elem === this && timers[index].queue === type) {
						timers[index].anim.stop(true);
						timers.splice(index, 1);
					}
				}
				// Look for any animations in the old queue and finish them
				for (index = 0; index < length; index++) {
					if (queue[index] && queue[index].finish) {
						queue[index].finish.call(this);
					}
				}
				// Turn off finishing flag
				delete data.finish;
			});
		}
	});
	jQuery.each(["toggle", "show", "hide"], function(_i, name) {
		var cssFn = jQuery.fn[name];
		jQuery.fn[name] = function(speed, easing, callback) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply(this, arguments) :
				this.animate(genFx(name, true), speed, easing, callback);
		};
	});
	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: {
			opacity: "show"
		},
		fadeOut: {
			opacity: "hide"
		},
		fadeToggle: {
			opacity: "toggle"
		}
	}, function(name, props) {
		jQuery.fn[name] = function(speed, easing, callback) {
			return this.animate(props, speed, easing, callback);
		};
	});
	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;
		fxNow = Date.now();
		for (; i < timers.length; i++) {
			timer = timers[i];
			// Run the timer and safely remove it when done (allowing for external removal)
			if (!timer() && timers[i] === timer) {
				timers.splice(i--, 1);
			}
		}
		if (!timers.length) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};
	jQuery.fx.timer = function(timer) {
		jQuery.timers.push(timer);
		jQuery.fx.start();
	};
	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if (inProgress) {
			return;
		}
		inProgress = true;
		schedule();
	};
	jQuery.fx.stop = function() {
		inProgress = null;
	};
	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	};
	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function(time, type) {
		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
		type = type || "fx";
		return this.queue(type, function(next, hooks) {
			var timeout = window.setTimeout(next, time);
			hooks.stop = function() {
				window.clearTimeout(timeout);
			};
		});
	};
	(function() {
		var input = document.createElement("input"),
			select = document.createElement("select"),
			opt = select.appendChild(document.createElement("option"));
		input.type = "checkbox";
		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";
		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;
		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement("input");
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	})();
	var boolHook,
		attrHandle = jQuery.expr.attrHandle;
	jQuery.fn.extend({
		attr: function(name, value) {
			return access(this, jQuery.attr, name, value, arguments.length > 1);
		},
		removeAttr: function(name) {
			return this.each(function() {
				jQuery.removeAttr(this, name);
			});
		}
	});
	jQuery.extend({
		attr: function(elem, name, value) {
			var ret, hooks,
				nType = elem.nodeType;
			// Don't get/set attributes on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}
			// Fallback to prop when attributes are not supported
			if (typeof elem.getAttribute === "undefined") {
				return jQuery.prop(elem, name, value);
			}
			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
				hooks = jQuery.attrHooks[name.toLowerCase()] ||
					(jQuery.expr.match.bool.test(name) ? boolHook : undefined);
			}
			if (value !== undefined) {
				if (value === null) {
					jQuery.removeAttr(elem, name);
					return;
				}
				if (hooks && "set" in hooks &&
					(ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}
				elem.setAttribute(name, value + "");
				return value;
			}
			if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}
			ret = jQuery.find.attr(elem, name);
			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},
		attrHooks: {
			type: {
				set: function(elem, value) {
					if (!support.radioValue && value === "radio" &&
						nodeName(elem, "input")) {
						var val = elem.value;
						elem.setAttribute("type", value);
						if (val) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},
		removeAttr: function(elem, value) {
			var name,
				i = 0,
				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match(rnothtmlwhite);
			if (attrNames && elem.nodeType === 1) {
				while ((name = attrNames[i++])) {
					elem.removeAttribute(name);
				}
			}
		}
	});
	// Hooks for boolean attributes
	boolHook = {
		set: function(elem, value, name) {
			if (value === false) {
				// Remove boolean attributes when set to false
				jQuery.removeAttr(elem, name);
			} else {
				elem.setAttribute(name, name);
			}
			return name;
		}
	};
	jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name) {
		var getter = attrHandle[name] || jQuery.find.attr;
		attrHandle[name] = function(elem, name, isXML) {
			var ret, handle,
				lowercaseName = name.toLowerCase();
			if (!isXML) {
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[lowercaseName];
				attrHandle[lowercaseName] = ret;
				ret = getter(elem, name, isXML) != null ?
					lowercaseName :
					null;
				attrHandle[lowercaseName] = handle;
			}
			return ret;
		};
	});
	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;
	jQuery.fn.extend({
		prop: function(name, value) {
			return access(this, jQuery.prop, name, value, arguments.length > 1);
		},
		removeProp: function(name) {
			return this.each(function() {
				delete this[jQuery.propFix[name] || name];
			});
		}
	});
	jQuery.extend({
		prop: function(elem, name, value) {
			var ret, hooks,
				nType = elem.nodeType;
			// Don't get/set properties on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}
			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
				// Fix name and attach hooks
				name = jQuery.propFix[name] || name;
				hooks = jQuery.propHooks[name];
			}
			if (value !== undefined) {
				if (hooks && "set" in hooks &&
					(ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}
				return (elem[name] = value);
			}
			if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}
			return elem[name];
		},
		propHooks: {
			tabIndex: {
				get: function(elem) {
					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr(elem, "tabindex");
					if (tabindex) {
						return parseInt(tabindex, 10);
					}
					if (
						rfocusable.test(elem.nodeName) ||
						rclickable.test(elem.nodeName) &&
						elem.href
					) {
						return 0;
					}
					return -1;
				}
			}
		},
		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	});
	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if (!support.optSelected) {
		jQuery.propHooks.selected = {
			get: function(elem) {
				/* eslint no-unused-expressions: "off" */
				var parent = elem.parentNode;
				if (parent && parent.parentNode) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function(elem) {
				/* eslint no-unused-expressions: "off" */
				var parent = elem.parentNode;
				if (parent) {
					parent.selectedIndex;
					if (parent.parentNode) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}
	jQuery.each([
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[this.toLowerCase()] = this;
	});
	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse(value) {
		var tokens = value.match(rnothtmlwhite) || [];
		return tokens.join(" ");
	}

	function getClass(elem) {
		return elem.getAttribute && elem.getAttribute("class") || "";
	}

	function classesToArray(value) {
		if (Array.isArray(value)) {
			return value;
		}
		if (typeof value === "string") {
			return value.match(rnothtmlwhite) || [];
		}
		return [];
	}
	jQuery.fn.extend({
		addClass: function(value) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
			if (isFunction(value)) {
				return this.each(function(j) {
					jQuery(this).addClass(value.call(this, j, getClass(this)));
				});
			}
			classes = classesToArray(value);
			if (classes.length) {
				while ((elem = this[i++])) {
					curValue = getClass(elem);
					cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");
					if (cur) {
						j = 0;
						while ((clazz = classes[j++])) {
							if (cur.indexOf(" " + clazz + " ") < 0) {
								cur += clazz + " ";
							}
						}
						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}
			return this;
		},
		removeClass: function(value) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
			if (isFunction(value)) {
				return this.each(function(j) {
					jQuery(this).removeClass(value.call(this, j, getClass(this)));
				});
			}
			if (!arguments.length) {
				return this.attr("class", "");
			}
			classes = classesToArray(value);
			if (classes.length) {
				while ((elem = this[i++])) {
					curValue = getClass(elem);
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");
					if (cur) {
						j = 0;
						while ((clazz = classes[j++])) {
							// Remove *all* instances
							while (cur.indexOf(" " + clazz + " ") > -1) {
								cur = cur.replace(" " + clazz + " ", " ");
							}
						}
						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}
			return this;
		},
		toggleClass: function(value, stateVal) {
			var type = typeof value,
				isValidValue = type === "string" || Array.isArray(value);
			if (typeof stateVal === "boolean" && isValidValue) {
				return stateVal ? this.addClass(value) : this.removeClass(value);
			}
			if (isFunction(value)) {
				return this.each(function(i) {
					jQuery(this).toggleClass(
						value.call(this, i, getClass(this), stateVal),
						stateVal
					);
				});
			}
			return this.each(function() {
				var className, i, self, classNames;
				if (isValidValue) {
					// Toggle individual class names
					i = 0;
					self = jQuery(this);
					classNames = classesToArray(value);
					while ((className = classNames[i++])) {
						// Check each className given, space separated list
						if (self.hasClass(className)) {
							self.removeClass(className);
						} else {
							self.addClass(className);
						}
					}
					// Toggle whole class name
				} else if (value === undefined || type === "boolean") {
					className = getClass(this);
					if (className) {
						// Store className if set
						dataPriv.set(this, "__className__", className);
					}
					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if (this.setAttribute) {
						this.setAttribute("class",
							className || value === false ?
							"" :
							dataPriv.get(this, "__className__") || ""
						);
					}
				}
			});
		},
		hasClass: function(selector) {
			var className, elem,
				i = 0;
			className = " " + selector + " ";
			while ((elem = this[i++])) {
				if (elem.nodeType === 1 &&
					(" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
					return true;
				}
			}
			return false;
		}
	});
	var rreturn = /\r/g;
	jQuery.fn.extend({
		val: function(value) {
			var hooks, ret, valueIsFunction,
				elem = this[0];
			if (!arguments.length) {
				if (elem) {
					hooks = jQuery.valHooks[elem.type] ||
						jQuery.valHooks[elem.nodeName.toLowerCase()];
					if (hooks &&
						"get" in hooks &&
						(ret = hooks.get(elem, "value")) !== undefined
					) {
						return ret;
					}
					ret = elem.value;
					// Handle most common string cases
					if (typeof ret === "string") {
						return ret.replace(rreturn, "");
					}
					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}
				return;
			}
			valueIsFunction = isFunction(value);
			return this.each(function(i) {
				var val;
				if (this.nodeType !== 1) {
					return;
				}
				if (valueIsFunction) {
					val = value.call(this, i, jQuery(this).val());
				} else {
					val = value;
				}
				// Treat null/undefined as ""; convert numbers to string
				if (val == null) {
					val = "";
				} else if (typeof val === "number") {
					val += "";
				} else if (Array.isArray(val)) {
					val = jQuery.map(val, function(value) {
						return value == null ? "" : value + "";
					});
				}
				hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
				// If set returns undefined, fall back to normal setting
				if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
					this.value = val;
				}
			});
		}
	});
	jQuery.extend({
		valHooks: {
			option: {
				get: function(elem) {
					var val = jQuery.find.attr(elem, "value");
					return val != null ?
						val :
						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse(jQuery.text(elem));
				}
			},
			select: {
				get: function(elem) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;
					if (index < 0) {
						i = max;
					} else {
						i = one ? index : 0;
					}
					// Loop through all the selected options
					for (; i < max; i++) {
						option = options[i];
						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ((option.selected || i === index) &&
							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							(!option.parentNode.disabled ||
								!nodeName(option.parentNode, "optgroup"))) {
							// Get the specific value for the option
							value = jQuery(option).val();
							// We don't need an array for one selects
							if (one) {
								return value;
							}
							// Multi-Selects return an array
							values.push(value);
						}
					}
					return values;
				},
				set: function(elem, value) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray(value),
						i = options.length;
					while (i--) {
						option = options[i];
						/* eslint-disable no-cond-assign */
						if (option.selected =
							jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1
						) {
							optionSet = true;
						}
						/* eslint-enable no-cond-assign */
					}
					// Force browsers to behave consistently when non-matching value is set
					if (!optionSet) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	});
	// Radios and checkboxes getter/setter
	jQuery.each(["radio", "checkbox"], function() {
		jQuery.valHooks[this] = {
			set: function(elem, value) {
				if (Array.isArray(value)) {
					return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
				}
			}
		};
		if (!support.checkOn) {
			jQuery.valHooks[this].get = function(elem) {
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});
	// Return jQuery for attributes-only inclusion
	support.focusin = "onfocusin" in window;
	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		stopPropagationCallback = function(e) {
			e.stopPropagation();
		};
	jQuery.extend(jQuery.event, {
		trigger: function(event, data, elem, onlyHandlers) {
			var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
				eventPath = [elem || document],
				type = hasOwn.call(event, "type") ? event.type : event,
				namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
			cur = lastElement = tmp = elem = elem || document;
			// Don't do events on text and comment nodes
			if (elem.nodeType === 3 || elem.nodeType === 8) {
				return;
			}
			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if (rfocusMorph.test(type + jQuery.event.triggered)) {
				return;
			}
			if (type.indexOf(".") > -1) {
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;
			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[jQuery.expando] ?
				event :
				new jQuery.Event(type, typeof event === "object" && event);
			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.rnamespace = event.namespace ?
				new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
				null;
			// Clean up the event in case it is being reused
			event.result = undefined;
			if (!event.target) {
				event.target = elem;
			}
			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ? [event] :
				jQuery.makeArray(data, [event]);
			// Allow special events to draw outside the lines
			special = jQuery.event.special[type] || {};
			if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
				return;
			}
			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
				bubbleType = special.delegateType || type;
				if (!rfocusMorph.test(bubbleType + type)) {
					cur = cur.parentNode;
				}
				for (; cur; cur = cur.parentNode) {
					eventPath.push(cur);
					tmp = cur;
				}
				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if (tmp === (elem.ownerDocument || document)) {
					eventPath.push(tmp.defaultView || tmp.parentWindow || window);
				}
			}
			// Fire handlers on the event path
			i = 0;
			while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
				lastElement = cur;
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;
				// jQuery handler
				handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] &&
					dataPriv.get(cur, "handle");
				if (handle) {
					handle.apply(cur, data);
				}
				// Native handler
				handle = ontype && cur[ontype];
				if (handle && handle.apply && acceptData(cur)) {
					event.result = handle.apply(cur, data);
					if (event.result === false) {
						event.preventDefault();
					}
				}
			}
			event.type = type;
			// If nobody prevented the default action, do it now
			if (!onlyHandlers && !event.isDefaultPrevented()) {
				if ((!special._default ||
						special._default.apply(eventPath.pop(), data) === false) &&
					acceptData(elem)) {
					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ontype];
						if (tmp) {
							elem[ontype] = null;
						}
						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						if (event.isPropagationStopped()) {
							lastElement.addEventListener(type, stopPropagationCallback);
						}
						elem[type]();
						if (event.isPropagationStopped()) {
							lastElement.removeEventListener(type, stopPropagationCallback);
						}
						jQuery.event.triggered = undefined;
						if (tmp) {
							elem[ontype] = tmp;
						}
					}
				}
			}
			return event.result;
		},
		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function(type, elem, event) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event, {
					type: type,
					isSimulated: true
				}
			);
			jQuery.event.trigger(e, null, elem);
		}
	});
	jQuery.fn.extend({
		trigger: function(type, data) {
			return this.each(function() {
				jQuery.event.trigger(type, data, this);
			});
		},
		triggerHandler: function(type, data) {
			var elem = this[0];
			if (elem) {
				return jQuery.event.trigger(type, data, elem, true);
			}
		}
	});
	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if (!support.focusin) {
		jQuery.each({
			focus: "focusin",
			blur: "focusout"
		}, function(orig, fix) {
			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function(event) {
				jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
			};
			jQuery.event.special[fix] = {
				setup: function() {
					// Handle: regular nodes (via `this.ownerDocument`), window
					// (via `this.document`) & document (via `this`).
					var doc = this.ownerDocument || this.document || this,
						attaches = dataPriv.access(doc, fix);
					if (!attaches) {
						doc.addEventListener(orig, handler, true);
					}
					dataPriv.access(doc, fix, (attaches || 0) + 1);
				},
				teardown: function() {
					var doc = this.ownerDocument || this.document || this,
						attaches = dataPriv.access(doc, fix) - 1;
					if (!attaches) {
						doc.removeEventListener(orig, handler, true);
						dataPriv.remove(doc, fix);
					} else {
						dataPriv.access(doc, fix, attaches);
					}
				}
			};
		});
	}
	var location = window.location;
	var nonce = {
		guid: Date.now()
	};
	var rquery = (/\?/);
	// Cross-browser xml parsing
	jQuery.parseXML = function(data) {
		var xml, parserErrorElem;
		if (!data || typeof data !== "string") {
			return null;
		}
		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = (new window.DOMParser()).parseFromString(data, "text/xml");
		} catch (e) {}
		parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
		if (!xml || parserErrorElem) {
			jQuery.error("Invalid XML: " + (
				parserErrorElem ?
				jQuery.map(parserErrorElem.childNodes, function(el) {
					return el.textContent;
				}).join("\n") :
				data
			));
		}
		return xml;
	};
	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams(prefix, obj, traditional, add) {
		var name;
		if (Array.isArray(obj)) {
			// Serialize array item.
			jQuery.each(obj, function(i, v) {
				if (traditional || rbracket.test(prefix)) {
					// Treat each array item as a scalar.
					add(prefix, v);
				} else {
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
						v,
						traditional,
						add
					);
				}
			});
		} else if (!traditional && toType(obj) === "object") {
			// Serialize object item.
			for (name in obj) {
				buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
			}
		} else {
			// Serialize scalar item.
			add(prefix, obj);
		}
	}
	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function(a, traditional) {
		var prefix,
			s = [],
			add = function(key, valueOrFunction) {
				// If value is a function, invoke it and use its return value
				var value = isFunction(valueOrFunction) ?
					valueOrFunction() :
					valueOrFunction;
				s[s.length] = encodeURIComponent(key) + "=" +
					encodeURIComponent(value == null ? "" : value);
			};
		if (a == null) {
			return "";
		}
		// If an array was passed in, assume that it is an array of form elements.
		if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
			// Serialize the form elements
			jQuery.each(a, function() {
				add(this.name, this.value);
			});
		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for (prefix in a) {
				buildParams(prefix, a[prefix], traditional, add);
			}
		}
		// Return the resulting serialization
		return s.join("&");
	};
	jQuery.fn.extend({
		serialize: function() {
			return jQuery.param(this.serializeArray());
		},
		serializeArray: function() {
			return this.map(function() {
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop(this, "elements");
				return elements ? jQuery.makeArray(elements) : this;
			}).filter(function() {
				var type = this.type;
				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery(this).is(":disabled") &&
					rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
					(this.checked || !rcheckableType.test(type));
			}).map(function(_i, elem) {
				var val = jQuery(this).val();
				if (val == null) {
					return null;
				}
				if (Array.isArray(val)) {
					return jQuery.map(val, function(val) {
						return {
							name: elem.name,
							value: val.replace(rCRLF, "\r\n")
						};
					});
				}
				return {
					name: elem.name,
					value: val.replace(rCRLF, "\r\n")
				};
			}).get();
		}
	});
	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},
		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat("*"),
		// Anchor tag for parsing the document origin
		originAnchor = document.createElement("a");
	originAnchor.href = location.href;
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports(structure) {
		// dataTypeExpression is optional and defaults to "*"
		return function(dataTypeExpression, func) {
			if (typeof dataTypeExpression !== "string") {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}
			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
			if (isFunction(func)) {
				// For each dataType in the dataTypeExpression
				while ((dataType = dataTypes[i++])) {
					// Prepend if requested
					if (dataType[0] === "+") {
						dataType = dataType.slice(1) || "*";
						(structure[dataType] = structure[dataType] || []).unshift(func);
						// Otherwise append
					} else {
						(structure[dataType] = structure[dataType] || []).push(func);
					}
				}
			}
		};
	}
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
		var inspected = {},
			seekingTransport = (structure === transports);

		function inspect(dataType) {
			var selected;
			inspected[dataType] = true;
			jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
				var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
				if (typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[dataTypeOrTransport]) {
					options.dataTypes.unshift(dataTypeOrTransport);
					inspect(dataTypeOrTransport);
					return false;
				} else if (seekingTransport) {
					return !(selected = dataTypeOrTransport);
				}
			});
			return selected;
		}
		return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
	}
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend(target, src) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};
		for (key in src) {
			if (src[key] !== undefined) {
				(flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
			}
		}
		if (deep) {
			jQuery.extend(true, target, deep);
		}
		return target;
	}
	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses(s, jqXHR, responses) {
		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;
		// Remove auto dataType and get content-type in the process
		while (dataTypes[0] === "*") {
			dataTypes.shift();
			if (ct === undefined) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}
		// Check if we're dealing with a known content-type
		if (ct) {
			for (type in contents) {
				if (contents[type] && contents[type].test(ct)) {
					dataTypes.unshift(type);
					break;
				}
			}
		}
		// Check to see if we have a response for the expected dataType
		if (dataTypes[0] in responses) {
			finalDataType = dataTypes[0];
		} else {
			// Try convertible dataTypes
			for (type in responses) {
				if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
					finalDataType = type;
					break;
				}
				if (!firstDataType) {
					firstDataType = type;
				}
			}
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}
		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if (finalDataType) {
			if (finalDataType !== dataTypes[0]) {
				dataTypes.unshift(finalDataType);
			}
			return responses[finalDataType];
		}
	}
	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert(s, response, jqXHR, isSuccess) {
		var conv2, current, conv, tmp, prev,
			converters = {},
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();
		// Create converters map with lowercased keys
		if (dataTypes[1]) {
			for (conv in s.converters) {
				converters[conv.toLowerCase()] = s.converters[conv];
			}
		}
		current = dataTypes.shift();
		// Convert to each sequential dataType
		while (current) {
			if (s.responseFields[current]) {
				jqXHR[s.responseFields[current]] = response;
			}
			// Apply the dataFilter if provided
			if (!prev && isSuccess && s.dataFilter) {
				response = s.dataFilter(response, s.dataType);
			}
			prev = current;
			current = dataTypes.shift();
			if (current) {
				// There's only work to do if current dataType is non-auto
				if (current === "*") {
					current = prev;
					// Convert response if prev dataType is non-auto and differs from current
				} else if (prev !== "*" && prev !== current) {
					// Seek a direct converter
					conv = converters[prev + " " + current] || converters["* " + current];
					// If none found, seek a pair
					if (!conv) {
						for (conv2 in converters) {
							// If conv2 outputs current
							tmp = conv2.split(" ");
							if (tmp[1] === current) {
								// If prev can be converted to accepted input
								conv = converters[prev + " " + tmp[0]] ||
									converters["* " + tmp[0]];
								if (conv) {
									// Condense equivalence converters
									if (conv === true) {
										conv = converters[conv2];
										// Otherwise, insert the intermediate dataType
									} else if (converters[conv2] !== true) {
										current = tmp[0];
										dataTypes.unshift(tmp[1]);
									}
									break;
								}
							}
						}
					}
					// Apply converter (if not an equivalence)
					if (conv !== true) {
						// Unless errors are allowed to bubble, catch and return them
						if (conv && s.throws) {
							response = conv(response);
						} else {
							try {
								response = conv(response);
							} catch (e) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}
		return {
			state: "success",
			data: response
		};
	}
	jQuery.extend({
		// Counter for holding the number of active queries
		active: 0,
		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},
		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test(location.protocol),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/
			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {
				// Convert anything to text
				"* text": String,
				// Text to html (true = no transformation)
				"text html": true,
				// Evaluate text as a json expression
				"text json": JSON.parse,
				// Parse text as xml
				"text xml": jQuery.parseXML
			},
			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},
		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function(target, settings) {
			return settings ?
				// Building a settings object
				ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :
				// Extending ajaxSettings
				ajaxExtend(jQuery.ajaxSettings, target);
		},
		ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
		ajaxTransport: addToPrefiltersOrTransports(transports),
		// Main method
		ajax: function(url, options) {
			// If url is an object, simulate pre-1.5 signature
			if (typeof url === "object") {
				options = url;
				url = undefined;
			}
			// Force options to be an object
			options = options || {};
			var transport,
				// URL without anti-cache param
				cacheURL,
				// Response headers
				responseHeadersString,
				responseHeaders,
				// timeout handle
				timeoutTimer,
				// Url cleanup var
				urlAnchor,
				// Request state (becomes false upon send and true upon completion)
				completed,
				// To know if global events are to be dispatched
				fireGlobals,
				// Loop variable
				i,
				// uncached part of the url
				uncached,
				// Create the final options object
				s = jQuery.ajaxSetup({}, options),
				// Callbacks context
				callbackContext = s.context || s,
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
				(callbackContext.nodeType || callbackContext.jquery) ?
				jQuery(callbackContext) :
				jQuery.event,
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks("once memory"),
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
				// Default abort message
				strAbort = "canceled",
				// Fake xhr
				jqXHR = {
					readyState: 0,
					// Builds headers hashtable if needed
					getResponseHeader: function(key) {
						var match;
						if (completed) {
							if (!responseHeaders) {
								responseHeaders = {};
								while ((match = rheaders.exec(responseHeadersString))) {
									responseHeaders[match[1].toLowerCase() + " "] =
										(responseHeaders[match[1].toLowerCase() + " "] || [])
										.concat(match[2]);
								}
							}
							match = responseHeaders[key.toLowerCase() + " "];
						}
						return match == null ? null : match.join(", ");
					},
					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},
					// Caches the header
					setRequestHeader: function(name, value) {
						if (completed == null) {
							name = requestHeadersNames[name.toLowerCase()] =
								requestHeadersNames[name.toLowerCase()] || name;
							requestHeaders[name] = value;
						}
						return this;
					},
					// Overrides response content-type header
					overrideMimeType: function(type) {
						if (completed == null) {
							s.mimeType = type;
						}
						return this;
					},
					// Status-dependent callbacks
					statusCode: function(map) {
						var code;
						if (map) {
							if (completed) {
								// Execute the appropriate callbacks
								jqXHR.always(map[jqXHR.status]);
							} else {
								// Lazy-add the new callbacks in a way that preserves old ones
								for (code in map) {
									statusCode[code] = [statusCode[code], map[code]];
								}
							}
						}
						return this;
					},
					// Cancel the request
					abort: function(statusText) {
						var finalText = statusText || strAbort;
						if (transport) {
							transport.abort(finalText);
						}
						done(0, finalText);
						return this;
					}
				};
			// Attach deferreds
			deferred.promise(jqXHR);
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ((url || s.url || location.href) + "")
				.replace(rprotocol, location.protocol + "//");
			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;
			// Extract dataTypes list
			s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
			// A cross-domain request is in order when the origin doesn't match the current origin.
			if (s.crossDomain == null) {
				urlAnchor = document.createElement("a");
				// Support: IE <=8 - 11, Edge 12 - 15
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;
					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch (e) {
					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}
			// Convert data if not already a string
			if (s.data && s.processData && typeof s.data !== "string") {
				s.data = jQuery.param(s.data, s.traditional);
			}
			// Apply prefilters
			inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
			// If request was aborted inside a prefilter, stop there
			if (completed) {
				return jqXHR;
			}
			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;
			// Watch for a new set of requests
			if (fireGlobals && jQuery.active++ === 0) {
				jQuery.event.trigger("ajaxStart");
			}
			// Uppercase the type
			s.type = s.type.toUpperCase();
			// Determine if request has content
			s.hasContent = !rnoContent.test(s.type);
			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace(rhash, "");
			// More options handling for requests with no content
			if (!s.hasContent) {
				// Remember the hash so we can put it back
				uncached = s.url.slice(cacheURL.length);
				// If data is available and should be processed, append data to url
				if (s.data && (s.processData || typeof s.data === "string")) {
					cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}
				// Add or update anti-cache param if needed
				if (s.cache === false) {
					cacheURL = cacheURL.replace(rantiCache, "$1");
					uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + (nonce.guid++) +
						uncached;
				}
				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;
				// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if (s.data && s.processData &&
				(s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
				s.data = s.data.replace(r20, "+");
			}
			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if (s.ifModified) {
				if (jQuery.lastModified[cacheURL]) {
					jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
				}
				if (jQuery.etag[cacheURL]) {
					jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
				}
			}
			// Set the correct header, if data is being sent
			if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
				jqXHR.setRequestHeader("Content-Type", s.contentType);
			}
			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
				s.accepts[s.dataTypes[0]] +
				(s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
				s.accepts["*"]
			);
			// Check for headers option
			for (i in s.headers) {
				jqXHR.setRequestHeader(i, s.headers[i]);
			}
			// Allow custom headers/mimetypes and early abort
			if (s.beforeSend &&
				(s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
				// Abort if not done already and return
				return jqXHR.abort();
			}
			// Aborting is no longer a cancellation
			strAbort = "abort";
			// Install callbacks on deferreds
			completeDeferred.add(s.complete);
			jqXHR.done(s.success);
			jqXHR.fail(s.error);
			// Get transport
			transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
			// If no transport, we auto-abort
			if (!transport) {
				done(-1, "No Transport");
			} else {
				jqXHR.readyState = 1;
				// Send global event
				if (fireGlobals) {
					globalEventContext.trigger("ajaxSend", [jqXHR, s]);
				}
				// If request was aborted inside ajaxSend, stop there
				if (completed) {
					return jqXHR;
				}
				// Timeout
				if (s.async && s.timeout > 0) {
					timeoutTimer = window.setTimeout(function() {
						jqXHR.abort("timeout");
					}, s.timeout);
				}
				try {
					completed = false;
					transport.send(requestHeaders, done);
				} catch (e) {
					// Rethrow post-completion exceptions
					if (completed) {
						throw e;
					}
					// Propagate others as results
					done(-1, e);
				}
			}
			// Callback for when everything is done
			function done(status, nativeStatusText, responses, headers) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;
				// Ignore repeat invocations
				if (completed) {
					return;
				}
				completed = true;
				// Clear timeout if it exists
				if (timeoutTimer) {
					window.clearTimeout(timeoutTimer);
				}
				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;
				// Cache response headers
				responseHeadersString = headers || "";
				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;
				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;
				// Get response data
				if (responses) {
					response = ajaxHandleResponses(s, jqXHR, responses);
				}
				// Use a noop converter for missing script but not if jsonp
				if (!isSuccess &&
					jQuery.inArray("script", s.dataTypes) > -1 &&
					jQuery.inArray("json", s.dataTypes) < 0) {
					s.converters["text script"] = function() {};
				}
				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert(s, response, jqXHR, isSuccess);
				// If successful, handle type chaining
				if (isSuccess) {
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if (s.ifModified) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if (modified) {
							jQuery.lastModified[cacheURL] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if (modified) {
							jQuery.etag[cacheURL] = modified;
						}
					}
					// if no content
					if (status === 204 || s.type === "HEAD") {
						statusText = "nocontent";
						// if not modified
					} else if (status === 304) {
						statusText = "notmodified";
						// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if (status || !statusText) {
						statusText = "error";
						if (status < 0) {
							status = 0;
						}
					}
				}
				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = (nativeStatusText || statusText) + "";
				// Success/Error
				if (isSuccess) {
					deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
				} else {
					deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
				}
				// Status-dependent callbacks
				jqXHR.statusCode(statusCode);
				statusCode = undefined;
				if (fireGlobals) {
					globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError",
						[jqXHR, s, isSuccess ? success : error]);
				}
				// Complete
				completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
				if (fireGlobals) {
					globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
					// Handle the global AJAX counter
					if (!(--jQuery.active)) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}
			return jqXHR;
		},
		getJSON: function(url, data, callback) {
			return jQuery.get(url, data, callback, "json");
		},
		getScript: function(url, callback) {
			return jQuery.get(url, undefined, callback, "script");
		}
	});
	jQuery.each(["get", "post"], function(_i, method) {
		jQuery[method] = function(url, data, callback, type) {
			// Shift arguments if data argument was omitted
			if (isFunction(data)) {
				type = type || callback;
				callback = data;
				data = undefined;
			}
			// The url can be an options object (which then must have .url)
			return jQuery.ajax(jQuery.extend({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject(url) && url));
		};
	});
	jQuery.ajaxPrefilter(function(s) {
		var i;
		for (i in s.headers) {
			if (i.toLowerCase() === "content-type") {
				s.contentType = s.headers[i] || "";
			}
		}
	});
	jQuery._evalUrl = function(url, options, doc) {
		return jQuery.ajax({
			url: url,
			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			// Only evaluate the response if it is successful (gh-4126)
			// dataFilter is not invoked for failure responses, so using it instead
			// of the default converter is kludgy but it works.
			converters: {
				"text script": function() {}
			},
			dataFilter: function(response) {
				jQuery.globalEval(response, options, doc);
			}
		});
	};
	jQuery.fn.extend({
		wrapAll: function(html) {
			var wrap;
			if (this[0]) {
				if (isFunction(html)) {
					html = html.call(this[0]);
				}
				// The elements to wrap the target around
				wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
				if (this[0].parentNode) {
					wrap.insertBefore(this[0]);
				}
				wrap.map(function() {
					var elem = this;
					while (elem.firstElementChild) {
						elem = elem.firstElementChild;
					}
					return elem;
				}).append(this);
			}
			return this;
		},
		wrapInner: function(html) {
			if (isFunction(html)) {
				return this.each(function(i) {
					jQuery(this).wrapInner(html.call(this, i));
				});
			}
			return this.each(function() {
				var self = jQuery(this),
					contents = self.contents();
				if (contents.length) {
					contents.wrapAll(html);
				} else {
					self.append(html);
				}
			});
		},
		wrap: function(html) {
			var htmlIsFunction = isFunction(html);
			return this.each(function(i) {
				jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
			});
		},
		unwrap: function(selector) {
			this.parent(selector).not("body").each(function() {
				jQuery(this).replaceWith(this.childNodes);
			});
			return this;
		}
	});
	jQuery.expr.pseudos.hidden = function(elem) {
		return !jQuery.expr.pseudos.visible(elem);
	};
	jQuery.expr.pseudos.visible = function(elem) {
		return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
	};
	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch (e) {}
	};
	var xhrSuccessStatus = {
			// File protocol always yields status code 0, assume 200
			0: 200,
			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();
	support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
	support.ajax = xhrSupported = !!xhrSupported;
	jQuery.ajaxTransport(function(options) {
		var callback, errorCallback;
		// Cross domain only allowed if supported through XMLHttpRequest
		if (support.cors || xhrSupported && !options.crossDomain) {
			return {
				send: function(headers, complete) {
					var i,
						xhr = options.xhr();
					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);
					// Apply custom fields if provided
					if (options.xhrFields) {
						for (i in options.xhrFields) {
							xhr[i] = options.xhrFields[i];
						}
					}
					// Override mime type if needed
					if (options.mimeType && xhr.overrideMimeType) {
						xhr.overrideMimeType(options.mimeType);
					}
					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if (!options.crossDomain && !headers["X-Requested-With"]) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}
					// Set headers
					for (i in headers) {
						xhr.setRequestHeader(i, headers[i]);
					}
					// Callback
					callback = function(type) {
						return function() {
							if (callback) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;
								if (type === "abort") {
									xhr.abort();
								} else if (type === "error") {
									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if (typeof xhr.status !== "number") {
										complete(0, "error");
									} else {
										complete(
											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[xhr.status] || xhr.status,
										xhr.statusText,
										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										(xhr.responseType || "text") !== "text" ||
										typeof xhr.responseText !== "string" ? {
											binary: xhr.response
										} : {
											text: xhr.responseText
										},
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};
					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if (xhr.onabort !== undefined) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {
							// Check readyState before timeout as it changes
							if (xhr.readyState === 4) {
								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout(function() {
									if (callback) {
										errorCallback();
									}
								});
							}
						};
					}
					// Create the abort callback
					callback = callback("abort");
					try {
						// Do send the request (this may raise an exception)
						xhr.send(options.hasContent && options.data || null);
					} catch (e) {
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if (callback) {
							throw e;
						}
					}
				},
				abort: function() {
					if (callback) {
						callback();
					}
				}
			};
		}
	});
	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter(function(s) {
		if (s.crossDomain) {
			s.contents.script = false;
		}
	});
	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function(text) {
				jQuery.globalEval(text);
				return text;
			}
		}
	});
	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter("script", function(s) {
		if (s.cache === undefined) {
			s.cache = false;
		}
		if (s.crossDomain) {
			s.type = "GET";
		}
	});
	// Bind script tag hack transport
	jQuery.ajaxTransport("script", function(s) {
		// This transport only deals with cross domain or forced-by-attrs requests
		if (s.crossDomain || s.scriptAttrs) {
			var script, callback;
			return {
				send: function(_, complete) {
					script = jQuery("<script>")
						.attr(s.scriptAttrs || {})
						.prop({
							charset: s.scriptCharset,
							src: s.url
						})
						.on("load error", callback = function(evt) {
							script.remove();
							callback = null;
							if (evt) {
								complete(evt.type === "error" ? 404 : 200, evt.type);
							}
						});
					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild(script[0]);
				},
				abort: function() {
					if (callback) {
						callback();
					}
				}
			};
		}
	});
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;
	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce.guid++));
			this[callback] = true;
			return callback;
		}
	});
	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
				"url" :
				typeof s.data === "string" &&
				(s.contentType || "")
				.indexOf("application/x-www-form-urlencoded") === 0 &&
				rjsonp.test(s.data) && "data"
			);
		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if (jsonProp || s.dataTypes[0] === "jsonp") {
			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ?
				s.jsonpCallback() :
				s.jsonpCallback;
			// Insert callback into url or form data
			if (jsonProp) {
				s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
			} else if (s.jsonp !== false) {
				s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
			}
			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function() {
				if (!responseContainer) {
					jQuery.error(callbackName + " was not called");
				}
				return responseContainer[0];
			};
			// Force json dataType
			s.dataTypes[0] = "json";
			// Install callback
			overwritten = window[callbackName];
			window[callbackName] = function() {
				responseContainer = arguments;
			};
			// Clean-up function (fires after converters)
			jqXHR.always(function() {
				// If previous value didn't exist - remove it
				if (overwritten === undefined) {
					jQuery(window).removeProp(callbackName);
					// Otherwise restore preexisting value
				} else {
					window[callbackName] = overwritten;
				}
				// Save back as free
				if (s[callbackName]) {
					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;
					// Save the callback name for future use
					oldCallbacks.push(callbackName);
				}
				// Call if it was a function and we have a response
				if (responseContainer && isFunction(overwritten)) {
					overwritten(responseContainer[0]);
				}
				responseContainer = overwritten = undefined;
			});
			// Delegate to script
			return "script";
		}
	});
	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = (function() {
		var body = document.implementation.createHTMLDocument("").body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	})();
	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function(data, context, keepScripts) {
		if (typeof data !== "string") {
			return [];
		}
		if (typeof context === "boolean") {
			keepScripts = context;
			context = false;
		}
		var base, parsed, scripts;
		if (!context) {
			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if (support.createHTMLDocument) {
				context = document.implementation.createHTMLDocument("");
				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement("base");
				base.href = document.location.href;
				context.head.appendChild(base);
			} else {
				context = document;
			}
		}
		parsed = rsingleTag.exec(data);
		scripts = !keepScripts && [];
		// Single tag
		if (parsed) {
			return [context.createElement(parsed[1])];
		}
		parsed = buildFragment([data], context, scripts);
		if (scripts && scripts.length) {
			jQuery(scripts).remove();
		}
		return jQuery.merge([], parsed.childNodes);
	};
	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function(url, params, callback) {
		var selector, type, response,
			self = this,
			off = url.indexOf(" ");
		if (off > -1) {
			selector = stripAndCollapse(url.slice(off));
			url = url.slice(0, off);
		}
		// If it's a function
		if (isFunction(params)) {
			// We assume that it's the callback
			callback = params;
			params = undefined;
			// Otherwise, build a param string
		} else if (params && typeof params === "object") {
			type = "POST";
		}
		// If we have elements to modify, make the request
		if (self.length > 0) {
			jQuery.ajax({
				url: url,
				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			}).done(function(responseText) {
				// Save response for use in complete callback
				response = arguments;
				self.html(selector ?
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :
					// Otherwise use the full result
					responseText);
				// If the request succeeds, this function gets "data", "status", "jqXHR"
				// but they are ignored because response was set above.
				// If it fails, this function gets "jqXHR", "status", "error"
			}).always(callback && function(jqXHR, status) {
				self.each(function() {
					callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
				});
			});
		}
		return this;
	};
	jQuery.expr.pseudos.animated = function(elem) {
		return jQuery.grep(jQuery.timers, function(fn) {
			return elem === fn.elem;
		}).length;
	};
	jQuery.offset = {
		setOffset: function(elem, options, i) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css(elem, "position"),
				curElem = jQuery(elem),
				props = {};
			// Set position first, in-case top/left are set even on static elem
			if (position === "static") {
				elem.style.position = "relative";
			}
			curOffset = curElem.offset();
			curCSSTop = jQuery.css(elem, "top");
			curCSSLeft = jQuery.css(elem, "left");
			calculatePosition = (position === "absolute" || position === "fixed") &&
				(curCSSTop + curCSSLeft).indexOf("auto") > -1;
			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if (calculatePosition) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
			} else {
				curTop = parseFloat(curCSSTop) || 0;
				curLeft = parseFloat(curCSSLeft) || 0;
			}
			if (isFunction(options)) {
				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call(elem, i, jQuery.extend({}, curOffset));
			}
			if (options.top != null) {
				props.top = (options.top - curOffset.top) + curTop;
			}
			if (options.left != null) {
				props.left = (options.left - curOffset.left) + curLeft;
			}
			if ("using" in options) {
				options.using.call(elem, props);
			} else {
				curElem.css(props);
			}
		}
	};
	jQuery.fn.extend({
		// offset() relates an element's border box to the document origin
		offset: function(options) {
			// Preserve chaining for setter
			if (arguments.length) {
				return options === undefined ?
					this :
					this.each(function(i) {
						jQuery.offset.setOffset(this, options, i);
					});
			}
			var rect, win,
				elem = this[0];
			if (!elem) {
				return;
			}
			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if (!elem.getClientRects().length) {
				return {
					top: 0,
					left: 0
				};
			}
			// Get document-relative position by adding viewport scroll to viewport-relative gBCR
			rect = elem.getBoundingClientRect();
			win = elem.ownerDocument.defaultView;
			return {
				top: rect.top + win.pageYOffset,
				left: rect.left + win.pageXOffset
			};
		},
		// position() relates an element's margin box to its offset parent's padding box
		// This corresponds to the behavior of CSS absolute positioning
		position: function() {
			if (!this[0]) {
				return;
			}
			var offsetParent, offset, doc,
				elem = this[0],
				parentOffset = {
					top: 0,
					left: 0
				};
			// position:fixed elements are offset from the viewport, which itself always has zero offset
			if (jQuery.css(elem, "position") === "fixed") {
				// Assume position:fixed implies availability of getBoundingClientRect
				offset = elem.getBoundingClientRect();
			} else {
				offset = this.offset();
				// Account for the *real* offset parent, which can be the document or its root element
				// when a statically positioned element is identified
				doc = elem.ownerDocument;
				offsetParent = elem.offsetParent || doc.documentElement;
				while (offsetParent &&
					(offsetParent === doc.body || offsetParent === doc.documentElement) &&
					jQuery.css(offsetParent, "position") === "static") {
					offsetParent = offsetParent.parentNode;
				}
				if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
					// Incorporate borders into its offset, since they are outside its content origin
					parentOffset = jQuery(offsetParent).offset();
					parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
					parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
				}
			}
			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
				left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
			};
		},
		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map(function() {
				var offsetParent = this.offsetParent;
				while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
					offsetParent = offsetParent.offsetParent;
				}
				return offsetParent || documentElement;
			});
		}
	});
	// Create scrollLeft and scrollTop methods
	jQuery.each({
		scrollLeft: "pageXOffset",
		scrollTop: "pageYOffset"
	}, function(method, prop) {
		var top = "pageYOffset" === prop;
		jQuery.fn[method] = function(val) {
			return access(this, function(elem, method, val) {
				// Coalesce documents and windows
				var win;
				if (isWindow(elem)) {
					win = elem;
				} else if (elem.nodeType === 9) {
					win = elem.defaultView;
				}
				if (val === undefined) {
					return win ? win[prop] : elem[method];
				}
				if (win) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);
				} else {
					elem[method] = val;
				}
			}, method, val, arguments.length);
		};
	});
	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each(["top", "left"], function(_i, prop) {
		jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
			function(elem, computed) {
				if (computed) {
					computed = curCSS(elem, prop);
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test(computed) ?
						jQuery(elem).position()[prop] + "px" :
						computed;
				}
			}
		);
	});
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each({
		Height: "height",
		Width: "width"
	}, function(name, type) {
		jQuery.each({
			padding: "inner" + name,
			content: type,
			"": "outer" + name
		}, function(defaultExtra, funcName) {
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[funcName] = function(margin, value) {
				var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
					extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
				return access(this, function(elem, type, value) {
					var doc;
					if (isWindow(elem)) {
						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf("outer") === 0 ?
							elem["inner" + name] :
							elem.document.documentElement["client" + name];
					}
					// Get document width or height
					if (elem.nodeType === 9) {
						doc = elem.documentElement;
						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body["scroll" + name], doc["scroll" + name],
							elem.body["offset" + name], doc["offset" + name],
							doc["client" + name]
						);
					}
					return value === undefined ?
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css(elem, type, extra) :
						// Set width or height on the element
						jQuery.style(elem, type, value, extra);
				}, type, chainable ? margin : undefined, chainable);
			};
		});
	});
	jQuery.each([
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function(_i, type) {
		jQuery.fn[type] = function(fn) {
			return this.on(type, fn);
		};
	});
	jQuery.fn.extend({
		bind: function(types, data, fn) {
			return this.on(types, null, data, fn);
		},
		unbind: function(types, fn) {
			return this.off(types, null, fn);
		},
		delegate: function(selector, types, data, fn) {
			return this.on(types, selector, data, fn);
		},
		undelegate: function(selector, types, fn) {
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off(selector, "**") :
				this.off(types, selector || "**", fn);
		},
		hover: function(fnOver, fnOut) {
			return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
		}
	});
	jQuery.each(
		("blur focus focusin focusout resize scroll click dblclick " +
			"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
			"change select submit keydown keypress keyup contextmenu").split(" "),
		function(_i, name) {
			// Handle event binding
			jQuery.fn[name] = function(data, fn) {
				return arguments.length > 0 ?
					this.on(name, null, data, fn) :
					this.trigger(name);
			};
		}
	);
	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
	// Bind a function to a context, optionally partially applying any
	// arguments.
	// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
	// However, it is not slated for removal any time soon
	jQuery.proxy = function(fn, context) {
		var tmp, args, proxy;
		if (typeof context === "string") {
			tmp = fn[context];
			context = fn;
			fn = tmp;
		}
		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if (!isFunction(fn)) {
			return undefined;
		}
		// Simulated bind
		args = slice.call(arguments, 2);
		proxy = function() {
			return fn.apply(context || this, args.concat(slice.call(arguments)));
		};
		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;
		return proxy;
	};
	jQuery.holdReady = function(hold) {
		if (hold) {
			jQuery.readyWait++;
		} else {
			jQuery.ready(true);
		}
	};
	jQuery.isArray = Array.isArray;
	jQuery.parseJSON = JSON.parse;
	jQuery.nodeName = nodeName;
	jQuery.isFunction = isFunction;
	jQuery.isWindow = isWindow;
	jQuery.camelCase = camelCase;
	jQuery.type = toType;
	jQuery.now = Date.now;
	jQuery.isNumeric = function(obj) {
		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type(obj);
		return (type === "number" || type === "string") &&
			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN(obj - parseFloat(obj));
	};
	jQuery.trim = function(text) {
		return text == null ?
			"" :
			(text + "").replace(rtrim, "");
	};
	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	if (typeof define === "function" && define.amd) {
		define("jquery", [], function() {
			return jQuery;
		});
	}
	var
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
		// Map over the $ in case of overwrite
		_$ = window.$;
	jQuery.noConflict = function(deep) {
		if (window.$ === jQuery) {
			window.$ = _$;
		}
		if (deep && window.jQuery === jQuery) {
			window.jQuery = _jQuery;
		}
		return jQuery;
	};
	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if (typeof noGlobal === "undefined") {
		window.jQuery = window.$ = jQuery;
	}
	return jQuery;
});
! function(t, e) {
	"object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.device = t.device || {})
}(this, function(t) {
	function e(t, e) {
		return e = {
			exports: {}
		}, t(e, e.exports), e.exports
	}

	function i(t) {
		var e = typeof t;
		return null != t && ("object" == e || "function" == e)
	}

	function n(t) {
		var e = A.call(t, L),
			i = t[L];
		try {
			t[L] = void 0;
			var n = !0
		} catch (t) {}
		var o = E.call(t);
		return n && (e ? t[L] = i : delete t[L]), o
	}

	function o(t) {
		return D.call(t)
	}

	function s(t) {
		return null == t ? void 0 === t ? $ : S : U && U in Object(t) ? M(t) : W(t)
	}

	function a(t) {
		return null != t && "object" == typeof t
	}

	function r(t) {
		return "symbol" == typeof t || z(t) && B(t) == R
	}

	function c(t) {
		if ("number" == typeof t) return t;
		if (F(t)) return H;
		if (w(t)) {
			var e = "function" == typeof t.valueOf ? t.valueOf() : t;
			t = w(e) ? e + "" : e
		}
		if ("string" != typeof t) return 0 === t ? t : +t;
		t = t.replace(I, "");
		var i = G.test(t);
		return i || J.test(t) ? K(t.slice(2), i ? 2 : 8) : q.test(t) ? H : +t
	}

	function h(t, e, i) {
		function n(e) {
			var i = l,
				n = f;
			return l = f = void 0, v = e, m = t.apply(n, i)
		}

		function o(t) {
			return v = t, b = setTimeout(r, e), y ? n(t) : m
		}

		function s(t) {
			var i = t - g,
				n = t - v,
				o = e - i;
			return C ? Y(o, p - n) : o
		}

		function a(t) {
			var i = t - g,
				n = t - v;
			return void 0 === g || i >= e || i < 0 || C && n >= p
		}

		function r() {
			var t = O();
			if (a(t)) return c(t);
			b = setTimeout(r, s(t))
		}

		function c(t) {
			return b = void 0, x && l ? n(t) : (l = f = void 0, m)
		}

		function h() {
			void 0 !== b && clearTimeout(b), v = 0, l = g = f = b = void 0
		}

		function d() {
			return void 0 === b ? m : c(O())
		}

		function u() {
			var t = O(),
				i = a(t);
			if (l = arguments, f = this, g = t, i) {
				if (void 0 === b) return o(g);
				if (C) return b = setTimeout(r, e), n(g)
			}
			return void 0 === b && (b = setTimeout(r, e)), m
		}
		var l, f, p, m, b, g, v = 0,
			y = !1,
			C = !1,
			x = !0;
		if ("function" != typeof t) throw new TypeError(V);
		return e = Q(e) || 0, w(i) && (y = !!i.leading, C = "maxWait" in i, p = C ? X(Q(i.maxWait) || 0, e) : p, x = "trailing" in i ? !!i.trailing : x), u.cancel = h, u.flush = d, u
	}

	function d(t, e, i) {
		var n = !0,
			o = !0;
		if ("function" != typeof t) throw new TypeError(tt);
		return w(i) && (n = "leading" in i ? !!i.leading : n, o = "trailing" in i ? !!i.trailing : o), Z(t, e, {
			leading: n,
			maxWait: e,
			trailing: o
		})
	}
	var u = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {},
		l = e(function(t, e) {
			"use strict";

			function i(t, e) {
				return t.classList ? !!e && t.classList.contains(e) : -1 !== (" " + t.className + " ").indexOf(" " + e + " ")
			}
			Object.defineProperty(e, "__esModule", {
				value: !0
			}), e.default = i, t.exports = e.default
		}),
		f = e(function(t, e) {
			"use strict";

			function i(t, e) {
				t.classList ? t.classList.add(e) : (0, n.default)(t) || (t.className = t.className + " " + e)
			}
			Object.defineProperty(e, "__esModule", {
				value: !0
			}), e.default = i;
			var n = function(t) {
				return t && t.__esModule ? t : {
					default: t
				}
			}(l);
			t.exports = e.default
		}),
		p = function(t, e) {
			t.classList ? t.classList.remove(e) : t.className = t.className.replace(new RegExp("(^|\\s)" + e + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "")
		},
		m = e(function(t, e) {
			"use strict";

			function i(t) {
				return t && t.__esModule ? t : {
					default: t
				}
			}
			Object.defineProperty(e, "__esModule", {
				value: !0
			}), e.hasClass = e.removeClass = e.addClass = void 0;
			var n = i(f),
				o = i(p),
				s = i(l);
			e.addClass = n.default, e.removeClass = o.default, e.hasClass = s.default, e.default = {
				addClass: n.default,
				removeClass: o.default,
				hasClass: s.default
			}
		}),
		b = m.removeClass,
		g = m.addClass,
		w = i,
		v = "object" == typeof u && u && u.Object === Object && u,
		y = v,
		C = "object" == typeof self && self && self.Object === Object && self,
		x = y || C || Function("return this")(),
		k = x,
		T = function() {
			return k.Date.now()
		},
		O = T,
		P = k.Symbol,
		j = P,
		N = Object.prototype,
		A = N.hasOwnProperty,
		E = N.toString,
		L = j ? j.toStringTag : void 0,
		M = n,
		_ = Object.prototype,
		D = _.toString,
		W = o,
		S = "[object Null]",
		$ = "[object Undefined]",
		U = j ? j.toStringTag : void 0,
		B = s,
		z = a,
		R = "[object Symbol]",
		F = r,
		H = NaN,
		I = /^\s+|\s+$/g,
		q = /^[-+]0x[0-9a-f]+$/i,
		G = /^0b[01]+$/i,
		J = /^0o[0-7]+$/i,
		K = parseInt,
		Q = c,
		V = "Expected a function",
		X = Math.max,
		Y = Math.min,
		Z = h,
		tt = "Expected a function",
		et = d,
		it = null,
		nt = [],
		ot = function() {
			it && (clearTimeout(it), it = null)
		},
		st = function(t) {
			if (t && nt.push(t), "undefined" != typeof document) {
				ot();
				for (var e = 0, i = nt.length; e < i; e++) nt[e](document);
				return void(nt.length = 0)
			}
			ot(), setTimeout(function() {
				st()
			}, 100)
		},
		at = function() {
			return "undefined" != typeof document ? window.navigator.userAgent : ""
		},
		rt = function(t) {
			return RegExp("msie" + (isNaN(t) ? "" : "\\s" + t), "i").test(navigator.userAgent)
		},
		ct = null,
		ht = function(t) {
			var e = this;
			void 0 === t && (t = null), this.state = {
				addedClasses: !1
			}, this.matchCache = {}, this.featureCache = {}, this.classes = "", this.setUserAgent(t), this.callback = null, "undefined" != typeof document || this.userAgent || st(function() {
				e.setUserAgent()
			})
		},
		dt = {
			features: {},
			deviceorientation: {},
			ie9: {},
			touchDevice: {},
			touch: {},
			ios: {},
			iphone: {},
			ipod: {},
			ipad: {},
			android: {},
			androidPhone: {},
			androidTablet: {},
			blackberry: {},
			blackberryPhone: {},
			blackberryTablet: {},
			windows: {},
			ie10: {},
			windowsPhone: {},
			windowsTablet: {},
			fxos: {},
			fxosPhone: {},
			fxosTablet: {},
			meego: {},
			cordova: {},
			nodeWebkit: {},
			mobile: {},
			tablet: {},
			desktop: {},
			television: {},
			portrait: {},
			landscape: {}
		},
		ut = {
			device: {}
		};
	ut.device.get = function() {
		return ct || (ct = new ht), ct
	}, ht.prototype.match = function(t) {
		return this.matchCache[t] || (this.matchCache[t] = this.userAgent.indexOf(t) > -1), this.matchCache[t]
	}, ht.prototype.feature = function(t) {
		return this.featureCache[t]
	}, ht.prototype.addFeature = function(t, e) {
		return this.featureCache[t] || (this.featureCache[t] = e), e
	}, ht.prototype.setUserAgent = function(t) {
		void 0 === t && (t = null), this.userAgent = t || this.userAgent || at(), this.userAgent && (ot(), this.matchCache = {}, this.userAgent = this.userAgent.toLowerCase())
	}, ht.prototype.onOrientationChange = function(t) {}, ht.prototype.getClasses = function() {
		return this.classes ? this.classes : (this.userAgent || this.setUserAgent(), this.landscape ? this.classes += "landscape " : this.classes += "portrait ", this.touch && (this.classes += "touch "), this.ios ? this.ipad ? this.classes += "ios ipad tablet " : this.iphone ? this.classes += "ios iphone mobile " : this.ipod && (this.classes += "ios ipod mobile ") : this.android ? this.androidTablet ? this.classes += "android tablet " : this.classes += "android mobile " : this.blackberry ? this.blackberryTablet ? this.classes += "blackberry tablet " : this.classes += "blackberry mobile " : this.windows ? this.windowsTablet ? this.classes += "windows tablet " : this.windowsPhone ? this.classes += "windows mobile " : this.classes += "windows desktop " : this.fxos ? this.fxosTablet ? this.classes += "fxos tablet " : this.classes += "fxos mobile " : this.meego ? this.classes += "meego mobile " : this.nodeWebkit ? this.classes += "node-webkit " : this.television ? this.classes += "television " : this.desktop && (this.classes += "desktop "), this.cordova && (this.classes += "cordova "), !this.desktop && this.deviceorientation && (this.classes += "deviceorientation "), this.classes = this.classes.slice(0, -1), this.classes)
	}, ht.prototype.addClasses = function(t) {
		if (!this.targetNode) {
			if (this.targetNode = t, t || "undefined" == typeof document || (this.targetNode = document.documentElement), !this.targetNode) return;
			this.userAgent || this.setUserAgent(), this.commitClasses(), this.addListener()
		}
	}, ht.prototype.addListener = function() {
		var t = this;
		if (!this.hasListener) {
			this.hasListener = !0, this.handleOrientation = this.handleOrientation.bind(this), this.onResize = et(this.handleOrientation, 200);
			var e = function() {
				setTimeout(function() {
					t.handleOrientation()
				}, 10)
			};
			"onorientationchange" in window ? window.addEventListener("orientationchange", e, !1) : window.addEventListener("resize", this.onResize, !1), e()
		}
	}, ht.prototype.handleOrientation = function() {
		this.onOrientationChange(this.landscape), this.targetNode && (this.landscape ? (b(this.targetNode, "portrait"), g(this.targetNode, "landscape")) : (b(this.targetNode, "landscape"), g(this.targetNode, "portrait")))
	}, ht.prototype.commitClasses = function() {
		!this.state.addedClasses && this.targetNode && (this.state.addedClasses = !0, this.targetNode.className += this.getClasses())
	}, dt.features.get = function() {
		return {
			wheelEvent: this.feature("wheelEvent") || this.addFeature("wheelEvent", "onwheel" in document.createElement("div") ? "wheel" : void 0 !== document.onmousewheel ? "mousewheel" : "DOMMouseScroll")
		}
	}, dt.deviceorientation.get = function() {
		return this.canOrientate || (this.canOrientate = "ondeviceorientation" in window || "deviceorientation" in window), !this.desktop && this.canOrientate
	}, dt.ie9.get = function() {
		return this.matchCache.ie9 || "undefined" != typeof document && (this.matchCache.ie9 = this.windows && rt(10)), this.matchCache.ie9 || !1
	}, dt.touchDevice.get = function() {
		return this.matchCache.touchDevice || "undefined" != typeof document && (this.matchCache.touchDevice = !(!navigator || !navigator.userAgent) && navigator.userAgent.match(/(iPhone|iPod|iPad|Android|playbook|silk|BlackBerry|BB10|Windows Phone|Tizen|Bada|webOS|IEMobile|Opera Mini)/)), this.matchCache.touchDevice || !1
	}, dt.touch.get = function() {
		return this.matchCache.touch || "undefined" != typeof document && (this.matchCache.touch = "ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch || navigator && navigator.msMaxTouchPoints > 0 || navigator && navigator.maxTouchPoints), this.matchCache.touch || !1
	}, dt.ios.get = function() {
		return this.iphone || this.ipod || this.ipad
	}, dt.iphone.get = function() {
		return !this.windows && this.match("iphone")
	}, dt.ipod.get = function() {
		return this.match("ipod")
	}, dt.ipad.get = function() {
		return this.match("ipad")
	}, dt.android.get = function() {
		return !this.windows && this.match("android")
	}, dt.androidPhone.get = function() {
		return this.android && this.match("mobile")
	}, dt.androidTablet.get = function() {
		return this.android && !this.match("mobile")
	}, dt.blackberry.get = function() {
		return this.match("blackberry") || this.match("bb10") || this.match("rim")
	}, dt.blackberryPhone.get = function() {
		return this.blackberry && !this.match("tablet")
	}, dt.blackberryTablet.get = function() {
		return this.blackberry && this.match("tablet")
	}, dt.windows.get = function() {
		return this.match("windows")
	}, dt.ie10.get = function() {
		return this.matchCache.ie10 || "undefined" != typeof document && (this.matchCache.ie10 = this.windows && rt(10)), this.matchCache.ie10 || !1
	}, dt.windowsPhone.get = function() {
		return this.windows && this.match("phone")
	}, dt.windowsTablet.get = function() {
		return this.windows && this.match("touch") && !this.windowsPhone
	}, dt.fxos.get = function() {
		return (this.match("(mobile;") || this.match("(tablet;")) && this.match("; rv:")
	}, dt.fxosPhone.get = function() {
		return this.fxos && this.match("mobile")
	}, dt.fxosTablet.get = function() {
		return this.fxos && this.match("tablet")
	}, dt.meego.get = function() {
		return this.match("meego")
	}, dt.cordova.get = function() {
		return window.cordova && "file:" === location.protocol
	}, dt.nodeWebkit.get = function() {
		return "object" == typeof window.process
	}, dt.mobile.get = function() {
		return this.androidPhone || this.iphone || this.ipod || this.windowsPhone || this.blackberryPhone || this.fxosPhone || this.meego
	}, dt.tablet.get = function() {
		return this.ipad || this.androidTablet || this.blackberryTablet || this.windowsTablet || this.fxosTablet
	}, dt.desktop.get = function() {
		return !this.tablet && !this.mobile
	}, dt.television.get = function() {
		var t, e = this,
			i = ["googletv", "viera", "smarttv", "internet.tv", "netcast", "nettv", "appletv", "boxee", "kylo", "roku", "dlnadoc", "roku", "pov_tv", "hbbtv", "ce-html"];
		for (t = 0; t++ < i.length;)
			if (e.match(i[t])) return !0;
		return !1
	}, dt.portrait.get = function() {
		return "orientation" in window ? 0 === window.orientation : "undefined" != typeof window && window.innerHeight / window.innerWidth > 1
	}, dt.landscape.get = function() {
		return "undefined" != typeof window && ("orientation" in window ? 0 !== window.orientation : window.innerHeight / window.innerWidth < 1)
	}, Object.defineProperties(ht.prototype, dt), Object.defineProperties(ht, ut);
	var lt = new ht;
	t.device = lt, t.default = ht, Object.defineProperty(t, "__esModule", {
		value: !0
	})
});
//# sourceMappingURL=device.umd.js.map
(function(global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		(global = global || self, global.Lenis = factory());
})(this, (function() {
	function _defineProperties(target, props) {
		for (var i = 0; i < props.length; i++) {
			var descriptor = props[i];
			descriptor.enumerable = descriptor.enumerable || false;
			descriptor.configurable = true;
			if ("value" in descriptor) descriptor.writable = true;
			Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
		}
	}

	function _createClass(Constructor, protoProps, staticProps) {
		if (protoProps) _defineProperties(Constructor.prototype, protoProps);
		if (staticProps) _defineProperties(Constructor, staticProps);
		Object.defineProperty(Constructor, "prototype", {
			writable: false
		});
		return Constructor;
	}

	function _toPrimitive(input, hint) {
		if (typeof input !== "object" || input === null) return input;
		var prim = input[Symbol.toPrimitive];
		if (prim !== undefined) {
			var res = prim.call(input, hint || "default");
			if (typeof res !== "object") return res;
			throw new TypeError("@@toPrimitive must return a primitive value.");
		}
		return (hint === "string" ? String : Number)(input);
	}

	function _toPropertyKey(arg) {
		var key = _toPrimitive(arg, "string");
		return typeof key === "symbol" ? key : String(key);
	}
	var version = "1.0.3";
	// Clamp a value between a minimum and maximum value
	function clamp(min, input, max) {
		return Math.max(min, Math.min(input, max));
	}
	// Linearly interpolate between two values using an amount (0 <= amt <= 1)
	function lerp(start, end, amt) {
		return (1 - amt) * start + amt * end;
	}
	// Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor
	function clampedModulo(dividend, divisor) {
		var remainder = dividend % divisor;
		// If the remainder and divisor have different signs, adjust the remainder
		if (divisor > 0 && remainder < 0 || divisor < 0 && remainder > 0) {
			remainder += divisor;
		}
		return remainder;
	}
	// Animate class to handle value animations with lerping or easing
	var Animate = /*#__PURE__*/ function() {
		function Animate() {}
		var _proto = Animate.prototype;
		// Advance the animation by the given delta time
		_proto.advance = function advance(deltaTime) {
			var _this$onUpdate;
			if (!this.isRunning) return;
			var completed = false;
			if (this.lerp) {
				this.value = lerp(this.value, this.to, this.lerp);
				if (Math.round(this.value) === this.to) {
					this.value = this.to;
					completed = true;
				}
			} else {
				this.currentTime += deltaTime;
				var linearProgress = clamp(0, this.currentTime / this.duration, 1);
				completed = linearProgress >= 1;
				var easedProgress = completed ? 1 : this.easing(linearProgress);
				this.value = this.from + (this.to - this.from) * easedProgress;
			}
			// Call the onUpdate callback with the current value and completed status
			(_this$onUpdate = this.onUpdate) == null ? void 0 : _this$onUpdate.call(this, this.value, {
				completed: completed
			});
			if (completed) {
				this.stop();
			}
		}
		// Stop the animation
		;
		_proto.stop = function stop() {
			this.isRunning = false;
		}
		// Set up the animation from a starting value to an ending value
		// with optional parameters for lerping, duration, easing, and onUpdate callback
		;
		_proto.fromTo = function fromTo(from, to, _ref) {
			var _ref$lerp = _ref.lerp,
				lerp = _ref$lerp === void 0 ? 0.1 : _ref$lerp,
				_ref$duration = _ref.duration,
				duration = _ref$duration === void 0 ? 1 : _ref$duration,
				_ref$easing = _ref.easing,
				easing = _ref$easing === void 0 ? function(t) {
					return t;
				} : _ref$easing,
				onUpdate = _ref.onUpdate;
			this.from = this.value = from;
			this.to = to;
			this.lerp = lerp;
			this.duration = duration;
			this.easing = easing;
			this.currentTime = 0;
			this.isRunning = true;
			this.onUpdate = onUpdate;
		};
		return Animate;
	}();
	var createNanoEvents = function createNanoEvents() {
		return {
			events: {},
			// Emit an event with the provided arguments
			emit: function emit(event) {
				var callbacks = this.events[event] || [];
				for (var i = 0, length = callbacks.length; i < length; i++) {
					callbacks[i].apply(callbacks, [].slice.call(arguments, 1));
				}
			},
			// Register a callback for the specified event
			on: function on(event, cb) {
				var _this$events$event,
					_this = this;
				// Add the callback to the event's callback list, or create a new list with the callback
				((_this$events$event = this.events[event]) == null ? void 0 : _this$events$event.push(cb)) || (this.events[event] = [cb]);
				// Return an unsubscribe function
				return function() {
					var _this$events$event2;
					_this.events[event] = (_this$events$event2 = _this.events[event]) == null ? void 0 : _this$events$event2.filter(function(i) {
						return cb !== i;
					});
				};
			}
		};
	};
	var ObservedElement = /*#__PURE__*/ function() {
		function ObservedElement(element) {
			var _this = this;
			// Update the width and height properties based on the observed element's size
			this.onResize = function(_ref) {
				var entry = _ref[0];
				if (entry) {
					var _entry$contentRect = entry.contentRect,
						width = _entry$contentRect.width,
						height = _entry$contentRect.height;
					_this.width = width;
					_this.height = height;
				}
			};
			// Update the width and height properties based on the window's size
			this.onWindowResize = function() {
				_this.width = window.innerWidth;
				_this.height = window.innerHeight;
			};
			this.element = element;
			// If the element is the window, add a resize event listener and trigger it initially
			if (element === window) {
				window.addEventListener('resize', this.onWindowResize);
				this.onWindowResize();
			} else {
				// If the element is not the window, observe its size using ResizeObserver
				this.width = this.element.offsetWidth;
				this.height = this.element.offsetHeight;
				this.resizeObserver = new ResizeObserver(this.onResize);
				this.resizeObserver.observe(this.element);
			}
		}
		// Clean up event listeners and disconnect the ResizeObserver when destroying the instance
		var _proto = ObservedElement.prototype;
		_proto.destroy = function destroy() {
			window.removeEventListener('resize', this.onWindowResize);
			this.resizeObserver.disconnect();
		};
		return ObservedElement;
	}();
	var VirtualScroll = /*#__PURE__*/ function() {
		function VirtualScroll(element, _ref) {
			var _this = this;
			var _ref$wheelMultiplier = _ref.wheelMultiplier,
				wheelMultiplier = _ref$wheelMultiplier === void 0 ? 1 : _ref$wheelMultiplier,
				_ref$touchMultiplier = _ref.touchMultiplier,
				touchMultiplier = _ref$touchMultiplier === void 0 ? 2 : _ref$touchMultiplier,
				_ref$normalizeWheel = _ref.normalizeWheel,
				normalizeWheel = _ref$normalizeWheel === void 0 ? false : _ref$normalizeWheel;
			// Event handler for 'touchstart' event
			this.onTouchStart = function(event) {
				var _ref2 = event.targetTouches ? event.targetTouches[0] : event,
					pageX = _ref2.pageX,
					pageY = _ref2.pageY;
				_this.touchStart.x = pageX;
				_this.touchStart.y = pageY;
			};
			// Event handler for 'touchmove' event
			this.onTouchMove = function(event) {
				var _ref3 = event.targetTouches ? event.targetTouches[0] : event,
					pageX = _ref3.pageX,
					pageY = _ref3.pageY;
				var deltaX = -(pageX - _this.touchStart.x) * _this.touchMultiplier;
				var deltaY = -(pageY - _this.touchStart.y) * _this.touchMultiplier;
				_this.touchStart.x = pageX;
				_this.touchStart.y = pageY;
				_this.emitter.emit('scroll', {
					type: 'touch',
					deltaX: deltaX,
					deltaY: deltaY,
					event: event
				});
			};
			// Event handler for 'wheel' event
			this.onWheel = function(event) {
				var deltaX = event.deltaX,
					deltaY = event.deltaY;
				if (_this.normalizeWheel) {
					deltaX = clamp(-100, deltaX, 100);
					deltaY = clamp(-100, deltaY, 100);
				}
				deltaX *= _this.wheelMultiplier;
				deltaY *= _this.wheelMultiplier;
				_this.emitter.emit('scroll', {
					type: 'wheel',
					deltaX: deltaX,
					deltaY: deltaY,
					event: event
				});
			};
			this.element = element;
			this.wheelMultiplier = wheelMultiplier;
			this.touchMultiplier = touchMultiplier;
			this.normalizeWheel = normalizeWheel;
			this.touchStart = {
				x: null,
				y: null
			};
			this.emitter = createNanoEvents();
			this.element.addEventListener('wheel', this.onWheel, {
				passive: false
			});
			this.element.addEventListener('touchstart', this.onTouchStart, {
				passive: false
			});
			this.element.addEventListener('touchmove', this.onTouchMove, {
				passive: false
			});
		}
		// Add an event listener for the given event and callback
		var _proto = VirtualScroll.prototype;
		_proto.on = function on(event, callback) {
			return this.emitter.on(event, callback);
		}
		// Remove all event listeners and clean up
		;
		_proto.destroy = function destroy() {
			this.emitter.events = {};
			this.element.removeEventListener('wheel', this.onWheel, {
				passive: false
			});
			this.element.removeEventListener('touchstart', this.onTouchStart, {
				passive: false
			});
			this.element.removeEventListener('touchmove', this.onTouchMove, {
				passive: false
			});
		};
		return VirtualScroll;
	}();
	// Technical explaination
	// - listen to 'wheel' events
	// - prevent 'wheel' event to prevent scroll
	// - normalize wheel delta
	// - add delta to targetScroll
	// - animate scroll to targetScroll (smooth context)
	// - if animation is not running, listen to 'scroll' events (native context)
	var Lenis = /*#__PURE__*/ function() {
		// isScrolling = true when scroll is animating
		// isStopped = true if user should not be able to scroll - enable/disable programatically
		// isSmooth = true if scroll should be animated
		// isLocked = same as isStopped but enabled/disabled when scroll reaches target
		/**

		 * @typedef {(t: number) => number} EasingFunction

		 * @typedef {'vertical' | 'horizontal'} Orientation

		 * @typedef {'vertical' | 'horizontal' | 'both'} GestureOrientation

		 *

		 * @typedef LenisOptions

		 * @property {Orientation} [direction]

		 * @property {GestureOrientation} [gestureDirection]

		 * @property {number} [mouseMultiplier]

		 * @property {boolean} [smooth]

		 *

		 * @property {Window | HTMLElement} [wrapper]

		 * @property {HTMLElement} [content]

		 * @property {boolean} [smoothWheel]

		 * @property {boolean} [smoothTouch]

		 * @property {number} [duration]

		 * @property {EasingFunction} [easing]

		 * @property {number} [lerp]

		 * @property {boolean} [infinite]

		 * @property {Orientation} [orientation]

		 * @property {GestureOrientation} [gestureOrientation]

		 * @property {number} [touchMultiplier]

		 * @property {number} [wheelMultiplier]

		 * @property {boolean} [normalizeWheel]

		 *

		 * @param {LenisOptions}

		 */
		function Lenis(_temp) {
			var _this = this;
			var _ref = _temp === void 0 ? {} : _temp,
				direction = _ref.direction,
				gestureDirection = _ref.gestureDirection,
				mouseMultiplier = _ref.mouseMultiplier,
				smooth = _ref.smooth,
				_ref$wrapper = _ref.wrapper,
				wrapper = _ref$wrapper === void 0 ? window : _ref$wrapper,
				_ref$content = _ref.content,
				content = _ref$content === void 0 ? document.documentElement : _ref$content,
				_ref$smoothWheel = _ref.smoothWheel,
				smoothWheel = _ref$smoothWheel === void 0 ? smooth != null ? smooth : true : _ref$smoothWheel,
				_ref$smoothTouch = _ref.smoothTouch,
				smoothTouch = _ref$smoothTouch === void 0 ? false : _ref$smoothTouch,
				duration = _ref.duration,
				_ref$easing = _ref.easing,
				easing = _ref$easing === void 0 ? function(t) {
					return Math.min(1, 1.001 - Math.pow(2, -10 * t));
				} : _ref$easing,
				_ref$lerp = _ref.lerp,
				lerp = _ref$lerp === void 0 ? duration ? null : 0.1 : _ref$lerp,
				_ref$infinite = _ref.infinite,
				infinite = _ref$infinite === void 0 ? false : _ref$infinite,
				_ref$orientation = _ref.orientation,
				orientation = _ref$orientation === void 0 ? direction != null ? direction : 'vertical' : _ref$orientation,
				_ref$gestureOrientati = _ref.gestureOrientation,
				gestureOrientation = _ref$gestureOrientati === void 0 ? gestureDirection != null ? gestureDirection : 'vertical' : _ref$gestureOrientati,
				_ref$touchMultiplier = _ref.touchMultiplier,
				touchMultiplier = _ref$touchMultiplier === void 0 ? 2 : _ref$touchMultiplier,
				_ref$wheelMultiplier = _ref.wheelMultiplier,
				wheelMultiplier = _ref$wheelMultiplier === void 0 ? mouseMultiplier != null ? mouseMultiplier : 1 : _ref$wheelMultiplier,
				_ref$normalizeWheel = _ref.normalizeWheel,
				normalizeWheel = _ref$normalizeWheel === void 0 ? true : _ref$normalizeWheel;
			this.onVirtualScroll = function(_ref2) {
				var type = _ref2.type,
					deltaX = _ref2.deltaX,
					deltaY = _ref2.deltaY,
					event = _ref2.event;
				// keep zoom feature
				if (event.ctrlKey) return;
				// keep previous/next page gesture on trackpads
				if (_this.options.gestureOrientation === 'vertical' && deltaY === 0 || _this.options.gestureOrientation === 'horizontal' && deltaX === 0) return;
				// catch if scrolling on nested scroll elements
				if (!!event.composedPath().find(function(node) {
						return node == null ? void 0 : node.hasAttribute == null ? void 0 : node.hasAttribute('data-lenis-prevent');
					})) return;
				if (_this.isStopped || _this.isLocked) {
					event.preventDefault();
					return;
				}
				_this.isSmooth = _this.options.smoothTouch && type === 'touch' || _this.options.smoothWheel && type === 'wheel';
				if (!_this.isSmooth) {
					_this.isScrolling = false;
					_this.animate.stop();
					return;
				}
				event.preventDefault();
				var delta = deltaY;
				if (_this.options.gestureOrientation === 'both') {
					delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;
				} else if (_this.options.gestureOrientation === 'horizontal') {
					delta = deltaX;
				}
				_this.scrollTo(_this.targetScroll + delta, {
					programmatic: false
				});
			};
			this.onScroll = function() {
				if (!_this.isScrolling) {
					var lastScroll = _this.animatedScroll;
					_this.animatedScroll = _this.targetScroll = _this.actualScroll;
					_this.velocity = 0;
					_this.direction = Math.sign(_this.animatedScroll - lastScroll);
					_this.emit();
				}
			};
			// warn about legacy options
			if (direction) {
				console.warn('Lenis: `direction` option is deprecated, use `orientation` instead');
			}
			if (gestureDirection) {
				console.warn('Lenis: `gestureDirection` option is deprecated, use `gestureOrientation` instead');
			}
			if (mouseMultiplier) {
				console.warn('Lenis: `mouseMultiplier` option is deprecated, use `wheelMultiplier` instead');
			}
			if (smooth) {
				console.warn('Lenis: `smooth` option is deprecated, use `smoothWheel` instead');
			}
			window.lenisVersion = version;
			// if wrapper is html or body, fallback to window
			if (wrapper === document.documentElement || wrapper === document.body) {
				wrapper = window;
			}
			this.options = {
				wrapper: wrapper,
				content: content,
				smoothWheel: smoothWheel,
				smoothTouch: smoothTouch,
				duration: duration,
				easing: easing,
				lerp: lerp,
				infinite: infinite,
				gestureOrientation: gestureOrientation,
				orientation: orientation,
				touchMultiplier: touchMultiplier,
				wheelMultiplier: wheelMultiplier,
				normalizeWheel: normalizeWheel
			};
			this.wrapper = new ObservedElement(wrapper);
			this.content = new ObservedElement(content);
			this.rootElement.classList.add('lenis');
			this.velocity = 0;
			this.isStopped = false;
			this.isSmooth = smoothWheel || smoothTouch;
			this.isScrolling = false;
			this.targetScroll = this.animatedScroll = this.actualScroll;
			this.animate = new Animate();
			this.emitter = createNanoEvents();
			this.wrapper.element.addEventListener('scroll', this.onScroll, {
				passive: false
			});
			this.virtualScroll = new VirtualScroll(wrapper, {
				touchMultiplier: touchMultiplier,
				wheelMultiplier: wheelMultiplier,
				normalizeWheel: normalizeWheel
			});
			this.virtualScroll.on('scroll', this.onVirtualScroll);
		}
		var _proto = Lenis.prototype;
		_proto.destroy = function destroy() {
			this.emitter.events = {};
			this.wrapper.element.removeEventListener('scroll', this.onScroll, {
				passive: false
			});
			this.virtualScroll.destroy();
		};
		_proto.on = function on(event, callback) {
			return this.emitter.on(event, callback);
		};
		_proto.off = function off(event, callback) {
			var _this$emitter$events$;
			this.emitter.events[event] = (_this$emitter$events$ = this.emitter.events[event]) == null ? void 0 : _this$emitter$events$.filter(function(i) {
				return callback !== i;
			});
		};
		_proto.setScroll = function setScroll(scroll) {
			// apply scroll value immediately
			if (this.isHorizontal) {
				this.rootElement.scrollLeft = scroll;
			} else {
				this.rootElement.scrollTop = scroll;
			}
		};
		_proto.emit = function emit() {
			this.emitter.emit('scroll', this);
		};
		_proto.reset = function reset() {
			this.isLocked = false;
			this.isScrolling = false;
			this.velocity = 0;
		};
		_proto.start = function start() {
			this.isStopped = false;
			this.reset();
		};
		_proto.stop = function stop() {
			this.isStopped = true;
			this.animate.stop();
			this.reset();
		};
		_proto.raf = function raf(time) {
			var deltaTime = time - (this.time || time);
			this.time = time;
			this.animate.advance(deltaTime * 0.001);
		};
		_proto.scrollTo = function scrollTo(target, _temp2) {
			var _this2 = this;
			var _ref3 = _temp2 === void 0 ? {} : _temp2,
				_ref3$offset = _ref3.offset,
				offset = _ref3$offset === void 0 ? 0 : _ref3$offset,
				_ref3$immediate = _ref3.immediate,
				immediate = _ref3$immediate === void 0 ? false : _ref3$immediate,
				_ref3$lock = _ref3.lock,
				lock = _ref3$lock === void 0 ? false : _ref3$lock,
				_ref3$duration = _ref3.duration,
				duration = _ref3$duration === void 0 ? this.options.duration : _ref3$duration,
				_ref3$easing = _ref3.easing,
				easing = _ref3$easing === void 0 ? this.options.easing : _ref3$easing,
				_ref3$lerp = _ref3.lerp,
				lerp = _ref3$lerp === void 0 ? !duration && this.options.lerp : _ref3$lerp,
				_ref3$onComplete = _ref3.onComplete,
				onComplete = _ref3$onComplete === void 0 ? null : _ref3$onComplete,
				_ref3$force = _ref3.force,
				force = _ref3$force === void 0 ? false : _ref3$force,
				_ref3$programmatic = _ref3.programmatic,
				programmatic = _ref3$programmatic === void 0 ? true : _ref3$programmatic;
			if (this.isStopped && !force) return;
			// keywords
			if (['top', 'left', 'start'].includes(target)) {
				target = 0;
			} else if (['bottom', 'right', 'end'].includes(target)) {
				target = this.limit;
			} else {
				var _target;
				var node;
				if (typeof target === 'string') {
					// CSS selector
					node = document.querySelector(target);
				} else if ((_target = target) != null && _target.nodeType) {
					// Node element
					node = target;
				}
				if (node) {
					if (this.wrapper.element !== window) {
						// nested scroll offset correction
						var wrapperRect = this.wrapper.element.getBoundingClientRect();
						offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;
					}
					var rect = node.getBoundingClientRect();
					target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;
				}
			}
			if (typeof target !== 'number') return;
			target += offset;
			target = Math.round(target);
			if (this.options.infinite) {
				if (programmatic) {
					this.targetScroll = this.animatedScroll = this.scroll;
				}
			} else {
				target = clamp(0, target, this.limit);
			}
			if (immediate) {
				this.animatedScroll = this.targetScroll = target;
				this.setScroll(this.scroll);
				this.animate.stop();
				this.reset();
				this.emit();
				onComplete == null ? void 0 : onComplete();
				return;
			}
			if (!programmatic) {
				this.targetScroll = target;
			}
			this.animate.fromTo(this.animatedScroll, target, {
				duration: duration,
				easing: easing,
				lerp: lerp,
				onUpdate: function onUpdate(value, _ref4) {
					var completed = _ref4.completed;
					// started
					if (lock) _this2.isLocked = true;
					_this2.isScrolling = true;
					// updated
					_this2.velocity = value - _this2.animatedScroll;
					_this2.direction = Math.sign(_this2.velocity);
					_this2.animatedScroll = value;
					_this2.setScroll(_this2.scroll);
					if (programmatic) {
						// wheel during programmatic should stop it
						_this2.targetScroll = value;
					}
					// completed
					if (completed) {
						if (lock) _this2.isLocked = false;
						requestAnimationFrame(function() {
							//avoid double scroll event
							_this2.isScrolling = false;
						});
						_this2.velocity = 0;
						onComplete == null ? void 0 : onComplete();
					}
					_this2.emit();
				}
			});
		};
		_createClass(Lenis, [{
			key: "rootElement",
			get: function get() {
				return this.wrapper.element === window ? this.content.element : this.wrapper.element;
			}
		}, {
			key: "limit",
			get: function get() {
				return Math.round(this.isHorizontal ? this.content.width - this.wrapper.width : this.content.height - this.wrapper.height);
			}
		}, {
			key: "isHorizontal",
			get: function get() {
				return this.options.orientation === 'horizontal';
			}
		}, {
			key: "actualScroll",
			get: function get() {
				// value browser takes into account
				return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop;
			}
		}, {
			key: "scroll",
			get: function get() {
				return this.options.infinite ? clampedModulo(this.animatedScroll, this.limit) : this.animatedScroll;
			}
		}, {
			key: "progress",
			get: function get() {
				return this.scroll / this.limit;
			}
		}, {
			key: "isSmooth",
			get: function get() {
				return this.__isSmooth;
			},
			set: function set(value) {
				if (this.__isSmooth !== value) {
					this.rootElement.classList.toggle('lenis-smooth', value);
					this.__isSmooth = value;
				}
			}
		}, {
			key: "isScrolling",
			get: function get() {
				return this.__isScrolling;
			},
			set: function set(value) {
				if (this.__isScrolling !== value) {
					this.rootElement.classList.toggle('lenis-scrolling', value);
					this.__isScrolling = value;
				}
			}
		}, {
			key: "isStopped",
			get: function get() {
				return this.__isStopped;
			},
			set: function set(value) {
				if (this.__isStopped !== value) {
					this.rootElement.classList.toggle('lenis-stopped', value);
					this.__isStopped = value;
				}
			}
		}]);
		return Lenis;
	}();
	return Lenis;
}));
(function(global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(global = global || self, factory(global.window = global.window || {}));
}(this, (function(exports) {
	'use strict';

	function _inheritsLoose(subClass, superClass) {
		subClass.prototype = Object.create(superClass.prototype);
		subClass.prototype.constructor = subClass;
		subClass.__proto__ = superClass;
	}

	function _assertThisInitialized(self) {
		if (self === void 0) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}
		return self;
	}
	/*!

	 * GSAP 3.11.5

	 * https://greensock.com

	 *

	 * @license Copyright 2008-2023, GreenSock. All rights reserved.

	 * Subject to the terms at https://greensock.com/standard-license or for

	 * Club GreenSock members, the agreement issued with that membership.

	 * @author: Jack Doyle, jack@greensock.com

	*/
	var _config = {
			autoSleep: 120,
			force3D: "auto",
			nullTargetWarn: 1,
			units: {
				lineHeight: ""
			}
		},
		_defaults = {
			duration: .5,
			overwrite: false,
			delay: 0
		},
		_suppressOverwrites,
		_reverting,
		_context,
		_bigNum = 1e8,
		_tinyNum = 1 / _bigNum,
		_2PI = Math.PI * 2,
		_HALF_PI = _2PI / 4,
		_gsID = 0,
		_sqrt = Math.sqrt,
		_cos = Math.cos,
		_sin = Math.sin,
		_isString = function _isString(value) {
			return typeof value === "string";
		},
		_isFunction = function _isFunction(value) {
			return typeof value === "function";
		},
		_isNumber = function _isNumber(value) {
			return typeof value === "number";
		},
		_isUndefined = function _isUndefined(value) {
			return typeof value === "undefined";
		},
		_isObject = function _isObject(value) {
			return typeof value === "object";
		},
		_isNotFalse = function _isNotFalse(value) {
			return value !== false;
		},
		_windowExists = function _windowExists() {
			return typeof window !== "undefined";
		},
		_isFuncOrString = function _isFuncOrString(value) {
			return _isFunction(value) || _isString(value);
		},
		_isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {},
		_isArray = Array.isArray,
		_strictNumExp = /(?:-?\.?\d|\.)+/gi,
		_numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
		_numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
		_complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
		_relExp = /[+-]=-?[.\d]+/,
		_delimitedValueExp = /[^,'"\[\]\s]+/gi,
		_unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
		_globalTimeline,
		_win,
		_coreInitted,
		_doc,
		_globals = {},
		_installScope = {},
		_coreReady,
		_install = function _install(scope) {
			return (_installScope = _merge(scope, _globals)) && gsap;
		},
		_missingPlugin = function _missingPlugin(property, value) {
			return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
		},
		_warn = function _warn(message, suppress) {
			return !suppress && console.warn(message);
		},
		_addGlobal = function _addGlobal(name, obj) {
			return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
		},
		_emptyFunc = function _emptyFunc() {
			return 0;
		},
		_startAtRevertConfig = {
			suppressEvents: true,
			isStart: true,
			kill: false
		},
		_revertConfigNoKill = {
			suppressEvents: true,
			kill: false
		},
		_revertConfig = {
			suppressEvents: true
		},
		_reservedProps = {},
		_lazyTweens = [],
		_lazyLookup = {},
		_lastRenderedFrame,
		_plugins = {},
		_effects = {},
		_nextGCFrame = 30,
		_harnessPlugins = [],
		_callbackNames = "",
		_harness = function _harness(targets) {
			var target = targets[0],
				harnessPlugin,
				i;
			_isObject(target) || _isFunction(target) || (targets = [targets]);
			if (!(harnessPlugin = (target._gsap || {}).harness)) {
				i = _harnessPlugins.length;
				while (i-- && !_harnessPlugins[i].targetTest(target)) {}
				harnessPlugin = _harnessPlugins[i];
			}
			i = targets.length;
			while (i--) {
				targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
			}
			return targets;
		},
		_getCache = function _getCache(target) {
			return target._gsap || _harness(toArray(target))[0]._gsap;
		},
		_getProperty = function _getProperty(target, property, v) {
			return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
		},
		_forEachName = function _forEachName(names, func) {
			return (names = names.split(",")).forEach(func) || names;
		},
		_round = function _round(value) {
			return Math.round(value * 100000) / 100000 || 0;
		},
		_roundPrecise = function _roundPrecise(value) {
			return Math.round(value * 10000000) / 10000000 || 0;
		},
		_parseRelative = function _parseRelative(start, value) {
			var operator = value.charAt(0),
				end = parseFloat(value.substr(2));
			start = parseFloat(start);
			return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
		},
		_arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
			var l = toFind.length,
				i = 0;
			for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}
			return i < l;
		},
		_lazyRender = function _lazyRender() {
			var l = _lazyTweens.length,
				a = _lazyTweens.slice(0),
				i,
				tween;
			_lazyLookup = {};
			_lazyTweens.length = 0;
			for (i = 0; i < l; i++) {
				tween = a[i];
				tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
			}
		},
		_lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
			_lazyTweens.length && !_reverting && _lazyRender();
			animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));
			_lazyTweens.length && !_reverting && _lazyRender();
		},
		_numericIfPossible = function _numericIfPossible(value) {
			var n = parseFloat(value);
			return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
		},
		_passThrough = function _passThrough(p) {
			return p;
		},
		_setDefaults = function _setDefaults(obj, defaults) {
			for (var p in defaults) {
				p in obj || (obj[p] = defaults[p]);
			}
			return obj;
		},
		_setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
			return function(obj, defaults) {
				for (var p in defaults) {
					p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
				}
			};
		},
		_merge = function _merge(base, toMerge) {
			for (var p in toMerge) {
				base[p] = toMerge[p];
			}
			return base;
		},
		_mergeDeep = function _mergeDeep(base, toMerge) {
			for (var p in toMerge) {
				p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
			}
			return base;
		},
		_copyExcluding = function _copyExcluding(obj, excluding) {
			var copy = {},
				p;
			for (p in obj) {
				p in excluding || (copy[p] = obj[p]);
			}
			return copy;
		},
		_inheritDefaults = function _inheritDefaults(vars) {
			var parent = vars.parent || _globalTimeline,
				func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
			if (_isNotFalse(vars.inherit)) {
				while (parent) {
					func(vars, parent.vars.defaults);
					parent = parent.parent || parent._dp;
				}
			}
			return vars;
		},
		_arraysMatch = function _arraysMatch(a1, a2) {
			var i = a1.length,
				match = i === a2.length;
			while (match && i-- && a1[i] === a2[i]) {}
			return i < 0;
		},
		_addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
			if (firstProp === void 0) {
				firstProp = "_first";
			}
			if (lastProp === void 0) {
				lastProp = "_last";
			}
			var prev = parent[lastProp],
				t;
			if (sortBy) {
				t = child[sortBy];
				while (prev && prev[sortBy] > t) {
					prev = prev._prev;
				}
			}
			if (prev) {
				child._next = prev._next;
				prev._next = child;
			} else {
				child._next = parent[firstProp];
				parent[firstProp] = child;
			}
			if (child._next) {
				child._next._prev = child;
			} else {
				parent[lastProp] = child;
			}
			child._prev = prev;
			child.parent = child._dp = parent;
			return child;
		},
		_removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
			if (firstProp === void 0) {
				firstProp = "_first";
			}
			if (lastProp === void 0) {
				lastProp = "_last";
			}
			var prev = child._prev,
				next = child._next;
			if (prev) {
				prev._next = next;
			} else if (parent[firstProp] === child) {
				parent[firstProp] = next;
			}
			if (next) {
				next._prev = prev;
			} else if (parent[lastProp] === child) {
				parent[lastProp] = prev;
			}
			child._next = child._prev = child.parent = null;
		},
		_removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
			child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
			child._act = 0;
		},
		_uncache = function _uncache(animation, child) {
			if (animation && (!child || child._end > animation._dur || child._start < 0)) {
				var a = animation;
				while (a) {
					a._dirty = 1;
					a = a.parent;
				}
			}
			return animation;
		},
		_recacheAncestors = function _recacheAncestors(animation) {
			var parent = animation.parent;
			while (parent && parent.parent) {
				parent._dirty = 1;
				parent.totalDuration();
				parent = parent.parent;
			}
			return animation;
		},
		_rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {
			return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
		},
		_hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
			return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
		},
		_elapsedCycleDuration = function _elapsedCycleDuration(animation) {
			return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
		},
		_animationCycle = function _animationCycle(tTime, cycleDuration) {
			var whole = Math.floor(tTime /= cycleDuration);
			return tTime && whole === tTime ? whole - 1 : whole;
		},
		_parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
			return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
		},
		_setEnd = function _setEnd(animation) {
			return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
		},
		_alignPlayhead = function _alignPlayhead(animation, totalTime) {
			var parent = animation._dp;
			if (parent && parent.smoothChildTiming && animation._ts) {
				animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
				_setEnd(animation);
				parent._dirty || _uncache(parent, animation);
			}
			return animation;
		},
		_postAddChecks = function _postAddChecks(timeline, child) {
			var t;
			if (child._time || child._initted && !child._dur) {
				t = _parentToChildTotalTime(timeline.rawTime(), child);
				if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
					child.render(t, true);
				}
			}
			if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
				if (timeline._dur < timeline.duration()) {
					t = timeline;
					while (t._dp) {
						t.rawTime() >= 0 && t.totalTime(t._tTime);
						t = t._dp;
					}
				}
				timeline._zTime = -_tinyNum;
			}
		},
		_addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
			child.parent && _removeFromParent(child);
			child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
			child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
			_addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);
			_isFromOrFromStart(child) || (timeline._recent = child);
			skipChecks || _postAddChecks(timeline, child);
			timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime);
			return timeline;
		},
		_scrollTrigger = function _scrollTrigger(animation, trigger) {
			return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
		},
		_attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {
			_initTween(tween, time, tTime);
			if (!tween._initted) {
				return 1;
			}
			if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
				_lazyTweens.push(tween);
				tween._lazy = [tTime, suppressEvents];
				return 1;
			}
		},
		_parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
			var parent = _ref.parent;
			return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
		},
		_isFromOrFromStart = function _isFromOrFromStart(_ref2) {
			var data = _ref2.data;
			return data === "isFromStart" || data === "isStart";
		},
		_renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
			var prevRatio = tween.ratio,
				ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
				repeatDelay = tween._rDelay,
				tTime = 0,
				pt,
				iteration,
				prevIteration;
			if (repeatDelay && tween._repeat) {
				tTime = _clamp(0, tween._tDur, totalTime);
				iteration = _animationCycle(tTime, repeatDelay);
				tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
				if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
					prevRatio = 1 - ratio;
					tween.vars.repeatRefresh && tween._initted && tween.invalidate();
				}
			}
			if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
				if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
					return;
				}
				prevIteration = tween._zTime;
				tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
				suppressEvents || (suppressEvents = totalTime && !prevIteration);
				tween.ratio = ratio;
				tween._from && (ratio = 1 - ratio);
				tween._time = 0;
				tween._tTime = tTime;
				pt = tween._pt;
				while (pt) {
					pt.r(ratio, pt.d);
					pt = pt._next;
				}
				totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
				tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
				tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
				if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
					ratio && _removeFromParent(tween, 1);
					if (!suppressEvents && !_reverting) {
						_callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
						tween._prom && tween._prom();
					}
				}
			} else if (!tween._zTime) {
				tween._zTime = totalTime;
			}
		},
		_findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
			var child;
			if (time > prevTime) {
				child = animation._first;
				while (child && child._start <= time) {
					if (child.data === "isPause" && child._start > prevTime) {
						return child;
					}
					child = child._next;
				}
			} else {
				child = animation._last;
				while (child && child._start >= time) {
					if (child.data === "isPause" && child._start < prevTime) {
						return child;
					}
					child = child._prev;
				}
			}
		},
		_setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
			var repeat = animation._repeat,
				dur = _roundPrecise(duration) || 0,
				totalProgress = animation._tTime / animation._tDur;
			totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
			animation._dur = dur;
			animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
			totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
			animation.parent && _setEnd(animation);
			skipUncache || _uncache(animation.parent, animation);
			return animation;
		},
		_onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
			return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
		},
		_zeroPosition = {
			_start: 0,
			endTime: _emptyFunc,
			totalDuration: _emptyFunc
		},
		_parsePosition = function _parsePosition(animation, position, percentAnimation) {
			var labels = animation.labels,
				recent = animation._recent || _zeroPosition,
				clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
				i,
				offset,
				isPercent;
			if (_isString(position) && (isNaN(position) || position in labels)) {
				offset = position.charAt(0);
				isPercent = position.substr(-1) === "%";
				i = position.indexOf("=");
				if (offset === "<" || offset === ">") {
					i >= 0 && (position = position.replace(/=/, ""));
					return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
				}
				if (i < 0) {
					position in labels || (labels[position] = clippedDuration);
					return labels[position];
				}
				offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
				if (isPercent && percentAnimation) {
					offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
				}
				return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
			}
			return position == null ? clippedDuration : +position;
		},
		_createTweenType = function _createTweenType(type, params, timeline) {
			var isLegacy = _isNumber(params[1]),
				varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
				vars = params[varsIndex],
				irVars,
				parent;
			isLegacy && (vars.duration = params[1]);
			vars.parent = timeline;
			if (type) {
				irVars = vars;
				parent = timeline;
				while (parent && !("immediateRender" in irVars)) {
					irVars = parent.vars.defaults || {};
					parent = _isNotFalse(parent.vars.inherit) && parent.parent;
				}
				vars.immediateRender = _isNotFalse(irVars.immediateRender);
				type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
			}
			return new Tween(params[0], vars, params[varsIndex + 1]);
		},
		_conditionalReturn = function _conditionalReturn(value, func) {
			return value || value === 0 ? func(value) : func;
		},
		_clamp = function _clamp(min, max, value) {
			return value < min ? min : value > max ? max : value;
		},
		getUnit = function getUnit(value, v) {
			return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
		},
		clamp = function clamp(min, max, value) {
			return _conditionalReturn(value, function(v) {
				return _clamp(min, max, v);
			});
		},
		_slice = [].slice,
		_isArrayLike = function _isArrayLike(value, nonEmpty) {
			return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
		},
		_flatten = function _flatten(ar, leaveStrings, accumulator) {
			if (accumulator === void 0) {
				accumulator = [];
			}
			return ar.forEach(function(value) {
				var _accumulator;
				return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
			}) || accumulator;
		},
		toArray = function toArray(value, scope, leaveStrings) {
			return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
		},
		selector = function selector(value) {
			value = toArray(value)[0] || _warn("Invalid scope") || {};
			return function(v) {
				var el = value.current || value.nativeElement || value;
				return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
			};
		},
		shuffle = function shuffle(a) {
			return a.sort(function() {
				return .5 - Math.random();
			});
		},
		distribute = function distribute(v) {
			if (_isFunction(v)) {
				return v;
			}
			var vars = _isObject(v) ? v : {
					each: v
				},
				ease = _parseEase(vars.ease),
				from = vars.from || 0,
				base = parseFloat(vars.base) || 0,
				cache = {},
				isDecimal = from > 0 && from < 1,
				ratios = isNaN(from) || isDecimal,
				axis = vars.axis,
				ratioX = from,
				ratioY = from;
			if (_isString(from)) {
				ratioX = ratioY = {
					center: .5,
					edges: .5,
					end: 1
				} [from] || 0;
			} else if (!isDecimal && ratios) {
				ratioX = from[0];
				ratioY = from[1];
			}
			return function(i, target, a) {
				var l = (a || vars).length,
					distances = cache[l],
					originX,
					originY,
					x,
					y,
					d,
					j,
					max,
					min,
					wrapAt;
				if (!distances) {
					wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
					if (!wrapAt) {
						max = -_bigNum;
						while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}
						wrapAt--;
					}
					distances = cache[l] = [];
					originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
					originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
					max = 0;
					min = _bigNum;
					for (j = 0; j < l; j++) {
						x = j % wrapAt - originX;
						y = originY - (j / wrapAt | 0);
						distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
						d > max && (max = d);
						d < min && (min = d);
					}
					from === "random" && shuffle(distances);
					distances.max = max - min;
					distances.min = min;
					distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
					distances.b = l < 0 ? base - l : base;
					distances.u = getUnit(vars.amount || vars.each) || 0;
					ease = ease && l < 0 ? _invertEase(ease) : ease;
				}
				l = (distances[i] - distances.min) / distances.max || 0;
				return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u;
			};
		},
		_roundModifier = function _roundModifier(v) {
			var p = Math.pow(10, ((v + "").split(".")[1] || "").length);
			return function(raw) {
				var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);
				return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw));
			};
		},
		snap = function snap(snapTo, value) {
			var isArray = _isArray(snapTo),
				radius,
				is2D;
			if (!isArray && _isObject(snapTo)) {
				radius = isArray = snapTo.radius || _bigNum;
				if (snapTo.values) {
					snapTo = toArray(snapTo.values);
					if (is2D = !_isNumber(snapTo[0])) {
						radius *= radius;
					}
				} else {
					snapTo = _roundModifier(snapTo.increment);
				}
			}
			return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
				is2D = snapTo(raw);
				return Math.abs(is2D - raw) <= radius ? is2D : raw;
			} : function(raw) {
				var x = parseFloat(is2D ? raw.x : raw),
					y = parseFloat(is2D ? raw.y : 0),
					min = _bigNum,
					closest = 0,
					i = snapTo.length,
					dx,
					dy;
				while (i--) {
					if (is2D) {
						dx = snapTo[i].x - x;
						dy = snapTo[i].y - y;
						dx = dx * dx + dy * dy;
					} else {
						dx = Math.abs(snapTo[i] - x);
					}
					if (dx < min) {
						min = dx;
						closest = i;
					}
				}
				closest = !radius || min <= radius ? snapTo[closest] : raw;
				return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
			});
		},
		random = function random(min, max, roundingIncrement, returnFunction) {
			return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
				return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
			});
		},
		pipe = function pipe() {
			for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
				functions[_key] = arguments[_key];
			}
			return function(value) {
				return functions.reduce(function(v, f) {
					return f(v);
				}, value);
			};
		},
		unitize = function unitize(func, unit) {
			return function(value) {
				return func(parseFloat(value)) + (unit || getUnit(value));
			};
		},
		normalize = function normalize(min, max, value) {
			return mapRange(min, max, 0, 1, value);
		},
		_wrapArray = function _wrapArray(a, wrapper, value) {
			return _conditionalReturn(value, function(index) {
				return a[~~wrapper(index)];
			});
		},
		wrap = function wrap(min, max, value) {
			var range = max - min;
			return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function(value) {
				return (range + (value - min) % range) % range + min;
			});
		},
		wrapYoyo = function wrapYoyo(min, max, value) {
			var range = max - min,
				total = range * 2;
			return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function(value) {
				value = (total + (value - min) % total) % total || 0;
				return min + (value > range ? total - value : value);
			});
		},
		_replaceRandom = function _replaceRandom(value) {
			var prev = 0,
				s = "",
				i,
				nums,
				end,
				isArray;
			while (~(i = value.indexOf("random(", prev))) {
				end = value.indexOf(")", i);
				isArray = value.charAt(i + 7) === "[";
				nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
				s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
				prev = end + 1;
			}
			return s + value.substr(prev, value.length - prev);
		},
		mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
			var inRange = inMax - inMin,
				outRange = outMax - outMin;
			return _conditionalReturn(value, function(value) {
				return outMin + ((value - inMin) / inRange * outRange || 0);
			});
		},
		interpolate = function interpolate(start, end, progress, mutate) {
			var func = isNaN(start + end) ? 0 : function(p) {
				return (1 - p) * start + p * end;
			};
			if (!func) {
				var isString = _isString(start),
					master = {},
					p,
					i,
					interpolators,
					l,
					il;
				progress === true && (mutate = 1) && (progress = null);
				if (isString) {
					start = {
						p: start
					};
					end = {
						p: end
					};
				} else if (_isArray(start) && !_isArray(end)) {
					interpolators = [];
					l = start.length;
					il = l - 2;
					for (i = 1; i < l; i++) {
						interpolators.push(interpolate(start[i - 1], start[i]));
					}
					l--;
					func = function func(p) {
						p *= l;
						var i = Math.min(il, ~~p);
						return interpolators[i](p - i);
					};
					progress = end;
				} else if (!mutate) {
					start = _merge(_isArray(start) ? [] : {}, start);
				}
				if (!interpolators) {
					for (p in end) {
						_addPropTween.call(master, start, p, "get", end[p]);
					}
					func = function func(p) {
						return _renderPropTweens(p, master) || (isString ? start.p : start);
					};
				}
			}
			return _conditionalReturn(progress, func);
		},
		_getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
			var labels = timeline.labels,
				min = _bigNum,
				p,
				distance,
				label;
			for (p in labels) {
				distance = labels[p] - fromTime;
				if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
					label = p;
					min = distance;
				}
			}
			return label;
		},
		_callback = function _callback(animation, type, executeLazyFirst) {
			var v = animation.vars,
				callback = v[type],
				prevContext = _context,
				context = animation._ctx,
				params,
				scope,
				result;
			if (!callback) {
				return;
			}
			params = v[type + "Params"];
			scope = v.callbackScope || animation;
			executeLazyFirst && _lazyTweens.length && _lazyRender();
			context && (_context = context);
			result = params ? callback.apply(scope, params) : callback.call(scope);
			_context = prevContext;
			return result;
		},
		_interrupt = function _interrupt(animation) {
			_removeFromParent(animation);
			animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
			animation.progress() < 1 && _callback(animation, "onInterrupt");
			return animation;
		},
		_quickTween,
		_registerPluginQueue = [],
		_createPlugin = function _createPlugin(config) {
			if (!_windowExists()) {
				_registerPluginQueue.push(config);
				return;
			}
			config = !config.name && config["default"] || config;
			var name = config.name,
				isFunc = _isFunction(config),
				Plugin = name && !isFunc && config.init ? function() {
					this._props = [];
				} : config,
				instanceDefaults = {
					init: _emptyFunc,
					render: _renderPropTweens,
					add: _addPropTween,
					kill: _killPropTweensOf,
					modifier: _addPluginModifier,
					rawVars: 0
				},
				statics = {
					targetTest: 0,
					get: 0,
					getSetter: _getSetter,
					aliases: {},
					register: 0
				};
			_wake();
			if (config !== Plugin) {
				if (_plugins[name]) {
					return;
				}
				_setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics));
				_merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics)));
				_plugins[Plugin.prop = name] = Plugin;
				if (config.targetTest) {
					_harnessPlugins.push(Plugin);
					_reservedProps[name] = 1;
				}
				name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
			}
			_addGlobal(name, Plugin);
			config.register && config.register(gsap, Plugin, PropTween);
		},
		_255 = 255,
		_colorLookup = {
			aqua: [0, _255, _255],
			lime: [0, _255, 0],
			silver: [192, 192, 192],
			black: [0, 0, 0],
			maroon: [128, 0, 0],
			teal: [0, 128, 128],
			blue: [0, 0, _255],
			navy: [0, 0, 128],
			white: [_255, _255, _255],
			olive: [128, 128, 0],
			yellow: [_255, _255, 0],
			orange: [_255, 165, 0],
			gray: [128, 128, 128],
			purple: [128, 0, 128],
			green: [0, 128, 0],
			red: [_255, 0, 0],
			pink: [_255, 192, 203],
			cyan: [0, _255, _255],
			transparent: [_255, _255, _255, 0]
		},
		_hue = function _hue(h, m1, m2) {
			h += h < 0 ? 1 : h > 1 ? -1 : 0;
			return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
		},
		splitColor = function splitColor(v, toHSL, forceAlpha) {
			var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
				r,
				g,
				b,
				h,
				s,
				l,
				max,
				min,
				d,
				wasHSL;
			if (!a) {
				if (v.substr(-1) === ",") {
					v = v.substr(0, v.length - 1);
				}
				if (_colorLookup[v]) {
					a = _colorLookup[v];
				} else if (v.charAt(0) === "#") {
					if (v.length < 6) {
						r = v.charAt(1);
						g = v.charAt(2);
						b = v.charAt(3);
						v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
					}
					if (v.length === 9) {
						a = parseInt(v.substr(1, 6), 16);
						return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
					}
					v = parseInt(v.substr(1), 16);
					a = [v >> 16, v >> 8 & _255, v & _255];
				} else if (v.substr(0, 3) === "hsl") {
					a = wasHSL = v.match(_strictNumExp);
					if (!toHSL) {
						h = +a[0] % 360 / 360;
						s = +a[1] / 100;
						l = +a[2] / 100;
						g = l <= .5 ? l * (s + 1) : l + s - l * s;
						r = l * 2 - g;
						a.length > 3 && (a[3] *= 1);
						a[0] = _hue(h + 1 / 3, r, g);
						a[1] = _hue(h, r, g);
						a[2] = _hue(h - 1 / 3, r, g);
					} else if (~v.indexOf("=")) {
						a = v.match(_numExp);
						forceAlpha && a.length < 4 && (a[3] = 1);
						return a;
					}
				} else {
					a = v.match(_strictNumExp) || _colorLookup.transparent;
				}
				a = a.map(Number);
			}
			if (toHSL && !wasHSL) {
				r = a[0] / _255;
				g = a[1] / _255;
				b = a[2] / _255;
				max = Math.max(r, g, b);
				min = Math.min(r, g, b);
				l = (max + min) / 2;
				if (max === min) {
					h = s = 0;
				} else {
					d = max - min;
					s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
					h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
					h *= 60;
				}
				a[0] = ~~(h + .5);
				a[1] = ~~(s * 100 + .5);
				a[2] = ~~(l * 100 + .5);
			}
			forceAlpha && a.length < 4 && (a[3] = 1);
			return a;
		},
		_colorOrderData = function _colorOrderData(v) {
			var values = [],
				c = [],
				i = -1;
			v.split(_colorExp).forEach(function(v) {
				var a = v.match(_numWithUnitExp) || [];
				values.push.apply(values, a);
				c.push(i += a.length + 1);
			});
			values.c = c;
			return values;
		},
		_formatColors = function _formatColors(s, toHSL, orderMatchData) {
			var result = "",
				colors = (s + result).match(_colorExp),
				type = toHSL ? "hsla(" : "rgba(",
				i = 0,
				c,
				shell,
				d,
				l;
			if (!colors) {
				return s;
			}
			colors = colors.map(function(color) {
				return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
			});
			if (orderMatchData) {
				d = _colorOrderData(s);
				c = orderMatchData.c;
				if (c.join(result) !== d.c.join(result)) {
					shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
					l = shell.length - 1;
					for (; i < l; i++) {
						result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
					}
				}
			}
			if (!shell) {
				shell = s.split(_colorExp);
				l = shell.length - 1;
				for (; i < l; i++) {
					result += shell[i] + colors[i];
				}
			}
			return result + shell[l];
		},
		_colorExp = function() {
			var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
				p;
			for (p in _colorLookup) {
				s += "|" + p + "\\b";
			}
			return new RegExp(s + ")", "gi");
		}(),
		_hslExp = /hsl[a]?\(/,
		_colorStringFilter = function _colorStringFilter(a) {
			var combined = a.join(" "),
				toHSL;
			_colorExp.lastIndex = 0;
			if (_colorExp.test(combined)) {
				toHSL = _hslExp.test(combined);
				a[1] = _formatColors(a[1], toHSL);
				a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
				return true;
			}
		},
		_tickerActive,
		_ticker = function() {
			var _getTime = Date.now,
				_lagThreshold = 500,
				_adjustedLag = 33,
				_startTime = _getTime(),
				_lastUpdate = _startTime,
				_gap = 1000 / 240,
				_nextTime = _gap,
				_listeners = [],
				_id,
				_req,
				_raf,
				_self,
				_delta,
				_i,
				_tick = function _tick(v) {
					var elapsed = _getTime() - _lastUpdate,
						manual = v === true,
						overlap,
						dispatch,
						time,
						frame;
					elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
					_lastUpdate += elapsed;
					time = _lastUpdate - _startTime;
					overlap = time - _nextTime;
					if (overlap > 0 || manual) {
						frame = ++_self.frame;
						_delta = time - _self.time * 1000;
						_self.time = time = time / 1000;
						_nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
						dispatch = 1;
					}
					manual || (_id = _req(_tick));
					if (dispatch) {
						for (_i = 0; _i < _listeners.length; _i++) {
							_listeners[_i](time, _delta, frame, v);
						}
					}
				};
			_self = {
				time: 0,
				frame: 0,
				tick: function tick() {
					_tick(true);
				},
				deltaRatio: function deltaRatio(fps) {
					return _delta / (1000 / (fps || 60));
				},
				wake: function wake() {
					if (_coreReady) {
						if (!_coreInitted && _windowExists()) {
							_win = _coreInitted = window;
							_doc = _win.document || {};
							_globals.gsap = gsap;
							(_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
							_install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
							_raf = _win.requestAnimationFrame;
							_registerPluginQueue.forEach(_createPlugin);
						}
						_id && _self.sleep();
						_req = _raf || function(f) {
							return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
						};
						_tickerActive = 1;
						_tick(2);
					}
				},
				sleep: function sleep() {
					(_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
					_tickerActive = 0;
					_req = _emptyFunc;
				},
				lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
					_lagThreshold = threshold || Infinity;
					_adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
				},
				fps: function fps(_fps) {
					_gap = 1000 / (_fps || 240);
					_nextTime = _self.time * 1000 + _gap;
				},
				add: function add(callback, once, prioritize) {
					var func = once ? function(t, d, f, v) {
						callback(t, d, f, v);
						_self.remove(func);
					} : callback;
					_self.remove(callback);
					_listeners[prioritize ? "unshift" : "push"](func);
					_wake();
					return func;
				},
				remove: function remove(callback, i) {
					~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
				},
				_listeners: _listeners
			};
			return _self;
		}(),
		_wake = function _wake() {
			return !_tickerActive && _ticker.wake();
		},
		_easeMap = {},
		_customEaseExp = /^[\d.\-M][\d.\-,\s]/,
		_quotesExp = /["']/g,
		_parseObjectInString = function _parseObjectInString(value) {
			var obj = {},
				split = value.substr(1, value.length - 3).split(":"),
				key = split[0],
				i = 1,
				l = split.length,
				index,
				val,
				parsedVal;
			for (; i < l; i++) {
				val = split[i];
				index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
				parsedVal = val.substr(0, index);
				obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
				key = val.substr(index + 1).trim();
			}
			return obj;
		},
		_valueInParentheses = function _valueInParentheses(value) {
			var open = value.indexOf("(") + 1,
				close = value.indexOf(")"),
				nested = value.indexOf("(", open);
			return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
		},
		_configEaseFromString = function _configEaseFromString(name) {
			var split = (name + "").split("("),
				ease = _easeMap[split[0]];
			return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
		},
		_invertEase = function _invertEase(ease) {
			return function(p) {
				return 1 - ease(1 - p);
			};
		},
		_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
			var child = timeline._first,
				ease;
			while (child) {
				if (child instanceof Timeline) {
					_propagateYoyoEase(child, isYoyo);
				} else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
					if (child.timeline) {
						_propagateYoyoEase(child.timeline, isYoyo);
					} else {
						ease = child._ease;
						child._ease = child._yEase;
						child._yEase = ease;
						child._yoyo = isYoyo;
					}
				}
				child = child._next;
			}
		},
		_parseEase = function _parseEase(ease, defaultEase) {
			return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
		},
		_insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
			if (easeOut === void 0) {
				easeOut = function easeOut(p) {
					return 1 - easeIn(1 - p);
				};
			}
			if (easeInOut === void 0) {
				easeInOut = function easeInOut(p) {
					return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
				};
			}
			var ease = {
					easeIn: easeIn,
					easeOut: easeOut,
					easeInOut: easeInOut
				},
				lowercaseName;
			_forEachName(names, function(name) {
				_easeMap[name] = _globals[name] = ease;
				_easeMap[lowercaseName = name.toLowerCase()] = easeOut;
				for (var p in ease) {
					_easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
				}
			});
			return ease;
		},
		_easeInOutFromOut = function _easeInOutFromOut(easeOut) {
			return function(p) {
				return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
			};
		},
		_configElastic = function _configElastic(type, amplitude, period) {
			var p1 = amplitude >= 1 ? amplitude : 1,
				p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
				p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
				easeOut = function easeOut(p) {
					return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
				},
				ease = type === "out" ? easeOut : type === "in" ? function(p) {
					return 1 - easeOut(1 - p);
				} : _easeInOutFromOut(easeOut);
			p2 = _2PI / p2;
			ease.config = function(amplitude, period) {
				return _configElastic(type, amplitude, period);
			};
			return ease;
		},
		_configBack = function _configBack(type, overshoot) {
			if (overshoot === void 0) {
				overshoot = 1.70158;
			}
			var easeOut = function easeOut(p) {
					return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
				},
				ease = type === "out" ? easeOut : type === "in" ? function(p) {
					return 1 - easeOut(1 - p);
				} : _easeInOutFromOut(easeOut);
			ease.config = function(overshoot) {
				return _configBack(type, overshoot);
			};
			return ease;
		};
	_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i) {
		var power = i < 5 ? i + 1 : i;
		_insertEase(name + ",Power" + (power - 1), i ? function(p) {
			return Math.pow(p, power);
		} : function(p) {
			return p;
		}, function(p) {
			return 1 - Math.pow(1 - p, power);
		}, function(p) {
			return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
		});
	});
	_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
	_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
	(function(n, c) {
		var n1 = 1 / c,
			n2 = 2 * n1,
			n3 = 2.5 * n1,
			easeOut = function easeOut(p) {
				return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
			};
		_insertEase("Bounce", function(p) {
			return 1 - easeOut(1 - p);
		}, easeOut);
	})(7.5625, 2.75);
	_insertEase("Expo", function(p) {
		return p ? Math.pow(2, 10 * (p - 1)) : 0;
	});
	_insertEase("Circ", function(p) {
		return -(_sqrt(1 - p * p) - 1);
	});
	_insertEase("Sine", function(p) {
		return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
	});
	_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
	_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
		config: function config(steps, immediateStart) {
			if (steps === void 0) {
				steps = 1;
			}
			var p1 = 1 / steps,
				p2 = steps + (immediateStart ? 0 : 1),
				p3 = immediateStart ? 1 : 0,
				max = 1 - _tinyNum;
			return function(p) {
				return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
			};
		}
	};
	_defaults.ease = _easeMap["quad.out"];
	_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
		return _callbackNames += name + "," + name + "Params,";
	});
	var GSCache = function GSCache(target, harness) {
		this.id = _gsID++;
		target._gsap = this;
		this.target = target;
		this.harness = harness;
		this.get = harness ? harness.get : _getProperty;
		this.set = harness ? harness.getSetter : _getSetter;
	};
	var Animation = function() {
		function Animation(vars) {
			this.vars = vars;
			this._delay = +vars.delay || 0;
			if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
				this._rDelay = vars.repeatDelay || 0;
				this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
			}
			this._ts = 1;
			_setDuration(this, +vars.duration, 1, 1);
			this.data = vars.data;
			if (_context) {
				this._ctx = _context;
				_context.data.push(this);
			}
			_tickerActive || _ticker.wake();
		}
		var _proto = Animation.prototype;
		_proto.delay = function delay(value) {
			if (value || value === 0) {
				this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
				this._delay = value;
				return this;
			}
			return this._delay;
		};
		_proto.duration = function duration(value) {
			return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
		};
		_proto.totalDuration = function totalDuration(value) {
			if (!arguments.length) {
				return this._tDur;
			}
			this._dirty = 0;
			return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
		};
		_proto.totalTime = function totalTime(_totalTime, suppressEvents) {
			_wake();
			if (!arguments.length) {
				return this._tTime;
			}
			var parent = this._dp;
			if (parent && parent.smoothChildTiming && this._ts) {
				_alignPlayhead(this, _totalTime);
				!parent._dp || parent.parent || _postAddChecks(parent, this);
				while (parent && parent.parent) {
					if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
						parent.totalTime(parent._tTime, true);
					}
					parent = parent.parent;
				}
				if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
					_addToTimeline(this._dp, this, this._start - this._delay);
				}
			}
			if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
				this._ts || (this._pTime = _totalTime);
				_lazySafeRender(this, _totalTime, suppressEvents);
			}
			return this;
		};
		_proto.time = function time(value, suppressEvents) {
			return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
		};
		_proto.totalProgress = function totalProgress(value, suppressEvents) {
			return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
		};
		_proto.progress = function progress(value, suppressEvents) {
			return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
		};
		_proto.iteration = function iteration(value, suppressEvents) {
			var cycleDuration = this.duration() + this._rDelay;
			return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
		};
		_proto.timeScale = function timeScale(value) {
			if (!arguments.length) {
				return this._rts === -_tinyNum ? 0 : this._rts;
			}
			if (this._rts === value) {
				return this;
			}
			var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
			this._rts = +value || 0;
			this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
			this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), true);
			_setEnd(this);
			return _recacheAncestors(this);
		};
		_proto.paused = function paused(value) {
			if (!arguments.length) {
				return this._ps;
			}
			if (this._ps !== value) {
				this._ps = value;
				if (value) {
					this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
					this._ts = this._act = 0;
				} else {
					_wake();
					this._ts = this._rts;
					this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
				}
			}
			return this;
		};
		_proto.startTime = function startTime(value) {
			if (arguments.length) {
				this._start = value;
				var parent = this.parent || this._dp;
				parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
				return this;
			}
			return this._start;
		};
		_proto.endTime = function endTime(includeRepeats) {
			return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
		};
		_proto.rawTime = function rawTime(wrapRepeats) {
			var parent = this.parent || this._dp;
			return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
		};
		_proto.revert = function revert(config) {
			if (config === void 0) {
				config = _revertConfig;
			}
			var prevIsReverting = _reverting;
			_reverting = config;
			if (this._initted || this._startAt) {
				this.timeline && this.timeline.revert(config);
				this.totalTime(-0.01, config.suppressEvents);
			}
			this.data !== "nested" && config.kill !== false && this.kill();
			_reverting = prevIsReverting;
			return this;
		};
		_proto.globalTime = function globalTime(rawTime) {
			var animation = this,
				time = arguments.length ? rawTime : animation.rawTime();
			while (animation) {
				time = animation._start + time / (animation._ts || 1);
				animation = animation._dp;
			}
			return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 : this._sat.globalTime(rawTime) : time;
		};
		_proto.repeat = function repeat(value) {
			if (arguments.length) {
				this._repeat = value === Infinity ? -2 : value;
				return _onUpdateTotalDuration(this);
			}
			return this._repeat === -2 ? Infinity : this._repeat;
		};
		_proto.repeatDelay = function repeatDelay(value) {
			if (arguments.length) {
				var time = this._time;
				this._rDelay = value;
				_onUpdateTotalDuration(this);
				return time ? this.time(time) : this;
			}
			return this._rDelay;
		};
		_proto.yoyo = function yoyo(value) {
			if (arguments.length) {
				this._yoyo = value;
				return this;
			}
			return this._yoyo;
		};
		_proto.seek = function seek(position, suppressEvents) {
			return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
		};
		_proto.restart = function restart(includeDelay, suppressEvents) {
			return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
		};
		_proto.play = function play(from, suppressEvents) {
			from != null && this.seek(from, suppressEvents);
			return this.reversed(false).paused(false);
		};
		_proto.reverse = function reverse(from, suppressEvents) {
			from != null && this.seek(from || this.totalDuration(), suppressEvents);
			return this.reversed(true).paused(false);
		};
		_proto.pause = function pause(atTime, suppressEvents) {
			atTime != null && this.seek(atTime, suppressEvents);
			return this.paused(true);
		};
		_proto.resume = function resume() {
			return this.paused(false);
		};
		_proto.reversed = function reversed(value) {
			if (arguments.length) {
				!!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
				return this;
			}
			return this._rts < 0;
		};
		_proto.invalidate = function invalidate() {
			this._initted = this._act = 0;
			this._zTime = -_tinyNum;
			return this;
		};
		_proto.isActive = function isActive() {
			var parent = this.parent || this._dp,
				start = this._start,
				rawTime;
			return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
		};
		_proto.eventCallback = function eventCallback(type, callback, params) {
			var vars = this.vars;
			if (arguments.length > 1) {
				if (!callback) {
					delete vars[type];
				} else {
					vars[type] = callback;
					params && (vars[type + "Params"] = params);
					type === "onUpdate" && (this._onUpdate = callback);
				}
				return this;
			}
			return vars[type];
		};
		_proto.then = function then(onFulfilled) {
			var self = this;
			return new Promise(function(resolve) {
				var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
					_resolve = function _resolve() {
						var _then = self.then;
						self.then = null;
						_isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
						resolve(f);
						self.then = _then;
					};
				if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
					_resolve();
				} else {
					self._prom = _resolve;
				}
			});
		};
		_proto.kill = function kill() {
			_interrupt(this);
		};
		return Animation;
	}();
	_setDefaults(Animation.prototype, {
		_time: 0,
		_start: 0,
		_end: 0,
		_tTime: 0,
		_tDur: 0,
		_dirty: 0,
		_repeat: 0,
		_yoyo: false,
		parent: null,
		_initted: false,
		_rDelay: 0,
		_ts: 1,
		_dp: 0,
		ratio: 0,
		_zTime: -_tinyNum,
		_prom: 0,
		_ps: false,
		_rts: 1
	});
	var Timeline = function(_Animation) {
		_inheritsLoose(Timeline, _Animation);

		function Timeline(vars, position) {
			var _this;
			if (vars === void 0) {
				vars = {};
			}
			_this = _Animation.call(this, vars) || this;
			_this.labels = {};
			_this.smoothChildTiming = !!vars.smoothChildTiming;
			_this.autoRemoveChildren = !!vars.autoRemoveChildren;
			_this._sort = _isNotFalse(vars.sortChildren);
			_globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
			vars.reversed && _this.reverse();
			vars.paused && _this.paused(true);
			vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
			return _this;
		}
		var _proto2 = Timeline.prototype;
		_proto2.to = function to(targets, vars, position) {
			_createTweenType(0, arguments, this);
			return this;
		};
		_proto2.from = function from(targets, vars, position) {
			_createTweenType(1, arguments, this);
			return this;
		};
		_proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
			_createTweenType(2, arguments, this);
			return this;
		};
		_proto2.set = function set(targets, vars, position) {
			vars.duration = 0;
			vars.parent = this;
			_inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
			vars.immediateRender = !!vars.immediateRender;
			new Tween(targets, vars, _parsePosition(this, position), 1);
			return this;
		};
		_proto2.call = function call(callback, params, position) {
			return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
		};
		_proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
			vars.duration = duration;
			vars.stagger = vars.stagger || stagger;
			vars.onComplete = onCompleteAll;
			vars.onCompleteParams = onCompleteAllParams;
			vars.parent = this;
			new Tween(targets, vars, _parsePosition(this, position));
			return this;
		};
		_proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
			vars.runBackwards = 1;
			_inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
			return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
		};
		_proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
			toVars.startAt = fromVars;
			_inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
		};
		_proto2.render = function render(totalTime, suppressEvents, force) {
			var prevTime = this._time,
				tDur = this._dirty ? this.totalDuration() : this._tDur,
				dur = this._dur,
				tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
				crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
				time,
				child,
				next,
				iteration,
				cycleDuration,
				prevPaused,
				pauseTween,
				timeScale,
				prevStart,
				prevIteration,
				yoyo,
				isYoyo;
			this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
			if (tTime !== this._tTime || force || crossingStart) {
				if (prevTime !== this._time && dur) {
					tTime += this._time - prevTime;
					totalTime += this._time - prevTime;
				}
				time = tTime;
				prevStart = this._start;
				timeScale = this._ts;
				prevPaused = !timeScale;
				if (crossingStart) {
					dur || (prevTime = this._zTime);
					(totalTime || !suppressEvents) && (this._zTime = totalTime);
				}
				if (this._repeat) {
					yoyo = this._yoyo;
					cycleDuration = dur + this._rDelay;
					if (this._repeat < -1 && totalTime < 0) {
						return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
					}
					time = _roundPrecise(tTime % cycleDuration);
					if (tTime === tDur) {
						iteration = this._repeat;
						time = dur;
					} else {
						iteration = ~~(tTime / cycleDuration);
						if (iteration && iteration === tTime / cycleDuration) {
							time = dur;
							iteration--;
						}
						time > dur && (time = dur);
					}
					prevIteration = _animationCycle(this._tTime, cycleDuration);
					!prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
					if (yoyo && iteration & 1) {
						time = dur - time;
						isYoyo = 1;
					}
					if (iteration !== prevIteration && !this._lock) {
						var rewinding = yoyo && prevIteration & 1,
							doesWrap = rewinding === (yoyo && iteration & 1);
						iteration < prevIteration && (rewinding = !rewinding);
						prevTime = rewinding ? 0 : dur;
						this._lock = 1;
						this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
						this._tTime = tTime;
						!suppressEvents && this.parent && _callback(this, "onRepeat");
						this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
						if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
							return this;
						}
						dur = this._dur;
						tDur = this._tDur;
						if (doesWrap) {
							this._lock = 2;
							prevTime = rewinding ? dur : -0.0001;
							this.render(prevTime, true);
							this.vars.repeatRefresh && !isYoyo && this.invalidate();
						}
						this._lock = 0;
						if (!this._ts && !prevPaused) {
							return this;
						}
						_propagateYoyoEase(this, isYoyo);
					}
				}
				if (this._hasPause && !this._forcing && this._lock < 2) {
					pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
					if (pauseTween) {
						tTime -= time - (time = pauseTween._start);
					}
				}
				this._tTime = tTime;
				this._time = time;
				this._act = !timeScale;
				if (!this._initted) {
					this._onUpdate = this.vars.onUpdate;
					this._initted = 1;
					this._zTime = totalTime;
					prevTime = 0;
				}
				if (!prevTime && time && !suppressEvents && !iteration) {
					_callback(this, "onStart");
					if (this._tTime !== tTime) {
						return this;
					}
				}
				if (time >= prevTime && totalTime >= 0) {
					child = this._first;
					while (child) {
						next = child._next;
						if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
							if (child.parent !== this) {
								return this.render(totalTime, suppressEvents, force);
							}
							child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
							if (time !== this._time || !this._ts && !prevPaused) {
								pauseTween = 0;
								next && (tTime += this._zTime = -_tinyNum);
								break;
							}
						}
						child = next;
					}
				} else {
					child = this._last;
					var adjustedTime = totalTime < 0 ? totalTime : time;
					while (child) {
						next = child._prev;
						if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
							if (child.parent !== this) {
								return this.render(totalTime, suppressEvents, force);
							}
							child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt));
							if (time !== this._time || !this._ts && !prevPaused) {
								pauseTween = 0;
								next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
								break;
							}
						}
						child = next;
					}
				}
				if (pauseTween && !suppressEvents) {
					this.pause();
					pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
					if (this._ts) {
						this._start = prevStart;
						_setEnd(this);
						return this.render(totalTime, suppressEvents, force);
					}
				}
				this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
				if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime)
					if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts))
						if (!this._lock) {
							(totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
							if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
								_callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
								this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
							}
						}
			}
			return this;
		};
		_proto2.add = function add(child, position) {
			var _this2 = this;
			_isNumber(position) || (position = _parsePosition(this, position, child));
			if (!(child instanceof Animation)) {
				if (_isArray(child)) {
					child.forEach(function(obj) {
						return _this2.add(obj, position);
					});
					return this;
				}
				if (_isString(child)) {
					return this.addLabel(child, position);
				}
				if (_isFunction(child)) {
					child = Tween.delayedCall(0, child);
				} else {
					return this;
				}
			}
			return this !== child ? _addToTimeline(this, child, position) : this;
		};
		_proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
			if (nested === void 0) {
				nested = true;
			}
			if (tweens === void 0) {
				tweens = true;
			}
			if (timelines === void 0) {
				timelines = true;
			}
			if (ignoreBeforeTime === void 0) {
				ignoreBeforeTime = -_bigNum;
			}
			var a = [],
				child = this._first;
			while (child) {
				if (child._start >= ignoreBeforeTime) {
					if (child instanceof Tween) {
						tweens && a.push(child);
					} else {
						timelines && a.push(child);
						nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
					}
				}
				child = child._next;
			}
			return a;
		};
		_proto2.getById = function getById(id) {
			var animations = this.getChildren(1, 1, 1),
				i = animations.length;
			while (i--) {
				if (animations[i].vars.id === id) {
					return animations[i];
				}
			}
		};
		_proto2.remove = function remove(child) {
			if (_isString(child)) {
				return this.removeLabel(child);
			}
			if (_isFunction(child)) {
				return this.killTweensOf(child);
			}
			_removeLinkedListItem(this, child);
			if (child === this._recent) {
				this._recent = this._last;
			}
			return _uncache(this);
		};
		_proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
			if (!arguments.length) {
				return this._tTime;
			}
			this._forcing = 1;
			if (!this._dp && this._ts) {
				this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
			}
			_Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
			this._forcing = 0;
			return this;
		};
		_proto2.addLabel = function addLabel(label, position) {
			this.labels[label] = _parsePosition(this, position);
			return this;
		};
		_proto2.removeLabel = function removeLabel(label) {
			delete this.labels[label];
			return this;
		};
		_proto2.addPause = function addPause(position, callback, params) {
			var t = Tween.delayedCall(0, callback || _emptyFunc, params);
			t.data = "isPause";
			this._hasPause = 1;
			return _addToTimeline(this, t, _parsePosition(this, position));
		};
		_proto2.removePause = function removePause(position) {
			var child = this._first;
			position = _parsePosition(this, position);
			while (child) {
				if (child._start === position && child.data === "isPause") {
					_removeFromParent(child);
				}
				child = child._next;
			}
		};
		_proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
			var tweens = this.getTweensOf(targets, onlyActive),
				i = tweens.length;
			while (i--) {
				_overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
			}
			return this;
		};
		_proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
			var a = [],
				parsedTargets = toArray(targets),
				child = this._first,
				isGlobalTime = _isNumber(onlyActive),
				children;
			while (child) {
				if (child instanceof Tween) {
					if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
						a.push(child);
					}
				} else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
					a.push.apply(a, children);
				}
				child = child._next;
			}
			return a;
		};
		_proto2.tweenTo = function tweenTo(position, vars) {
			vars = vars || {};
			var tl = this,
				endTime = _parsePosition(tl, position),
				_vars = vars,
				startAt = _vars.startAt,
				_onStart = _vars.onStart,
				onStartParams = _vars.onStartParams,
				immediateRender = _vars.immediateRender,
				initted,
				tween = Tween.to(tl, _setDefaults({
					ease: vars.ease || "none",
					lazy: false,
					immediateRender: false,
					time: endTime,
					overwrite: "auto",
					duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
					onStart: function onStart() {
						tl.pause();
						if (!initted) {
							var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
							tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
							initted = 1;
						}
						_onStart && _onStart.apply(tween, onStartParams || []);
					}
				}, vars));
			return immediateRender ? tween.render(0) : tween;
		};
		_proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
			return this.tweenTo(toPosition, _setDefaults({
				startAt: {
					time: _parsePosition(this, fromPosition)
				}
			}, vars));
		};
		_proto2.recent = function recent() {
			return this._recent;
		};
		_proto2.nextLabel = function nextLabel(afterTime) {
			if (afterTime === void 0) {
				afterTime = this._time;
			}
			return _getLabelInDirection(this, _parsePosition(this, afterTime));
		};
		_proto2.previousLabel = function previousLabel(beforeTime) {
			if (beforeTime === void 0) {
				beforeTime = this._time;
			}
			return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
		};
		_proto2.currentLabel = function currentLabel(value) {
			return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
		};
		_proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
			if (ignoreBeforeTime === void 0) {
				ignoreBeforeTime = 0;
			}
			var child = this._first,
				labels = this.labels,
				p;
			while (child) {
				if (child._start >= ignoreBeforeTime) {
					child._start += amount;
					child._end += amount;
				}
				child = child._next;
			}
			if (adjustLabels) {
				for (p in labels) {
					if (labels[p] >= ignoreBeforeTime) {
						labels[p] += amount;
					}
				}
			}
			return _uncache(this);
		};
		_proto2.invalidate = function invalidate(soft) {
			var child = this._first;
			this._lock = 0;
			while (child) {
				child.invalidate(soft);
				child = child._next;
			}
			return _Animation.prototype.invalidate.call(this, soft);
		};
		_proto2.clear = function clear(includeLabels) {
			if (includeLabels === void 0) {
				includeLabels = true;
			}
			var child = this._first,
				next;
			while (child) {
				next = child._next;
				this.remove(child);
				child = next;
			}
			this._dp && (this._time = this._tTime = this._pTime = 0);
			includeLabels && (this.labels = {});
			return _uncache(this);
		};
		_proto2.totalDuration = function totalDuration(value) {
			var max = 0,
				self = this,
				child = self._last,
				prevStart = _bigNum,
				prev,
				start,
				parent;
			if (arguments.length) {
				return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
			}
			if (self._dirty) {
				parent = self.parent;
				while (child) {
					prev = child._prev;
					child._dirty && child.totalDuration();
					start = child._start;
					if (start > prevStart && self._sort && child._ts && !self._lock) {
						self._lock = 1;
						_addToTimeline(self, child, start - child._delay, 1)._lock = 0;
					} else {
						prevStart = start;
					}
					if (start < 0 && child._ts) {
						max -= start;
						if (!parent && !self._dp || parent && parent.smoothChildTiming) {
							self._start += start / self._ts;
							self._time -= start;
							self._tTime -= start;
						}
						self.shiftChildren(-start, false, -1e999);
						prevStart = 0;
					}
					child._end > max && child._ts && (max = child._end);
					child = prev;
				}
				_setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);
				self._dirty = 0;
			}
			return self._tDur;
		};
		Timeline.updateRoot = function updateRoot(time) {
			if (_globalTimeline._ts) {
				_lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
				_lastRenderedFrame = _ticker.frame;
			}
			if (_ticker.frame >= _nextGCFrame) {
				_nextGCFrame += _config.autoSleep || 120;
				var child = _globalTimeline._first;
				if (!child || !child._ts)
					if (_config.autoSleep && _ticker._listeners.length < 2) {
						while (child && !child._ts) {
							child = child._next;
						}
						child || _ticker.sleep();
					}
			}
		};
		return Timeline;
	}(Animation);
	_setDefaults(Timeline.prototype, {
		_lock: 0,
		_hasPause: 0,
		_forcing: 0
	});
	var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
			var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
				index = 0,
				matchIndex = 0,
				result,
				startNums,
				color,
				endNum,
				chunk,
				startNum,
				hasRandom,
				a;
			pt.b = start;
			pt.e = end;
			start += "";
			end += "";
			if (hasRandom = ~end.indexOf("random(")) {
				end = _replaceRandom(end);
			}
			if (stringFilter) {
				a = [start, end];
				stringFilter(a, target, prop);
				start = a[0];
				end = a[1];
			}
			startNums = start.match(_complexStringNumExp) || [];
			while (result = _complexStringNumExp.exec(end)) {
				endNum = result[0];
				chunk = end.substring(index, result.index);
				if (color) {
					color = (color + 1) % 5;
				} else if (chunk.substr(-5) === "rgba(") {
					color = 1;
				}
				if (endNum !== startNums[matchIndex++]) {
					startNum = parseFloat(startNums[matchIndex - 1]) || 0;
					pt._pt = {
						_next: pt._pt,
						p: chunk || matchIndex === 1 ? chunk : ",",
						s: startNum,
						c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
						m: color && color < 4 ? Math.round : 0
					};
					index = _complexStringNumExp.lastIndex;
				}
			}
			pt.c = index < end.length ? end.substring(index, end.length) : "";
			pt.fp = funcParam;
			if (_relExp.test(end) || hasRandom) {
				pt.e = 0;
			}
			this._pt = pt;
			return pt;
		},
		_addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
			_isFunction(end) && (end = end(index || 0, target, targets));
			var currentValue = target[prop],
				parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
				setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
				pt;
			if (_isString(end)) {
				if (~end.indexOf("random(")) {
					end = _replaceRandom(end);
				}
				if (end.charAt(1) === "=") {
					pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
					if (pt || pt === 0) {
						end = pt;
					}
				}
			}
			if (!optional || parsedStart !== end || _forceAllPropTweens) {
				if (!isNaN(parsedStart * end) && end !== "") {
					pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
					funcParam && (pt.fp = funcParam);
					modifier && pt.modifier(modifier, this, target);
					return this._pt = pt;
				}!currentValue && !(prop in target) && _missingPlugin(prop, end);
				return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
			}
		},
		_processVars = function _processVars(vars, index, target, targets, tween) {
			_isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
			if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
				return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
			}
			var copy = {},
				p;
			for (p in vars) {
				copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
			}
			return copy;
		},
		_checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
			var plugin, pt, ptLookup, i;
			if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
				tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
				if (tween !== _quickTween) {
					ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
					i = plugin._props.length;
					while (i--) {
						ptLookup[plugin._props[i]] = pt;
					}
				}
			}
			return plugin;
		},
		_overwritingTween,
		_forceAllPropTweens,
		_initTween = function _initTween(tween, time, tTime) {
			var vars = tween.vars,
				ease = vars.ease,
				startAt = vars.startAt,
				immediateRender = vars.immediateRender,
				lazy = vars.lazy,
				onUpdate = vars.onUpdate,
				onUpdateParams = vars.onUpdateParams,
				callbackScope = vars.callbackScope,
				runBackwards = vars.runBackwards,
				yoyoEase = vars.yoyoEase,
				keyframes = vars.keyframes,
				autoRevert = vars.autoRevert,
				dur = tween._dur,
				prevStartAt = tween._startAt,
				targets = tween._targets,
				parent = tween.parent,
				fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets,
				autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
				tl = tween.timeline,
				cleanVars,
				i,
				p,
				pt,
				target,
				hasPriority,
				gsData,
				harness,
				plugin,
				ptLookup,
				index,
				harnessVars,
				overwritten;
			tl && (!keyframes || !ease) && (ease = "none");
			tween._ease = _parseEase(ease, _defaults.ease);
			tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
			if (yoyoEase && tween._yoyo && !tween._repeat) {
				yoyoEase = tween._yEase;
				tween._yEase = tween._ease;
				tween._ease = yoyoEase;
			}
			tween._from = !tl && !!vars.runBackwards;
			if (!tl || keyframes && !vars.stagger) {
				harness = targets[0] ? _getCache(targets[0]).harness : 0;
				harnessVars = harness && vars[harness.prop];
				cleanVars = _copyExcluding(vars, _reservedProps);
				if (prevStartAt) {
					prevStartAt._zTime < 0 && prevStartAt.progress(1);
					time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
					prevStartAt._lazy = 0;
				}
				if (startAt) {
					_removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
						data: "isStart",
						overwrite: false,
						parent: parent,
						immediateRender: true,
						lazy: !prevStartAt && _isNotFalse(lazy),
						startAt: null,
						delay: 0,
						onUpdate: onUpdate,
						onUpdateParams: onUpdateParams,
						callbackScope: callbackScope,
						stagger: 0
					}, startAt)));
					tween._startAt._dp = 0;
					tween._startAt._sat = tween;
					time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
					if (immediateRender) {
						if (dur && time <= 0 && tTime <= 0) {
							time && (tween._zTime = time);
							return;
						}
					}
				} else if (runBackwards && dur) {
					if (!prevStartAt) {
						time && (immediateRender = false);
						p = _setDefaults({
							overwrite: false,
							data: "isFromStart",
							lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
							immediateRender: immediateRender,
							stagger: 0,
							parent: parent
						}, cleanVars);
						harnessVars && (p[harness.prop] = harnessVars);
						_removeFromParent(tween._startAt = Tween.set(targets, p));
						tween._startAt._dp = 0;
						tween._startAt._sat = tween;
						time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
						tween._zTime = time;
						if (!immediateRender) {
							_initTween(tween._startAt, _tinyNum, _tinyNum);
						} else if (!time) {
							return;
						}
					}
				}
				tween._pt = tween._ptCache = 0;
				lazy = dur && _isNotFalse(lazy) || lazy && !dur;
				for (i = 0; i < targets.length; i++) {
					target = targets[i];
					gsData = target._gsap || _harness(targets)[i]._gsap;
					tween._ptLookup[i] = ptLookup = {};
					_lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
					index = fullTargets === targets ? i : fullTargets.indexOf(target);
					if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
						tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
						plugin._props.forEach(function(name) {
							ptLookup[name] = pt;
						});
						plugin.priority && (hasPriority = 1);
					}
					if (!harness || harnessVars) {
						for (p in cleanVars) {
							if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
								plugin.priority && (hasPriority = 1);
							} else {
								ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
							}
						}
					}
					tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
					if (autoOverwrite && tween._pt) {
						_overwritingTween = tween;
						_globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
						overwritten = !tween.parent;
						_overwritingTween = 0;
					}
					tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
				}
				hasPriority && _sortPropTweensByPriority(tween);
				tween._onInit && tween._onInit(tween);
			}
			tween._onUpdate = onUpdate;
			tween._initted = (!tween._op || tween._pt) && !overwritten;
			keyframes && time <= 0 && tl.render(_bigNum, true, true);
		},
		_updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time) {
			var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],
				pt,
				rootPT,
				lookup,
				i;
			if (!ptCache) {
				ptCache = tween._ptCache[property] = [];
				lookup = tween._ptLookup;
				i = tween._targets.length;
				while (i--) {
					pt = lookup[i][property];
					if (pt && pt.d && pt.d._pt) {
						pt = pt.d._pt;
						while (pt && pt.p !== property && pt.fp !== property) {
							pt = pt._next;
						}
					}
					if (!pt) {
						_forceAllPropTweens = 1;
						tween.vars[property] = "+=0";
						_initTween(tween, time);
						_forceAllPropTweens = 0;
						return 1;
					}
					ptCache.push(pt);
				}
			}
			i = ptCache.length;
			while (i--) {
				rootPT = ptCache[i];
				pt = rootPT._pt || rootPT;
				pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
				pt.c = value - pt.s;
				rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
				rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
			}
		},
		_addAliasesToVars = function _addAliasesToVars(targets, vars) {
			var harness = targets[0] ? _getCache(targets[0]).harness : 0,
				propertyAliases = harness && harness.aliases,
				copy,
				p,
				i,
				aliases;
			if (!propertyAliases) {
				return vars;
			}
			copy = _merge({}, vars);
			for (p in propertyAliases) {
				if (p in copy) {
					aliases = propertyAliases[p].split(",");
					i = aliases.length;
					while (i--) {
						copy[aliases[i]] = copy[p];
					}
				}
			}
			return copy;
		},
		_parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
			var ease = obj.ease || easeEach || "power1.inOut",
				p,
				a;
			if (_isArray(obj)) {
				a = allProps[prop] || (allProps[prop] = []);
				obj.forEach(function(value, i) {
					return a.push({
						t: i / (obj.length - 1) * 100,
						v: value,
						e: ease
					});
				});
			} else {
				for (p in obj) {
					a = allProps[p] || (allProps[p] = []);
					p === "ease" || a.push({
						t: parseFloat(prop),
						v: obj[p],
						e: ease
					});
				}
			}
		},
		_parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
			return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
		},
		_staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
		_staggerPropsToSkip = {};
	_forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
		return _staggerPropsToSkip[name] = 1;
	});
	var Tween = function(_Animation2) {
		_inheritsLoose(Tween, _Animation2);

		function Tween(targets, vars, position, skipInherit) {
			var _this3;
			if (typeof vars === "number") {
				position.duration = vars;
				vars = position;
				position = null;
			}
			_this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
			var _this3$vars = _this3.vars,
				duration = _this3$vars.duration,
				delay = _this3$vars.delay,
				immediateRender = _this3$vars.immediateRender,
				stagger = _this3$vars.stagger,
				overwrite = _this3$vars.overwrite,
				keyframes = _this3$vars.keyframes,
				defaults = _this3$vars.defaults,
				scrollTrigger = _this3$vars.scrollTrigger,
				yoyoEase = _this3$vars.yoyoEase,
				parent = vars.parent || _globalTimeline,
				parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
				tl,
				i,
				copy,
				l,
				p,
				curTarget,
				staggerFunc,
				staggerVarsToMerge;
			_this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
			_this3._ptLookup = [];
			_this3._overwrite = overwrite;
			if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
				vars = _this3.vars;
				tl = _this3.timeline = new Timeline({
					data: "nested",
					defaults: defaults || {},
					targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
				});
				tl.kill();
				tl.parent = tl._dp = _assertThisInitialized(_this3);
				tl._start = 0;
				if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
					l = parsedTargets.length;
					staggerFunc = stagger && distribute(stagger);
					if (_isObject(stagger)) {
						for (p in stagger) {
							if (~_staggerTweenProps.indexOf(p)) {
								staggerVarsToMerge || (staggerVarsToMerge = {});
								staggerVarsToMerge[p] = stagger[p];
							}
						}
					}
					for (i = 0; i < l; i++) {
						copy = _copyExcluding(vars, _staggerPropsToSkip);
						copy.stagger = 0;
						yoyoEase && (copy.yoyoEase = yoyoEase);
						staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
						curTarget = parsedTargets[i];
						copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
						copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;
						if (!stagger && l === 1 && copy.delay) {
							_this3._delay = delay = copy.delay;
							_this3._start += delay;
							copy.delay = 0;
						}
						tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
						tl._ease = _easeMap.none;
					}
					tl.duration() ? duration = delay = 0 : _this3.timeline = 0;
				} else if (keyframes) {
					_inheritDefaults(_setDefaults(tl.vars.defaults, {
						ease: "none"
					}));
					tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
					var time = 0,
						a,
						kf,
						v;
					if (_isArray(keyframes)) {
						keyframes.forEach(function(frame) {
							return tl.to(parsedTargets, frame, ">");
						});
						tl.duration();
					} else {
						copy = {};
						for (p in keyframes) {
							p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
						}
						for (p in copy) {
							a = copy[p].sort(function(a, b) {
								return a.t - b.t;
							});
							time = 0;
							for (i = 0; i < a.length; i++) {
								kf = a[i];
								v = {
									ease: kf.e,
									duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
								};
								v[p] = kf.v;
								tl.to(parsedTargets, v, time);
								time += v.duration;
							}
						}
						tl.duration() < duration && tl.to({}, {
							duration: duration - tl.duration()
						});
					}
				}
				duration || _this3.duration(duration = tl.duration());
			} else {
				_this3.timeline = 0;
			}
			if (overwrite === true && !_suppressOverwrites) {
				_overwritingTween = _assertThisInitialized(_this3);
				_globalTimeline.killTweensOf(parsedTargets);
				_overwritingTween = 0;
			}
			_addToTimeline(parent, _assertThisInitialized(_this3), position);
			vars.reversed && _this3.reverse();
			vars.paused && _this3.paused(true);
			if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
				_this3._tTime = -_tinyNum;
				_this3.render(Math.max(0, -delay) || 0);
			}
			scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
			return _this3;
		}
		var _proto3 = Tween.prototype;
		_proto3.render = function render(totalTime, suppressEvents, force) {
			var prevTime = this._time,
				tDur = this._tDur,
				dur = this._dur,
				isNegative = totalTime < 0,
				tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime,
				time,
				pt,
				iteration,
				cycleDuration,
				prevIteration,
				isYoyo,
				ratio,
				timeline,
				yoyoEase;
			if (!dur) {
				_renderZeroDurationTween(this, totalTime, suppressEvents, force);
			} else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
				time = tTime;
				timeline = this.timeline;
				if (this._repeat) {
					cycleDuration = dur + this._rDelay;
					if (this._repeat < -1 && isNegative) {
						return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
					}
					time = _roundPrecise(tTime % cycleDuration);
					if (tTime === tDur) {
						iteration = this._repeat;
						time = dur;
					} else {
						iteration = ~~(tTime / cycleDuration);
						if (iteration && iteration === tTime / cycleDuration) {
							time = dur;
							iteration--;
						}
						time > dur && (time = dur);
					}
					isYoyo = this._yoyo && iteration & 1;
					if (isYoyo) {
						yoyoEase = this._yEase;
						time = dur - time;
					}
					prevIteration = _animationCycle(this._tTime, cycleDuration);
					if (time === prevTime && !force && this._initted) {
						this._tTime = tTime;
						return this;
					}
					if (iteration !== prevIteration) {
						timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo);
						if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
							this._lock = force = 1;
							this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
						}
					}
				}
				if (!this._initted) {
					if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
						this._tTime = 0;
						return this;
					}
					if (prevTime !== this._time) {
						return this;
					}
					if (dur !== this._dur) {
						return this.render(totalTime, suppressEvents, force);
					}
				}
				this._tTime = tTime;
				this._time = time;
				if (!this._act && this._ts) {
					this._act = 1;
					this._lazy = 0;
				}
				this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
				if (this._from) {
					this.ratio = ratio = 1 - ratio;
				}
				if (time && !prevTime && !suppressEvents && !iteration) {
					_callback(this, "onStart");
					if (this._tTime !== tTime) {
						return this;
					}
				}
				pt = this._pt;
				while (pt) {
					pt.r(ratio, pt.d);
					pt = pt._next;
				}
				timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
				if (this._onUpdate && !suppressEvents) {
					isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
					_callback(this, "onUpdate");
				}
				this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
				if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
					isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
					(totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
					if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
						_callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
						this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
					}
				}
			}
			return this;
		};
		_proto3.targets = function targets() {
			return this._targets;
		};
		_proto3.invalidate = function invalidate(soft) {
			(!soft || !this.vars.runBackwards) && (this._startAt = 0);
			this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
			this._ptLookup = [];
			this.timeline && this.timeline.invalidate(soft);
			return _Animation2.prototype.invalidate.call(this, soft);
		};
		_proto3.resetTo = function resetTo(property, value, start, startIsRelative) {
			_tickerActive || _ticker.wake();
			this._ts || this.play();
			var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
				ratio;
			this._initted || _initTween(this, time);
			ratio = this._ease(time / this._dur);
			if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) {
				return this.resetTo(property, value, start, startIsRelative);
			}
			_alignPlayhead(this, 0);
			this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
			return this.render(0);
		};
		_proto3.kill = function kill(targets, vars) {
			if (vars === void 0) {
				vars = "all";
			}
			if (!targets && (!vars || vars === "all")) {
				this._lazy = this._pt = 0;
				return this.parent ? _interrupt(this) : this;
			}
			if (this.timeline) {
				var tDur = this.timeline.totalDuration();
				this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
				this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
				return this;
			}
			var parsedTargets = this._targets,
				killingTargets = targets ? toArray(targets) : parsedTargets,
				propTweenLookup = this._ptLookup,
				firstPT = this._pt,
				overwrittenProps,
				curLookup,
				curOverwriteProps,
				props,
				p,
				pt,
				i;
			if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
				vars === "all" && (this._pt = 0);
				return _interrupt(this);
			}
			overwrittenProps = this._op = this._op || [];
			if (vars !== "all") {
				if (_isString(vars)) {
					p = {};
					_forEachName(vars, function(name) {
						return p[name] = 1;
					});
					vars = p;
				}
				vars = _addAliasesToVars(parsedTargets, vars);
			}
			i = parsedTargets.length;
			while (i--) {
				if (~killingTargets.indexOf(parsedTargets[i])) {
					curLookup = propTweenLookup[i];
					if (vars === "all") {
						overwrittenProps[i] = vars;
						props = curLookup;
						curOverwriteProps = {};
					} else {
						curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
						props = vars;
					}
					for (p in props) {
						pt = curLookup && curLookup[p];
						if (pt) {
							if (!("kill" in pt.d) || pt.d.kill(p) === true) {
								_removeLinkedListItem(this, pt, "_pt");
							}
							delete curLookup[p];
						}
						if (curOverwriteProps !== "all") {
							curOverwriteProps[p] = 1;
						}
					}
				}
			}
			this._initted && !this._pt && firstPT && _interrupt(this);
			return this;
		};
		Tween.to = function to(targets, vars) {
			return new Tween(targets, vars, arguments[2]);
		};
		Tween.from = function from(targets, vars) {
			return _createTweenType(1, arguments);
		};
		Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
			return new Tween(callback, 0, {
				immediateRender: false,
				lazy: false,
				overwrite: false,
				delay: delay,
				onComplete: callback,
				onReverseComplete: callback,
				onCompleteParams: params,
				onReverseCompleteParams: params,
				callbackScope: scope
			});
		};
		Tween.fromTo = function fromTo(targets, fromVars, toVars) {
			return _createTweenType(2, arguments);
		};
		Tween.set = function set(targets, vars) {
			vars.duration = 0;
			vars.repeatDelay || (vars.repeat = 0);
			return new Tween(targets, vars);
		};
		Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
			return _globalTimeline.killTweensOf(targets, props, onlyActive);
		};
		return Tween;
	}(Animation);
	_setDefaults(Tween.prototype, {
		_targets: [],
		_lazy: 0,
		_startAt: 0,
		_op: 0,
		_onInit: 0
	});
	_forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
		Tween[name] = function() {
			var tl = new Timeline(),
				params = _slice.call(arguments, 0);
			params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
			return tl[name].apply(tl, params);
		};
	});
	var _setterPlain = function _setterPlain(target, property, value) {
			return target[property] = value;
		},
		_setterFunc = function _setterFunc(target, property, value) {
			return target[property](value);
		},
		_setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
			return target[property](data.fp, value);
		},
		_setterAttribute = function _setterAttribute(target, property, value) {
			return target.setAttribute(property, value);
		},
		_getSetter = function _getSetter(target, property) {
			return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
		},
		_renderPlain = function _renderPlain(ratio, data) {
			return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
		},
		_renderBoolean = function _renderBoolean(ratio, data) {
			return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
		},
		_renderComplexString = function _renderComplexString(ratio, data) {
			var pt = data._pt,
				s = "";
			if (!ratio && data.b) {
				s = data.b;
			} else if (ratio === 1 && data.e) {
				s = data.e;
			} else {
				while (pt) {
					s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s;
					pt = pt._next;
				}
				s += data.c;
			}
			data.set(data.t, data.p, s, data);
		},
		_renderPropTweens = function _renderPropTweens(ratio, data) {
			var pt = data._pt;
			while (pt) {
				pt.r(ratio, pt.d);
				pt = pt._next;
			}
		},
		_addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
			var pt = this._pt,
				next;
			while (pt) {
				next = pt._next;
				pt.p === property && pt.modifier(modifier, tween, target);
				pt = next;
			}
		},
		_killPropTweensOf = function _killPropTweensOf(property) {
			var pt = this._pt,
				hasNonDependentRemaining,
				next;
			while (pt) {
				next = pt._next;
				if (pt.p === property && !pt.op || pt.op === property) {
					_removeLinkedListItem(this, pt, "_pt");
				} else if (!pt.dep) {
					hasNonDependentRemaining = 1;
				}
				pt = next;
			}
			return !hasNonDependentRemaining;
		},
		_setterWithModifier = function _setterWithModifier(target, property, value, data) {
			data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
		},
		_sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
			var pt = parent._pt,
				next,
				pt2,
				first,
				last;
			while (pt) {
				next = pt._next;
				pt2 = first;
				while (pt2 && pt2.pr > pt.pr) {
					pt2 = pt2._next;
				}
				if (pt._prev = pt2 ? pt2._prev : last) {
					pt._prev._next = pt;
				} else {
					first = pt;
				}
				if (pt._next = pt2) {
					pt2._prev = pt;
				} else {
					last = pt;
				}
				pt = next;
			}
			parent._pt = first;
		};
	var PropTween = function() {
		function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
			this.t = target;
			this.s = start;
			this.c = change;
			this.p = prop;
			this.r = renderer || _renderPlain;
			this.d = data || this;
			this.set = setter || _setterPlain;
			this.pr = priority || 0;
			this._next = next;
			if (next) {
				next._prev = this;
			}
		}
		var _proto4 = PropTween.prototype;
		_proto4.modifier = function modifier(func, tween, target) {
			this.mSet = this.mSet || this.set;
			this.set = _setterWithModifier;
			this.m = func;
			this.mt = target;
			this.tween = tween;
		};
		return PropTween;
	}();
	_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
		return _reservedProps[name] = 1;
	});
	_globals.TweenMax = _globals.TweenLite = Tween;
	_globals.TimelineLite = _globals.TimelineMax = Timeline;
	_globalTimeline = new Timeline({
		sortChildren: false,
		defaults: _defaults,
		autoRemoveChildren: true,
		id: "root",
		smoothChildTiming: true
	});
	_config.stringFilter = _colorStringFilter;
	var _media = [],
		_listeners = {},
		_emptyArray = [],
		_lastMediaTime = 0,
		_dispatch = function _dispatch(type) {
			return (_listeners[type] || _emptyArray).map(function(f) {
				return f();
			});
		},
		_onMediaChange = function _onMediaChange() {
			var time = Date.now(),
				matches = [];
			if (time - _lastMediaTime > 2) {
				_dispatch("matchMediaInit");
				_media.forEach(function(c) {
					var queries = c.queries,
						conditions = c.conditions,
						match,
						p,
						anyMatch,
						toggled;
					for (p in queries) {
						match = _win.matchMedia(queries[p]).matches;
						match && (anyMatch = 1);
						if (match !== conditions[p]) {
							conditions[p] = match;
							toggled = 1;
						}
					}
					if (toggled) {
						c.revert();
						anyMatch && matches.push(c);
					}
				});
				_dispatch("matchMediaRevert");
				matches.forEach(function(c) {
					return c.onMatch(c);
				});
				_lastMediaTime = time;
				_dispatch("matchMedia");
			}
		};
	var Context = function() {
		function Context(func, scope) {
			this.selector = scope && selector(scope);
			this.data = [];
			this._r = [];
			this.isReverted = false;
			func && this.add(func);
		}
		var _proto5 = Context.prototype;
		_proto5.add = function add(name, func, scope) {
			if (_isFunction(name)) {
				scope = func;
				func = name;
				name = _isFunction;
			}
			var self = this,
				f = function f() {
					var prev = _context,
						prevSelector = self.selector,
						result;
					prev && prev !== self && prev.data.push(self);
					scope && (self.selector = selector(scope));
					_context = self;
					result = func.apply(self, arguments);
					_isFunction(result) && self._r.push(result);
					_context = prev;
					self.selector = prevSelector;
					self.isReverted = false;
					return result;
				};
			self.last = f;
			return name === _isFunction ? f(self) : name ? self[name] = f : f;
		};
		_proto5.ignore = function ignore(func) {
			var prev = _context;
			_context = null;
			func(this);
			_context = prev;
		};
		_proto5.getTweens = function getTweens() {
			var a = [];
			this.data.forEach(function(e) {
				return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e);
			});
			return a;
		};
		_proto5.clear = function clear() {
			this._r.length = this.data.length = 0;
		};
		_proto5.kill = function kill(revert, matchMedia) {
			var _this4 = this;
			if (revert) {
				var tweens = this.getTweens();
				this.data.forEach(function(t) {
					if (t.data === "isFlip") {
						t.revert();
						t.getChildren(true, true, false).forEach(function(tween) {
							return tweens.splice(tweens.indexOf(tween), 1);
						});
					}
				});
				tweens.map(function(t) {
					return {
						g: t.globalTime(0),
						t: t
					};
				}).sort(function(a, b) {
					return b.g - a.g || -1;
				}).forEach(function(o) {
					return o.t.revert(revert);
				});
				this.data.forEach(function(e) {
					return !(e instanceof Animation) && e.revert && e.revert(revert);
				});
				this._r.forEach(function(f) {
					return f(revert, _this4);
				});
				this.isReverted = true;
			} else {
				this.data.forEach(function(e) {
					return e.kill && e.kill();
				});
			}
			this.clear();
			if (matchMedia) {
				var i = _media.indexOf(this);
				!!~i && _media.splice(i, 1);
			}
		};
		_proto5.revert = function revert(config) {
			this.kill(config || {});
		};
		return Context;
	}();
	var MatchMedia = function() {
		function MatchMedia(scope) {
			this.contexts = [];
			this.scope = scope;
		}
		var _proto6 = MatchMedia.prototype;
		_proto6.add = function add(conditions, func, scope) {
			_isObject(conditions) || (conditions = {
				matches: conditions
			});
			var context = new Context(0, scope || this.scope),
				cond = context.conditions = {},
				mq,
				p,
				active;
			this.contexts.push(context);
			func = context.add("onMatch", func);
			context.queries = conditions;
			for (p in conditions) {
				if (p === "all") {
					active = 1;
				} else {
					mq = _win.matchMedia(conditions[p]);
					if (mq) {
						_media.indexOf(context) < 0 && _media.push(context);
						(cond[p] = mq.matches) && (active = 1);
						mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
					}
				}
			}
			active && func(context);
			return this;
		};
		_proto6.revert = function revert(config) {
			this.kill(config || {});
		};
		_proto6.kill = function kill(revert) {
			this.contexts.forEach(function(c) {
				return c.kill(revert, true);
			});
		};
		return MatchMedia;
	}();
	var _gsap = {
		registerPlugin: function registerPlugin() {
			for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				args[_key2] = arguments[_key2];
			}
			args.forEach(function(config) {
				return _createPlugin(config);
			});
		},
		timeline: function timeline(vars) {
			return new Timeline(vars);
		},
		getTweensOf: function getTweensOf(targets, onlyActive) {
			return _globalTimeline.getTweensOf(targets, onlyActive);
		},
		getProperty: function getProperty(target, property, unit, uncache) {
			_isString(target) && (target = toArray(target)[0]);
			var getter = _getCache(target || {}).get,
				format = unit ? _passThrough : _numericIfPossible;
			unit === "native" && (unit = "");
			return !target ? target : !property ? function(property, unit, uncache) {
				return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
			} : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
		},
		quickSetter: function quickSetter(target, property, unit) {
			target = toArray(target);
			if (target.length > 1) {
				var setters = target.map(function(t) {
						return gsap.quickSetter(t, property, unit);
					}),
					l = setters.length;
				return function(value) {
					var i = l;
					while (i--) {
						setters[i](value);
					}
				};
			}
			target = target[0] || {};
			var Plugin = _plugins[property],
				cache = _getCache(target),
				p = cache.harness && (cache.harness.aliases || {})[property] || property,
				setter = Plugin ? function(value) {
					var p = new Plugin();
					_quickTween._pt = 0;
					p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
					p.render(1, p);
					_quickTween._pt && _renderPropTweens(1, _quickTween);
				} : cache.set(target, p);
			return Plugin ? setter : function(value) {
				return setter(target, p, unit ? value + unit : value, cache, 1);
			};
		},
		quickTo: function quickTo(target, property, vars) {
			var _merge2;
			var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = "+=0.1", _merge2.paused = true, _merge2), vars || {})),
				func = function func(value, start, startIsRelative) {
					return tween.resetTo(property, value, start, startIsRelative);
				};
			func.tween = tween;
			return func;
		},
		isTweening: function isTweening(targets) {
			return _globalTimeline.getTweensOf(targets, true).length > 0;
		},
		defaults: function defaults(value) {
			value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
			return _mergeDeep(_defaults, value || {});
		},
		config: function config(value) {
			return _mergeDeep(_config, value || {});
		},
		registerEffect: function registerEffect(_ref3) {
			var name = _ref3.name,
				effect = _ref3.effect,
				plugins = _ref3.plugins,
				defaults = _ref3.defaults,
				extendTimeline = _ref3.extendTimeline;
			(plugins || "").split(",").forEach(function(pluginName) {
				return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
			});
			_effects[name] = function(targets, vars, tl) {
				return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
			};
			if (extendTimeline) {
				Timeline.prototype[name] = function(targets, vars, position) {
					return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
				};
			}
		},
		registerEase: function registerEase(name, ease) {
			_easeMap[name] = _parseEase(ease);
		},
		parseEase: function parseEase(ease, defaultEase) {
			return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
		},
		getById: function getById(id) {
			return _globalTimeline.getById(id);
		},
		exportRoot: function exportRoot(vars, includeDelayedCalls) {
			if (vars === void 0) {
				vars = {};
			}
			var tl = new Timeline(vars),
				child,
				next;
			tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
			_globalTimeline.remove(tl);
			tl._dp = 0;
			tl._time = tl._tTime = _globalTimeline._time;
			child = _globalTimeline._first;
			while (child) {
				next = child._next;
				if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
					_addToTimeline(tl, child, child._start - child._delay);
				}
				child = next;
			}
			_addToTimeline(_globalTimeline, tl, 0);
			return tl;
		},
		context: function context(func, scope) {
			return func ? new Context(func, scope) : _context;
		},
		matchMedia: function matchMedia(scope) {
			return new MatchMedia(scope);
		},
		matchMediaRefresh: function matchMediaRefresh() {
			return _media.forEach(function(c) {
				var cond = c.conditions,
					found,
					p;
				for (p in cond) {
					if (cond[p]) {
						cond[p] = false;
						found = 1;
					}
				}
				found && c.revert();
			}) || _onMediaChange();
		},
		addEventListener: function addEventListener(type, callback) {
			var a = _listeners[type] || (_listeners[type] = []);
			~a.indexOf(callback) || a.push(callback);
		},
		removeEventListener: function removeEventListener(type, callback) {
			var a = _listeners[type],
				i = a && a.indexOf(callback);
			i >= 0 && a.splice(i, 1);
		},
		utils: {
			wrap: wrap,
			wrapYoyo: wrapYoyo,
			distribute: distribute,
			random: random,
			snap: snap,
			normalize: normalize,
			getUnit: getUnit,
			clamp: clamp,
			splitColor: splitColor,
			toArray: toArray,
			selector: selector,
			mapRange: mapRange,
			pipe: pipe,
			unitize: unitize,
			interpolate: interpolate,
			shuffle: shuffle
		},
		install: _install,
		effects: _effects,
		ticker: _ticker,
		updateRoot: Timeline.updateRoot,
		plugins: _plugins,
		globalTimeline: _globalTimeline,
		core: {
			PropTween: PropTween,
			globals: _addGlobal,
			Tween: Tween,
			Timeline: Timeline,
			Animation: Animation,
			getCache: _getCache,
			_removeLinkedListItem: _removeLinkedListItem,
			reverting: function reverting() {
				return _reverting;
			},
			context: function context(toAdd) {
				if (toAdd && _context) {
					_context.data.push(toAdd);
					toAdd._ctx = _context;
				}
				return _context;
			},
			suppressOverwrites: function suppressOverwrites(value) {
				return _suppressOverwrites = value;
			}
		}
	};
	_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
		return _gsap[name] = Tween[name];
	});
	_ticker.add(Timeline.updateRoot);
	_quickTween = _gsap.to({}, {
		duration: 0
	});
	var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
			var pt = plugin._pt;
			while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
				pt = pt._next;
			}
			return pt;
		},
		_addModifiers = function _addModifiers(tween, modifiers) {
			var targets = tween._targets,
				p,
				i,
				pt;
			for (p in modifiers) {
				i = targets.length;
				while (i--) {
					pt = tween._ptLookup[i][p];
					if (pt && (pt = pt.d)) {
						if (pt._pt) {
							pt = _getPluginPropTween(pt, p);
						}
						pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
					}
				}
			}
		},
		_buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
			return {
				name: name,
				rawVars: 1,
				init: function init(target, vars, tween) {
					tween._onInit = function(tween) {
						var temp, p;
						if (_isString(vars)) {
							temp = {};
							_forEachName(vars, function(name) {
								return temp[name] = 1;
							});
							vars = temp;
						}
						if (modifier) {
							temp = {};
							for (p in vars) {
								temp[p] = modifier(vars[p]);
							}
							vars = temp;
						}
						_addModifiers(tween, vars);
					};
				}
			};
		};
	var gsap = _gsap.registerPlugin({
		name: "attr",
		init: function init(target, vars, tween, index, targets) {
			var p, pt, v;
			this.tween = tween;
			for (p in vars) {
				v = target.getAttribute(p) || "";
				pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
				pt.op = p;
				pt.b = v;
				this._props.push(p);
			}
		},
		render: function render(ratio, data) {
			var pt = data._pt;
			while (pt) {
				_reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
				pt = pt._next;
			}
		}
	}, {
		name: "endArray",
		init: function init(target, value) {
			var i = value.length;
			while (i--) {
				this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);
			}
		}
	}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
	Tween.version = Timeline.version = gsap.version = "3.11.5";
	_coreReady = 1;
	_windowExists() && _wake();
	var Power0 = _easeMap.Power0,
		Power1 = _easeMap.Power1,
		Power2 = _easeMap.Power2,
		Power3 = _easeMap.Power3,
		Power4 = _easeMap.Power4,
		Linear = _easeMap.Linear,
		Quad = _easeMap.Quad,
		Cubic = _easeMap.Cubic,
		Quart = _easeMap.Quart,
		Quint = _easeMap.Quint,
		Strong = _easeMap.Strong,
		Elastic = _easeMap.Elastic,
		Back = _easeMap.Back,
		SteppedEase = _easeMap.SteppedEase,
		Bounce = _easeMap.Bounce,
		Sine = _easeMap.Sine,
		Expo = _easeMap.Expo,
		Circ = _easeMap.Circ;
	var _win$1,
		_doc$1,
		_docElement,
		_pluginInitted,
		_tempDiv,
		_tempDivStyler,
		_recentSetterPlugin,
		_reverting$1,
		_windowExists$1 = function _windowExists() {
			return typeof window !== "undefined";
		},
		_transformProps = {},
		_RAD2DEG = 180 / Math.PI,
		_DEG2RAD = Math.PI / 180,
		_atan2 = Math.atan2,
		_bigNum$1 = 1e8,
		_capsExp = /([A-Z])/g,
		_horizontalExp = /(left|right|width|margin|padding|x)/i,
		_complexExp = /[\s,\(]\S/,
		_propertyAliases = {
			autoAlpha: "opacity,visibility",
			scale: "scaleX,scaleY",
			alpha: "opacity"
		},
		_renderCSSProp = function _renderCSSProp(ratio, data) {
			return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
		},
		_renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
			return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
		},
		_renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
			return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
		},
		_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
			var value = data.s + data.c * ratio;
			data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
		},
		_renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
			return data.set(data.t, data.p, ratio ? data.e : data.b, data);
		},
		_renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
			return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
		},
		_setterCSSStyle = function _setterCSSStyle(target, property, value) {
			return target.style[property] = value;
		},
		_setterCSSProp = function _setterCSSProp(target, property, value) {
			return target.style.setProperty(property, value);
		},
		_setterTransform = function _setterTransform(target, property, value) {
			return target._gsap[property] = value;
		},
		_setterScale = function _setterScale(target, property, value) {
			return target._gsap.scaleX = target._gsap.scaleY = value;
		},
		_setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
			var cache = target._gsap;
			cache.scaleX = cache.scaleY = value;
			cache.renderTransform(ratio, cache);
		},
		_setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
			var cache = target._gsap;
			cache[property] = value;
			cache.renderTransform(ratio, cache);
		},
		_transformProp = "transform",
		_transformOriginProp = _transformProp + "Origin",
		_saveStyle = function _saveStyle(property, isNotCSS) {
			var _this = this;
			var target = this.target,
				style = target.style;
			if (property in _transformProps) {
				this.tfm = this.tfm || {};
				if (property !== "transform") {
					property = _propertyAliases[property] || property;
					~property.indexOf(",") ? property.split(",").forEach(function(a) {
						return _this.tfm[a] = _get(target, a);
					}) : this.tfm[property] = target._gsap.x ? target._gsap[property] : _get(target, property);
				} else {
					return _propertyAliases.transform.split(",").forEach(function(p) {
						return _saveStyle.call(_this, p, isNotCSS);
					});
				}
				if (this.props.indexOf(_transformProp) >= 0) {
					return;
				}
				if (target._gsap.svg) {
					this.svgo = target.getAttribute("data-svg-origin");
					this.props.push(_transformOriginProp, isNotCSS, "");
				}
				property = _transformProp;
			}
			(style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
		},
		_removeIndependentTransforms = function _removeIndependentTransforms(style) {
			if (style.translate) {
				style.removeProperty("translate");
				style.removeProperty("scale");
				style.removeProperty("rotate");
			}
		},
		_revertStyle = function _revertStyle() {
			var props = this.props,
				target = this.target,
				style = target.style,
				cache = target._gsap,
				i,
				p;
			for (i = 0; i < props.length; i += 3) {
				props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === "--" ? props[i] : props[i].replace(_capsExp, "-$1").toLowerCase());
			}
			if (this.tfm) {
				for (p in this.tfm) {
					cache[p] = this.tfm[p];
				}
				if (cache.svg) {
					cache.renderTransform();
					target.setAttribute("data-svg-origin", this.svgo || "");
				}
				i = _reverting$1();
				if ((!i || !i.isStart) && !style[_transformProp]) {
					_removeIndependentTransforms(style);
					cache.uncache = 1;
				}
			}
		},
		_getStyleSaver = function _getStyleSaver(target, properties) {
			var saver = {
				target: target,
				props: [],
				revert: _revertStyle,
				save: _saveStyle
			};
			target._gsap || gsap.core.getCache(target);
			properties && properties.split(",").forEach(function(p) {
				return saver.save(p);
			});
			return saver;
		},
		_supports3D,
		_createElement = function _createElement(type, ns) {
			var e = _doc$1.createElementNS ? _doc$1.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc$1.createElement(type);
			return e.style ? e : _doc$1.createElement(type);
		},
		_getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
			var cs = getComputedStyle(target);
			return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || "";
		},
		_prefixes = "O,Moz,ms,Ms,Webkit".split(","),
		_checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
			var e = element || _tempDiv,
				s = e.style,
				i = 5;
			if (property in s && !preferPrefix) {
				return property;
			}
			property = property.charAt(0).toUpperCase() + property.substr(1);
			while (i-- && !(_prefixes[i] + property in s)) {}
			return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
		},
		_initCore = function _initCore() {
			if (_windowExists$1() && window.document) {
				_win$1 = window;
				_doc$1 = _win$1.document;
				_docElement = _doc$1.documentElement;
				_tempDiv = _createElement("div") || {
					style: {}
				};
				_tempDivStyler = _createElement("div");
				_transformProp = _checkPropPrefix(_transformProp);
				_transformOriginProp = _transformProp + "Origin";
				_tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
				_supports3D = !!_checkPropPrefix("perspective");
				_reverting$1 = gsap.core.reverting;
				_pluginInitted = 1;
			}
		},
		_getBBoxHack = function _getBBoxHack(swapIfPossible) {
			var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
				oldParent = this.parentNode,
				oldSibling = this.nextSibling,
				oldCSS = this.style.cssText,
				bbox;
			_docElement.appendChild(svg);
			svg.appendChild(this);
			this.style.display = "block";
			if (swapIfPossible) {
				try {
					bbox = this.getBBox();
					this._gsapBBox = this.getBBox;
					this.getBBox = _getBBoxHack;
				} catch (e) {}
			} else if (this._gsapBBox) {
				bbox = this._gsapBBox();
			}
			if (oldParent) {
				if (oldSibling) {
					oldParent.insertBefore(this, oldSibling);
				} else {
					oldParent.appendChild(this);
				}
			}
			_docElement.removeChild(svg);
			this.style.cssText = oldCSS;
			return bbox;
		},
		_getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
			var i = attributesArray.length;
			while (i--) {
				if (target.hasAttribute(attributesArray[i])) {
					return target.getAttribute(attributesArray[i]);
				}
			}
		},
		_getBBox = function _getBBox(target) {
			var bounds;
			try {
				bounds = target.getBBox();
			} catch (error) {
				bounds = _getBBoxHack.call(target, true);
			}
			bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
			return bounds && !bounds.width && !bounds.x && !bounds.y ? {
				x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
				y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
				width: 0,
				height: 0
			} : bounds;
		},
		_isSVG = function _isSVG(e) {
			return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
		},
		_removeProperty = function _removeProperty(target, property) {
			if (property) {
				var style = target.style;
				if (property in _transformProps && property !== _transformOriginProp) {
					property = _transformProp;
				}
				if (style.removeProperty) {
					if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
						property = "-" + property;
					}
					style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
				} else {
					style.removeAttribute(property);
				}
			}
		},
		_addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
			var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
			plugin._pt = pt;
			pt.b = beginning;
			pt.e = end;
			plugin._props.push(property);
			return pt;
		},
		_nonConvertibleUnits = {
			deg: 1,
			rad: 1,
			turn: 1
		},
		_nonStandardLayouts = {
			grid: 1,
			flex: 1
		},
		_convertToUnit = function _convertToUnit(target, property, value, unit) {
			var curValue = parseFloat(value) || 0,
				curUnit = (value + "").trim().substr((curValue + "").length) || "px",
				style = _tempDiv.style,
				horizontal = _horizontalExp.test(property),
				isRootSVG = target.tagName.toLowerCase() === "svg",
				measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
				amount = 100,
				toPixels = unit === "px",
				toPercent = unit === "%",
				px,
				parent,
				cache,
				isSVG;
			if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
				return curValue;
			}
			curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
			isSVG = target.getCTM && _isSVG(target);
			if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
				px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
				return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
			}
			style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
			parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
			if (isSVG) {
				parent = (target.ownerSVGElement || {}).parentNode;
			}
			if (!parent || parent === _doc$1 || !parent.appendChild) {
				parent = _doc$1.body;
			}
			cache = parent._gsap;
			if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
				return _round(curValue / cache.width * amount);
			} else {
				(toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
				parent === target && (style.position = "static");
				parent.appendChild(_tempDiv);
				px = _tempDiv[measureProperty];
				parent.removeChild(_tempDiv);
				style.position = "absolute";
				if (horizontal && toPercent) {
					cache = _getCache(parent);
					cache.time = _ticker.time;
					cache.width = parent[measureProperty];
				}
			}
			return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
		},
		_get = function _get(target, property, unit, uncache) {
			var value;
			_pluginInitted || _initCore();
			if (property in _propertyAliases && property !== "transform") {
				property = _propertyAliases[property];
				if (~property.indexOf(",")) {
					property = property.split(",")[0];
				}
			}
			if (_transformProps[property] && property !== "transform") {
				value = _parseTransform(target, uncache);
				value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
			} else {
				value = target.style[property];
				if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
					value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
				}
			}
			return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
		},
		_tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
			if (!start || start === "none") {
				var p = _checkPropPrefix(prop, target, 1),
					s = p && _getComputedProperty(target, p, 1);
				if (s && s !== start) {
					prop = p;
					start = s;
				} else if (prop === "borderColor") {
					start = _getComputedProperty(target, "borderTopColor");
				}
			}
			var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString),
				index = 0,
				matchIndex = 0,
				a,
				result,
				startValues,
				startNum,
				color,
				startValue,
				endValue,
				endNum,
				chunk,
				endUnit,
				startUnit,
				endValues;
			pt.b = start;
			pt.e = end;
			start += "";
			end += "";
			if (end === "auto") {
				target.style[prop] = end;
				end = _getComputedProperty(target, prop) || end;
				target.style[prop] = start;
			}
			a = [start, end];
			_colorStringFilter(a);
			start = a[0];
			end = a[1];
			startValues = start.match(_numWithUnitExp) || [];
			endValues = end.match(_numWithUnitExp) || [];
			if (endValues.length) {
				while (result = _numWithUnitExp.exec(end)) {
					endValue = result[0];
					chunk = end.substring(index, result.index);
					if (color) {
						color = (color + 1) % 5;
					} else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
						color = 1;
					}
					if (endValue !== (startValue = startValues[matchIndex++] || "")) {
						startNum = parseFloat(startValue) || 0;
						startUnit = startValue.substr((startNum + "").length);
						endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
						endNum = parseFloat(endValue);
						endUnit = endValue.substr((endNum + "").length);
						index = _numWithUnitExp.lastIndex - endUnit.length;
						if (!endUnit) {
							endUnit = endUnit || _config.units[prop] || startUnit;
							if (index === end.length) {
								end += endUnit;
								pt.e += endUnit;
							}
						}
						if (startUnit !== endUnit) {
							startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
						}
						pt._pt = {
							_next: pt._pt,
							p: chunk || matchIndex === 1 ? chunk : ",",
							s: startNum,
							c: endNum - startNum,
							m: color && color < 4 || prop === "zIndex" ? Math.round : 0
						};
					}
				}
				pt.c = index < end.length ? end.substring(index, end.length) : "";
			} else {
				pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
			}
			_relExp.test(end) && (pt.e = 0);
			this._pt = pt;
			return pt;
		},
		_keywordToPercent = {
			top: "0%",
			bottom: "100%",
			left: "0%",
			right: "100%",
			center: "50%"
		},
		_convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
			var split = value.split(" "),
				x = split[0],
				y = split[1] || "50%";
			if (x === "top" || x === "bottom" || y === "left" || y === "right") {
				value = x;
				x = y;
				y = value;
			}
			split[0] = _keywordToPercent[x] || x;
			split[1] = _keywordToPercent[y] || y;
			return split.join(" ");
		},
		_renderClearProps = function _renderClearProps(ratio, data) {
			if (data.tween && data.tween._time === data.tween._dur) {
				var target = data.t,
					style = target.style,
					props = data.u,
					cache = target._gsap,
					prop,
					clearTransforms,
					i;
				if (props === "all" || props === true) {
					style.cssText = "";
					clearTransforms = 1;
				} else {
					props = props.split(",");
					i = props.length;
					while (--i > -1) {
						prop = props[i];
						if (_transformProps[prop]) {
							clearTransforms = 1;
							prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
						}
						_removeProperty(target, prop);
					}
				}
				if (clearTransforms) {
					_removeProperty(target, _transformProp);
					if (cache) {
						cache.svg && target.removeAttribute("transform");
						_parseTransform(target, 1);
						cache.uncache = 1;
						_removeIndependentTransforms(style);
					}
				}
			}
		},
		_specialProps = {
			clearProps: function clearProps(plugin, target, property, endValue, tween) {
				if (tween.data !== "isFromStart") {
					var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
					pt.u = endValue;
					pt.pr = -10;
					pt.tween = tween;
					plugin._props.push(property);
					return 1;
				}
			}
		},
		_identity2DMatrix = [1, 0, 0, 1, 0, 0],
		_rotationalProperties = {},
		_isNullTransform = function _isNullTransform(value) {
			return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
		},
		_getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
			var matrixString = _getComputedProperty(target, _transformProp);
			return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
		},
		_getMatrix = function _getMatrix(target, force2D) {
			var cache = target._gsap || _getCache(target),
				style = target.style,
				matrix = _getComputedTransformMatrixAsArray(target),
				parent,
				nextSibling,
				temp,
				addedToDOM;
			if (cache.svg && target.getAttribute("transform")) {
				temp = target.transform.baseVal.consolidate().matrix;
				matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
				return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
			} else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
				temp = style.display;
				style.display = "block";
				parent = target.parentNode;
				if (!parent || !target.offsetParent) {
					addedToDOM = 1;
					nextSibling = target.nextElementSibling;
					_docElement.appendChild(target);
				}
				matrix = _getComputedTransformMatrixAsArray(target);
				temp ? style.display = temp : _removeProperty(target, "display");
				if (addedToDOM) {
					nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
				}
			}
			return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
		},
		_applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
			var cache = target._gsap,
				matrix = matrixArray || _getMatrix(target, true),
				xOriginOld = cache.xOrigin || 0,
				yOriginOld = cache.yOrigin || 0,
				xOffsetOld = cache.xOffset || 0,
				yOffsetOld = cache.yOffset || 0,
				a = matrix[0],
				b = matrix[1],
				c = matrix[2],
				d = matrix[3],
				tx = matrix[4],
				ty = matrix[5],
				originSplit = origin.split(" "),
				xOrigin = parseFloat(originSplit[0]) || 0,
				yOrigin = parseFloat(originSplit[1]) || 0,
				bounds,
				determinant,
				x,
				y;
			if (!originIsAbsolute) {
				bounds = _getBBox(target);
				xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
				yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
			} else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
				x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
				y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
				xOrigin = x;
				yOrigin = y;
			}
			if (smooth || smooth !== false && cache.smooth) {
				tx = xOrigin - xOriginOld;
				ty = yOrigin - yOriginOld;
				cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
				cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
			} else {
				cache.xOffset = cache.yOffset = 0;
			}
			cache.xOrigin = xOrigin;
			cache.yOrigin = yOrigin;
			cache.smooth = !!smooth;
			cache.origin = origin;
			cache.originIsAbsolute = !!originIsAbsolute;
			target.style[_transformOriginProp] = "0px 0px";
			if (pluginToAddPropTweensTo) {
				_addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
				_addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
				_addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
				_addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
			}
			target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
		},
		_parseTransform = function _parseTransform(target, uncache) {
			var cache = target._gsap || new GSCache(target);
			if ("x" in cache && !uncache && !cache.uncache) {
				return cache;
			}
			var style = target.style,
				invertedScaleX = cache.scaleX < 0,
				px = "px",
				deg = "deg",
				cs = getComputedStyle(target),
				origin = _getComputedProperty(target, _transformOriginProp) || "0",
				x,
				y,
				z,
				scaleX,
				scaleY,
				rotation,
				rotationX,
				rotationY,
				skewX,
				skewY,
				perspective,
				xOrigin,
				yOrigin,
				matrix,
				angle,
				cos,
				sin,
				a,
				b,
				c,
				d,
				a12,
				a22,
				t1,
				t2,
				t3,
				a13,
				a23,
				a33,
				a42,
				a43,
				a32;
			x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
			scaleX = scaleY = 1;
			cache.svg = !!(target.getCTM && _isSVG(target));
			if (cs.translate) {
				if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
					style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
				}
				style.scale = style.rotate = style.translate = "none";
			}
			matrix = _getMatrix(target, cache.svg);
			if (cache.svg) {
				if (cache.uncache) {
					t2 = target.getBBox();
					origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
					t1 = "";
				} else {
					t1 = !uncache && target.getAttribute("data-svg-origin");
				}
				_applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
			}
			xOrigin = cache.xOrigin || 0;
			yOrigin = cache.yOrigin || 0;
			if (matrix !== _identity2DMatrix) {
				a = matrix[0];
				b = matrix[1];
				c = matrix[2];
				d = matrix[3];
				x = a12 = matrix[4];
				y = a22 = matrix[5];
				if (matrix.length === 6) {
					scaleX = Math.sqrt(a * a + b * b);
					scaleY = Math.sqrt(d * d + c * c);
					rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;
					skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
					skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
					if (cache.svg) {
						x -= xOrigin - (xOrigin * a + yOrigin * c);
						y -= yOrigin - (xOrigin * b + yOrigin * d);
					}
				} else {
					a32 = matrix[6];
					a42 = matrix[7];
					a13 = matrix[8];
					a23 = matrix[9];
					a33 = matrix[10];
					a43 = matrix[11];
					x = matrix[12];
					y = matrix[13];
					z = matrix[14];
					angle = _atan2(a32, a33);
					rotationX = angle * _RAD2DEG;
					if (angle) {
						cos = Math.cos(-angle);
						sin = Math.sin(-angle);
						t1 = a12 * cos + a13 * sin;
						t2 = a22 * cos + a23 * sin;
						t3 = a32 * cos + a33 * sin;
						a13 = a12 * -sin + a13 * cos;
						a23 = a22 * -sin + a23 * cos;
						a33 = a32 * -sin + a33 * cos;
						a43 = a42 * -sin + a43 * cos;
						a12 = t1;
						a22 = t2;
						a32 = t3;
					}
					angle = _atan2(-c, a33);
					rotationY = angle * _RAD2DEG;
					if (angle) {
						cos = Math.cos(-angle);
						sin = Math.sin(-angle);
						t1 = a * cos - a13 * sin;
						t2 = b * cos - a23 * sin;
						t3 = c * cos - a33 * sin;
						a43 = d * sin + a43 * cos;
						a = t1;
						b = t2;
						c = t3;
					}
					angle = _atan2(b, a);
					rotation = angle * _RAD2DEG;
					if (angle) {
						cos = Math.cos(angle);
						sin = Math.sin(angle);
						t1 = a * cos + b * sin;
						t2 = a12 * cos + a22 * sin;
						b = b * cos - a * sin;
						a22 = a22 * cos - a12 * sin;
						a = t1;
						a12 = t2;
					}
					if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
						rotationX = rotation = 0;
						rotationY = 180 - rotationY;
					}
					scaleX = _round(Math.sqrt(a * a + b * b + c * c));
					scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
					angle = _atan2(a12, a22);
					skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
					perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
				}
				if (cache.svg) {
					t1 = target.getAttribute("transform");
					cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
					t1 && target.setAttribute("transform", t1);
				}
			}
			if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
				if (invertedScaleX) {
					scaleX *= -1;
					skewX += rotation <= 0 ? 180 : -180;
					rotation += rotation <= 0 ? 180 : -180;
				} else {
					scaleY *= -1;
					skewX += skewX <= 0 ? 180 : -180;
				}
			}
			uncache = uncache || cache.uncache;
			cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
			cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
			cache.z = z + px;
			cache.scaleX = _round(scaleX);
			cache.scaleY = _round(scaleY);
			cache.rotation = _round(rotation) + deg;
			cache.rotationX = _round(rotationX) + deg;
			cache.rotationY = _round(rotationY) + deg;
			cache.skewX = skewX + deg;
			cache.skewY = skewY + deg;
			cache.transformPerspective = perspective + px;
			if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
				style[_transformOriginProp] = _firstTwoOnly(origin);
			}
			cache.xOffset = cache.yOffset = 0;
			cache.force3D = _config.force3D;
			cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
			cache.uncache = 0;
			return cache;
		},
		_firstTwoOnly = function _firstTwoOnly(value) {
			return (value = value.split(" "))[0] + " " + value[1];
		},
		_addPxTranslate = function _addPxTranslate(target, start, value) {
			var unit = getUnit(start);
			return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
		},
		_renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
			cache.z = "0px";
			cache.rotationY = cache.rotationX = "0deg";
			cache.force3D = 0;
			_renderCSSTransforms(ratio, cache);
		},
		_zeroDeg = "0deg",
		_zeroPx = "0px",
		_endParenthesis = ") ",
		_renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
			var _ref = cache || this,
				xPercent = _ref.xPercent,
				yPercent = _ref.yPercent,
				x = _ref.x,
				y = _ref.y,
				z = _ref.z,
				rotation = _ref.rotation,
				rotationY = _ref.rotationY,
				rotationX = _ref.rotationX,
				skewX = _ref.skewX,
				skewY = _ref.skewY,
				scaleX = _ref.scaleX,
				scaleY = _ref.scaleY,
				transformPerspective = _ref.transformPerspective,
				force3D = _ref.force3D,
				target = _ref.target,
				zOrigin = _ref.zOrigin,
				transforms = "",
				use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
			if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
				var angle = parseFloat(rotationY) * _DEG2RAD,
					a13 = Math.sin(angle),
					a33 = Math.cos(angle),
					cos;
				angle = parseFloat(rotationX) * _DEG2RAD;
				cos = Math.cos(angle);
				x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
				y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
				z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
			}
			if (transformPerspective !== _zeroPx) {
				transforms += "perspective(" + transformPerspective + _endParenthesis;
			}
			if (xPercent || yPercent) {
				transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
			}
			if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
				transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
			}
			if (rotation !== _zeroDeg) {
				transforms += "rotate(" + rotation + _endParenthesis;
			}
			if (rotationY !== _zeroDeg) {
				transforms += "rotateY(" + rotationY + _endParenthesis;
			}
			if (rotationX !== _zeroDeg) {
				transforms += "rotateX(" + rotationX + _endParenthesis;
			}
			if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
				transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
			}
			if (scaleX !== 1 || scaleY !== 1) {
				transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
			}
			target.style[_transformProp] = transforms || "translate(0, 0)";
		},
		_renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
			var _ref2 = cache || this,
				xPercent = _ref2.xPercent,
				yPercent = _ref2.yPercent,
				x = _ref2.x,
				y = _ref2.y,
				rotation = _ref2.rotation,
				skewX = _ref2.skewX,
				skewY = _ref2.skewY,
				scaleX = _ref2.scaleX,
				scaleY = _ref2.scaleY,
				target = _ref2.target,
				xOrigin = _ref2.xOrigin,
				yOrigin = _ref2.yOrigin,
				xOffset = _ref2.xOffset,
				yOffset = _ref2.yOffset,
				forceCSS = _ref2.forceCSS,
				tx = parseFloat(x),
				ty = parseFloat(y),
				a11,
				a21,
				a12,
				a22,
				temp;
			rotation = parseFloat(rotation);
			skewX = parseFloat(skewX);
			skewY = parseFloat(skewY);
			if (skewY) {
				skewY = parseFloat(skewY);
				skewX += skewY;
				rotation += skewY;
			}
			if (rotation || skewX) {
				rotation *= _DEG2RAD;
				skewX *= _DEG2RAD;
				a11 = Math.cos(rotation) * scaleX;
				a21 = Math.sin(rotation) * scaleX;
				a12 = Math.sin(rotation - skewX) * -scaleY;
				a22 = Math.cos(rotation - skewX) * scaleY;
				if (skewX) {
					skewY *= _DEG2RAD;
					temp = Math.tan(skewX - skewY);
					temp = Math.sqrt(1 + temp * temp);
					a12 *= temp;
					a22 *= temp;
					if (skewY) {
						temp = Math.tan(skewY);
						temp = Math.sqrt(1 + temp * temp);
						a11 *= temp;
						a21 *= temp;
					}
				}
				a11 = _round(a11);
				a21 = _round(a21);
				a12 = _round(a12);
				a22 = _round(a22);
			} else {
				a11 = scaleX;
				a22 = scaleY;
				a21 = a12 = 0;
			}
			if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
				tx = _convertToUnit(target, "x", x, "px");
				ty = _convertToUnit(target, "y", y, "px");
			}
			if (xOrigin || yOrigin || xOffset || yOffset) {
				tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
				ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
			}
			if (xPercent || yPercent) {
				temp = target.getBBox();
				tx = _round(tx + xPercent / 100 * temp.width);
				ty = _round(ty + yPercent / 100 * temp.height);
			}
			temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
			target.setAttribute("transform", temp);
			forceCSS && (target.style[_transformProp] = temp);
		},
		_addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
			var cap = 360,
				isString = _isString(endValue),
				endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
				change = endNum - startNum,
				finalValue = startNum + change + "deg",
				direction,
				pt;
			if (isString) {
				direction = endValue.split("_")[1];
				if (direction === "short") {
					change %= cap;
					if (change !== change % (cap / 2)) {
						change += change < 0 ? cap : -cap;
					}
				}
				if (direction === "cw" && change < 0) {
					change = (change + cap * _bigNum$1) % cap - ~~(change / cap) * cap;
				} else if (direction === "ccw" && change > 0) {
					change = (change - cap * _bigNum$1) % cap - ~~(change / cap) * cap;
				}
			}
			plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
			pt.e = finalValue;
			pt.u = "deg";
			plugin._props.push(property);
			return pt;
		},
		_assign = function _assign(target, source) {
			for (var p in source) {
				target[p] = source[p];
			}
			return target;
		},
		_addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
			var startCache = _assign({}, target._gsap),
				exclude = "perspective,force3D,transformOrigin,svgOrigin",
				style = target.style,
				endCache,
				p,
				startValue,
				endValue,
				startNum,
				endNum,
				startUnit,
				endUnit;
			if (startCache.svg) {
				startValue = target.getAttribute("transform");
				target.setAttribute("transform", "");
				style[_transformProp] = transforms;
				endCache = _parseTransform(target, 1);
				_removeProperty(target, _transformProp);
				target.setAttribute("transform", startValue);
			} else {
				startValue = getComputedStyle(target)[_transformProp];
				style[_transformProp] = transforms;
				endCache = _parseTransform(target, 1);
				style[_transformProp] = startValue;
			}
			for (p in _transformProps) {
				startValue = startCache[p];
				endValue = endCache[p];
				if (startValue !== endValue && exclude.indexOf(p) < 0) {
					startUnit = getUnit(startValue);
					endUnit = getUnit(endValue);
					startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
					endNum = parseFloat(endValue);
					plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
					plugin._pt.u = endUnit || 0;
					plugin._props.push(p);
				}
			}
			_assign(endCache, startCache);
		};
	_forEachName("padding,margin,Width,Radius", function(name, index) {
		var t = "Top",
			r = "Right",
			b = "Bottom",
			l = "Left",
			props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function(side) {
				return index < 2 ? name + side : "border" + side + name;
			});
		_specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
			var a, vars;
			if (arguments.length < 4) {
				a = props.map(function(prop) {
					return _get(plugin, prop, property);
				});
				vars = a.join(" ");
				return vars.split(a[0]).length === 5 ? a[0] : vars;
			}
			a = (endValue + "").split(" ");
			vars = {};
			props.forEach(function(prop, i) {
				return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
			});
			plugin.init(target, vars, tween);
		};
	});
	var CSSPlugin = {
		name: "css",
		register: _initCore,
		targetTest: function targetTest(target) {
			return target.style && target.nodeType;
		},
		init: function init(target, vars, tween, index, targets) {
			var props = this._props,
				style = target.style,
				startAt = tween.vars.startAt,
				startValue,
				endValue,
				endNum,
				startNum,
				type,
				specialProp,
				p,
				startUnit,
				endUnit,
				relative,
				isTransformRelated,
				transformPropTween,
				cache,
				smooth,
				hasPriority,
				inlineProps;
			_pluginInitted || _initCore();
			this.styles = this.styles || _getStyleSaver(target);
			inlineProps = this.styles.props;
			this.tween = tween;
			for (p in vars) {
				if (p === "autoRound") {
					continue;
				}
				endValue = vars[p];
				if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
					continue;
				}
				type = typeof endValue;
				specialProp = _specialProps[p];
				if (type === "function") {
					endValue = endValue.call(tween, index, target, targets);
					type = typeof endValue;
				}
				if (type === "string" && ~endValue.indexOf("random(")) {
					endValue = _replaceRandom(endValue);
				}
				if (specialProp) {
					specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
				} else if (p.substr(0, 2) === "--") {
					startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
					endValue += "";
					_colorExp.lastIndex = 0;
					if (!_colorExp.test(startValue)) {
						startUnit = getUnit(startValue);
						endUnit = getUnit(endValue);
					}
					endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
					this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
					props.push(p);
					inlineProps.push(p, 0, style[p]);
				} else if (type !== "undefined") {
					if (startAt && p in startAt) {
						startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
						_isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
						getUnit(startValue + "") || (startValue += _config.units[p] || getUnit(_get(target, p)) || "");
						(startValue + "").charAt(1) === "=" && (startValue = _get(target, p));
					} else {
						startValue = _get(target, p);
					}
					startNum = parseFloat(startValue);
					relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
					relative && (endValue = endValue.substr(2));
					endNum = parseFloat(endValue);
					if (p in _propertyAliases) {
						if (p === "autoAlpha") {
							if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
								startNum = 0;
							}
							inlineProps.push("visibility", 0, style.visibility);
							_addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
						}
						if (p !== "scale" && p !== "transform") {
							p = _propertyAliases[p];
							~p.indexOf(",") && (p = p.split(",")[0]);
						}
					}
					isTransformRelated = p in _transformProps;
					if (isTransformRelated) {
						this.styles.save(p);
						if (!transformPropTween) {
							cache = target._gsap;
							cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
							smooth = vars.smoothOrigin !== false && cache.smooth;
							transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
							transformPropTween.dep = 1;
						}
						if (p === "scale") {
							this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
							this._pt.u = 0;
							props.push("scaleY", p);
							p += "X";
						} else if (p === "transformOrigin") {
							inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
							endValue = _convertKeywordsToPercentages(endValue);
							if (cache.svg) {
								_applySVGOrigin(target, endValue, 0, smooth, 0, this);
							} else {
								endUnit = parseFloat(endValue.split(" ")[2]) || 0;
								endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
								_addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
							}
							continue;
						} else if (p === "svgOrigin") {
							_applySVGOrigin(target, endValue, 1, smooth, 0, this);
							continue;
						} else if (p in _rotationalProperties) {
							_addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
							continue;
						} else if (p === "smoothOrigin") {
							_addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
							continue;
						} else if (p === "force3D") {
							cache[p] = endValue;
							continue;
						} else if (p === "transform") {
							_addRawTransformPTs(this, endValue, target);
							continue;
						}
					} else if (!(p in style)) {
						p = _checkPropPrefix(p) || p;
					}
					if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
						startUnit = (startValue + "").substr((startNum + "").length);
						endNum || (endNum = 0);
						endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
						startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
						this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
						this._pt.u = endUnit || 0;
						if (startUnit !== endUnit && endUnit !== "%") {
							this._pt.b = startValue;
							this._pt.r = _renderCSSPropWithBeginning;
						}
					} else if (!(p in style)) {
						if (p in target) {
							this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
						} else if (p !== "parseTransform") {
							_missingPlugin(p, endValue);
							continue;
						}
					} else {
						_tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
					}
					isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));
					props.push(p);
				}
			}
			hasPriority && _sortPropTweensByPriority(this);
		},
		render: function render(ratio, data) {
			if (data.tween._time || !_reverting$1()) {
				var pt = data._pt;
				while (pt) {
					pt.r(ratio, pt.d);
					pt = pt._next;
				}
			} else {
				data.styles.revert();
			}
		},
		get: _get,
		aliases: _propertyAliases,
		getSetter: function getSetter(target, property, plugin) {
			var p = _propertyAliases[property];
			p && p.indexOf(",") < 0 && (property = p);
			return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
		},
		core: {
			_removeProperty: _removeProperty,
			_getMatrix: _getMatrix
		}
	};
	gsap.utils.checkPrefix = _checkPropPrefix;
	gsap.core.getStyleSaver = _getStyleSaver;
	(function(positionAndScale, rotation, others, aliases) {
		var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
			_transformProps[name] = 1;
		});
		_forEachName(rotation, function(name) {
			_config.units[name] = "deg";
			_rotationalProperties[name] = 1;
		});
		_propertyAliases[all[13]] = positionAndScale + "," + rotation;
		_forEachName(aliases, function(name) {
			var split = name.split(":");
			_propertyAliases[split[1]] = all[split[0]];
		});
	})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
	_forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
		_config.units[name] = "px";
	});
	gsap.registerPlugin(CSSPlugin);
	var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap,
		TweenMaxWithCSS = gsapWithCSS.core.Tween;
	exports.Back = Back;
	exports.Bounce = Bounce;
	exports.CSSPlugin = CSSPlugin;
	exports.Circ = Circ;
	exports.Cubic = Cubic;
	exports.Elastic = Elastic;
	exports.Expo = Expo;
	exports.Linear = Linear;
	exports.Power0 = Power0;
	exports.Power1 = Power1;
	exports.Power2 = Power2;
	exports.Power3 = Power3;
	exports.Power4 = Power4;
	exports.Quad = Quad;
	exports.Quart = Quart;
	exports.Quint = Quint;
	exports.Sine = Sine;
	exports.SteppedEase = SteppedEase;
	exports.Strong = Strong;
	exports.TimelineLite = Timeline;
	exports.TimelineMax = Timeline;
	exports.TweenLite = Tween;
	exports.TweenMax = TweenMaxWithCSS;
	exports.default = gsapWithCSS;
	exports.gsap = gsapWithCSS;
	if (typeof(window) === 'undefined' || window !== exports) {
		Object.defineProperty(exports, '__esModule', {
			value: true
		});
	} else {
		delete window.default;
	}
})));
console.warn('Scripts "build/three.js" and "build/three.min.js" are deprecated with r150+, and will be removed with r160. Please use ES Modules or alternatives: https://threejs.org/docs/index.html#manual/en/introduction/Installation');
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
(function(global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.THREE = {}));
})(this, (function(exports) {
	'use strict';
	const REVISION = '150';
	const MOUSE = {
		LEFT: 0,
		MIDDLE: 1,
		RIGHT: 2,
		ROTATE: 0,
		DOLLY: 1,
		PAN: 2
	};
	const TOUCH = {
		ROTATE: 0,
		PAN: 1,
		DOLLY_PAN: 2,
		DOLLY_ROTATE: 3
	};
	const CullFaceNone = 0;
	const CullFaceBack = 1;
	const CullFaceFront = 2;
	const CullFaceFrontBack = 3;
	const BasicShadowMap = 0;
	const PCFShadowMap = 1;
	const PCFSoftShadowMap = 2;
	const VSMShadowMap = 3;
	const FrontSide = 0;
	const BackSide = 1;
	const DoubleSide = 2;
	const TwoPassDoubleSide = 2; // r149
	const NoBlending = 0;
	const NormalBlending = 1;
	const AdditiveBlending = 2;
	const SubtractiveBlending = 3;
	const MultiplyBlending = 4;
	const CustomBlending = 5;
	const AddEquation = 100;
	const SubtractEquation = 101;
	const ReverseSubtractEquation = 102;
	const MinEquation = 103;
	const MaxEquation = 104;
	const ZeroFactor = 200;
	const OneFactor = 201;
	const SrcColorFactor = 202;
	const OneMinusSrcColorFactor = 203;
	const SrcAlphaFactor = 204;
	const OneMinusSrcAlphaFactor = 205;
	const DstAlphaFactor = 206;
	const OneMinusDstAlphaFactor = 207;
	const DstColorFactor = 208;
	const OneMinusDstColorFactor = 209;
	const SrcAlphaSaturateFactor = 210;
	const NeverDepth = 0;
	const AlwaysDepth = 1;
	const LessDepth = 2;
	const LessEqualDepth = 3;
	const EqualDepth = 4;
	const GreaterEqualDepth = 5;
	const GreaterDepth = 6;
	const NotEqualDepth = 7;
	const MultiplyOperation = 0;
	const MixOperation = 1;
	const AddOperation = 2;
	const NoToneMapping = 0;
	const LinearToneMapping = 1;
	const ReinhardToneMapping = 2;
	const CineonToneMapping = 3;
	const ACESFilmicToneMapping = 4;
	const CustomToneMapping = 5;
	const UVMapping = 300;
	const CubeReflectionMapping = 301;
	const CubeRefractionMapping = 302;
	const EquirectangularReflectionMapping = 303;
	const EquirectangularRefractionMapping = 304;
	const CubeUVReflectionMapping = 306;
	const RepeatWrapping = 1000;
	const ClampToEdgeWrapping = 1001;
	const MirroredRepeatWrapping = 1002;
	const NearestFilter = 1003;
	const NearestMipmapNearestFilter = 1004;
	const NearestMipMapNearestFilter = 1004;
	const NearestMipmapLinearFilter = 1005;
	const NearestMipMapLinearFilter = 1005;
	const LinearFilter = 1006;
	const LinearMipmapNearestFilter = 1007;
	const LinearMipMapNearestFilter = 1007;
	const LinearMipmapLinearFilter = 1008;
	const LinearMipMapLinearFilter = 1008;
	const UnsignedByteType = 1009;
	const ByteType = 1010;
	const ShortType = 1011;
	const UnsignedShortType = 1012;
	const IntType = 1013;
	const UnsignedIntType = 1014;
	const FloatType = 1015;
	const HalfFloatType = 1016;
	const UnsignedShort4444Type = 1017;
	const UnsignedShort5551Type = 1018;
	const UnsignedInt248Type = 1020;
	const AlphaFormat = 1021;
	const RGBAFormat = 1023;
	const LuminanceFormat = 1024;
	const LuminanceAlphaFormat = 1025;
	const DepthFormat = 1026;
	const DepthStencilFormat = 1027;
	const RedFormat = 1028;
	const RedIntegerFormat = 1029;
	const RGFormat = 1030;
	const RGIntegerFormat = 1031;
	const RGBAIntegerFormat = 1033;
	const RGB_S3TC_DXT1_Format = 33776;
	const RGBA_S3TC_DXT1_Format = 33777;
	const RGBA_S3TC_DXT3_Format = 33778;
	const RGBA_S3TC_DXT5_Format = 33779;
	const RGB_PVRTC_4BPPV1_Format = 35840;
	const RGB_PVRTC_2BPPV1_Format = 35841;
	const RGBA_PVRTC_4BPPV1_Format = 35842;
	const RGBA_PVRTC_2BPPV1_Format = 35843;
	const RGB_ETC1_Format = 36196;
	const RGB_ETC2_Format = 37492;
	const RGBA_ETC2_EAC_Format = 37496;
	const RGBA_ASTC_4x4_Format = 37808;
	const RGBA_ASTC_5x4_Format = 37809;
	const RGBA_ASTC_5x5_Format = 37810;
	const RGBA_ASTC_6x5_Format = 37811;
	const RGBA_ASTC_6x6_Format = 37812;
	const RGBA_ASTC_8x5_Format = 37813;
	const RGBA_ASTC_8x6_Format = 37814;
	const RGBA_ASTC_8x8_Format = 37815;
	const RGBA_ASTC_10x5_Format = 37816;
	const RGBA_ASTC_10x6_Format = 37817;
	const RGBA_ASTC_10x8_Format = 37818;
	const RGBA_ASTC_10x10_Format = 37819;
	const RGBA_ASTC_12x10_Format = 37820;
	const RGBA_ASTC_12x12_Format = 37821;
	const RGBA_BPTC_Format = 36492;
	const RED_RGTC1_Format = 36283;
	const SIGNED_RED_RGTC1_Format = 36284;
	const RED_GREEN_RGTC2_Format = 36285;
	const SIGNED_RED_GREEN_RGTC2_Format = 36286;
	const LoopOnce = 2200;
	const LoopRepeat = 2201;
	const LoopPingPong = 2202;
	const InterpolateDiscrete = 2300;
	const InterpolateLinear = 2301;
	const InterpolateSmooth = 2302;
	const ZeroCurvatureEnding = 2400;
	const ZeroSlopeEnding = 2401;
	const WrapAroundEnding = 2402;
	const NormalAnimationBlendMode = 2500;
	const AdditiveAnimationBlendMode = 2501;
	const TrianglesDrawMode = 0;
	const TriangleStripDrawMode = 1;
	const TriangleFanDrawMode = 2;
	const LinearEncoding = 3000;
	const sRGBEncoding = 3001;
	const BasicDepthPacking = 3200;
	const RGBADepthPacking = 3201;
	const TangentSpaceNormalMap = 0;
	const ObjectSpaceNormalMap = 1;
	// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
	const NoColorSpace = '';
	const SRGBColorSpace = 'srgb';
	const LinearSRGBColorSpace = 'srgb-linear';
	const DisplayP3ColorSpace = 'display-p3';
	const ZeroStencilOp = 0;
	const KeepStencilOp = 7680;
	const ReplaceStencilOp = 7681;
	const IncrementStencilOp = 7682;
	const DecrementStencilOp = 7683;
	const IncrementWrapStencilOp = 34055;
	const DecrementWrapStencilOp = 34056;
	const InvertStencilOp = 5386;
	const NeverStencilFunc = 512;
	const LessStencilFunc = 513;
	const EqualStencilFunc = 514;
	const LessEqualStencilFunc = 515;
	const GreaterStencilFunc = 516;
	const NotEqualStencilFunc = 517;
	const GreaterEqualStencilFunc = 518;
	const AlwaysStencilFunc = 519;
	const StaticDrawUsage = 35044;
	const DynamicDrawUsage = 35048;
	const StreamDrawUsage = 35040;
	const StaticReadUsage = 35045;
	const DynamicReadUsage = 35049;
	const StreamReadUsage = 35041;
	const StaticCopyUsage = 35046;
	const DynamicCopyUsage = 35050;
	const StreamCopyUsage = 35042;
	const GLSL1 = '100';
	const GLSL3 = '300 es';
	const _SRGBAFormat = 1035; // fallback for WebGL 1
	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */
	class EventDispatcher {
		addEventListener(type, listener) {
			if (this._listeners === undefined) this._listeners = {};
			const listeners = this._listeners;
			if (listeners[type] === undefined) {
				listeners[type] = [];
			}
			if (listeners[type].indexOf(listener) === -1) {
				listeners[type].push(listener);
			}
		}
		hasEventListener(type, listener) {
			if (this._listeners === undefined) return false;
			const listeners = this._listeners;
			return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
		}
		removeEventListener(type, listener) {
			if (this._listeners === undefined) return;
			const listeners = this._listeners;
			const listenerArray = listeners[type];
			if (listenerArray !== undefined) {
				const index = listenerArray.indexOf(listener);
				if (index !== -1) {
					listenerArray.splice(index, 1);
				}
			}
		}
		dispatchEvent(event) {
			if (this._listeners === undefined) return;
			const listeners = this._listeners;
			const listenerArray = listeners[event.type];
			if (listenerArray !== undefined) {
				event.target = this;
				// Make a copy, in case listeners are removed while iterating.
				const array = listenerArray.slice(0);
				for (let i = 0, l = array.length; i < l; i++) {
					array[i].call(this, event);
				}
				event.target = null;
			}
		}
	}
	const _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];
	let _seed = 1234567;
	const DEG2RAD = Math.PI / 180;
	const RAD2DEG = 180 / Math.PI;
	// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
	function generateUUID() {
		const d0 = Math.random() * 0xffffffff | 0;
		const d1 = Math.random() * 0xffffffff | 0;
		const d2 = Math.random() * 0xffffffff | 0;
		const d3 = Math.random() * 0xffffffff | 0;
		const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +
			_lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +
			_lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +
			_lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];
		// .toLowerCase() here flattens concatenated strings to save heap memory space.
		return uuid.toLowerCase();
	}

	function clamp(value, min, max) {
		return Math.max(min, Math.min(max, value));
	}
	// compute euclidean modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation
	function euclideanModulo(n, m) {
		return ((n % m) + m) % m;
	}
	// Linear mapping from range <a1, a2> to range <b1, b2>
	function mapLinear(x, a1, a2, b1, b2) {
		return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
	}
	// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
	function inverseLerp(x, y, value) {
		if (x !== y) {
			return (value - x) / (y - x);
		} else {
			return 0;
		}
	}
	// https://en.wikipedia.org/wiki/Linear_interpolation
	function lerp(x, y, t) {
		return (1 - t) * x + t * y;
	}
	// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
	function damp(x, y, lambda, dt) {
		return lerp(x, y, 1 - Math.exp(-lambda * dt));
	}
	// https://www.desmos.com/calculator/vcsjnyz7x4
	function pingpong(x, length = 1) {
		return length - Math.abs(euclideanModulo(x, length * 2) - length);
	}
	// http://en.wikipedia.org/wiki/Smoothstep
	function smoothstep(x, min, max) {
		if (x <= min) return 0;
		if (x >= max) return 1;
		x = (x - min) / (max - min);
		return x * x * (3 - 2 * x);
	}

	function smootherstep(x, min, max) {
		if (x <= min) return 0;
		if (x >= max) return 1;
		x = (x - min) / (max - min);
		return x * x * x * (x * (x * 6 - 15) + 10);
	}
	// Random integer from <low, high> interval
	function randInt(low, high) {
		return low + Math.floor(Math.random() * (high - low + 1));
	}
	// Random float from <low, high> interval
	function randFloat(low, high) {
		return low + Math.random() * (high - low);
	}
	// Random float from <-range/2, range/2> interval
	function randFloatSpread(range) {
		return range * (0.5 - Math.random());
	}
	// Deterministic pseudo-random float in the interval [ 0, 1 ]
	function seededRandom(s) {
		if (s !== undefined) _seed = s;
		// Mulberry32 generator
		let t = _seed += 0x6D2B79F5;
		t = Math.imul(t ^ t >>> 15, t | 1);
		t ^= t + Math.imul(t ^ t >>> 7, t | 61);
		return ((t ^ t >>> 14) >>> 0) / 4294967296;
	}

	function degToRad(degrees) {
		return degrees * DEG2RAD;
	}

	function radToDeg(radians) {
		return radians * RAD2DEG;
	}

	function isPowerOfTwo(value) {
		return (value & (value - 1)) === 0 && value !== 0;
	}

	function ceilPowerOfTwo(value) {
		return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
	}

	function floorPowerOfTwo(value) {
		return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
	}

	function setQuaternionFromProperEuler(q, a, b, c, order) {
		// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
		// rotations are applied to the axes in the order specified by 'order'
		// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
		// angles are in radians
		const cos = Math.cos;
		const sin = Math.sin;
		const c2 = cos(b / 2);
		const s2 = sin(b / 2);
		const c13 = cos((a + c) / 2);
		const s13 = sin((a + c) / 2);
		const c1_3 = cos((a - c) / 2);
		const s1_3 = sin((a - c) / 2);
		const c3_1 = cos((c - a) / 2);
		const s3_1 = sin((c - a) / 2);
		switch (order) {
			case 'XYX':
				q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
				break;
			case 'YZY':
				q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
				break;
			case 'ZXZ':
				q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
				break;
			case 'XZX':
				q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
				break;
			case 'YXY':
				q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
				break;
			case 'ZYZ':
				q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
				break;
			default:
				console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
		}
	}

	function denormalize(value, array) {
		switch (array.constructor) {
			case Float32Array:
				return value;
			case Uint16Array:
				return value / 65535.0;
			case Uint8Array:
				return value / 255.0;
			case Int16Array:
				return Math.max(value / 32767.0, -1.0);
			case Int8Array:
				return Math.max(value / 127.0, -1.0);
			default:
				throw new Error('Invalid component type.');
		}
	}

	function normalize(value, array) {
		switch (array.constructor) {
			case Float32Array:
				return value;
			case Uint16Array:
				return Math.round(value * 65535.0);
			case Uint8Array:
				return Math.round(value * 255.0);
			case Int16Array:
				return Math.round(value * 32767.0);
			case Int8Array:
				return Math.round(value * 127.0);
			default:
				throw new Error('Invalid component type.');
		}
	}
	const MathUtils = {
		DEG2RAD: DEG2RAD,
		RAD2DEG: RAD2DEG,
		generateUUID: generateUUID,
		clamp: clamp,
		euclideanModulo: euclideanModulo,
		mapLinear: mapLinear,
		inverseLerp: inverseLerp,
		lerp: lerp,
		damp: damp,
		pingpong: pingpong,
		smoothstep: smoothstep,
		smootherstep: smootherstep,
		randInt: randInt,
		randFloat: randFloat,
		randFloatSpread: randFloatSpread,
		seededRandom: seededRandom,
		degToRad: degToRad,
		radToDeg: radToDeg,
		isPowerOfTwo: isPowerOfTwo,
		ceilPowerOfTwo: ceilPowerOfTwo,
		floorPowerOfTwo: floorPowerOfTwo,
		setQuaternionFromProperEuler: setQuaternionFromProperEuler,
		normalize: normalize,
		denormalize: denormalize
	};
	class Vector2 {
		constructor(x = 0, y = 0) {
			Vector2.prototype.isVector2 = true;
			this.x = x;
			this.y = y;
		}
		get width() {
			return this.x;
		}
		set width(value) {
			this.x = value;
		}
		get height() {
			return this.y;
		}
		set height(value) {
			this.y = value;
		}
		set(x, y) {
			this.x = x;
			this.y = y;
			return this;
		}
		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			return this;
		}
		setX(x) {
			this.x = x;
			return this;
		}
		setY(y) {
			this.y = y;
			return this;
		}
		setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;
				case 1:
					this.y = value;
					break;
				default:
					throw new Error('index is out of range: ' + index);
			}
			return this;
		}
		getComponent(index) {
			switch (index) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				default:
					throw new Error('index is out of range: ' + index);
			}
		}
		clone() {
			return new this.constructor(this.x, this.y);
		}
		copy(v) {
			this.x = v.x;
			this.y = v.y;
			return this;
		}
		add(v) {
			this.x += v.x;
			this.y += v.y;
			return this;
		}
		addScalar(s) {
			this.x += s;
			this.y += s;
			return this;
		}
		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			return this;
		}
		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			return this;
		}
		sub(v) {
			this.x -= v.x;
			this.y -= v.y;
			return this;
		}
		subScalar(s) {
			this.x -= s;
			this.y -= s;
			return this;
		}
		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			return this;
		}
		multiply(v) {
			this.x *= v.x;
			this.y *= v.y;
			return this;
		}
		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			return this;
		}
		divide(v) {
			this.x /= v.x;
			this.y /= v.y;
			return this;
		}
		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		}
		applyMatrix3(m) {
			const x = this.x,
				y = this.y;
			const e = m.elements;
			this.x = e[0] * x + e[3] * y + e[6];
			this.y = e[1] * x + e[4] * y + e[7];
			return this;
		}
		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			return this;
		}
		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			return this;
		}
		clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			return this;
		}
		clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			return this;
		}
		clampLength(min, max) {
			const length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		}
		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			return this;
		}
		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			return this;
		}
		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			return this;
		}
		roundToZero() {
			this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
			return this;
		}
		negate() {
			this.x = -this.x;
			this.y = -this.y;
			return this;
		}
		dot(v) {
			return this.x * v.x + this.y * v.y;
		}
		cross(v) {
			return this.x * v.y - this.y * v.x;
		}
		lengthSq() {
			return this.x * this.x + this.y * this.y;
		}
		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		}
		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y);
		}
		normalize() {
			return this.divideScalar(this.length() || 1);
		}
		angle() {
			// computes the angle in radians with respect to the positive x-axis
			const angle = Math.atan2(-this.y, -this.x) + Math.PI;
			return angle;
		}
		distanceTo(v) {
			return Math.sqrt(this.distanceToSquared(v));
		}
		distanceToSquared(v) {
			const dx = this.x - v.x,
				dy = this.y - v.y;
			return dx * dx + dy * dy;
		}
		manhattanDistanceTo(v) {
			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
		}
		setLength(length) {
			return this.normalize().multiplyScalar(length);
		}
		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			return this;
		}
		lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			return this;
		}
		equals(v) {
			return ((v.x === this.x) && (v.y === this.y));
		}
		fromArray(array, offset = 0) {
			this.x = array[offset];
			this.y = array[offset + 1];
			return this;
		}
		toArray(array = [], offset = 0) {
			array[offset] = this.x;
			array[offset + 1] = this.y;
			return array;
		}
		fromBufferAttribute(attribute, index) {
			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			return this;
		}
		rotateAround(center, angle) {
			const c = Math.cos(angle),
				s = Math.sin(angle);
			const x = this.x - center.x;
			const y = this.y - center.y;
			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;
			return this;
		}
		random() {
				this.x = Math.random();
				this.y = Math.random();
				return this;
			}
			*[Symbol.iterator]() {
				yield this.x;
				yield this.y;
			}
	}
	class Matrix3 {
		constructor() {
			Matrix3.prototype.isMatrix3 = true;
			this.elements = [
				1, 0, 0,
				0, 1, 0,
				0, 0, 1
			];
		}
		set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
			const te = this.elements;
			te[0] = n11;
			te[1] = n21;
			te[2] = n31;
			te[3] = n12;
			te[4] = n22;
			te[5] = n32;
			te[6] = n13;
			te[7] = n23;
			te[8] = n33;
			return this;
		}
		identity() {
			this.set(
				1, 0, 0,
				0, 1, 0,
				0, 0, 1
			);
			return this;
		}
		copy(m) {
			const te = this.elements;
			const me = m.elements;
			te[0] = me[0];
			te[1] = me[1];
			te[2] = me[2];
			te[3] = me[3];
			te[4] = me[4];
			te[5] = me[5];
			te[6] = me[6];
			te[7] = me[7];
			te[8] = me[8];
			return this;
		}
		extractBasis(xAxis, yAxis, zAxis) {
			xAxis.setFromMatrix3Column(this, 0);
			yAxis.setFromMatrix3Column(this, 1);
			zAxis.setFromMatrix3Column(this, 2);
			return this;
		}
		setFromMatrix4(m) {
			const me = m.elements;
			this.set(
				me[0], me[4], me[8],
				me[1], me[5], me[9],
				me[2], me[6], me[10]
			);
			return this;
		}
		multiply(m) {
			return this.multiplyMatrices(this, m);
		}
		premultiply(m) {
			return this.multiplyMatrices(m, this);
		}
		multiplyMatrices(a, b) {
			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;
			const a11 = ae[0],
				a12 = ae[3],
				a13 = ae[6];
			const a21 = ae[1],
				a22 = ae[4],
				a23 = ae[7];
			const a31 = ae[2],
				a32 = ae[5],
				a33 = ae[8];
			const b11 = be[0],
				b12 = be[3],
				b13 = be[6];
			const b21 = be[1],
				b22 = be[4],
				b23 = be[7];
			const b31 = be[2],
				b32 = be[5],
				b33 = be[8];
			te[0] = a11 * b11 + a12 * b21 + a13 * b31;
			te[3] = a11 * b12 + a12 * b22 + a13 * b32;
			te[6] = a11 * b13 + a12 * b23 + a13 * b33;
			te[1] = a21 * b11 + a22 * b21 + a23 * b31;
			te[4] = a21 * b12 + a22 * b22 + a23 * b32;
			te[7] = a21 * b13 + a22 * b23 + a23 * b33;
			te[2] = a31 * b11 + a32 * b21 + a33 * b31;
			te[5] = a31 * b12 + a32 * b22 + a33 * b32;
			te[8] = a31 * b13 + a32 * b23 + a33 * b33;
			return this;
		}
		multiplyScalar(s) {
			const te = this.elements;
			te[0] *= s;
			te[3] *= s;
			te[6] *= s;
			te[1] *= s;
			te[4] *= s;
			te[7] *= s;
			te[2] *= s;
			te[5] *= s;
			te[8] *= s;
			return this;
		}
		determinant() {
			const te = this.elements;
			const a = te[0],
				b = te[1],
				c = te[2],
				d = te[3],
				e = te[4],
				f = te[5],
				g = te[6],
				h = te[7],
				i = te[8];
			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
		}
		invert() {
			const te = this.elements,
				n11 = te[0],
				n21 = te[1],
				n31 = te[2],
				n12 = te[3],
				n22 = te[4],
				n32 = te[5],
				n13 = te[6],
				n23 = te[7],
				n33 = te[8],
				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,
				det = n11 * t11 + n21 * t12 + n31 * t13;
			if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
			const detInv = 1 / det;
			te[0] = t11 * detInv;
			te[1] = (n31 * n23 - n33 * n21) * detInv;
			te[2] = (n32 * n21 - n31 * n22) * detInv;
			te[3] = t12 * detInv;
			te[4] = (n33 * n11 - n31 * n13) * detInv;
			te[5] = (n31 * n12 - n32 * n11) * detInv;
			te[6] = t13 * detInv;
			te[7] = (n21 * n13 - n23 * n11) * detInv;
			te[8] = (n22 * n11 - n21 * n12) * detInv;
			return this;
		}
		transpose() {
			let tmp;
			const m = this.elements;
			tmp = m[1];
			m[1] = m[3];
			m[3] = tmp;
			tmp = m[2];
			m[2] = m[6];
			m[6] = tmp;
			tmp = m[5];
			m[5] = m[7];
			m[7] = tmp;
			return this;
		}
		getNormalMatrix(matrix4) {
			return this.setFromMatrix4(matrix4).invert().transpose();
		}
		transposeIntoArray(r) {
			const m = this.elements;
			r[0] = m[0];
			r[1] = m[3];
			r[2] = m[6];
			r[3] = m[1];
			r[4] = m[4];
			r[5] = m[7];
			r[6] = m[2];
			r[7] = m[5];
			r[8] = m[8];
			return this;
		}
		setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
			const c = Math.cos(rotation);
			const s = Math.sin(rotation);
			this.set(
				sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx,
				-sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty,
				0, 0, 1
			);
			return this;
		}
		//
		scale(sx, sy) {
			this.premultiply(_m3.makeScale(sx, sy));
			return this;
		}
		rotate(theta) {
			this.premultiply(_m3.makeRotation(-theta));
			return this;
		}
		translate(tx, ty) {
			this.premultiply(_m3.makeTranslation(tx, ty));
			return this;
		}
		// for 2D Transforms
		makeTranslation(x, y) {
			this.set(
				1, 0, x,
				0, 1, y,
				0, 0, 1
			);
			return this;
		}
		makeRotation(theta) {
			// counterclockwise
			const c = Math.cos(theta);
			const s = Math.sin(theta);
			this.set(
				c, -s, 0,
				s, c, 0,
				0, 0, 1
			);
			return this;
		}
		makeScale(x, y) {
			this.set(
				x, 0, 0,
				0, y, 0,
				0, 0, 1
			);
			return this;
		}
		//
		equals(matrix) {
			const te = this.elements;
			const me = matrix.elements;
			for (let i = 0; i < 9; i++) {
				if (te[i] !== me[i]) return false;
			}
			return true;
		}
		fromArray(array, offset = 0) {
			for (let i = 0; i < 9; i++) {
				this.elements[i] = array[i + offset];
			}
			return this;
		}
		toArray(array = [], offset = 0) {
			const te = this.elements;
			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];
			array[offset + 3] = te[3];
			array[offset + 4] = te[4];
			array[offset + 5] = te[5];
			array[offset + 6] = te[6];
			array[offset + 7] = te[7];
			array[offset + 8] = te[8];
			return array;
		}
		clone() {
			return new this.constructor().fromArray(this.elements);
		}
	}
	const _m3 = /*@__PURE__*/ new Matrix3();

	function arrayNeedsUint32(array) {
		// assumes larger values usually on last
		for (let i = array.length - 1; i >= 0; --i) {
			if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
		}
		return false;
	}
	const TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		Uint8ClampedArray: Uint8ClampedArray,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};

	function getTypedArray(type, buffer) {
		return new TYPED_ARRAYS[type](buffer);
	}

	function createElementNS(name) {
		return document.createElementNS('http://www.w3.org/1999/xhtml', name);
	}
	class Quaternion {
		constructor(x = 0, y = 0, z = 0, w = 1) {
			this.isQuaternion = true;
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
		}
		static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
			// fuzz-free, array-based Quaternion SLERP operation
			let x0 = src0[srcOffset0 + 0],
				y0 = src0[srcOffset0 + 1],
				z0 = src0[srcOffset0 + 2],
				w0 = src0[srcOffset0 + 3];
			const x1 = src1[srcOffset1 + 0],
				y1 = src1[srcOffset1 + 1],
				z1 = src1[srcOffset1 + 2],
				w1 = src1[srcOffset1 + 3];
			if (t === 0) {
				dst[dstOffset + 0] = x0;
				dst[dstOffset + 1] = y0;
				dst[dstOffset + 2] = z0;
				dst[dstOffset + 3] = w0;
				return;
			}
			if (t === 1) {
				dst[dstOffset + 0] = x1;
				dst[dstOffset + 1] = y1;
				dst[dstOffset + 2] = z1;
				dst[dstOffset + 3] = w1;
				return;
			}
			if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
				let s = 1 - t;
				const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
					dir = (cos >= 0 ? 1 : -1),
					sqrSin = 1 - cos * cos;
				// Skip the Slerp for tiny steps to avoid numeric problems:
				if (sqrSin > Number.EPSILON) {
					const sin = Math.sqrt(sqrSin),
						len = Math.atan2(sin, cos * dir);
					s = Math.sin(s * len) / sin;
					t = Math.sin(t * len) / sin;
				}
				const tDir = t * dir;
				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;
				// Normalize in case we just did a lerp:
				if (s === 1 - t) {
					const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;
				}
			}
			dst[dstOffset] = x0;
			dst[dstOffset + 1] = y0;
			dst[dstOffset + 2] = z0;
			dst[dstOffset + 3] = w0;
		}
		static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
			const x0 = src0[srcOffset0];
			const y0 = src0[srcOffset0 + 1];
			const z0 = src0[srcOffset0 + 2];
			const w0 = src0[srcOffset0 + 3];
			const x1 = src1[srcOffset1];
			const y1 = src1[srcOffset1 + 1];
			const z1 = src1[srcOffset1 + 2];
			const w1 = src1[srcOffset1 + 3];
			dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
			dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
			dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
			dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
			return dst;
		}
		get x() {
			return this._x;
		}
		set x(value) {
			this._x = value;
			this._onChangeCallback();
		}
		get y() {
			return this._y;
		}
		set y(value) {
			this._y = value;
			this._onChangeCallback();
		}
		get z() {
			return this._z;
		}
		set z(value) {
			this._z = value;
			this._onChangeCallback();
		}
		get w() {
			return this._w;
		}
		set w(value) {
			this._w = value;
			this._onChangeCallback();
		}
		set(x, y, z, w) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
			this._onChangeCallback();
			return this;
		}
		clone() {
			return new this.constructor(this._x, this._y, this._z, this._w);
		}
		copy(quaternion) {
			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;
			this._onChangeCallback();
			return this;
		}
		setFromEuler(euler, update) {
			const x = euler._x,
				y = euler._y,
				z = euler._z,
				order = euler._order;
			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m
			const cos = Math.cos;
			const sin = Math.sin;
			const c1 = cos(x / 2);
			const c2 = cos(y / 2);
			const c3 = cos(z / 2);
			const s1 = sin(x / 2);
			const s2 = sin(y / 2);
			const s3 = sin(z / 2);
			switch (order) {
				case 'XYZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;
				case 'YXZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;
				case 'ZXY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;
				case 'ZYX':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;
				case 'YZX':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;
				case 'XZY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;
				default:
					console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
			}
			if (update !== false) this._onChangeCallback();
			return this;
		}
		setFromAxisAngle(axis, angle) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
			// assumes axis is normalized
			const halfAngle = angle / 2,
				s = Math.sin(halfAngle);
			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos(halfAngle);
			this._onChangeCallback();
			return this;
		}
		setFromRotationMatrix(m) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			const te = m.elements,
				m11 = te[0],
				m12 = te[4],
				m13 = te[8],
				m21 = te[1],
				m22 = te[5],
				m23 = te[9],
				m31 = te[2],
				m32 = te[6],
				m33 = te[10],
				trace = m11 + m22 + m33;
			if (trace > 0) {
				const s = 0.5 / Math.sqrt(trace + 1.0);
				this._w = 0.25 / s;
				this._x = (m32 - m23) * s;
				this._y = (m13 - m31) * s;
				this._z = (m21 - m12) * s;
			} else if (m11 > m22 && m11 > m33) {
				const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
				this._w = (m32 - m23) / s;
				this._x = 0.25 * s;
				this._y = (m12 + m21) / s;
				this._z = (m13 + m31) / s;
			} else if (m22 > m33) {
				const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
				this._w = (m13 - m31) / s;
				this._x = (m12 + m21) / s;
				this._y = 0.25 * s;
				this._z = (m23 + m32) / s;
			} else {
				const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
				this._w = (m21 - m12) / s;
				this._x = (m13 + m31) / s;
				this._y = (m23 + m32) / s;
				this._z = 0.25 * s;
			}
			this._onChangeCallback();
			return this;
		}
		setFromUnitVectors(vFrom, vTo) {
			// assumes direction vectors vFrom and vTo are normalized
			let r = vFrom.dot(vTo) + 1;
			if (r < Number.EPSILON) {
				// vFrom and vTo point in opposite directions
				r = 0;
				if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
					this._x = -vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;
				} else {
					this._x = 0;
					this._y = -vFrom.z;
					this._z = vFrom.y;
					this._w = r;
				}
			} else {
				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;
			}
			return this.normalize();
		}
		angleTo(q) {
			return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
		}
		rotateTowards(q, step) {
			const angle = this.angleTo(q);
			if (angle === 0) return this;
			const t = Math.min(1, step / angle);
			this.slerp(q, t);
			return this;
		}
		identity() {
			return this.set(0, 0, 0, 1);
		}
		invert() {
			// quaternion is assumed to have unit length
			return this.conjugate();
		}
		conjugate() {
			this._x *= -1;
			this._y *= -1;
			this._z *= -1;
			this._onChangeCallback();
			return this;
		}
		dot(v) {
			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
		}
		lengthSq() {
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
		}
		length() {
			return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
		}
		normalize() {
			let l = this.length();
			if (l === 0) {
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
			} else {
				l = 1 / l;
				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
			}
			this._onChangeCallback();
			return this;
		}
		multiply(q) {
			return this.multiplyQuaternions(this, q);
		}
		premultiply(q) {
			return this.multiplyQuaternions(q, this);
		}
		multiplyQuaternions(a, b) {
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
			const qax = a._x,
				qay = a._y,
				qaz = a._z,
				qaw = a._w;
			const qbx = b._x,
				qby = b._y,
				qbz = b._z,
				qbw = b._w;
			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
			this._onChangeCallback();
			return this;
		}
		slerp(qb, t) {
			if (t === 0) return this;
			if (t === 1) return this.copy(qb);
			const x = this._x,
				y = this._y,
				z = this._z,
				w = this._w;
			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
			let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
			if (cosHalfTheta < 0) {
				this._w = -qb._w;
				this._x = -qb._x;
				this._y = -qb._y;
				this._z = -qb._z;
				cosHalfTheta = -cosHalfTheta;
			} else {
				this.copy(qb);
			}
			if (cosHalfTheta >= 1.0) {
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
				return this;
			}
			const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
			if (sqrSinHalfTheta <= Number.EPSILON) {
				const s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;
				this.normalize();
				this._onChangeCallback();
				return this;
			}
			const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
			const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
			const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
				ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
			this._w = (w * ratioA + this._w * ratioB);
			this._x = (x * ratioA + this._x * ratioB);
			this._y = (y * ratioA + this._y * ratioB);
			this._z = (z * ratioA + this._z * ratioB);
			this._onChangeCallback();
			return this;
		}
		slerpQuaternions(qa, qb, t) {
			return this.copy(qa).slerp(qb, t);
		}
		random() {
			// Derived from http://planning.cs.uiuc.edu/node198.html
			// Note, this source uses w, x, y, z ordering,
			// so we swap the order below.
			const u1 = Math.random();
			const sqrt1u1 = Math.sqrt(1 - u1);
			const sqrtu1 = Math.sqrt(u1);
			const u2 = 2 * Math.PI * Math.random();
			const u3 = 2 * Math.PI * Math.random();
			return this.set(
				sqrt1u1 * Math.cos(u2),
				sqrtu1 * Math.sin(u3),
				sqrtu1 * Math.cos(u3),
				sqrt1u1 * Math.sin(u2),
			);
		}
		equals(quaternion) {
			return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
		}
		fromArray(array, offset = 0) {
			this._x = array[offset];
			this._y = array[offset + 1];
			this._z = array[offset + 2];
			this._w = array[offset + 3];
			this._onChangeCallback();
			return this;
		}
		toArray(array = [], offset = 0) {
			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._w;
			return array;
		}
		fromBufferAttribute(attribute, index) {
			this._x = attribute.getX(index);
			this._y = attribute.getY(index);
			this._z = attribute.getZ(index);
			this._w = attribute.getW(index);
			return this;
		}
		_onChange(callback) {
			this._onChangeCallback = callback;
			return this;
		}
		_onChangeCallback() {}
			*[Symbol.iterator]() {
				yield this._x;
				yield this._y;
				yield this._z;
				yield this._w;
			}
	}
	class Vector3 {
		constructor(x = 0, y = 0, z = 0) {
			Vector3.prototype.isVector3 = true;
			this.x = x;
			this.y = y;
			this.z = z;
		}
		set(x, y, z) {
			if (z === undefined) z = this.z; // sprite.scale.set(x,y)
			this.x = x;
			this.y = y;
			this.z = z;
			return this;
		}
		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			return this;
		}
		setX(x) {
			this.x = x;
			return this;
		}
		setY(y) {
			this.y = y;
			return this;
		}
		setZ(z) {
			this.z = z;
			return this;
		}
		setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;
				case 1:
					this.y = value;
					break;
				case 2:
					this.z = value;
					break;
				default:
					throw new Error('index is out of range: ' + index);
			}
			return this;
		}
		getComponent(index) {
			switch (index) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				case 2:
					return this.z;
				default:
					throw new Error('index is out of range: ' + index);
			}
		}
		clone() {
			return new this.constructor(this.x, this.y, this.z);
		}
		copy(v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			return this;
		}
		add(v) {
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			return this;
		}
		addScalar(s) {
			this.x += s;
			this.y += s;
			this.z += s;
			return this;
		}
		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			return this;
		}
		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			return this;
		}
		sub(v) {
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			return this;
		}
		subScalar(s) {
			this.x -= s;
			this.y -= s;
			this.z -= s;
			return this;
		}
		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			return this;
		}
		multiply(v) {
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			return this;
		}
		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			return this;
		}
		multiplyVectors(a, b) {
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
			return this;
		}
		applyEuler(euler) {
			return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
		}
		applyAxisAngle(axis, angle) {
			return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
		}
		applyMatrix3(m) {
			const x = this.x,
				y = this.y,
				z = this.z;
			const e = m.elements;
			this.x = e[0] * x + e[3] * y + e[6] * z;
			this.y = e[1] * x + e[4] * y + e[7] * z;
			this.z = e[2] * x + e[5] * y + e[8] * z;
			return this;
		}
		applyNormalMatrix(m) {
			return this.applyMatrix3(m).normalize();
		}
		applyMatrix4(m) {
			const x = this.x,
				y = this.y,
				z = this.z;
			const e = m.elements;
			const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
			this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
			this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
			this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
			return this;
		}
		applyQuaternion(q) {
			const x = this.x,
				y = this.y,
				z = this.z;
			const qx = q.x,
				qy = q.y,
				qz = q.z,
				qw = q.w;
			// calculate quat * vector
			const ix = qw * x + qy * z - qz * y;
			const iy = qw * y + qz * x - qx * z;
			const iz = qw * z + qx * y - qy * x;
			const iw = -qx * x - qy * y - qz * z;
			// calculate result * inverse quat
			this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
			this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
			this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
			return this;
		}
		project(camera) {
			return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
		}
		unproject(camera) {
			return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
		}
		transformDirection(m) {
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
			const x = this.x,
				y = this.y,
				z = this.z;
			const e = m.elements;
			this.x = e[0] * x + e[4] * y + e[8] * z;
			this.y = e[1] * x + e[5] * y + e[9] * z;
			this.z = e[2] * x + e[6] * y + e[10] * z;
			return this.normalize();
		}
		divide(v) {
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
			return this;
		}
		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		}
		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);
			return this;
		}
		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);
			return this;
		}
		clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));
			return this;
		}
		clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			this.z = Math.max(minVal, Math.min(maxVal, this.z));
			return this;
		}
		clampLength(min, max) {
			const length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		}
		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			return this;
		}
		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			return this;
		}
		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			return this;
		}
		roundToZero() {
			this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
			return this;
		}
		negate() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			return this;
		}
		dot(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z;
		}
		// TODO lengthSquared?
		lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z;
		}
		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		}
		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
		}
		normalize() {
			return this.divideScalar(this.length() || 1);
		}
		setLength(length) {
			return this.normalize().multiplyScalar(length);
		}
		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;
			return this;
		}
		lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			this.z = v1.z + (v2.z - v1.z) * alpha;
			return this;
		}
		cross(v) {
			return this.crossVectors(this, v);
		}
		crossVectors(a, b) {
			const ax = a.x,
				ay = a.y,
				az = a.z;
			const bx = b.x,
				by = b.y,
				bz = b.z;
			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;
			return this;
		}
		projectOnVector(v) {
			const denominator = v.lengthSq();
			if (denominator === 0) return this.set(0, 0, 0);
			const scalar = v.dot(this) / denominator;
			return this.copy(v).multiplyScalar(scalar);
		}
		projectOnPlane(planeNormal) {
			_vector$d.copy(this).projectOnVector(planeNormal);
			return this.sub(_vector$d);
		}
		reflect(normal) {
			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length
			return this.sub(_vector$d.copy(normal).multiplyScalar(2 * this.dot(normal)));
		}
		angleTo(v) {
			const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
			if (denominator === 0) return Math.PI / 2;
			const theta = this.dot(v) / denominator;
			// clamp, to handle numerical problems
			return Math.acos(clamp(theta, -1, 1));
		}
		distanceTo(v) {
			return Math.sqrt(this.distanceToSquared(v));
		}
		distanceToSquared(v) {
			const dx = this.x - v.x,
				dy = this.y - v.y,
				dz = this.z - v.z;
			return dx * dx + dy * dy + dz * dz;
		}
		manhattanDistanceTo(v) {
			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
		}
		setFromSpherical(s) {
			return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
		}
		setFromSphericalCoords(radius, phi, theta) {
			const sinPhiRadius = Math.sin(phi) * radius;
			this.x = sinPhiRadius * Math.sin(theta);
			this.y = Math.cos(phi) * radius;
			this.z = sinPhiRadius * Math.cos(theta);
			return this;
		}
		setFromCylindrical(c) {
			return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
		}
		setFromCylindricalCoords(radius, theta, y) {
			this.x = radius * Math.sin(theta);
			this.y = y;
			this.z = radius * Math.cos(theta);
			return this;
		}
		setFromMatrixPosition(m) {
			const e = m.elements;
			this.x = e[12];
			this.y = e[13];
			this.z = e[14];
			return this;
		}
		setFromMatrixScale(m) {
			const sx = this.setFromMatrixColumn(m, 0).length();
			const sy = this.setFromMatrixColumn(m, 1).length();
			const sz = this.setFromMatrixColumn(m, 2).length();
			this.x = sx;
			this.y = sy;
			this.z = sz;
			return this;
		}
		setFromMatrixColumn(m, index) {
			return this.fromArray(m.elements, index * 4);
		}
		setFromMatrix3Column(m, index) {
			return this.fromArray(m.elements, index * 3);
		}
		setFromEuler(e) {
			this.x = e._x;
			this.y = e._y;
			this.z = e._z;
			return this;
		}
		equals(v) {
			return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
		}
		fromArray(array, offset = 0) {
			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];
			return this;
		}
		toArray(array = [], offset = 0) {
			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;
			return array;
		}
		fromBufferAttribute(attribute, index) {
			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			this.z = attribute.getZ(index);
			return this;
		}
		random() {
			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			return this;
		}
		randomDirection() {
				// Derived from https://mathworld.wolfram.com/SpherePointPicking.html
				const u = (Math.random() - 0.5) * 2;
				const t = Math.random() * Math.PI * 2;
				const f = Math.sqrt(1 - u ** 2);
				this.x = f * Math.cos(t);
				this.y = f * Math.sin(t);
				this.z = u;
				return this;
			}
			*[Symbol.iterator]() {
				yield this.x;
				yield this.y;
				yield this.z;
			}
	}
	const _vector$d = /*@__PURE__*/ new Vector3();
	const _quaternion$4 = /*@__PURE__*/ new Quaternion();

	function SRGBToLinear(c) {
		return (c < 0.04045) ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
	}

	function LinearToSRGB(c) {
		return (c < 0.0031308) ? c * 12.92 : 1.055 * (Math.pow(c, 0.41666)) - 0.055;
	}
	/**
	 * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping
	 * or clipping. Based on W3C specifications for sRGB and Display P3,
	 * and ICC specifications for the D50 connection space. Values in/out
	 * are _linear_ sRGB and _linear_ Display P3.
	 *
	 * Note that both sRGB and Display P3 use the sRGB transfer functions.
	 *
	 * Reference:
	 * - http://www.russellcottrell.com/photo/matrixCalculator.htm
	 */
	const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = new Matrix3().fromArray([
		0.8224621, 0.0331941, 0.0170827,
		0.1775380, 0.9668058, 0.0723974,
		-0.0000001, 0.0000001, 0.9105199
	]);
	const LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = new Matrix3().fromArray([
		1.2249401, -0.0420569, -0.0196376,
		-0.2249404, 1.0420571, -0.0786361,
		0.0000001, 0.0000000, 1.0982735
	]);
	const _vector$c = new Vector3();

	function DisplayP3ToLinearSRGB(color) {
		color.convertSRGBToLinear();
		_vector$c.set(color.r, color.g, color.b).applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB);
		return color.setRGB(_vector$c.x, _vector$c.y, _vector$c.z);
	}

	function LinearSRGBToDisplayP3(color) {
		_vector$c.set(color.r, color.g, color.b).applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3);
		return color.setRGB(_vector$c.x, _vector$c.y, _vector$c.z).convertLinearToSRGB();
	}
	// Conversions from <source> to Linear-sRGB reference space.
	const TO_LINEAR = {
		[LinearSRGBColorSpace]: (color) => color,
		[SRGBColorSpace]: (color) => color.convertSRGBToLinear(),
		[DisplayP3ColorSpace]: DisplayP3ToLinearSRGB,
	};
	// Conversions to <target> from Linear-sRGB reference space.
	const FROM_LINEAR = {
		[LinearSRGBColorSpace]: (color) => color,
		[SRGBColorSpace]: (color) => color.convertLinearToSRGB(),
		[DisplayP3ColorSpace]: LinearSRGBToDisplayP3,
	};
	const ColorManagement = {
		enabled: false,
		get legacyMode() {
			console.warn('THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.');
			return !this.enabled;
		},
		set legacyMode(legacyMode) {
			console.warn('THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.');
			this.enabled = !legacyMode;
		},
		get workingColorSpace() {
			return LinearSRGBColorSpace;
		},
		set workingColorSpace(colorSpace) {
			console.warn('THREE.ColorManagement: .workingColorSpace is readonly.');
		},
		convert: function(color, sourceColorSpace, targetColorSpace) {
			if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
				return color;
			}
			const sourceToLinear = TO_LINEAR[sourceColorSpace];
			const targetFromLinear = FROM_LINEAR[targetColorSpace];
			if (sourceToLinear === undefined || targetFromLinear === undefined) {
				throw new Error(`Unsupported color space conversion, "${ sourceColorSpace }" to "${ targetColorSpace }".`);
			}
			return targetFromLinear(sourceToLinear(color));
		},
		fromWorkingColorSpace: function(color, targetColorSpace) {
			return this.convert(color, this.workingColorSpace, targetColorSpace);
		},
		toWorkingColorSpace: function(color, sourceColorSpace) {
			return this.convert(color, sourceColorSpace, this.workingColorSpace);
		},
	};
	let _canvas;
	class ImageUtils {
		static getDataURL(image) {
			if (/^data:/i.test(image.src)) {
				return image.src;
			}
			if (typeof HTMLCanvasElement == 'undefined') {
				return image.src;
			}
			let canvas;
			if (image instanceof HTMLCanvasElement) {
				canvas = image;
			} else {
				if (_canvas === undefined) _canvas = createElementNS('canvas');
				_canvas.width = image.width;
				_canvas.height = image.height;
				const context = _canvas.getContext('2d');
				if (image instanceof ImageData) {
					context.putImageData(image, 0, 0);
				} else {
					context.drawImage(image, 0, 0, image.width, image.height);
				}
				canvas = _canvas;
			}
			if (canvas.width > 2048 || canvas.height > 2048) {
				console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
				return canvas.toDataURL('image/jpeg', 0.6);
			} else {
				return canvas.toDataURL('image/png');
			}
		}
		static sRGBToLinear(image) {
			if ((typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||
				(typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||
				(typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)) {
				const canvas = createElementNS('canvas');
				canvas.width = image.width;
				canvas.height = image.height;
				const context = canvas.getContext('2d');
				context.drawImage(image, 0, 0, image.width, image.height);
				const imageData = context.getImageData(0, 0, image.width, image.height);
				const data = imageData.data;
				for (let i = 0; i < data.length; i++) {
					data[i] = SRGBToLinear(data[i] / 255) * 255;
				}
				context.putImageData(imageData, 0, 0);
				return canvas;
			} else if (image.data) {
				const data = image.data.slice(0);
				for (let i = 0; i < data.length; i++) {
					if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
						data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
					} else {
						// assuming float
						data[i] = SRGBToLinear(data[i]);
					}
				}
				return {
					data: data,
					width: image.width,
					height: image.height
				};
			} else {
				console.warn('THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.');
				return image;
			}
		}
	}
	class Source {
		constructor(data = null) {
			this.isSource = true;
			this.uuid = generateUUID();
			this.data = data;
			this.version = 0;
		}
		set needsUpdate(value) {
			if (value === true) this.version++;
		}
		toJSON(meta) {
			const isRootObject = (meta === undefined || typeof meta === 'string');
			if (!isRootObject && meta.images[this.uuid] !== undefined) {
				return meta.images[this.uuid];
			}
			const output = {
				uuid: this.uuid,
				url: ''
			};
			const data = this.data;
			if (data !== null) {
				let url;
				if (Array.isArray(data)) {
					// cube texture
					url = [];
					for (let i = 0, l = data.length; i < l; i++) {
						if (data[i].isDataTexture) {
							url.push(serializeImage(data[i].image));
						} else {
							url.push(serializeImage(data[i]));
						}
					}
				} else {
					// texture
					url = serializeImage(data);
				}
				output.url = url;
			}
			if (!isRootObject) {
				meta.images[this.uuid] = output;
			}
			return output;
		}
	}

	function serializeImage(image) {
		if ((typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||
			(typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||
			(typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)) {
			// default images
			return ImageUtils.getDataURL(image);
		} else {
			if (image.data) {
				// images of DataTexture
				return {
					data: Array.from(image.data),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				};
			} else {
				console.warn('THREE.Texture: Unable to serialize Texture.');
				return {};
			}
		}
	}
	let textureId = 0;
	class Texture extends EventDispatcher {
		constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, encoding = LinearEncoding) {
			super();
			this.isTexture = true;
			Object.defineProperty(this, 'id', {
				value: textureId++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.source = new Source(image);
			this.mipmaps = [];
			this.mapping = mapping;
			this.wrapS = wrapS;
			this.wrapT = wrapT;
			this.magFilter = magFilter;
			this.minFilter = minFilter;
			this.anisotropy = anisotropy;
			this.format = format;
			this.internalFormat = null;
			this.type = type;
			this.offset = new Vector2(0, 0);
			this.repeat = new Vector2(1, 1);
			this.center = new Vector2(0, 0);
			this.rotation = 0;
			this.matrixAutoUpdate = true;
			this.matrix = new Matrix3();
			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
			this.encoding = encoding;
			this.userData = {};
			this.version = 0;
			this.onUpdate = null;
			this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
			this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)
		}
		get image() {
			return this.source.data;
		}
		set image(value = null) {
			this.source.data = value;
		}
		updateMatrix() {
			this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
		}
		clone() {
			return new this.constructor().copy(this);
		}
		copy(source) {
			this.name = source.name;
			this.source = source.source;
			this.mipmaps = source.mipmaps.slice(0);
			this.mapping = source.mapping;
			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;
			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;
			this.anisotropy = source.anisotropy;
			this.format = source.format;
			this.internalFormat = source.internalFormat;
			this.type = source.type;
			this.offset.copy(source.offset);
			this.repeat.copy(source.repeat);
			this.center.copy(source.center);
			this.rotation = source.rotation;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy(source.matrix);
			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;
			this.userData = JSON.parse(JSON.stringify(source.userData));
			this.needsUpdate = true;
			return this;
		}
		toJSON(meta) {
			const isRootObject = (meta === undefined || typeof meta === 'string');
			if (!isRootObject && meta.textures[this.uuid] !== undefined) {
				return meta.textures[this.uuid];
			}
			const output = {
				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},
				uuid: this.uuid,
				name: this.name,
				image: this.source.toJSON(meta).uuid,
				mapping: this.mapping,
				repeat: [this.repeat.x, this.repeat.y],
				offset: [this.offset.x, this.offset.y],
				center: [this.center.x, this.center.y],
				rotation: this.rotation,
				wrap: [this.wrapS, this.wrapT],
				format: this.format,
				internalFormat: this.internalFormat,
				type: this.type,
				encoding: this.encoding,
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,
				flipY: this.flipY,
				generateMipmaps: this.generateMipmaps,
				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment
			};
			if (Object.keys(this.userData).length > 0) output.userData = this.userData;
			if (!isRootObject) {
				meta.textures[this.uuid] = output;
			}
			return output;
		}
		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}
		transformUv(uv) {
			if (this.mapping !== UVMapping) return uv;
			uv.applyMatrix3(this.matrix);
			if (uv.x < 0 || uv.x > 1) {
				switch (this.wrapS) {
					case RepeatWrapping:
						uv.x = uv.x - Math.floor(uv.x);
						break;
					case ClampToEdgeWrapping:
						uv.x = uv.x < 0 ? 0 : 1;
						break;
					case MirroredRepeatWrapping:
						if (Math.abs(Math.floor(uv.x) % 2) === 1) {
							uv.x = Math.ceil(uv.x) - uv.x;
						} else {
							uv.x = uv.x - Math.floor(uv.x);
						}
						break;
				}
			}
			if (uv.y < 0 || uv.y > 1) {
				switch (this.wrapT) {
					case RepeatWrapping:
						uv.y = uv.y - Math.floor(uv.y);
						break;
					case ClampToEdgeWrapping:
						uv.y = uv.y < 0 ? 0 : 1;
						break;
					case MirroredRepeatWrapping:
						if (Math.abs(Math.floor(uv.y) % 2) === 1) {
							uv.y = Math.ceil(uv.y) - uv.y;
						} else {
							uv.y = uv.y - Math.floor(uv.y);
						}
						break;
				}
			}
			if (this.flipY) {
				uv.y = 1 - uv.y;
			}
			return uv;
		}
		set needsUpdate(value) {
			if (value === true) {
				this.version++;
				this.source.needsUpdate = true;
			}
		}
	}
	Texture.DEFAULT_IMAGE = null;
	Texture.DEFAULT_MAPPING = UVMapping;
	Texture.DEFAULT_ANISOTROPY = 1;
	class Vector4 {
		constructor(x = 0, y = 0, z = 0, w = 1) {
			Vector4.prototype.isVector4 = true;
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}
		get width() {
			return this.z;
		}
		set width(value) {
			this.z = value;
		}
		get height() {
			return this.w;
		}
		set height(value) {
			this.w = value;
		}
		set(x, y, z, w) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return this;
		}
		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;
			return this;
		}
		setX(x) {
			this.x = x;
			return this;
		}
		setY(y) {
			this.y = y;
			return this;
		}
		setZ(z) {
			this.z = z;
			return this;
		}
		setW(w) {
			this.w = w;
			return this;
		}
		setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;
				case 1:
					this.y = value;
					break;
				case 2:
					this.z = value;
					break;
				case 3:
					this.w = value;
					break;
				default:
					throw new Error('index is out of range: ' + index);
			}
			return this;
		}
		getComponent(index) {
			switch (index) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				case 2:
					return this.z;
				case 3:
					return this.w;
				default:
					throw new Error('index is out of range: ' + index);
			}
		}
		clone() {
			return new this.constructor(this.x, this.y, this.z, this.w);
		}
		copy(v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = (v.w !== undefined) ? v.w : 1;
			return this;
		}
		add(v) {
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;
			return this;
		}
		addScalar(s) {
			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;
			return this;
		}
		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
			return this;
		}
		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;
			return this;
		}
		sub(v) {
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;
			return this;
		}
		subScalar(s) {
			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;
			return this;
		}
		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
			return this;
		}
		multiply(v) {
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			this.w *= v.w;
			return this;
		}
		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
			return this;
		}
		applyMatrix4(m) {
			const x = this.x,
				y = this.y,
				z = this.z,
				w = this.w;
			const e = m.elements;
			this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
			this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
			this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
			this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
			return this;
		}
		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		}
		setAxisAngleFromQuaternion(q) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
			// q is assumed to be normalized
			this.w = 2 * Math.acos(q.w);
			const s = Math.sqrt(1 - q.w * q.w);
			if (s < 0.0001) {
				this.x = 1;
				this.y = 0;
				this.z = 0;
			} else {
				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;
			}
			return this;
		}
		setAxisAngleFromRotationMatrix(m) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			let angle, x, y, z; // variables for result
			const epsilon = 0.01, // margin to allow for rounding errors
				epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees
				te = m.elements,
				m11 = te[0],
				m12 = te[4],
				m13 = te[8],
				m21 = te[1],
				m22 = te[5],
				m23 = te[9],
				m31 = te[2],
				m32 = te[6],
				m33 = te[10];
			if ((Math.abs(m12 - m21) < epsilon) &&
				(Math.abs(m13 - m31) < epsilon) &&
				(Math.abs(m23 - m32) < epsilon)) {
				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms
				if ((Math.abs(m12 + m21) < epsilon2) &&
					(Math.abs(m13 + m31) < epsilon2) &&
					(Math.abs(m23 + m32) < epsilon2) &&
					(Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
					// this singularity is identity matrix so angle = 0
					this.set(1, 0, 0, 0);
					return this; // zero angle, arbitrary axis
				}
				// otherwise this singularity is angle = 180
				angle = Math.PI;
				const xx = (m11 + 1) / 2;
				const yy = (m22 + 1) / 2;
				const zz = (m33 + 1) / 2;
				const xy = (m12 + m21) / 4;
				const xz = (m13 + m31) / 4;
				const yz = (m23 + m32) / 4;
				if ((xx > yy) && (xx > zz)) {
					// m11 is the largest diagonal term
					if (xx < epsilon) {
						x = 0;
						y = 0.707106781;
						z = 0.707106781;
					} else {
						x = Math.sqrt(xx);
						y = xy / x;
						z = xz / x;
					}
				} else if (yy > zz) {
					// m22 is the largest diagonal term
					if (yy < epsilon) {
						x = 0.707106781;
						y = 0;
						z = 0.707106781;
					} else {
						y = Math.sqrt(yy);
						x = xy / y;
						z = yz / y;
					}
				} else {
					// m33 is the largest diagonal term so base result on this
					if (zz < epsilon) {
						x = 0.707106781;
						y = 0.707106781;
						z = 0;
					} else {
						z = Math.sqrt(zz);
						x = xz / z;
						y = yz / z;
					}
				}
				this.set(x, y, z, angle);
				return this; // return 180 deg rotation
			}
			// as we have reached here there are no singularities so we can handle normally
			let s = Math.sqrt((m32 - m23) * (m32 - m23) +
				(m13 - m31) * (m13 - m31) +
				(m21 - m12) * (m21 - m12)); // used to normalize
			if (Math.abs(s) < 0.001) s = 1;
			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case
			this.x = (m32 - m23) / s;
			this.y = (m13 - m31) / s;
			this.z = (m21 - m12) / s;
			this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
			return this;
		}
		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);
			this.w = Math.min(this.w, v.w);
			return this;
		}
		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);
			this.w = Math.max(this.w, v.w);
			return this;
		}
		clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));
			this.w = Math.max(min.w, Math.min(max.w, this.w));
			return this;
		}
		clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			this.z = Math.max(minVal, Math.min(maxVal, this.z));
			this.w = Math.max(minVal, Math.min(maxVal, this.w));
			return this;
		}
		clampLength(min, max) {
			const length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		}
		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			this.w = Math.floor(this.w);
			return this;
		}
		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			this.w = Math.ceil(this.w);
			return this;
		}
		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			this.w = Math.round(this.w);
			return this;
		}
		roundToZero() {
			this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
			this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);
			return this;
		}
		negate() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			this.w = -this.w;
			return this;
		}
		dot(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
		}
		lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		}
		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		}
		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
		}
		normalize() {
			return this.divideScalar(this.length() || 1);
		}
		setLength(length) {
			return this.normalize().multiplyScalar(length);
		}
		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;
			this.w += (v.w - this.w) * alpha;
			return this;
		}
		lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			this.z = v1.z + (v2.z - v1.z) * alpha;
			this.w = v1.w + (v2.w - v1.w) * alpha;
			return this;
		}
		equals(v) {
			return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
		}
		fromArray(array, offset = 0) {
			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];
			this.w = array[offset + 3];
			return this;
		}
		toArray(array = [], offset = 0) {
			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;
			array[offset + 3] = this.w;
			return array;
		}
		fromBufferAttribute(attribute, index) {
			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			this.z = attribute.getZ(index);
			this.w = attribute.getW(index);
			return this;
		}
		random() {
				this.x = Math.random();
				this.y = Math.random();
				this.z = Math.random();
				this.w = Math.random();
				return this;
			}
			*[Symbol.iterator]() {
				yield this.x;
				yield this.y;
				yield this.z;
				yield this.w;
			}
	}
	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	class WebGLRenderTarget extends EventDispatcher {
		constructor(width = 1, height = 1, options = {}) {
			super();
			this.isWebGLRenderTarget = true;
			this.width = width;
			this.height = height;
			this.depth = 1;
			this.scissor = new Vector4(0, 0, width, height);
			this.scissorTest = false;
			this.viewport = new Vector4(0, 0, width, height);
			const image = {
				width: width,
				height: height,
				depth: 1
			};
			this.texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
			this.texture.isRenderTargetTexture = true;
			this.texture.flipY = false;
			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
			this.samples = options.samples !== undefined ? options.samples : 0;
		}
		setSize(width, height, depth = 1) {
			if (this.width !== width || this.height !== height || this.depth !== depth) {
				this.width = width;
				this.height = height;
				this.depth = depth;
				this.texture.image.width = width;
				this.texture.image.height = height;
				this.texture.image.depth = depth;
				this.dispose();
			}
			this.viewport.set(0, 0, width, height);
			this.scissor.set(0, 0, width, height);
		}
		clone() {
			return new this.constructor().copy(this);
		}
		copy(source) {
			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;
			this.viewport.copy(source.viewport);
			this.texture = source.texture.clone();
			this.texture.isRenderTargetTexture = true;
			// ensure image object is not shared, see #20328
			const image = Object.assign({}, source.texture.image);
			this.texture.source = new Source(image);
			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
			this.samples = source.samples;
			return this;
		}
		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}
	}
	class DataArrayTexture extends Texture {
		constructor(data = null, width = 1, height = 1, depth = 1) {
			super(null);
			this.isDataArrayTexture = true;
			this.image = {
				data,
				width,
				height,
				depth
			};
			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;
			this.wrapR = ClampToEdgeWrapping;
			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;
		}
	}
	class WebGLArrayRenderTarget extends WebGLRenderTarget {
		constructor(width = 1, height = 1, depth = 1) {
			super(width, height);
			this.isWebGLArrayRenderTarget = true;
			this.depth = depth;
			this.texture = new DataArrayTexture(null, width, height, depth);
			this.texture.isRenderTargetTexture = true;
		}
	}
	class Data3DTexture extends Texture {
		constructor(data = null, width = 1, height = 1, depth = 1) {
			// We're going to add .setXXX() methods for setting properties later.
			// Users can still set in DataTexture3D directly.
			//
			//	const texture = new THREE.DataTexture3D( data, width, height, depth );
			// 	texture.anisotropy = 16;
			//
			// See #14839
			super(null);
			this.isData3DTexture = true;
			this.image = {
				data,
				width,
				height,
				depth
			};
			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;
			this.wrapR = ClampToEdgeWrapping;
			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;
		}
	}
	class WebGL3DRenderTarget extends WebGLRenderTarget {
		constructor(width = 1, height = 1, depth = 1) {
			super(width, height);
			this.isWebGL3DRenderTarget = true;
			this.depth = depth;
			this.texture = new Data3DTexture(null, width, height, depth);
			this.texture.isRenderTargetTexture = true;
		}
	}
	class WebGLMultipleRenderTargets extends WebGLRenderTarget {
		constructor(width = 1, height = 1, count = 1, options = {}) {
			super(width, height, options);
			this.isWebGLMultipleRenderTargets = true;
			const texture = this.texture;
			this.texture = [];
			for (let i = 0; i < count; i++) {
				this.texture[i] = texture.clone();
				this.texture[i].isRenderTargetTexture = true;
			}
		}
		setSize(width, height, depth = 1) {
			if (this.width !== width || this.height !== height || this.depth !== depth) {
				this.width = width;
				this.height = height;
				this.depth = depth;
				for (let i = 0, il = this.texture.length; i < il; i++) {
					this.texture[i].image.width = width;
					this.texture[i].image.height = height;
					this.texture[i].image.depth = depth;
				}
				this.dispose();
			}
			this.viewport.set(0, 0, width, height);
			this.scissor.set(0, 0, width, height);
			return this;
		}
		copy(source) {
			this.dispose();
			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;
			this.viewport.set(0, 0, this.width, this.height);
			this.scissor.set(0, 0, this.width, this.height);
			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
			this.texture.length = 0;
			for (let i = 0, il = source.texture.length; i < il; i++) {
				this.texture[i] = source.texture[i].clone();
				this.texture[i].isRenderTargetTexture = true;
			}
			return this;
		}
	}
	class Box3 {
		constructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
			this.isBox3 = true;
			this.min = min;
			this.max = max;
		}
		set(min, max) {
			this.min.copy(min);
			this.max.copy(max);
			return this;
		}
		setFromArray(array) {
			let minX = +Infinity;
			let minY = +Infinity;
			let minZ = +Infinity;
			let maxX = -Infinity;
			let maxY = -Infinity;
			let maxZ = -Infinity;
			for (let i = 0, l = array.length; i < l; i += 3) {
				const x = array[i];
				const y = array[i + 1];
				const z = array[i + 2];
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;
			}
			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);
			return this;
		}
		setFromBufferAttribute(attribute) {
			let minX = +Infinity;
			let minY = +Infinity;
			let minZ = +Infinity;
			let maxX = -Infinity;
			let maxY = -Infinity;
			let maxZ = -Infinity;
			for (let i = 0, l = attribute.count; i < l; i++) {
				const x = attribute.getX(i);
				const y = attribute.getY(i);
				const z = attribute.getZ(i);
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;
			}
			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);
			return this;
		}
		setFromPoints(points) {
			this.makeEmpty();
			for (let i = 0, il = points.length; i < il; i++) {
				this.expandByPoint(points[i]);
			}
			return this;
		}
		setFromCenterAndSize(center, size) {
			const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
			this.min.copy(center).sub(halfSize);
			this.max.copy(center).add(halfSize);
			return this;
		}
		setFromObject(object, precise = false) {
			this.makeEmpty();
			return this.expandByObject(object, precise);
		}
		clone() {
			return new this.constructor().copy(this);
		}
		copy(box) {
			this.min.copy(box.min);
			this.max.copy(box.max);
			return this;
		}
		makeEmpty() {
			this.min.x = this.min.y = this.min.z = +Infinity;
			this.max.x = this.max.y = this.max.z = -Infinity;
			return this;
		}
		isEmpty() {
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
			return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
		}
		getCenter(target) {
			return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		}
		getSize(target) {
			return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
		}
		expandByPoint(point) {
			this.min.min(point);
			this.max.max(point);
			return this;
		}
		expandByVector(vector) {
			this.min.sub(vector);
			this.max.add(vector);
			return this;
		}
		expandByScalar(scalar) {
			this.min.addScalar(-scalar);
			this.max.addScalar(scalar);
			return this;
		}
		expandByObject(object, precise = false) {
			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms
			object.updateWorldMatrix(false, false);
			const geometry = object.geometry;
			if (geometry !== undefined) {
				if (precise && geometry.attributes != undefined && geometry.attributes.position !== undefined) {
					const position = geometry.attributes.position;
					for (let i = 0, l = position.count; i < l; i++) {
						_vector$b.fromBufferAttribute(position, i).applyMatrix4(object.matrixWorld);
						this.expandByPoint(_vector$b);
					}
				} else {
					if (geometry.boundingBox === null) {
						geometry.computeBoundingBox();
					}
					_box$3.copy(geometry.boundingBox);
					_box$3.applyMatrix4(object.matrixWorld);
					this.union(_box$3);
				}
			}
			const children = object.children;
			for (let i = 0, l = children.length; i < l; i++) {
				this.expandByObject(children[i], precise);
			}
			return this;
		}
		containsPoint(point) {
			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z ? false : true;
		}
		containsBox(box) {
			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z;
		}
		getParameter(point, target) {
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
			return target.set(
				(point.x - this.min.x) / (this.max.x - this.min.x),
				(point.y - this.min.y) / (this.max.y - this.min.y),
				(point.z - this.min.z) / (this.max.z - this.min.z)
			);
		}
		intersectsBox(box) {
			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
		}
		intersectsSphere(sphere) {
			// Find the point on the AABB closest to the sphere center.
			this.clampPoint(sphere.center, _vector$b);
			// If that point is inside the sphere, the AABB and sphere intersect.
			return _vector$b.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius);
		}
		intersectsPlane(plane) {
			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.
			let min, max;
			if (plane.normal.x > 0) {
				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;
			} else {
				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;
			}
			if (plane.normal.y > 0) {
				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;
			} else {
				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;
			}
			if (plane.normal.z > 0) {
				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;
			} else {
				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;
			}
			return (min <= -plane.constant && max >= -plane.constant);
		}
		intersectsTriangle(triangle) {
			if (this.isEmpty()) {
				return false;
			}
			// compute box center and extents
			this.getCenter(_center);
			_extents.subVectors(this.max, _center);
			// translate triangle to aabb origin
			_v0$2.subVectors(triangle.a, _center);
			_v1$7.subVectors(triangle.b, _center);
			_v2$4.subVectors(triangle.c, _center);
			// compute edge vectors for triangle
			_f0.subVectors(_v1$7, _v0$2);
			_f1.subVectors(_v2$4, _v1$7);
			_f2.subVectors(_v0$2, _v2$4);
			// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
			let axes = [
				0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y,
				_f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x,
				-_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0
			];
			if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
				return false;
			}
			// test 3 face normals from the aabb
			axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
			if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
				return false;
			}
			// finally testing the face normal of the triangle
			// use already existing triangle edge vectors here
			_triangleNormal.crossVectors(_f0, _f1);
			axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
			return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
		}
		clampPoint(point, target) {
			return target.copy(point).clamp(this.min, this.max);
		}
		distanceToPoint(point) {
			return this.clampPoint(point, _vector$b).distanceTo(point);
		}
		getBoundingSphere(target) {
			if (this.isEmpty()) {
				target.makeEmpty();
			} else {
				this.getCenter(target.center);
				target.radius = this.getSize(_vector$b).length() * 0.5;
			}
			return target;
		}
		intersect(box) {
			this.min.max(box.min);
			this.max.min(box.max);
			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if (this.isEmpty()) this.makeEmpty();
			return this;
		}
		union(box) {
			this.min.min(box.min);
			this.max.max(box.max);
			return this;
		}
		applyMatrix4(matrix) {
			// transform of empty box is an empty box.
			if (this.isEmpty()) return this;
			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
			_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
			_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
			_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
			_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
			_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
			_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
			_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
			this.setFromPoints(_points);
			return this;
		}
		translate(offset) {
			this.min.add(offset);
			this.max.add(offset);
			return this;
		}
		equals(box) {
			return box.min.equals(this.min) && box.max.equals(this.max);
		}
	}
	const _points = [
		/*@__PURE__*/
		new Vector3(),
		/*@__PURE__*/
		new Vector3(),
		/*@__PURE__*/
		new Vector3(),
		/*@__PURE__*/
		new Vector3(),
		/*@__PURE__*/
		new Vector3(),
		/*@__PURE__*/
		new Vector3(),
		/*@__PURE__*/
		new Vector3(),
		/*@__PURE__*/
		new Vector3()
	];
	const _vector$b = /*@__PURE__*/ new Vector3();
	const _box$3 = /*@__PURE__*/ new Box3();
	// triangle centered vertices
	const _v0$2 = /*@__PURE__*/ new Vector3();
	const _v1$7 = /*@__PURE__*/ new Vector3();
	const _v2$4 = /*@__PURE__*/ new Vector3();
	// triangle edge vectors
	const _f0 = /*@__PURE__*/ new Vector3();
	const _f1 = /*@__PURE__*/ new Vector3();
	const _f2 = /*@__PURE__*/ new Vector3();
	const _center = /*@__PURE__*/ new Vector3();
	const _extents = /*@__PURE__*/ new Vector3();
	const _triangleNormal = /*@__PURE__*/ new Vector3();
	const _testAxis = /*@__PURE__*/ new Vector3();

	function satForAxes(axes, v0, v1, v2, extents) {
		for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
			_testAxis.fromArray(axes, i);
			// project the aabb onto the separating axis
			const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
			// project all 3 vertices of the triangle onto the separating axis
			const p0 = v0.dot(_testAxis);
			const p1 = v1.dot(_testAxis);
			const p2 = v2.dot(_testAxis);
			// actual test, basically see if either of the most extreme of the triangle points intersects r
			if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is separating and we can exit
				return false;
			}
		}
		return true;
	}
	const _box$2 = /*@__PURE__*/ new Box3();
	const _v1$6 = /*@__PURE__*/ new Vector3();
	const _v2$3 = /*@__PURE__*/ new Vector3();
	class Sphere {
		constructor(center = new Vector3(), radius = -1) {
			this.center = center;
			this.radius = radius;
		}
		set(center, radius) {
			this.center.copy(center);
			this.radius = radius;
			return this;
		}
		setFromPoints(points, optionalCenter) {
			const center = this.center;
			if (optionalCenter !== undefined) {
				center.copy(optionalCenter);
			} else {
				_box$2.setFromPoints(points).getCenter(center);
			}
			let maxRadiusSq = 0;
			for (let i = 0, il = points.length; i < il; i++) {
				maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
			}
			this.radius = Math.sqrt(maxRadiusSq);
			return this;
		}
		copy(sphere) {
			this.center.copy(sphere.center);
			this.radius = sphere.radius;
			return this;
		}
		isEmpty() {
			return (this.radius < 0);
		}
		makeEmpty() {
			this.center.set(0, 0, 0);
			this.radius = -1;
			return this;
		}
		containsPoint(point) {
			return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
		}
		distanceToPoint(point) {
			return (point.distanceTo(this.center) - this.radius);
		}
		intersectsSphere(sphere) {
			const radiusSum = this.radius + sphere.radius;
			return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
		}
		intersectsBox(box) {
			return box.intersectsSphere(this);
		}
		intersectsPlane(plane) {
			return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
		}
		clampPoint(point, target) {
			const deltaLengthSq = this.center.distanceToSquared(point);
			target.copy(point);
			if (deltaLengthSq > (this.radius * this.radius)) {
				target.sub(this.center).normalize();
				target.multiplyScalar(this.radius).add(this.center);
			}
			return target;
		}
		getBoundingBox(target) {
			if (this.isEmpty()) {
				// Empty sphere produces empty bounding box
				target.makeEmpty();
				return target;
			}
			target.set(this.center, this.center);
			target.expandByScalar(this.radius);
			return target;
		}
		applyMatrix4(matrix) {
			this.center.applyMatrix4(matrix);
			this.radius = this.radius * matrix.getMaxScaleOnAxis();
			return this;
		}
		translate(offset) {
			this.center.add(offset);
			return this;
		}
		expandByPoint(point) {
			if (this.isEmpty()) {
				this.center.copy(point);
				this.radius = 0;
				return this;
			}
			_v1$6.subVectors(point, this.center);
			const lengthSq = _v1$6.lengthSq();
			if (lengthSq > (this.radius * this.radius)) {
				// calculate the minimal sphere
				const length = Math.sqrt(lengthSq);
				const delta = (length - this.radius) * 0.5;
				this.center.addScaledVector(_v1$6, delta / length);
				this.radius += delta;
			}
			return this;
		}
		union(sphere) {
			if (sphere.isEmpty()) {
				return this;
			}
			if (this.isEmpty()) {
				this.copy(sphere);
				return this;
			}
			if (this.center.equals(sphere.center) === true) {
				this.radius = Math.max(this.radius, sphere.radius);
			} else {
				_v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
				this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
				this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
			}
			return this;
		}
		equals(sphere) {
			return sphere.center.equals(this.center) && (sphere.radius === this.radius);
		}
		clone() {
			return new this.constructor().copy(this);
		}
	}
	const _vector$a = /*@__PURE__*/ new Vector3();
	const _segCenter = /*@__PURE__*/ new Vector3();
	const _segDir = /*@__PURE__*/ new Vector3();
	const _diff = /*@__PURE__*/ new Vector3();
	const _edge1 = /*@__PURE__*/ new Vector3();
	const _edge2 = /*@__PURE__*/ new Vector3();
	const _normal$1 = /*@__PURE__*/ new Vector3();
	class Ray {
		constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
			this.origin = origin;
			this.direction = direction;
		}
		set(origin, direction) {
			this.origin.copy(origin);
			this.direction.copy(direction);
			return this;
		}
		copy(ray) {
			this.origin.copy(ray.origin);
			this.direction.copy(ray.direction);
			return this;
		}
		at(t, target) {
			return target.copy(this.origin).addScaledVector(this.direction, t);
		}
		lookAt(v) {
			this.direction.copy(v).sub(this.origin).normalize();
			return this;
		}
		recast(t) {
			this.origin.copy(this.at(t, _vector$a));
			return this;
		}
		closestPointToPoint(point, target) {
			target.subVectors(point, this.origin);
			const directionDistance = target.dot(this.direction);
			if (directionDistance < 0) {
				return target.copy(this.origin);
			}
			return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
		}
		distanceToPoint(point) {
			return Math.sqrt(this.distanceSqToPoint(point));
		}
		distanceSqToPoint(point) {
			const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
			// point behind the ray
			if (directionDistance < 0) {
				return this.origin.distanceToSquared(point);
			}
			_vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
			return _vector$a.distanceToSquared(point);
		}
		distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
			// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment
			_segCenter.copy(v0).add(v1).multiplyScalar(0.5);
			_segDir.copy(v1).sub(v0).normalize();
			_diff.copy(this.origin).sub(_segCenter);
			const segExtent = v0.distanceTo(v1) * 0.5;
			const a01 = -this.direction.dot(_segDir);
			const b0 = _diff.dot(this.direction);
			const b1 = -_diff.dot(_segDir);
			const c = _diff.lengthSq();
			const det = Math.abs(1 - a01 * a01);
			let s0, s1, sqrDist, extDet;
			if (det > 0) {
				// The ray and segment are not parallel.
				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;
				if (s0 >= 0) {
					if (s1 >= -extDet) {
						if (s1 <= extDet) {
							// region 0
							// Minimum at interior points of ray and segment.
							const invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
						} else {
							// region 1
							s1 = segExtent;
							s0 = Math.max(0, -(a01 * s1 + b0));
							sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
						}
					} else {
						// region 5
						s1 = -segExtent;
						s0 = Math.max(0, -(a01 * s1 + b0));
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				} else {
					if (s1 <= -extDet) {
						// region 4
						s0 = Math.max(0, -(-a01 * segExtent + b0));
						s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					} else if (s1 <= extDet) {
						// region 3
						s0 = 0;
						s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = s1 * (s1 + 2 * b1) + c;
					} else {
						// region 2
						s0 = Math.max(0, -(a01 * segExtent + b0));
						s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				}
			} else {
				// Ray and segment are parallel.
				s1 = (a01 > 0) ? -segExtent : segExtent;
				s0 = Math.max(0, -(a01 * s1 + b0));
				sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
			}
			if (optionalPointOnRay) {
				optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
			}
			if (optionalPointOnSegment) {
				optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
			}
			return sqrDist;
		}
		intersectSphere(sphere, target) {
			_vector$a.subVectors(sphere.center, this.origin);
			const tca = _vector$a.dot(this.direction);
			const d2 = _vector$a.dot(_vector$a) - tca * tca;
			const radius2 = sphere.radius * sphere.radius;
			if (d2 > radius2) return null;
			const thc = Math.sqrt(radius2 - d2);
			// t0 = first intersect point - entrance on front of sphere
			const t0 = tca - thc;
			// t1 = second intersect point - exit point on back of sphere
			const t1 = tca + thc;
			// test to see if t1 is behind the ray - if so, return null
			if (t1 < 0) return null;
			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if (t0 < 0) return this.at(t1, target);
			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at(t0, target);
		}
		intersectsSphere(sphere) {
			return this.distanceSqToPoint(sphere.center) <= (sphere.radius * sphere.radius);
		}
		distanceToPlane(plane) {
			const denominator = plane.normal.dot(this.direction);
			if (denominator === 0) {
				// line is coplanar, return origin
				if (plane.distanceToPoint(this.origin) === 0) {
					return 0;
				}
				// Null is preferable to undefined since undefined means.... it is undefined
				return null;
			}
			const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
			// Return if the ray never intersects the plane
			return t >= 0 ? t : null;
		}
		intersectPlane(plane, target) {
			const t = this.distanceToPlane(plane);
			if (t === null) {
				return null;
			}
			return this.at(t, target);
		}
		intersectsPlane(plane) {
			// check if the ray lies on the plane first
			const distToPoint = plane.distanceToPoint(this.origin);
			if (distToPoint === 0) {
				return true;
			}
			const denominator = plane.normal.dot(this.direction);
			if (denominator * distToPoint < 0) {
				return true;
			}
			// ray origin is behind the plane (and is pointing behind it)
			return false;
		}
		intersectBox(box, target) {
			let tmin, tmax, tymin, tymax, tzmin, tzmax;
			const invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;
			const origin = this.origin;
			if (invdirx >= 0) {
				tmin = (box.min.x - origin.x) * invdirx;
				tmax = (box.max.x - origin.x) * invdirx;
			} else {
				tmin = (box.max.x - origin.x) * invdirx;
				tmax = (box.min.x - origin.x) * invdirx;
			}
			if (invdiry >= 0) {
				tymin = (box.min.y - origin.y) * invdiry;
				tymax = (box.max.y - origin.y) * invdiry;
			} else {
				tymin = (box.max.y - origin.y) * invdiry;
				tymax = (box.min.y - origin.y) * invdiry;
			}
			if ((tmin > tymax) || (tymin > tmax)) return null;
			if (tymin > tmin || isNaN(tmin)) tmin = tymin;
			if (tymax < tmax || isNaN(tmax)) tmax = tymax;
			if (invdirz >= 0) {
				tzmin = (box.min.z - origin.z) * invdirz;
				tzmax = (box.max.z - origin.z) * invdirz;
			} else {
				tzmin = (box.max.z - origin.z) * invdirz;
				tzmax = (box.min.z - origin.z) * invdirz;
			}
			if ((tmin > tzmax) || (tzmin > tmax)) return null;
			if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
			if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
			//return point closest to the ray (positive side)
			if (tmax < 0) return null;
			return this.at(tmin >= 0 ? tmin : tmax, target);
		}
		intersectsBox(box) {
			return this.intersectBox(box, _vector$a) !== null;
		}
		intersectTriangle(a, b, c, backfaceCulling, target) {
			// Compute the offset origin, edges, and normal.
			// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
			_edge1.subVectors(b, a);
			_edge2.subVectors(c, a);
			_normal$1.crossVectors(_edge1, _edge2);
			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			let DdN = this.direction.dot(_normal$1);
			let sign;
			if (DdN > 0) {
				if (backfaceCulling) return null;
				sign = 1;
			} else if (DdN < 0) {
				sign = -1;
				DdN = -DdN;
			} else {
				return null;
			}
			_diff.subVectors(this.origin, a);
			const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
			// b1 < 0, no intersection
			if (DdQxE2 < 0) {
				return null;
			}
			const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
			// b2 < 0, no intersection
			if (DdE1xQ < 0) {
				return null;
			}
			// b1+b2 > 1, no intersection
			if (DdQxE2 + DdE1xQ > DdN) {
				return null;
			}
			// Line intersects triangle, check if ray does.
			const QdN = -sign * _diff.dot(_normal$1);
			// t < 0, no intersection
			if (QdN < 0) {
				return null;
			}
			// Ray intersects triangle.
			return this.at(QdN / DdN, target);
		}
		applyMatrix4(matrix4) {
			this.origin.applyMatrix4(matrix4);
			this.direction.transformDirection(matrix4);
			return this;
		}
		equals(ray) {
			return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
		}
		clone() {
			return new this.constructor().copy(this);
		}
	}
	class Matrix4 {
		constructor() {
			Matrix4.prototype.isMatrix4 = true;
			this.elements = [
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
			];
		}
		set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
			const te = this.elements;
			te[0] = n11;
			te[4] = n12;
			te[8] = n13;
			te[12] = n14;
			te[1] = n21;
			te[5] = n22;
			te[9] = n23;
			te[13] = n24;
			te[2] = n31;
			te[6] = n32;
			te[10] = n33;
			te[14] = n34;
			te[3] = n41;
			te[7] = n42;
			te[11] = n43;
			te[15] = n44;
			return this;
		}
		identity() {
			this.set(
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
			);
			return this;
		}
		clone() {
			return new Matrix4().fromArray(this.elements);
		}
		copy(m) {
			const te = this.elements;
			const me = m.elements;
			te[0] = me[0];
			te[1] = me[1];
			te[2] = me[2];
			te[3] = me[3];
			te[4] = me[4];
			te[5] = me[5];
			te[6] = me[6];
			te[7] = me[7];
			te[8] = me[8];
			te[9] = me[9];
			te[10] = me[10];
			te[11] = me[11];
			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];
			te[15] = me[15];
			return this;
		}
		copyPosition(m) {
			const te = this.elements,
				me = m.elements;
			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];
			return this;
		}
		setFromMatrix3(m) {
			const me = m.elements;
			this.set(
				me[0], me[3], me[6], 0,
				me[1], me[4], me[7], 0,
				me[2], me[5], me[8], 0,
				0, 0, 0, 1
			);
			return this;
		}
		extractBasis(xAxis, yAxis, zAxis) {
			xAxis.setFromMatrixColumn(this, 0);
			yAxis.setFromMatrixColumn(this, 1);
			zAxis.setFromMatrixColumn(this, 2);
			return this;
		}
		makeBasis(xAxis, yAxis, zAxis) {
			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);
			return this;
		}
		extractRotation(m) {
			// this method does not support reflection matrices
			const te = this.elements;
			const me = m.elements;
			const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
			const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
			const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
			te[0] = me[0] * scaleX;
			te[1] = me[1] * scaleX;
			te[2] = me[2] * scaleX;
			te[3] = 0;
			te[4] = me[4] * scaleY;
			te[5] = me[5] * scaleY;
			te[6] = me[6] * scaleY;
			te[7] = 0;
			te[8] = me[8] * scaleZ;
			te[9] = me[9] * scaleZ;
			te[10] = me[10] * scaleZ;
			te[11] = 0;
			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;
			return this;
		}
		makeRotationFromEuler(euler) {
			const te = this.elements;
			const x = euler.x,
				y = euler.y,
				z = euler.z;
			const a = Math.cos(x),
				b = Math.sin(x);
			const c = Math.cos(y),
				d = Math.sin(y);
			const e = Math.cos(z),
				f = Math.sin(z);
			if (euler.order === 'XYZ') {
				const ae = a * e,
					af = a * f,
					be = b * e,
					bf = b * f;
				te[0] = c * e;
				te[4] = -c * f;
				te[8] = d;
				te[1] = af + be * d;
				te[5] = ae - bf * d;
				te[9] = -b * c;
				te[2] = bf - ae * d;
				te[6] = be + af * d;
				te[10] = a * c;
			} else if (euler.order === 'YXZ') {
				const ce = c * e,
					cf = c * f,
					de = d * e,
					df = d * f;
				te[0] = ce + df * b;
				te[4] = de * b - cf;
				te[8] = a * d;
				te[1] = a * f;
				te[5] = a * e;
				te[9] = -b;
				te[2] = cf * b - de;
				te[6] = df + ce * b;
				te[10] = a * c;
			} else if (euler.order === 'ZXY') {
				const ce = c * e,
					cf = c * f,
					de = d * e,
					df = d * f;
				te[0] = ce - df * b;
				te[4] = -a * f;
				te[8] = de + cf * b;
				te[1] = cf + de * b;
				te[5] = a * e;
				te[9] = df - ce * b;
				te[2] = -a * d;
				te[6] = b;
				te[10] = a * c;
			} else if (euler.order === 'ZYX') {
				const ae = a * e,
					af = a * f,
					be = b * e,
					bf = b * f;
				te[0] = c * e;
				te[4] = be * d - af;
				te[8] = ae * d + bf;
				te[1] = c * f;
				te[5] = bf * d + ae;
				te[9] = af * d - be;
				te[2] = -d;
				te[6] = b * c;
				te[10] = a * c;
			} else if (euler.order === 'YZX') {
				const ac = a * c,
					ad = a * d,
					bc = b * c,
					bd = b * d;
				te[0] = c * e;
				te[4] = bd - ac * f;
				te[8] = bc * f + ad;
				te[1] = f;
				te[5] = a * e;
				te[9] = -b * e;
				te[2] = -d * e;
				te[6] = ad * f + bc;
				te[10] = ac - bd * f;
			} else if (euler.order === 'XZY') {
				const ac = a * c,
					ad = a * d,
					bc = b * c,
					bd = b * d;
				te[0] = c * e;
				te[4] = -f;
				te[8] = d * e;
				te[1] = ac * f + bd;
				te[5] = a * e;
				te[9] = ad * f - bc;
				te[2] = bc * f - ad;
				te[6] = b * e;
				te[10] = bd * f + ac;
			}
			// bottom row
			te[3] = 0;
			te[7] = 0;
			te[11] = 0;
			// last column
			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;
			return this;
		}
		makeRotationFromQuaternion(q) {
			return this.compose(_zero, q, _one);
		}
		lookAt(eye, target, up) {
			const te = this.elements;
			_z.subVectors(eye, target);
			if (_z.lengthSq() === 0) {
				// eye and target are in the same position
				_z.z = 1;
			}
			_z.normalize();
			_x.crossVectors(up, _z);
			if (_x.lengthSq() === 0) {
				// up and z are parallel
				if (Math.abs(up.z) === 1) {
					_z.x += 0.0001;
				} else {
					_z.z += 0.0001;
				}
				_z.normalize();
				_x.crossVectors(up, _z);
			}
			_x.normalize();
			_y.crossVectors(_z, _x);
			te[0] = _x.x;
			te[4] = _y.x;
			te[8] = _z.x;
			te[1] = _x.y;
			te[5] = _y.y;
			te[9] = _z.y;
			te[2] = _x.z;
			te[6] = _y.z;
			te[10] = _z.z;
			return this;
		}
		multiply(m) {
			return this.multiplyMatrices(this, m);
		}
		premultiply(m) {
			return this.multiplyMatrices(m, this);
		}
		multiplyMatrices(a, b) {
			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;
			const a11 = ae[0],
				a12 = ae[4],
				a13 = ae[8],
				a14 = ae[12];
			const a21 = ae[1],
				a22 = ae[5],
				a23 = ae[9],
				a24 = ae[13];
			const a31 = ae[2],
				a32 = ae[6],
				a33 = ae[10],
				a34 = ae[14];
			const a41 = ae[3],
				a42 = ae[7],
				a43 = ae[11],
				a44 = ae[15];
			const b11 = be[0],
				b12 = be[4],
				b13 = be[8],
				b14 = be[12];
			const b21 = be[1],
				b22 = be[5],
				b23 = be[9],
				b24 = be[13];
			const b31 = be[2],
				b32 = be[6],
				b33 = be[10],
				b34 = be[14];
			const b41 = be[3],
				b42 = be[7],
				b43 = be[11],
				b44 = be[15];
			te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
			te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
			te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
			te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
			return this;
		}
		multiplyScalar(s) {
			const te = this.elements;
			te[0] *= s;
			te[4] *= s;
			te[8] *= s;
			te[12] *= s;
			te[1] *= s;
			te[5] *= s;
			te[9] *= s;
			te[13] *= s;
			te[2] *= s;
			te[6] *= s;
			te[10] *= s;
			te[14] *= s;
			te[3] *= s;
			te[7] *= s;
			te[11] *= s;
			te[15] *= s;
			return this;
		}
		determinant() {
			const te = this.elements;
			const n11 = te[0],
				n12 = te[4],
				n13 = te[8],
				n14 = te[12];
			const n21 = te[1],
				n22 = te[5],
				n23 = te[9],
				n24 = te[13];
			const n31 = te[2],
				n32 = te[6],
				n33 = te[10],
				n34 = te[14];
			const n41 = te[3],
				n42 = te[7],
				n43 = te[11],
				n44 = te[15];
			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
			return (
				n41 * (
					+n14 * n23 * n32 -
					n13 * n24 * n32 -
					n14 * n22 * n33 +
					n12 * n24 * n33 +
					n13 * n22 * n34 -
					n12 * n23 * n34
				) +
				n42 * (
					+n11 * n23 * n34 -
					n11 * n24 * n33 +
					n14 * n21 * n33 -
					n13 * n21 * n34 +
					n13 * n24 * n31 -
					n14 * n23 * n31
				) +
				n43 * (
					+n11 * n24 * n32 -
					n11 * n22 * n34 -
					n14 * n21 * n32 +
					n12 * n21 * n34 +
					n14 * n22 * n31 -
					n12 * n24 * n31
				) +
				n44 * (
					-n13 * n22 * n31 -
					n11 * n23 * n32 +
					n11 * n22 * n33 +
					n13 * n21 * n32 -
					n12 * n21 * n33 +
					n12 * n23 * n31
				)
			);
		}
		transpose() {
			const te = this.elements;
			let tmp;
			tmp = te[1];
			te[1] = te[4];
			te[4] = tmp;
			tmp = te[2];
			te[2] = te[8];
			te[8] = tmp;
			tmp = te[6];
			te[6] = te[9];
			te[9] = tmp;
			tmp = te[3];
			te[3] = te[12];
			te[12] = tmp;
			tmp = te[7];
			te[7] = te[13];
			te[13] = tmp;
			tmp = te[11];
			te[11] = te[14];
			te[14] = tmp;
			return this;
		}
		setPosition(x, y, z) {
			const te = this.elements;
			if (x.isVector3) {
				te[12] = x.x;
				te[13] = x.y;
				te[14] = x.z;
			} else {
				te[12] = x;
				te[13] = y;
				te[14] = z;
			}
			return this;
		}
		invert() {
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			const te = this.elements,
				n11 = te[0],
				n21 = te[1],
				n31 = te[2],
				n41 = te[3],
				n12 = te[4],
				n22 = te[5],
				n32 = te[6],
				n42 = te[7],
				n13 = te[8],
				n23 = te[9],
				n33 = te[10],
				n43 = te[11],
				n14 = te[12],
				n24 = te[13],
				n34 = te[14],
				n44 = te[15],
				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
			if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
			const detInv = 1 / det;
			te[0] = t11 * detInv;
			te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
			te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
			te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
			te[4] = t12 * detInv;
			te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
			te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
			te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
			te[8] = t13 * detInv;
			te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
			te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
			te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
			te[12] = t14 * detInv;
			te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
			te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
			te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
			return this;
		}
		scale(v) {
			const te = this.elements;
			const x = v.x,
				y = v.y,
				z = v.z;
			te[0] *= x;
			te[4] *= y;
			te[8] *= z;
			te[1] *= x;
			te[5] *= y;
			te[9] *= z;
			te[2] *= x;
			te[6] *= y;
			te[10] *= z;
			te[3] *= x;
			te[7] *= y;
			te[11] *= z;
			return this;
		}
		getMaxScaleOnAxis() {
			const te = this.elements;
			const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
			const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
			const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
			return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
		}
		makeTranslation(x, y, z) {
			this.set(
				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1
			);
			return this;
		}
		makeRotationX(theta) {
			const c = Math.cos(theta),
				s = Math.sin(theta);
			this.set(
				1, 0, 0, 0,
				0, c, -s, 0,
				0, s, c, 0,
				0, 0, 0, 1
			);
			return this;
		}
		makeRotationY(theta) {
			const c = Math.cos(theta),
				s = Math.sin(theta);
			this.set(
				c, 0, s, 0,
				0, 1, 0, 0,
				-s, 0, c, 0,
				0, 0, 0, 1
			);
			return this;
		}
		makeRotationZ(theta) {
			const c = Math.cos(theta),
				s = Math.sin(theta);
			this.set(
				c, -s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
			);
			return this;
		}
		makeRotationAxis(axis, angle) {
			// Based on http://www.gamedev.net/reference/articles/article1199.asp
			const c = Math.cos(angle);
			const s = Math.sin(angle);
			const t = 1 - c;
			const x = axis.x,
				y = axis.y,
				z = axis.z;
			const tx = t * x,
				ty = t * y;
			this.set(
				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1
			);
			return this;
		}
		makeScale(x, y, z) {
			this.set(
				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1
			);
			return this;
		}
		makeShear(xy, xz, yx, yz, zx, zy) {
			this.set(
				1, yx, zx, 0,
				xy, 1, zy, 0,
				xz, yz, 1, 0,
				0, 0, 0, 1
			);
			return this;
		}
		compose(position, quaternion, scale) {
			const te = this.elements;
			const x = quaternion._x,
				y = quaternion._y,
				z = quaternion._z,
				w = quaternion._w;
			const x2 = x + x,
				y2 = y + y,
				z2 = z + z;
			const xx = x * x2,
				xy = x * y2,
				xz = x * z2;
			const yy = y * y2,
				yz = y * z2,
				zz = z * z2;
			const wx = w * x2,
				wy = w * y2,
				wz = w * z2;
			const sx = scale.x,
				sy = scale.y,
				sz = scale.z;
			te[0] = (1 - (yy + zz)) * sx;
			te[1] = (xy + wz) * sx;
			te[2] = (xz - wy) * sx;
			te[3] = 0;
			te[4] = (xy - wz) * sy;
			te[5] = (1 - (xx + zz)) * sy;
			te[6] = (yz + wx) * sy;
			te[7] = 0;
			te[8] = (xz + wy) * sz;
			te[9] = (yz - wx) * sz;
			te[10] = (1 - (xx + yy)) * sz;
			te[11] = 0;
			te[12] = position.x;
			te[13] = position.y;
			te[14] = position.z;
			te[15] = 1;
			return this;
		}
		decompose(position, quaternion, scale) {
			const te = this.elements;
			let sx = _v1$5.set(te[0], te[1], te[2]).length();
			const sy = _v1$5.set(te[4], te[5], te[6]).length();
			const sz = _v1$5.set(te[8], te[9], te[10]).length();
			// if determine is negative, we need to invert one scale
			const det = this.determinant();
			if (det < 0) sx = -sx;
			position.x = te[12];
			position.y = te[13];
			position.z = te[14];
			// scale the rotation part
			_m1$2.copy(this);
			const invSX = 1 / sx;
			const invSY = 1 / sy;
			const invSZ = 1 / sz;
			_m1$2.elements[0] *= invSX;
			_m1$2.elements[1] *= invSX;
			_m1$2.elements[2] *= invSX;
			_m1$2.elements[4] *= invSY;
			_m1$2.elements[5] *= invSY;
			_m1$2.elements[6] *= invSY;
			_m1$2.elements[8] *= invSZ;
			_m1$2.elements[9] *= invSZ;
			_m1$2.elements[10] *= invSZ;
			quaternion.setFromRotationMatrix(_m1$2);
			scale.x = sx;
			scale.y = sy;
			scale.z = sz;
			return this;
		}
		makePerspective(left, right, top, bottom, near, far) {
			const te = this.elements;
			const x = 2 * near / (right - left);
			const y = 2 * near / (top - bottom);
			const a = (right + left) / (right - left);
			const b = (top + bottom) / (top - bottom);
			const c = -(far + near) / (far - near);
			const d = -2 * far * near / (far - near);
			te[0] = x;
			te[4] = 0;
			te[8] = a;
			te[12] = 0;
			te[1] = 0;
			te[5] = y;
			te[9] = b;
			te[13] = 0;
			te[2] = 0;
			te[6] = 0;
			te[10] = c;
			te[14] = d;
			te[3] = 0;
			te[7] = 0;
			te[11] = -1;
			te[15] = 0;
			return this;
		}
		makeOrthographic(left, right, top, bottom, near, far) {
			const te = this.elements;
			const w = 1.0 / (right - left);
			const h = 1.0 / (top - bottom);
			const p = 1.0 / (far - near);
			const x = (right + left) * w;
			const y = (top + bottom) * h;
			const z = (far + near) * p;
			te[0] = 2 * w;
			te[4] = 0;
			te[8] = 0;
			te[12] = -x;
			te[1] = 0;
			te[5] = 2 * h;
			te[9] = 0;
			te[13] = -y;
			te[2] = 0;
			te[6] = 0;
			te[10] = -2 * p;
			te[14] = -z;
			te[3] = 0;
			te[7] = 0;
			te[11] = 0;
			te[15] = 1;
			return this;
		}
		equals(matrix) {
			const te = this.elements;
			const me = matrix.elements;
			for (let i = 0; i < 16; i++) {
				if (te[i] !== me[i]) return false;
			}
			return true;
		}
		fromArray(array, offset = 0) {
			for (let i = 0; i < 16; i++) {
				this.elements[i] = array[i + offset];
			}
			return this;
		}
		toArray(array = [], offset = 0) {
			const te = this.elements;
			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];
			array[offset + 3] = te[3];
			array[offset + 4] = te[4];
			array[offset + 5] = te[5];
			array[offset + 6] = te[6];
			array[offset + 7] = te[7];
			array[offset + 8] = te[8];
			array[offset + 9] = te[9];
			array[offset + 10] = te[10];
			array[offset + 11] = te[11];
			array[offset + 12] = te[12];
			array[offset + 13] = te[13];
			array[offset + 14] = te[14];
			array[offset + 15] = te[15];
			return array;
		}
	}
	const _v1$5 = /*@__PURE__*/ new Vector3();
	const _m1$2 = /*@__PURE__*/ new Matrix4();
	const _zero = /*@__PURE__*/ new Vector3(0, 0, 0);
	const _one = /*@__PURE__*/ new Vector3(1, 1, 1);
	const _x = /*@__PURE__*/ new Vector3();
	const _y = /*@__PURE__*/ new Vector3();
	const _z = /*@__PURE__*/ new Vector3();
	const _matrix$1 = /*@__PURE__*/ new Matrix4();
	const _quaternion$3 = /*@__PURE__*/ new Quaternion();
	class Euler {
		constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
			this.isEuler = true;
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;
		}
		get x() {
			return this._x;
		}
		set x(value) {
			this._x = value;
			this._onChangeCallback();
		}
		get y() {
			return this._y;
		}
		set y(value) {
			this._y = value;
			this._onChangeCallback();
		}
		get z() {
			return this._z;
		}
		set z(value) {
			this._z = value;
			this._onChangeCallback();
		}
		get order() {
			return this._order;
		}
		set order(value) {
			this._order = value;
			this._onChangeCallback();
		}
		set(x, y, z, order = this._order) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;
			this._onChangeCallback();
			return this;
		}
		clone() {
			return new this.constructor(this._x, this._y, this._z, this._order);
		}
		copy(euler) {
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;
			this._onChangeCallback();
			return this;
		}
		setFromRotationMatrix(m, order = this._order, update = true) {
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			const te = m.elements;
			const m11 = te[0],
				m12 = te[4],
				m13 = te[8];
			const m21 = te[1],
				m22 = te[5],
				m23 = te[9];
			const m31 = te[2],
				m32 = te[6],
				m33 = te[10];
			switch (order) {
				case 'XYZ':
					this._y = Math.asin(clamp(m13, -1, 1));
					if (Math.abs(m13) < 0.9999999) {
						this._x = Math.atan2(-m23, m33);
						this._z = Math.atan2(-m12, m11);
					} else {
						this._x = Math.atan2(m32, m22);
						this._z = 0;
					}
					break;
				case 'YXZ':
					this._x = Math.asin(-clamp(m23, -1, 1));
					if (Math.abs(m23) < 0.9999999) {
						this._y = Math.atan2(m13, m33);
						this._z = Math.atan2(m21, m22);
					} else {
						this._y = Math.atan2(-m31, m11);
						this._z = 0;
					}
					break;
				case 'ZXY':
					this._x = Math.asin(clamp(m32, -1, 1));
					if (Math.abs(m32) < 0.9999999) {
						this._y = Math.atan2(-m31, m33);
						this._z = Math.atan2(-m12, m22);
					} else {
						this._y = 0;
						this._z = Math.atan2(m21, m11);
					}
					break;
				case 'ZYX':
					this._y = Math.asin(-clamp(m31, -1, 1));
					if (Math.abs(m31) < 0.9999999) {
						this._x = Math.atan2(m32, m33);
						this._z = Math.atan2(m21, m11);
					} else {
						this._x = 0;
						this._z = Math.atan2(-m12, m22);
					}
					break;
				case 'YZX':
					this._z = Math.asin(clamp(m21, -1, 1));
					if (Math.abs(m21) < 0.9999999) {
						this._x = Math.atan2(-m23, m22);
						this._y = Math.atan2(-m31, m11);
					} else {
						this._x = 0;
						this._y = Math.atan2(m13, m33);
					}
					break;
				case 'XZY':
					this._z = Math.asin(-clamp(m12, -1, 1));
					if (Math.abs(m12) < 0.9999999) {
						this._x = Math.atan2(m32, m22);
						this._y = Math.atan2(m13, m11);
					} else {
						this._x = Math.atan2(-m23, m33);
						this._y = 0;
					}
					break;
				default:
					console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
			}
			this._order = order;
			if (update === true) this._onChangeCallback();
			return this;
		}
		setFromQuaternion(q, order, update) {
			_matrix$1.makeRotationFromQuaternion(q);
			return this.setFromRotationMatrix(_matrix$1, order, update);
		}
		setFromVector3(v, order = this._order) {
			return this.set(v.x, v.y, v.z, order);
		}
		reorder(newOrder) {
			// WARNING: this discards revolution information -bhouston
			_quaternion$3.setFromEuler(this);
			return this.setFromQuaternion(_quaternion$3, newOrder);
		}
		equals(euler) {
			return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
		}
		fromArray(array) {
			this._x = array[0];
			this._y = array[1];
			this._z = array[2];
			if (array[3] !== undefined) this._order = array[3];
			this._onChangeCallback();
			return this;
		}
		toArray(array = [], offset = 0) {
			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._order;
			return array;
		}
		_onChange(callback) {
			this._onChangeCallback = callback;
			return this;
		}
		_onChangeCallback() {}
			*[Symbol.iterator]() {
				yield this._x;
				yield this._y;
				yield this._z;
				yield this._order;
			}
	}
	Euler.DEFAULT_ORDER = 'XYZ';
	class Layers {
		constructor() {
			this.mask = 1 | 0;
		}
		set(channel) {
			this.mask = (1 << channel | 0) >>> 0;
		}
		enable(channel) {
			this.mask |= 1 << channel | 0;
		}
		enableAll() {
			this.mask = 0xffffffff | 0;
		}
		toggle(channel) {
			this.mask ^= 1 << channel | 0;
		}
		disable(channel) {
			this.mask &= ~(1 << channel | 0);
		}
		disableAll() {
			this.mask = 0;
		}
		test(layers) {
			return (this.mask & layers.mask) !== 0;
		}
		isEnabled(channel) {
			return (this.mask & (1 << channel | 0)) !== 0;
		}
	}
	let _object3DId = 0;
	const _v1$4 = /*@__PURE__*/ new Vector3();
	const _q1 = /*@__PURE__*/ new Quaternion();
	const _m1$1 = /*@__PURE__*/ new Matrix4();
	const _target = /*@__PURE__*/ new Vector3();
	const _position$3 = /*@__PURE__*/ new Vector3();
	const _scale$2 = /*@__PURE__*/ new Vector3();
	const _quaternion$2 = /*@__PURE__*/ new Quaternion();
	const _xAxis = /*@__PURE__*/ new Vector3(1, 0, 0);
	const _yAxis = /*@__PURE__*/ new Vector3(0, 1, 0);
	const _zAxis = /*@__PURE__*/ new Vector3(0, 0, 1);
	const _addedEvent = {
		type: 'added'
	};
	const _removedEvent = {
		type: 'removed'
	};
	class Object3D extends EventDispatcher {
		constructor() {
			super();
			this.isObject3D = true;
			Object.defineProperty(this, 'id', {
				value: _object3DId++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.type = 'Object3D';
			this.parent = null;
			this.children = [];
			this.up = Object3D.DEFAULT_UP.clone();
			const position = new Vector3();
			const rotation = new Euler();
			const quaternion = new Quaternion();
			const scale = new Vector3(1, 1, 1);

			function onRotationChange() {
				quaternion.setFromEuler(rotation, false);
			}

			function onQuaternionChange() {
				rotation.setFromQuaternion(quaternion, undefined, false);
			}
			rotation._onChange(onRotationChange);
			quaternion._onChange(onQuaternionChange);
			Object.defineProperties(this, {
				position: {
					configurable: true,
					enumerable: true,
					value: position
				},
				rotation: {
					configurable: true,
					enumerable: true,
					value: rotation
				},
				quaternion: {
					configurable: true,
					enumerable: true,
					value: quaternion
				},
				scale: {
					configurable: true,
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			});
			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();
			this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
			this.matrixWorldNeedsUpdate = false;
			this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer
			this.layers = new Layers();
			this.visible = true;
			this.castShadow = false;
			this.receiveShadow = false;
			this.frustumCulled = true;
			this.renderOrder = 0;
			this.animations = [];
			this.userData = {};
		}
		onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}
		onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}
		applyMatrix4(matrix) {
			if (this.matrixAutoUpdate) this.updateMatrix();
			this.matrix.premultiply(matrix);
			this.matrix.decompose(this.position, this.quaternion, this.scale);
		}
		applyQuaternion(q) {
			this.quaternion.premultiply(q);
			return this;
		}
		setRotationFromAxisAngle(axis, angle) {
			// assumes axis is normalized
			this.quaternion.setFromAxisAngle(axis, angle);
		}
		setRotationFromEuler(euler) {
			this.quaternion.setFromEuler(euler, true);
		}
		setRotationFromMatrix(m) {
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			this.quaternion.setFromRotationMatrix(m);
		}
		setRotationFromQuaternion(q) {
			// assumes q is normalized
			this.quaternion.copy(q);
		}
		rotateOnAxis(axis, angle) {
			// rotate object on axis in object space
			// axis is assumed to be normalized
			_q1.setFromAxisAngle(axis, angle);
			this.quaternion.multiply(_q1);
			return this;
		}
		rotateOnWorldAxis(axis, angle) {
			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent
			_q1.setFromAxisAngle(axis, angle);
			this.quaternion.premultiply(_q1);
			return this;
		}
		rotateX(angle) {
			return this.rotateOnAxis(_xAxis, angle);
		}
		rotateY(angle) {
			return this.rotateOnAxis(_yAxis, angle);
		}
		rotateZ(angle) {
			return this.rotateOnAxis(_zAxis, angle);
		}
		translateOnAxis(axis, distance) {
			// translate object by distance along axis in object space
			// axis is assumed to be normalized
			_v1$4.copy(axis).applyQuaternion(this.quaternion);
			this.position.add(_v1$4.multiplyScalar(distance));
			return this;
		}
		translateX(distance) {
			return this.translateOnAxis(_xAxis, distance);
		}
		translateY(distance) {
			return this.translateOnAxis(_yAxis, distance);
		}
		translateZ(distance) {
			return this.translateOnAxis(_zAxis, distance);
		}
		localToWorld(vector) {
			this.updateWorldMatrix(true, false);
			return vector.applyMatrix4(this.matrixWorld);
		}
		worldToLocal(vector) {
			this.updateWorldMatrix(true, false);
			return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
		}
		lookAt(x, y, z) {
			// This method does not support objects having non-uniformly-scaled parent(s)
			if (x.isVector3) {
				_target.copy(x);
			} else {
				_target.set(x, y, z);
			}
			const parent = this.parent;
			this.updateWorldMatrix(true, false);
			_position$3.setFromMatrixPosition(this.matrixWorld);
			if (this.isCamera || this.isLight) {
				_m1$1.lookAt(_position$3, _target, this.up);
			} else {
				_m1$1.lookAt(_target, _position$3, this.up);
			}
			this.quaternion.setFromRotationMatrix(_m1$1);
			if (parent) {
				_m1$1.extractRotation(parent.matrixWorld);
				_q1.setFromRotationMatrix(_m1$1);
				this.quaternion.premultiply(_q1.invert());
			}
		}
		add(object) {
			if (arguments.length > 1) {
				for (let i = 0; i < arguments.length; i++) {
					this.add(arguments[i]);
				}
				return this;
			}
			if (object === this) {
				console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
				return this;
			}
			if (object && object.isObject3D) {
				if (object.parent !== null) {
					object.parent.remove(object);
				}
				object.parent = this;
				this.children.push(object);
				object.dispatchEvent(_addedEvent);
			} else {
				console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
			}
			return this;
		}
		remove(object) {
			if (arguments.length > 1) {
				for (let i = 0; i < arguments.length; i++) {
					this.remove(arguments[i]);
				}
				return this;
			}
			const index = this.children.indexOf(object);
			if (index !== -1) {
				object.parent = null;
				this.children.splice(index, 1);
				object.dispatchEvent(_removedEvent);
			}
			return this;
		}
		removeFromParent() {
			const parent = this.parent;
			if (parent !== null) {
				parent.remove(this);
			}
			return this;
		}
		clear() {
			for (let i = 0; i < this.children.length; i++) {
				const object = this.children[i];
				object.parent = null;
				object.dispatchEvent(_removedEvent);
			}
			this.children.length = 0;
			return this;
		}
		attach(object) {
			// adds object as a child of this, while maintaining the object's world transform
			// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
			this.updateWorldMatrix(true, false);
			_m1$1.copy(this.matrixWorld).invert();
			if (object.parent !== null) {
				object.parent.updateWorldMatrix(true, false);
				_m1$1.multiply(object.parent.matrixWorld);
			}
			object.applyMatrix4(_m1$1);
			this.add(object);
			object.updateWorldMatrix(false, true);
			return this;
		}
		getObjectById(id) {
			return this.getObjectByProperty('id', id);
		}
		getObjectByName(name) {
			return this.getObjectByProperty('name', name);
		}
		getObjectByProperty(name, value) {
			if (this[name] === value) return this;
			for (let i = 0, l = this.children.length; i < l; i++) {
				const child = this.children[i];
				const object = child.getObjectByProperty(name, value);
				if (object !== undefined) {
					return object;
				}
			}
			return undefined;
		}
		getObjectsByProperty(name, value) {
			let result = [];
			if (this[name] === value) result.push(this);
			for (let i = 0, l = this.children.length; i < l; i++) {
				const childResult = this.children[i].getObjectsByProperty(name, value);
				if (childResult.length > 0) {
					result = result.concat(childResult);
				}
			}
			return result;
		}
		getWorldPosition(target) {
			this.updateWorldMatrix(true, false);
			return target.setFromMatrixPosition(this.matrixWorld);
		}
		getWorldQuaternion(target) {
			this.updateWorldMatrix(true, false);
			this.matrixWorld.decompose(_position$3, target, _scale$2);
			return target;
		}
		getWorldScale(target) {
			this.updateWorldMatrix(true, false);
			this.matrixWorld.decompose(_position$3, _quaternion$2, target);
			return target;
		}
		getWorldDirection(target) {
			this.updateWorldMatrix(true, false);
			const e = this.matrixWorld.elements;
			return target.set(e[8], e[9], e[10]).normalize();
		}
		raycast( /* raycaster, intersects */ ) {}
		traverse(callback) {
			callback(this);
			const children = this.children;
			for (let i = 0, l = children.length; i < l; i++) {
				children[i].traverse(callback);
			}
		}
		traverseVisible(callback) {
			if (this.visible === false) return;
			callback(this);
			const children = this.children;
			for (let i = 0, l = children.length; i < l; i++) {
				children[i].traverseVisible(callback);
			}
		}
		traverseAncestors(callback) {
			const parent = this.parent;
			if (parent !== null) {
				callback(parent);
				parent.traverseAncestors(callback);
			}
		}
		updateMatrix() {
			this.matrix.compose(this.position, this.quaternion, this.scale);
			this.matrixWorldNeedsUpdate = true;
		}
		updateMatrixWorld(force) {
			if (this.matrixAutoUpdate) this.updateMatrix();
			if (this.matrixWorldNeedsUpdate || force) {
				if (this.parent === null) {
					this.matrixWorld.copy(this.matrix);
				} else {
					this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
				}
				this.matrixWorldNeedsUpdate = false;
				force = true;
			}
			// update children
			const children = this.children;
			for (let i = 0, l = children.length; i < l; i++) {
				const child = children[i];
				if (child.matrixWorldAutoUpdate === true || force === true) {
					child.updateMatrixWorld(force);
				}
			}
		}
		updateWorldMatrix(updateParents, updateChildren) {
			const parent = this.parent;
			if (updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true) {
				parent.updateWorldMatrix(true, false);
			}
			if (this.matrixAutoUpdate) this.updateMatrix();
			if (this.parent === null) {
				this.matrixWorld.copy(this.matrix);
			} else {
				this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
			}
			// update children
			if (updateChildren === true) {
				const children = this.children;
				for (let i = 0, l = children.length; i < l; i++) {
					const child = children[i];
					if (child.matrixWorldAutoUpdate === true) {
						child.updateWorldMatrix(false, true);
					}
				}
			}
		}
		toJSON(meta) {
			// meta is a string when called from JSON.stringify
			const isRootObject = (meta === undefined || typeof meta === 'string');
			const output = {};
			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if (isRootObject) {
				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {},
					nodes: {}
				};
				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};
			}
			// standard Object3D serialization
			const object = {};
			object.uuid = this.uuid;
			object.type = this.type;
			if (this.name !== '') object.name = this.name;
			if (this.castShadow === true) object.castShadow = true;
			if (this.receiveShadow === true) object.receiveShadow = true;
			if (this.visible === false) object.visible = false;
			if (this.frustumCulled === false) object.frustumCulled = false;
			if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
			if (Object.keys(this.userData).length > 0) object.userData = this.userData;
			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();
			if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
			// object specific properties
			if (this.isInstancedMesh) {
				object.type = 'InstancedMesh';
				object.count = this.count;
				object.instanceMatrix = this.instanceMatrix.toJSON();
				if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
			}
			//
			function serialize(library, element) {
				if (library[element.uuid] === undefined) {
					library[element.uuid] = element.toJSON(meta);
				}
				return element.uuid;
			}
			if (this.isScene) {
				if (this.background) {
					if (this.background.isColor) {
						object.background = this.background.toJSON();
					} else if (this.background.isTexture) {
						object.background = this.background.toJSON(meta).uuid;
					}
				}
				if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
					object.environment = this.environment.toJSON(meta).uuid;
				}
			} else if (this.isMesh || this.isLine || this.isPoints) {
				object.geometry = serialize(meta.geometries, this.geometry);
				const parameters = this.geometry.parameters;
				if (parameters !== undefined && parameters.shapes !== undefined) {
					const shapes = parameters.shapes;
					if (Array.isArray(shapes)) {
						for (let i = 0, l = shapes.length; i < l; i++) {
							const shape = shapes[i];
							serialize(meta.shapes, shape);
						}
					} else {
						serialize(meta.shapes, shapes);
					}
				}
			}
			if (this.isSkinnedMesh) {
				object.bindMode = this.bindMode;
				object.bindMatrix = this.bindMatrix.toArray();
				if (this.skeleton !== undefined) {
					serialize(meta.skeletons, this.skeleton);
					object.skeleton = this.skeleton.uuid;
				}
			}
			if (this.material !== undefined) {
				if (Array.isArray(this.material)) {
					const uuids = [];
					for (let i = 0, l = this.material.length; i < l; i++) {
						uuids.push(serialize(meta.materials, this.material[i]));
					}
					object.material = uuids;
				} else {
					object.material = serialize(meta.materials, this.material);
				}
			}
			//
			if (this.children.length > 0) {
				object.children = [];
				for (let i = 0; i < this.children.length; i++) {
					object.children.push(this.children[i].toJSON(meta).object);
				}
			}
			//
			if (this.animations.length > 0) {
				object.animations = [];
				for (let i = 0; i < this.animations.length; i++) {
					const animation = this.animations[i];
					object.animations.push(serialize(meta.animations, animation));
				}
			}
			if (isRootObject) {
				const geometries = extractFromCache(meta.geometries);
				const materials = extractFromCache(meta.materials);
				const textures = extractFromCache(meta.textures);
				const images = extractFromCache(meta.images);
				const shapes = extractFromCache(meta.shapes);
				const skeletons = extractFromCache(meta.skeletons);
				const animations = extractFromCache(meta.animations);
				const nodes = extractFromCache(meta.nodes);
				if (geometries.length > 0) output.geometries = geometries;
				if (materials.length > 0) output.materials = materials;
				if (textures.length > 0) output.textures = textures;
				if (images.length > 0) output.images = images;
				if (shapes.length > 0) output.shapes = shapes;
				if (skeletons.length > 0) output.skeletons = skeletons;
				if (animations.length > 0) output.animations = animations;
				if (nodes.length > 0) output.nodes = nodes;
			}
			output.object = object;
			return output;
			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache(cache) {
				const values = [];
				for (const key in cache) {
					const data = cache[key];
					delete data.metadata;
					values.push(data);
				}
				return values;
			}
		}
		clone(recursive) {
			return new this.constructor().copy(this, recursive);
		}
		copy(source, recursive = true) {
			this.name = source.name;
			this.up.copy(source.up);
			this.position.copy(source.position);
			this.rotation.order = source.rotation.order;
			this.quaternion.copy(source.quaternion);
			this.scale.copy(source.scale);
			this.matrix.copy(source.matrix);
			this.matrixWorld.copy(source.matrixWorld);
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
			this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
			this.layers.mask = source.layers.mask;
			this.visible = source.visible;
			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;
			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;
			this.userData = JSON.parse(JSON.stringify(source.userData));
			if (recursive === true) {
				for (let i = 0; i < source.children.length; i++) {
					const child = source.children[i];
					this.add(child.clone());
				}
			}
			return this;
		}
	}
	Object3D.DEFAULT_UP = /*@__PURE__*/ new Vector3(0, 1, 0);
	Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
	Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
	const _v0$1 = /*@__PURE__*/ new Vector3();
	const _v1$3 = /*@__PURE__*/ new Vector3();
	const _v2$2 = /*@__PURE__*/ new Vector3();
	const _v3$1 = /*@__PURE__*/ new Vector3();
	const _vab = /*@__PURE__*/ new Vector3();
	const _vac = /*@__PURE__*/ new Vector3();
	const _vbc = /*@__PURE__*/ new Vector3();
	const _vap = /*@__PURE__*/ new Vector3();
	const _vbp = /*@__PURE__*/ new Vector3();
	const _vcp = /*@__PURE__*/ new Vector3();
	class Triangle {
		constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
			this.a = a;
			this.b = b;
			this.c = c;
		}
		static getNormal(a, b, c, target) {
			target.subVectors(c, b);
			_v0$1.subVectors(a, b);
			target.cross(_v0$1);
			const targetLengthSq = target.lengthSq();
			if (targetLengthSq > 0) {
				return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
			}
			return target.set(0, 0, 0);
		}
		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		static getBarycoord(point, a, b, c, target) {
			_v0$1.subVectors(c, a);
			_v1$3.subVectors(b, a);
			_v2$2.subVectors(point, a);
			const dot00 = _v0$1.dot(_v0$1);
			const dot01 = _v0$1.dot(_v1$3);
			const dot02 = _v0$1.dot(_v2$2);
			const dot11 = _v1$3.dot(_v1$3);
			const dot12 = _v1$3.dot(_v2$2);
			const denom = (dot00 * dot11 - dot01 * dot01);
			// collinear or singular triangle
			if (denom === 0) {
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return target.set(-2, -1, -1);
			}
			const invDenom = 1 / denom;
			const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
			const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
			// barycentric coordinates must always sum to 1
			return target.set(1 - u - v, v, u);
		}
		static containsPoint(point, a, b, c) {
			this.getBarycoord(point, a, b, c, _v3$1);
			return (_v3$1.x >= 0) && (_v3$1.y >= 0) && ((_v3$1.x + _v3$1.y) <= 1);
		}
		static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
			this.getBarycoord(point, p1, p2, p3, _v3$1);
			target.set(0, 0);
			target.addScaledVector(uv1, _v3$1.x);
			target.addScaledVector(uv2, _v3$1.y);
			target.addScaledVector(uv3, _v3$1.z);
			return target;
		}
		static isFrontFacing(a, b, c, direction) {
			_v0$1.subVectors(c, b);
			_v1$3.subVectors(a, b);
			// strictly front facing
			return (_v0$1.cross(_v1$3).dot(direction) < 0) ? true : false;
		}
		set(a, b, c) {
			this.a.copy(a);
			this.b.copy(b);
			this.c.copy(c);
			return this;
		}
		setFromPointsAndIndices(points, i0, i1, i2) {
			this.a.copy(points[i0]);
			this.b.copy(points[i1]);
			this.c.copy(points[i2]);
			return this;
		}
		setFromAttributeAndIndices(attribute, i0, i1, i2) {
			this.a.fromBufferAttribute(attribute, i0);
			this.b.fromBufferAttribute(attribute, i1);
			this.c.fromBufferAttribute(attribute, i2);
			return this;
		}
		clone() {
			return new this.constructor().copy(this);
		}
		copy(triangle) {
			this.a.copy(triangle.a);
			this.b.copy(triangle.b);
			this.c.copy(triangle.c);
			return this;
		}
		getArea() {
			_v0$1.subVectors(this.c, this.b);
			_v1$3.subVectors(this.a, this.b);
			return _v0$1.cross(_v1$3).length() * 0.5;
		}
		getMidpoint(target) {
			return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
		}
		getNormal(target) {
			return Triangle.getNormal(this.a, this.b, this.c, target);
		}
		getPlane(target) {
			return target.setFromCoplanarPoints(this.a, this.b, this.c);
		}
		getBarycoord(point, target) {
			return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
		}
		getUV(point, uv1, uv2, uv3, target) {
			return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
		}
		containsPoint(point) {
			return Triangle.containsPoint(point, this.a, this.b, this.c);
		}
		isFrontFacing(direction) {
			return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
		}
		intersectsBox(box) {
			return box.intersectsTriangle(this);
		}
		closestPointToPoint(p, target) {
			const a = this.a,
				b = this.b,
				c = this.c;
			let v, w;
			// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.
			_vab.subVectors(b, a);
			_vac.subVectors(c, a);
			_vap.subVectors(p, a);
			const d1 = _vab.dot(_vap);
			const d2 = _vac.dot(_vap);
			if (d1 <= 0 && d2 <= 0) {
				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy(a);
			}
			_vbp.subVectors(p, b);
			const d3 = _vab.dot(_vbp);
			const d4 = _vac.dot(_vbp);
			if (d3 >= 0 && d4 <= d3) {
				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy(b);
			}
			const vc = d1 * d4 - d3 * d2;
			if (vc <= 0 && d1 >= 0 && d3 <= 0) {
				v = d1 / (d1 - d3);
				// edge region of AB; barycentric coords (1-v, v, 0)
				return target.copy(a).addScaledVector(_vab, v);
			}
			_vcp.subVectors(p, c);
			const d5 = _vab.dot(_vcp);
			const d6 = _vac.dot(_vcp);
			if (d6 >= 0 && d5 <= d6) {
				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy(c);
			}
			const vb = d5 * d2 - d1 * d6;
			if (vb <= 0 && d2 >= 0 && d6 <= 0) {
				w = d2 / (d2 - d6);
				// edge region of AC; barycentric coords (1-w, 0, w)
				return target.copy(a).addScaledVector(_vac, w);
			}
			const va = d3 * d6 - d5 * d4;
			if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
				_vbc.subVectors(c, b);
				w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
				// edge region of BC; barycentric coords (0, 1-w, w)
				return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
			}
			// face region
			const denom = 1 / (va + vb + vc);
			// u = va * denom
			v = vb * denom;
			w = vc * denom;
			return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
		}
		equals(triangle) {
			return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
		}
	}
	let materialId = 0;
	class Material extends EventDispatcher {
		constructor() {
			super();
			this.isMaterial = true;
			Object.defineProperty(this, 'id', {
				value: materialId++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.type = 'Material';
			this.blending = NormalBlending;
			this.side = FrontSide;
			this.vertexColors = false;
			this.opacity = 1;
			this.transparent = false;
			this.blendSrc = SrcAlphaFactor;
			this.blendDst = OneMinusSrcAlphaFactor;
			this.blendEquation = AddEquation;
			this.blendSrcAlpha = null;
			this.blendDstAlpha = null;
			this.blendEquationAlpha = null;
			this.depthFunc = LessEqualDepth;
			this.depthTest = true;
			this.depthWrite = true;
			this.stencilWriteMask = 0xff;
			this.stencilFunc = AlwaysStencilFunc;
			this.stencilRef = 0;
			this.stencilFuncMask = 0xff;
			this.stencilFail = KeepStencilOp;
			this.stencilZFail = KeepStencilOp;
			this.stencilZPass = KeepStencilOp;
			this.stencilWrite = false;
			this.clippingPlanes = null;
			this.clipIntersection = false;
			this.clipShadows = false;
			this.shadowSide = null;
			this.colorWrite = true;
			this.precision = null; // override the renderer's default precision for this material
			this.polygonOffset = false;
			this.polygonOffsetFactor = 0;
			this.polygonOffsetUnits = 0;
			this.dithering = false;
			this.alphaToCoverage = false;
			this.premultipliedAlpha = false;
			this.forceSinglePass = false;
			this.visible = true;
			this.toneMapped = true;
			this.userData = {};
			this.version = 0;
			this._alphaTest = 0;
		}
		get alphaTest() {
			return this._alphaTest;
		}
		set alphaTest(value) {
			if (this._alphaTest > 0 !== value > 0) {
				this.version++;
			}
			this._alphaTest = value;
		}
		onBuild( /* shaderobject, renderer */ ) {}
		onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}
		onBeforeCompile( /* shaderobject, renderer */ ) {}
		customProgramCacheKey() {
			return this.onBeforeCompile.toString();
		}
		setValues(values) {
			if (values === undefined) return;
			for (const key in values) {
				const newValue = values[key];
				if (newValue === undefined) {
					console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
					continue;
				}
				const currentValue = this[key];
				if (currentValue === undefined) {
					console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
					continue;
				}
				if (currentValue && currentValue.isColor) {
					currentValue.set(newValue);
				} else if ((currentValue && currentValue.isVector3) && (newValue && newValue.isVector3)) {
					currentValue.copy(newValue);
				} else {
					this[key] = newValue;
				}
			}
		}
		toJSON(meta) {
			const isRootObject = (meta === undefined || typeof meta === 'string');
			if (isRootObject) {
				meta = {
					textures: {},
					images: {}
				};
			}
			const data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};
			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;
			if (this.color && this.color.isColor) data.color = this.color.getHex();
			if (this.roughness !== undefined) data.roughness = this.roughness;
			if (this.metalness !== undefined) data.metalness = this.metalness;
			if (this.sheen !== undefined) data.sheen = this.sheen;
			if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
			if (this.sheenRoughness !== undefined) data.sheenRoughness = this.sheenRoughness;
			if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
			if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
			if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
			if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;
			if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
			if (this.shininess !== undefined) data.shininess = this.shininess;
			if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
			if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
			if (this.clearcoatMap && this.clearcoatMap.isTexture) {
				data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
			}
			if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
				data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
			}
			if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
			}
			if (this.iridescence !== undefined) data.iridescence = this.iridescence;
			if (this.iridescenceIOR !== undefined) data.iridescenceIOR = this.iridescenceIOR;
			if (this.iridescenceThicknessRange !== undefined) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
			if (this.iridescenceMap && this.iridescenceMap.isTexture) {
				data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
			}
			if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
				data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
			}
			if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
			if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
			if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
			if (this.lightMap && this.lightMap.isTexture) {
				data.lightMap = this.lightMap.toJSON(meta).uuid;
				data.lightMapIntensity = this.lightMapIntensity;
			}
			if (this.aoMap && this.aoMap.isTexture) {
				data.aoMap = this.aoMap.toJSON(meta).uuid;
				data.aoMapIntensity = this.aoMapIntensity;
			}
			if (this.bumpMap && this.bumpMap.isTexture) {
				data.bumpMap = this.bumpMap.toJSON(meta).uuid;
				data.bumpScale = this.bumpScale;
			}
			if (this.normalMap && this.normalMap.isTexture) {
				data.normalMap = this.normalMap.toJSON(meta).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();
			}
			if (this.displacementMap && this.displacementMap.isTexture) {
				data.displacementMap = this.displacementMap.toJSON(meta).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;
			}
			if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
			if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
			if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
			if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
			if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
			if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
			if (this.envMap && this.envMap.isTexture) {
				data.envMap = this.envMap.toJSON(meta).uuid;
				if (this.combine !== undefined) data.combine = this.combine;
			}
			if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
			if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
			if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;
			if (this.gradientMap && this.gradientMap.isTexture) {
				data.gradientMap = this.gradientMap.toJSON(meta).uuid;
			}
			if (this.transmission !== undefined) data.transmission = this.transmission;
			if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
			if (this.thickness !== undefined) data.thickness = this.thickness;
			if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
			if (this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
			if (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();
			if (this.size !== undefined) data.size = this.size;
			if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
			if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
			if (this.blending !== NormalBlending) data.blending = this.blending;
			if (this.side !== FrontSide) data.side = this.side;
			if (this.vertexColors) data.vertexColors = true;
			if (this.opacity < 1) data.opacity = this.opacity;
			if (this.transparent === true) data.transparent = this.transparent;
			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;
			data.colorWrite = this.colorWrite;
			data.stencilWrite = this.stencilWrite;
			data.stencilWriteMask = this.stencilWriteMask;
			data.stencilFunc = this.stencilFunc;
			data.stencilRef = this.stencilRef;
			data.stencilFuncMask = this.stencilFuncMask;
			data.stencilFail = this.stencilFail;
			data.stencilZFail = this.stencilZFail;
			data.stencilZPass = this.stencilZPass;
			// rotation (SpriteMaterial)
			if (this.rotation !== undefined && this.rotation !== 0) data.rotation = this.rotation;
			if (this.polygonOffset === true) data.polygonOffset = true;
			if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
			if (this.linewidth !== undefined && this.linewidth !== 1) data.linewidth = this.linewidth;
			if (this.dashSize !== undefined) data.dashSize = this.dashSize;
			if (this.gapSize !== undefined) data.gapSize = this.gapSize;
			if (this.scale !== undefined) data.scale = this.scale;
			if (this.dithering === true) data.dithering = true;
			if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
			if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;
			if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
			if (this.forceSinglePass === true) data.forceSinglePass = this.forceSinglePass;
			if (this.wireframe === true) data.wireframe = this.wireframe;
			if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
			if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
			if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
			if (this.flatShading === true) data.flatShading = this.flatShading;
			if (this.visible === false) data.visible = false;
			if (this.toneMapped === false) data.toneMapped = false;
			if (this.fog === false) data.fog = false;
			if (Object.keys(this.userData).length > 0) data.userData = this.userData;
			// TODO: Copied from Object3D.toJSON
			function extractFromCache(cache) {
				const values = [];
				for (const key in cache) {
					const data = cache[key];
					delete data.metadata;
					values.push(data);
				}
				return values;
			}
			if (isRootObject) {
				const textures = extractFromCache(meta.textures);
				const images = extractFromCache(meta.images);
				if (textures.length > 0) data.textures = textures;
				if (images.length > 0) data.images = images;
			}
			return data;
		}
		clone() {
			return new this.constructor().copy(this);
		}
		copy(source) {
			this.name = source.name;
			this.blending = source.blending;
			this.side = source.side;
			this.vertexColors = source.vertexColors;
			this.opacity = source.opacity;
			this.transparent = source.transparent;
			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;
			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;
			this.stencilWriteMask = source.stencilWriteMask;
			this.stencilFunc = source.stencilFunc;
			this.stencilRef = source.stencilRef;
			this.stencilFuncMask = source.stencilFuncMask;
			this.stencilFail = source.stencilFail;
			this.stencilZFail = source.stencilZFail;
			this.stencilZPass = source.stencilZPass;
			this.stencilWrite = source.stencilWrite;
			const srcPlanes = source.clippingPlanes;
			let dstPlanes = null;
			if (srcPlanes !== null) {
				const n = srcPlanes.length;
				dstPlanes = new Array(n);
				for (let i = 0; i !== n; ++i) {
					dstPlanes[i] = srcPlanes[i].clone();
				}
			}
			this.clippingPlanes = dstPlanes;
			this.clipIntersection = source.clipIntersection;
			this.clipShadows = source.clipShadows;
			this.shadowSide = source.shadowSide;
			this.colorWrite = source.colorWrite;
			this.precision = source.precision;
			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;
			this.dithering = source.dithering;
			this.alphaTest = source.alphaTest;
			this.alphaToCoverage = source.alphaToCoverage;
			this.premultipliedAlpha = source.premultipliedAlpha;
			this.forceSinglePass = source.forceSinglePass;
			this.visible = source.visible;
			this.toneMapped = source.toneMapped;
			this.userData = JSON.parse(JSON.stringify(source.userData));
			return this;
		}
		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}
		set needsUpdate(value) {
			if (value === true) this.version++;
		}
	}
	const _colorKeywords = {
		'aliceblue': 0xF0F8FF,
		'antiquewhite': 0xFAEBD7,
		'aqua': 0x00FFFF,
		'aquamarine': 0x7FFFD4,
		'azure': 0xF0FFFF,
		'beige': 0xF5F5DC,
		'bisque': 0xFFE4C4,
		'black': 0x000000,
		'blanchedalmond': 0xFFEBCD,
		'blue': 0x0000FF,
		'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A,
		'burlywood': 0xDEB887,
		'cadetblue': 0x5F9EA0,
		'chartreuse': 0x7FFF00,
		'chocolate': 0xD2691E,
		'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED,
		'cornsilk': 0xFFF8DC,
		'crimson': 0xDC143C,
		'cyan': 0x00FFFF,
		'darkblue': 0x00008B,
		'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B,
		'darkgray': 0xA9A9A9,
		'darkgreen': 0x006400,
		'darkgrey': 0xA9A9A9,
		'darkkhaki': 0xBDB76B,
		'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F,
		'darkorange': 0xFF8C00,
		'darkorchid': 0x9932CC,
		'darkred': 0x8B0000,
		'darksalmon': 0xE9967A,
		'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B,
		'darkslategray': 0x2F4F4F,
		'darkslategrey': 0x2F4F4F,
		'darkturquoise': 0x00CED1,
		'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493,
		'deepskyblue': 0x00BFFF,
		'dimgray': 0x696969,
		'dimgrey': 0x696969,
		'dodgerblue': 0x1E90FF,
		'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0,
		'forestgreen': 0x228B22,
		'fuchsia': 0xFF00FF,
		'gainsboro': 0xDCDCDC,
		'ghostwhite': 0xF8F8FF,
		'gold': 0xFFD700,
		'goldenrod': 0xDAA520,
		'gray': 0x808080,
		'green': 0x008000,
		'greenyellow': 0xADFF2F,
		'grey': 0x808080,
		'honeydew': 0xF0FFF0,
		'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C,
		'indigo': 0x4B0082,
		'ivory': 0xFFFFF0,
		'khaki': 0xF0E68C,
		'lavender': 0xE6E6FA,
		'lavenderblush': 0xFFF0F5,
		'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD,
		'lightblue': 0xADD8E6,
		'lightcoral': 0xF08080,
		'lightcyan': 0xE0FFFF,
		'lightgoldenrodyellow': 0xFAFAD2,
		'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90,
		'lightgrey': 0xD3D3D3,
		'lightpink': 0xFFB6C1,
		'lightsalmon': 0xFFA07A,
		'lightseagreen': 0x20B2AA,
		'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899,
		'lightslategrey': 0x778899,
		'lightsteelblue': 0xB0C4DE,
		'lightyellow': 0xFFFFE0,
		'lime': 0x00FF00,
		'limegreen': 0x32CD32,
		'linen': 0xFAF0E6,
		'magenta': 0xFF00FF,
		'maroon': 0x800000,
		'mediumaquamarine': 0x66CDAA,
		'mediumblue': 0x0000CD,
		'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB,
		'mediumseagreen': 0x3CB371,
		'mediumslateblue': 0x7B68EE,
		'mediumspringgreen': 0x00FA9A,
		'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585,
		'midnightblue': 0x191970,
		'mintcream': 0xF5FFFA,
		'mistyrose': 0xFFE4E1,
		'moccasin': 0xFFE4B5,
		'navajowhite': 0xFFDEAD,
		'navy': 0x000080,
		'oldlace': 0xFDF5E6,
		'olive': 0x808000,
		'olivedrab': 0x6B8E23,
		'orange': 0xFFA500,
		'orangered': 0xFF4500,
		'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA,
		'palegreen': 0x98FB98,
		'paleturquoise': 0xAFEEEE,
		'palevioletred': 0xDB7093,
		'papayawhip': 0xFFEFD5,
		'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F,
		'pink': 0xFFC0CB,
		'plum': 0xDDA0DD,
		'powderblue': 0xB0E0E6,
		'purple': 0x800080,
		'rebeccapurple': 0x663399,
		'red': 0xFF0000,
		'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1,
		'saddlebrown': 0x8B4513,
		'salmon': 0xFA8072,
		'sandybrown': 0xF4A460,
		'seagreen': 0x2E8B57,
		'seashell': 0xFFF5EE,
		'sienna': 0xA0522D,
		'silver': 0xC0C0C0,
		'skyblue': 0x87CEEB,
		'slateblue': 0x6A5ACD,
		'slategray': 0x708090,
		'slategrey': 0x708090,
		'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F,
		'steelblue': 0x4682B4,
		'tan': 0xD2B48C,
		'teal': 0x008080,
		'thistle': 0xD8BFD8,
		'tomato': 0xFF6347,
		'turquoise': 0x40E0D0,
		'violet': 0xEE82EE,
		'wheat': 0xF5DEB3,
		'white': 0xFFFFFF,
		'whitesmoke': 0xF5F5F5,
		'yellow': 0xFFFF00,
		'yellowgreen': 0x9ACD32
	};
	const _hslA = {
		h: 0,
		s: 0,
		l: 0
	};
	const _hslB = {
		h: 0,
		s: 0,
		l: 0
	};

	function hue2rgb(p, q, t) {
		if (t < 0) t += 1;
		if (t > 1) t -= 1;
		if (t < 1 / 6) return p + (q - p) * 6 * t;
		if (t < 1 / 2) return q;
		if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
		return p;
	}
	class Color {
		constructor(r, g, b) {
			this.isColor = true;
			this.r = 1;
			this.g = 1;
			this.b = 1;
			if (g === undefined && b === undefined) {
				// r is THREE.Color, hex or string
				return this.set(r);
			}
			return this.setRGB(r, g, b);
		}
		set(value) {
			if (value && value.isColor) {
				this.copy(value);
			} else if (typeof value === 'number') {
				this.setHex(value);
			} else if (typeof value === 'string') {
				this.setStyle(value);
			}
			return this;
		}
		setScalar(scalar) {
			this.r = scalar;
			this.g = scalar;
			this.b = scalar;
			return this;
		}
		setHex(hex, colorSpace = SRGBColorSpace) {
			hex = Math.floor(hex);
			this.r = (hex >> 16 & 255) / 255;
			this.g = (hex >> 8 & 255) / 255;
			this.b = (hex & 255) / 255;
			ColorManagement.toWorkingColorSpace(this, colorSpace);
			return this;
		}
		setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
			this.r = r;
			this.g = g;
			this.b = b;
			ColorManagement.toWorkingColorSpace(this, colorSpace);
			return this;
		}
		setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {
			// h,s,l ranges are in 0.0 - 1.0
			h = euclideanModulo(h, 1);
			s = clamp(s, 0, 1);
			l = clamp(l, 0, 1);
			if (s === 0) {
				this.r = this.g = this.b = l;
			} else {
				const p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
				const q = (2 * l) - p;
				this.r = hue2rgb(q, p, h + 1 / 3);
				this.g = hue2rgb(q, p, h);
				this.b = hue2rgb(q, p, h - 1 / 3);
			}
			ColorManagement.toWorkingColorSpace(this, colorSpace);
			return this;
		}
		setStyle(style, colorSpace = SRGBColorSpace) {
			function handleAlpha(string) {
				if (string === undefined) return;
				if (parseFloat(string) < 1) {
					console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
				}
			}
			let m;
			if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
				// rgb / hsl
				let color;
				const name = m[1];
				const components = m[2];
				switch (name) {
					case 'rgb':
					case 'rgba':
						if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min(255, parseInt(color[1], 10)) / 255;
							this.g = Math.min(255, parseInt(color[2], 10)) / 255;
							this.b = Math.min(255, parseInt(color[3], 10)) / 255;
							ColorManagement.toWorkingColorSpace(this, colorSpace);
							handleAlpha(color[4]);
							return this;
						}
						if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min(100, parseInt(color[1], 10)) / 100;
							this.g = Math.min(100, parseInt(color[2], 10)) / 100;
							this.b = Math.min(100, parseInt(color[3], 10)) / 100;
							ColorManagement.toWorkingColorSpace(this, colorSpace);
							handleAlpha(color[4]);
							return this;
						}
						break;
					case 'hsl':
					case 'hsla':
						if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							const h = parseFloat(color[1]) / 360;
							const s = parseFloat(color[2]) / 100;
							const l = parseFloat(color[3]) / 100;
							handleAlpha(color[4]);
							return this.setHSL(h, s, l, colorSpace);
						}
						break;
					default:
						console.warn('THREE.Color: Unknown color model ' + style);
				}
			} else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
				// hex color
				const hex = m[1];
				const size = hex.length;
				if (size === 3) {
					// #ff0
					this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
					this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
					this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
					ColorManagement.toWorkingColorSpace(this, colorSpace);
					return this;
				} else if (size === 6) {
					// #ff0000
					this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
					this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
					this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
					ColorManagement.toWorkingColorSpace(this, colorSpace);
					return this;
				} else {
					console.warn('THREE.Color: Invalid hex color ' + style);
				}
			} else if (style && style.length > 0) {
				return this.setColorName(style, colorSpace);
			}
			return this;
		}
		setColorName(style, colorSpace = SRGBColorSpace) {
			// color keywords
			const hex = _colorKeywords[style.toLowerCase()];
			if (hex !== undefined) {
				// red
				this.setHex(hex, colorSpace);
			} else {
				// unknown color
				console.warn('THREE.Color: Unknown color ' + style);
			}
			return this;
		}
		clone() {
			return new this.constructor(this.r, this.g, this.b);
		}
		copy(color) {
			this.r = color.r;
			this.g = color.g;
			this.b = color.b;
			return this;
		}
		copySRGBToLinear(color) {
			this.r = SRGBToLinear(color.r);
			this.g = SRGBToLinear(color.g);
			this.b = SRGBToLinear(color.b);
			return this;
		}
		copyLinearToSRGB(color) {
			this.r = LinearToSRGB(color.r);
			this.g = LinearToSRGB(color.g);
			this.b = LinearToSRGB(color.b);
			return this;
		}
		convertSRGBToLinear() {
			this.copySRGBToLinear(this);
			return this;
		}
		convertLinearToSRGB() {
			this.copyLinearToSRGB(this);
			return this;
		}
		getHex(colorSpace = SRGBColorSpace) {
			ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
			return clamp(_color.r * 255, 0, 255) << 16 ^ clamp(_color.g * 255, 0, 255) << 8 ^ clamp(_color.b * 255, 0, 255) << 0;
		}
		getHexString(colorSpace = SRGBColorSpace) {
			return ('000000' + this.getHex(colorSpace).toString(16)).slice(-6);
		}
		getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
			// h,s,l ranges are in 0.0 - 1.0
			ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
			const r = _color.r,
				g = _color.g,
				b = _color.b;
			const max = Math.max(r, g, b);
			const min = Math.min(r, g, b);
			let hue, saturation;
			const lightness = (min + max) / 2.0;
			if (min === max) {
				hue = 0;
				saturation = 0;
			} else {
				const delta = max - min;
				saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
				switch (max) {
					case r:
						hue = (g - b) / delta + (g < b ? 6 : 0);
						break;
					case g:
						hue = (b - r) / delta + 2;
						break;
					case b:
						hue = (r - g) / delta + 4;
						break;
				}
				hue /= 6;
			}
			target.h = hue;
			target.s = saturation;
			target.l = lightness;
			return target;
		}
		getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
			ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
			target.r = _color.r;
			target.g = _color.g;
			target.b = _color.b;
			return target;
		}
		getStyle(colorSpace = SRGBColorSpace) {
			ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
			const r = _color.r,
				g = _color.g,
				b = _color.b;
			if (colorSpace !== SRGBColorSpace) {
				// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
				return `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;
			}
			return `rgb(${( r * 255 ) | 0},${( g * 255 ) | 0},${( b * 255 ) | 0})`;
		}
		offsetHSL(h, s, l) {
			this.getHSL(_hslA);
			_hslA.h += h;
			_hslA.s += s;
			_hslA.l += l;
			this.setHSL(_hslA.h, _hslA.s, _hslA.l);
			return this;
		}
		add(color) {
			this.r += color.r;
			this.g += color.g;
			this.b += color.b;
			return this;
		}
		addColors(color1, color2) {
			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;
			return this;
		}
		addScalar(s) {
			this.r += s;
			this.g += s;
			this.b += s;
			return this;
		}
		sub(color) {
			this.r = Math.max(0, this.r - color.r);
			this.g = Math.max(0, this.g - color.g);
			this.b = Math.max(0, this.b - color.b);
			return this;
		}
		multiply(color) {
			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;
			return this;
		}
		multiplyScalar(s) {
			this.r *= s;
			this.g *= s;
			this.b *= s;
			return this;
		}
		lerp(color, alpha) {
			this.r += (color.r - this.r) * alpha;
			this.g += (color.g - this.g) * alpha;
			this.b += (color.b - this.b) * alpha;
			return this;
		}
		lerpColors(color1, color2, alpha) {
			this.r = color1.r + (color2.r - color1.r) * alpha;
			this.g = color1.g + (color2.g - color1.g) * alpha;
			this.b = color1.b + (color2.b - color1.b) * alpha;
			return this;
		}
		lerpHSL(color, alpha) {
			this.getHSL(_hslA);
			color.getHSL(_hslB);
			const h = lerp(_hslA.h, _hslB.h, alpha);
			const s = lerp(_hslA.s, _hslB.s, alpha);
			const l = lerp(_hslA.l, _hslB.l, alpha);
			this.setHSL(h, s, l);
			return this;
		}
		equals(c) {
			return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);
		}
		fromArray(array, offset = 0) {
			this.r = array[offset];
			this.g = array[offset + 1];
			this.b = array[offset + 2];
			return this;
		}
		toArray(array = [], offset = 0) {
			array[offset] = this.r;
			array[offset + 1] = this.g;
			array[offset + 2] = this.b;
			return array;
		}
		fromBufferAttribute(attribute, index) {
			this.r = attribute.getX(index);
			this.g = attribute.getY(index);
			this.b = attribute.getZ(index);
			return this;
		}
		toJSON() {
				return this.getHex();
			}
			*[Symbol.iterator]() {
				yield this.r;
				yield this.g;
				yield this.b;
			}
	}
	const _color = new Color();
	Color.NAMES = _colorKeywords;
	class MeshBasicMaterial extends Material {
		constructor(parameters) {
			super();
			this.isMeshBasicMaterial = true;
			this.type = 'MeshBasicMaterial';
			this.color = new Color(0xffffff); // emissive
			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.specularMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.fog = true;
			this.setValues(parameters);
		}
		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.fog = source.fog;
			return this;
		}
	}
	const _vector$9 = /*@__PURE__*/ new Vector3();
	const _vector2$1 = /*@__PURE__*/ new Vector2();
	class BufferAttribute {
		constructor(array, itemSize, normalized = false) {
			if (Array.isArray(array)) {
				throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
			}
			this.isBufferAttribute = true;
			this.name = '';
			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized;
			this.usage = StaticDrawUsage;
			this.updateRange = {
				offset: 0,
				count: -1
			};
			this.version = 0;
		}
		onUploadCallback() {}
		set needsUpdate(value) {
			if (value === true) this.version++;
		}
		setUsage(value) {
			this.usage = value;
			return this;
		}
		copy(source) {
			this.name = source.name;
			this.array = new source.array.constructor(source.array);
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;
			this.usage = source.usage;
			return this;
		}
		copyAt(index1, attribute, index2) {
			index1 *= this.itemSize;
			index2 *= attribute.itemSize;
			for (let i = 0, l = this.itemSize; i < l; i++) {
				this.array[index1 + i] = attribute.array[index2 + i];
			}
			return this;
		}
		copyArray(array) {
			this.array.set(array);
			return this;
		}
		applyMatrix3(m) {
			if (this.itemSize === 2) {
				for (let i = 0, l = this.count; i < l; i++) {
					_vector2$1.fromBufferAttribute(this, i);
					_vector2$1.applyMatrix3(m);
					this.setXY(i, _vector2$1.x, _vector2$1.y);
				}
			} else if (this.itemSize === 3) {
				for (let i = 0, l = this.count; i < l; i++) {
					_vector$9.fromBufferAttribute(this, i);
					_vector$9.applyMatrix3(m);
					this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
				}
			}
			return this;
		}
		applyMatrix4(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.fromBufferAttribute(this, i);
				_vector$9.applyMatrix4(m);
				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}
			return this;
		}
		applyNormalMatrix(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.fromBufferAttribute(this, i);
				_vector$9.applyNormalMatrix(m);
				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}
			return this;
		}
		transformDirection(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.fromBufferAttribute(this, i);
				_vector$9.transformDirection(m);
				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}
			return this;
		}
		set(value, offset = 0) {
			// Matching BufferAttribute constructor, do not normalize the array.
			this.array.set(value, offset);
			return this;
		}
		getX(index) {
			let x = this.array[index * this.itemSize];
			if (this.normalized) x = denormalize(x, this.array);
			return x;
		}
		setX(index, x) {
			if (this.normalized) x = normalize(x, this.array);
			this.array[index * this.itemSize] = x;
			return this;
		}
		getY(index) {
			let y = this.array[index * this.itemSize + 1];
			if (this.normalized) y = denormalize(y, this.array);
			return y;
		}
		setY(index, y) {
			if (this.normalized) y = normalize(y, this.array);
			this.array[index * this.itemSize + 1] = y;
			return this;
		}
		getZ(index) {
			let z = this.array[index * this.itemSize + 2];
			if (this.normalized) z = denormalize(z, this.array);
			return z;
		}
		setZ(index, z) {
			if (this.normalized) z = normalize(z, this.array);
			this.array[index * this.itemSize + 2] = z;
			return this;
		}
		getW(index) {
			let w = this.array[index * this.itemSize + 3];
			if (this.normalized) w = denormalize(w, this.array);
			return w;
		}
		setW(index, w) {
			if (this.normalized) w = normalize(w, this.array);
			this.array[index * this.itemSize + 3] = w;
			return this;
		}
		setXY(index, x, y) {
			index *= this.itemSize;
			if (this.normalized) {
				x = normalize(x, this.array);
				y = normalize(y, this.array);
			}
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			return this;
		}
		setXYZ(index, x, y, z) {
			index *= this.itemSize;
			if (this.normalized) {
				x = normalize(x, this.array);
				y = normalize(y, this.array);
				z = normalize(z, this.array);
			}
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;
			return this;
		}
		setXYZW(index, x, y, z, w) {
			index *= this.itemSize;
			if (this.normalized) {
				x = normalize(x, this.array);
				y = normalize(y, this.array);
				z = normalize(z, this.array);
				w = normalize(w, this.array);
			}
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;
			this.array[index + 3] = w;
			return this;
		}
		onUpload(callback) {
			this.onUploadCallback = callback;
			return this;
		}
		clone() {
			return new this.constructor(this.array, this.itemSize).copy(this);
		}
		toJSON() {
			const data = {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.from(this.array),
				normalized: this.normalized
			};
			if (this.name !== '') data.name = this.name;
			if (this.usage !== StaticDrawUsage) data.usage = this.usage;
			if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
			return data;
		}
		// @deprecated
		copyColorsArray() {
			console.error('THREE.BufferAttribute: copyColorsArray() was removed in r144.');
		}
		copyVector2sArray() {
			console.error('THREE.BufferAttribute: copyVector2sArray() was removed in r144.');
		}
		copyVector3sArray() {
			console.error('THREE.BufferAttribute: copyVector3sArray() was removed in r144.');
		}
		copyVector4sArray() {
			console.error('THREE.BufferAttribute: copyVector4sArray() was removed in r144.');
		}
	}
	//
	class Int8BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Int8Array(array), itemSize, normalized);
		}
	}
	class Uint8BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint8Array(array), itemSize, normalized);
		}
	}
	class Uint8ClampedBufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint8ClampedArray(array), itemSize, normalized);
		}
	}
	class Int16BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Int16Array(array), itemSize, normalized);
		}
	}
	class Uint16BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint16Array(array), itemSize, normalized);
		}
	}
	class Int32BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Int32Array(array), itemSize, normalized);
		}
	}
	class Uint32BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint32Array(array), itemSize, normalized);
		}
	}
	class Float16BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint16Array(array), itemSize, normalized);
			this.isFloat16BufferAttribute = true;
		}
	}
	class Float32BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Float32Array(array), itemSize, normalized);
		}
	}
	class Float64BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Float64Array(array), itemSize, normalized);
		}
	}
	let _id$1 = 0;
	const _m1 = /*@__PURE__*/ new Matrix4();
	const _obj = /*@__PURE__*/ new Object3D();
	const _offset = /*@__PURE__*/ new Vector3();
	const _box$1 = /*@__PURE__*/ new Box3();
	const _boxMorphTargets = /*@__PURE__*/ new Box3();
	const _vector$8 = /*@__PURE__*/ new Vector3();
	class BufferGeometry extends EventDispatcher {
		constructor() {
			super();
			this.isBufferGeometry = true;
			Object.defineProperty(this, 'id', {
				value: _id$1++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.type = 'BufferGeometry';
			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.morphTargetsRelative = false;
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;
			this.drawRange = {
				start: 0,
				count: Infinity
			};
			this.userData = {};
		}
		getIndex() {
			return this.index;
		}
		setIndex(index) {
			if (Array.isArray(index)) {
				this.index = new(arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
			} else {
				this.index = index;
			}
			return this;
		}
		getAttribute(name) {
			return this.attributes[name];
		}
		setAttribute(name, attribute) {
			this.attributes[name] = attribute;
			return this;
		}
		deleteAttribute(name) {
			delete this.attributes[name];
			return this;
		}
		hasAttribute(name) {
			return this.attributes[name] !== undefined;
		}
		addGroup(start, count, materialIndex = 0) {
			this.groups.push({
				start: start,
				count: count,
				materialIndex: materialIndex
			});
		}
		clearGroups() {
			this.groups = [];
		}
		setDrawRange(start, count) {
			this.drawRange.start = start;
			this.drawRange.count = count;
		}
		applyMatrix4(matrix) {
			const position = this.attributes.position;
			if (position !== undefined) {
				position.applyMatrix4(matrix);
				position.needsUpdate = true;
			}
			const normal = this.attributes.normal;
			if (normal !== undefined) {
				const normalMatrix = new Matrix3().getNormalMatrix(matrix);
				normal.applyNormalMatrix(normalMatrix);
				normal.needsUpdate = true;
			}
			const tangent = this.attributes.tangent;
			if (tangent !== undefined) {
				tangent.transformDirection(matrix);
				tangent.needsUpdate = true;
			}
			if (this.boundingBox !== null) {
				this.computeBoundingBox();
			}
			if (this.boundingSphere !== null) {
				this.computeBoundingSphere();
			}
			return this;
		}
		applyQuaternion(q) {
			_m1.makeRotationFromQuaternion(q);
			this.applyMatrix4(_m1);
			return this;
		}
		rotateX(angle) {
			// rotate geometry around world x-axis
			_m1.makeRotationX(angle);
			this.applyMatrix4(_m1);
			return this;
		}
		rotateY(angle) {
			// rotate geometry around world y-axis
			_m1.makeRotationY(angle);
			this.applyMatrix4(_m1);
			return this;
		}
		rotateZ(angle) {
			// rotate geometry around world z-axis
			_m1.makeRotationZ(angle);
			this.applyMatrix4(_m1);
			return this;
		}
		translate(x, y, z) {
			// translate geometry
			_m1.makeTranslation(x, y, z);
			this.applyMatrix4(_m1);
			return this;
		}
		scale(x, y, z) {
			// scale geometry
			_m1.makeScale(x, y, z);
			this.applyMatrix4(_m1);
			return this;
		}
		lookAt(vector) {
			_obj.lookAt(vector);
			_obj.updateMatrix();
			this.applyMatrix4(_obj.matrix);
			return this;
		}
		center() {
			this.computeBoundingBox();
			this.boundingBox.getCenter(_offset).negate();
			this.translate(_offset.x, _offset.y, _offset.z);
			return this;
		}
		setFromPoints(points) {
			const position = [];
			for (let i = 0, l = points.length; i < l; i++) {
				const point = points[i];
				position.push(point.x, point.y, point.z || 0);
			}
			this.setAttribute('position', new Float32BufferAttribute(position, 3));
			return this;
		}
		computeBoundingBox() {
			if (this.boundingBox === null) {
				this.boundingBox = new Box3();
			}
			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;
			if (position && position.isGLBufferAttribute) {
				console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
				this.boundingBox.set(
					new Vector3(-Infinity, -Infinity, -Infinity),
					new Vector3(+Infinity, +Infinity, +Infinity)
				);
				return;
			}
			if (position !== undefined) {
				this.boundingBox.setFromBufferAttribute(position);
				// process morph attributes if present
				if (morphAttributesPosition) {
					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
						const morphAttribute = morphAttributesPosition[i];
						_box$1.setFromBufferAttribute(morphAttribute);
						if (this.morphTargetsRelative) {
							_vector$8.addVectors(this.boundingBox.min, _box$1.min);
							this.boundingBox.expandByPoint(_vector$8);
							_vector$8.addVectors(this.boundingBox.max, _box$1.max);
							this.boundingBox.expandByPoint(_vector$8);
						} else {
							this.boundingBox.expandByPoint(_box$1.min);
							this.boundingBox.expandByPoint(_box$1.max);
						}
					}
				}
			} else {
				this.boundingBox.makeEmpty();
			}
			if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
				console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
			}
		}
		computeBoundingSphere() {
			if (this.boundingSphere === null) {
				this.boundingSphere = new Sphere();
			}
			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;
			if (position && position.isGLBufferAttribute) {
				console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
				this.boundingSphere.set(new Vector3(), Infinity);
				return;
			}
			if (position) {
				// first, find the center of the bounding sphere
				const center = this.boundingSphere.center;
				_box$1.setFromBufferAttribute(position);
				// process morph attributes if present
				if (morphAttributesPosition) {
					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
						const morphAttribute = morphAttributesPosition[i];
						_boxMorphTargets.setFromBufferAttribute(morphAttribute);
						if (this.morphTargetsRelative) {
							_vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
							_box$1.expandByPoint(_vector$8);
							_vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
							_box$1.expandByPoint(_vector$8);
						} else {
							_box$1.expandByPoint(_boxMorphTargets.min);
							_box$1.expandByPoint(_boxMorphTargets.max);
						}
					}
				}
				_box$1.getCenter(center);
				// second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
				let maxRadiusSq = 0;
				for (let i = 0, il = position.count; i < il; i++) {
					_vector$8.fromBufferAttribute(position, i);
					maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
				}
				// process morph attributes if present
				if (morphAttributesPosition) {
					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
						const morphAttribute = morphAttributesPosition[i];
						const morphTargetsRelative = this.morphTargetsRelative;
						for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
							_vector$8.fromBufferAttribute(morphAttribute, j);
							if (morphTargetsRelative) {
								_offset.fromBufferAttribute(position, j);
								_vector$8.add(_offset);
							}
							maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
						}
					}
				}
				this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
				if (isNaN(this.boundingSphere.radius)) {
					console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
				}
			}
		}
		computeTangents() {
			const index = this.index;
			const attributes = this.attributes;
			// based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)
			if (index === null ||
				attributes.position === undefined ||
				attributes.normal === undefined ||
				attributes.uv === undefined) {
				console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
				return;
			}
			const indices = index.array;
			const positions = attributes.position.array;
			const normals = attributes.normal.array;
			const uvs = attributes.uv.array;
			const nVertices = positions.length / 3;
			if (this.hasAttribute('tangent') === false) {
				this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
			}
			const tangents = this.getAttribute('tangent').array;
			const tan1 = [],
				tan2 = [];
			for (let i = 0; i < nVertices; i++) {
				tan1[i] = new Vector3();
				tan2[i] = new Vector3();
			}
			const vA = new Vector3(),
				vB = new Vector3(),
				vC = new Vector3(),
				uvA = new Vector2(),
				uvB = new Vector2(),
				uvC = new Vector2(),
				sdir = new Vector3(),
				tdir = new Vector3();

			function handleTriangle(a, b, c) {
				vA.fromArray(positions, a * 3);
				vB.fromArray(positions, b * 3);
				vC.fromArray(positions, c * 3);
				uvA.fromArray(uvs, a * 2);
				uvB.fromArray(uvs, b * 2);
				uvC.fromArray(uvs, c * 2);
				vB.sub(vA);
				vC.sub(vA);
				uvB.sub(uvA);
				uvC.sub(uvA);
				const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);
				// silently ignore degenerate uv triangles having coincident or colinear vertices
				if (!isFinite(r)) return;
				sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
				tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
				tan1[a].add(sdir);
				tan1[b].add(sdir);
				tan1[c].add(sdir);
				tan2[a].add(tdir);
				tan2[b].add(tdir);
				tan2[c].add(tdir);
			}
			let groups = this.groups;
			if (groups.length === 0) {
				groups = [{
					start: 0,
					count: indices.length
				}];
			}
			for (let i = 0, il = groups.length; i < il; ++i) {
				const group = groups[i];
				const start = group.start;
				const count = group.count;
				for (let j = start, jl = start + count; j < jl; j += 3) {
					handleTriangle(
						indices[j + 0],
						indices[j + 1],
						indices[j + 2]
					);
				}
			}
			const tmp = new Vector3(),
				tmp2 = new Vector3();
			const n = new Vector3(),
				n2 = new Vector3();

			function handleVertex(v) {
				n.fromArray(normals, v * 3);
				n2.copy(n);
				const t = tan1[v];
				// Gram-Schmidt orthogonalize
				tmp.copy(t);
				tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
				// Calculate handedness
				tmp2.crossVectors(n2, t);
				const test = tmp2.dot(tan2[v]);
				const w = (test < 0.0) ? -1.0 : 1.0;
				tangents[v * 4] = tmp.x;
				tangents[v * 4 + 1] = tmp.y;
				tangents[v * 4 + 2] = tmp.z;
				tangents[v * 4 + 3] = w;
			}
			for (let i = 0, il = groups.length; i < il; ++i) {
				const group = groups[i];
				const start = group.start;
				const count = group.count;
				for (let j = start, jl = start + count; j < jl; j += 3) {
					handleVertex(indices[j + 0]);
					handleVertex(indices[j + 1]);
					handleVertex(indices[j + 2]);
				}
			}
		}
		computeVertexNormals() {
			const index = this.index;
			const positionAttribute = this.getAttribute('position');
			if (positionAttribute !== undefined) {
				let normalAttribute = this.getAttribute('normal');
				if (normalAttribute === undefined) {
					normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
					this.setAttribute('normal', normalAttribute);
				} else {
					// reset existing normals to zero
					for (let i = 0, il = normalAttribute.count; i < il; i++) {
						normalAttribute.setXYZ(i, 0, 0, 0);
					}
				}
				const pA = new Vector3(),
					pB = new Vector3(),
					pC = new Vector3();
				const nA = new Vector3(),
					nB = new Vector3(),
					nC = new Vector3();
				const cb = new Vector3(),
					ab = new Vector3();
				// indexed elements
				if (index) {
					for (let i = 0, il = index.count; i < il; i += 3) {
						const vA = index.getX(i + 0);
						const vB = index.getX(i + 1);
						const vC = index.getX(i + 2);
						pA.fromBufferAttribute(positionAttribute, vA);
						pB.fromBufferAttribute(positionAttribute, vB);
						pC.fromBufferAttribute(positionAttribute, vC);
						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);
						nA.fromBufferAttribute(normalAttribute, vA);
						nB.fromBufferAttribute(normalAttribute, vB);
						nC.fromBufferAttribute(normalAttribute, vC);
						nA.add(cb);
						nB.add(cb);
						nC.add(cb);
						normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
						normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
						normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
					}
				} else {
					// non-indexed elements (unconnected triangle soup)
					for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
						pA.fromBufferAttribute(positionAttribute, i + 0);
						pB.fromBufferAttribute(positionAttribute, i + 1);
						pC.fromBufferAttribute(positionAttribute, i + 2);
						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);
						normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
						normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
						normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
					}
				}
				this.normalizeNormals();
				normalAttribute.needsUpdate = true;
			}
		}
		// @deprecated since r144
		merge() {
			console.error('THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead.');
			return this;
		}
		normalizeNormals() {
			const normals = this.attributes.normal;
			for (let i = 0, il = normals.count; i < il; i++) {
				_vector$8.fromBufferAttribute(normals, i);
				_vector$8.normalize();
				normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
			}
		}
		toNonIndexed() {
			function convertBufferAttribute(attribute, indices) {
				const array = attribute.array;
				const itemSize = attribute.itemSize;
				const normalized = attribute.normalized;
				const array2 = new array.constructor(indices.length * itemSize);
				let index = 0,
					index2 = 0;
				for (let i = 0, l = indices.length; i < l; i++) {
					if (attribute.isInterleavedBufferAttribute) {
						index = indices[i] * attribute.data.stride + attribute.offset;
					} else {
						index = indices[i] * itemSize;
					}
					for (let j = 0; j < itemSize; j++) {
						array2[index2++] = array[index++];
					}
				}
				return new BufferAttribute(array2, itemSize, normalized);
			}
			//
			if (this.index === null) {
				console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
				return this;
			}
			const geometry2 = new BufferGeometry();
			const indices = this.index.array;
			const attributes = this.attributes;
			// attributes
			for (const name in attributes) {
				const attribute = attributes[name];
				const newAttribute = convertBufferAttribute(attribute, indices);
				geometry2.setAttribute(name, newAttribute);
			}
			// morph attributes
			const morphAttributes = this.morphAttributes;
			for (const name in morphAttributes) {
				const morphArray = [];
				const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes
				for (let i = 0, il = morphAttribute.length; i < il; i++) {
					const attribute = morphAttribute[i];
					const newAttribute = convertBufferAttribute(attribute, indices);
					morphArray.push(newAttribute);
				}
				geometry2.morphAttributes[name] = morphArray;
			}
			geometry2.morphTargetsRelative = this.morphTargetsRelative;
			// groups
			const groups = this.groups;
			for (let i = 0, l = groups.length; i < l; i++) {
				const group = groups[i];
				geometry2.addGroup(group.start, group.count, group.materialIndex);
			}
			return geometry2;
		}
		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};
			// standard BufferGeometry serialization
			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;
			if (Object.keys(this.userData).length > 0) data.userData = this.userData;
			if (this.parameters !== undefined) {
				const parameters = this.parameters;
				for (const key in parameters) {
					if (parameters[key] !== undefined) data[key] = parameters[key];
				}
				return data;
			}
			// for simplicity the code assumes attributes are not shared across geometries, see #15811
			data.data = {
				attributes: {}
			};
			const index = this.index;
			if (index !== null) {
				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call(index.array)
				};
			}
			const attributes = this.attributes;
			for (const key in attributes) {
				const attribute = attributes[key];
				data.data.attributes[key] = attribute.toJSON(data.data);
			}
			const morphAttributes = {};
			let hasMorphAttributes = false;
			for (const key in this.morphAttributes) {
				const attributeArray = this.morphAttributes[key];
				const array = [];
				for (let i = 0, il = attributeArray.length; i < il; i++) {
					const attribute = attributeArray[i];
					array.push(attribute.toJSON(data.data));
				}
				if (array.length > 0) {
					morphAttributes[key] = array;
					hasMorphAttributes = true;
				}
			}
			if (hasMorphAttributes) {
				data.data.morphAttributes = morphAttributes;
				data.data.morphTargetsRelative = this.morphTargetsRelative;
			}
			const groups = this.groups;
			if (groups.length > 0) {
				data.data.groups = JSON.parse(JSON.stringify(groups));
			}
			const boundingSphere = this.boundingSphere;
			if (boundingSphere !== null) {
				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};
			}
			return data;
		}
		clone() {
			return new this.constructor().copy(this);
		}
		copy(source) {
			// reset
			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;
			// used for storing cloned, shared data
			const data = {};
			// name
			this.name = source.name;
			// index
			const index = source.index;
			if (index !== null) {
				this.setIndex(index.clone(data));
			}
			// attributes
			const attributes = source.attributes;
			for (const name in attributes) {
				const attribute = attributes[name];
				this.setAttribute(name, attribute.clone(data));
			}
			// morph attributes
			const morphAttributes = source.morphAttributes;
			for (const name in morphAttributes) {
				const array = [];
				const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes
				for (let i = 0, l = morphAttribute.length; i < l; i++) {
					array.push(morphAttribute[i].clone(data));
				}
				this.morphAttributes[name] = array;
			}
			this.morphTargetsRelative = source.morphTargetsRelative;
			// groups
			const groups = source.groups;
			for (let i = 0, l = groups.length; i < l; i++) {
				const group = groups[i];
				this.addGroup(group.start, group.count, group.materialIndex);
			}
			// bounding box
			const boundingBox = source.boundingBox;
			if (boundingBox !== null) {
				this.boundingBox = boundingBox.clone();
			}
			// bounding sphere
			const boundingSphere = source.boundingSphere;
			if (boundingSphere !== null) {
				this.boundingSphere = boundingSphere.clone();
			}
			// draw range
			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;
			// user data
			this.userData = source.userData;
			return this;
		}
		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}
	}
	const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
	const _ray$2 = /*@__PURE__*/ new Ray();
	const _sphere$3 = /*@__PURE__*/ new Sphere();
	const _sphereHitAt = /*@__PURE__*/ new Vector3();
	const _vA$1 = /*@__PURE__*/ new Vector3();
	const _vB$1 = /*@__PURE__*/ new Vector3();
	const _vC$1 = /*@__PURE__*/ new Vector3();
	const _tempA = /*@__PURE__*/ new Vector3();
	const _morphA = /*@__PURE__*/ new Vector3();
	const _uvA$1 = /*@__PURE__*/ new Vector2();
	const _uvB$1 = /*@__PURE__*/ new Vector2();
	const _uvC$1 = /*@__PURE__*/ new Vector2();
	const _intersectionPoint = /*@__PURE__*/ new Vector3();
	const _intersectionPointWorld = /*@__PURE__*/ new Vector3();
	class Mesh extends Object3D {
		constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
			super();
			this.isMesh = true;
			this.type = 'Mesh';
			this.geometry = geometry;
			this.material = material;
			this.updateMorphTargets();
		}
		copy(source, recursive) {
			super.copy(source, recursive);
			if (source.morphTargetInfluences !== undefined) {
				this.morphTargetInfluences = source.morphTargetInfluences.slice();
			}
			if (source.morphTargetDictionary !== undefined) {
				this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
			}
			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		}
		updateMorphTargets() {
			const geometry = this.geometry;
			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys(morphAttributes);
			if (keys.length > 0) {
				const morphAttribute = morphAttributes[keys[0]];
				if (morphAttribute !== undefined) {
					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};
					for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
						const name = morphAttribute[m].name || String(m);
						this.morphTargetInfluences.push(0);
						this.morphTargetDictionary[name] = m;
					}
				}
			}
		}
		getVertexPosition(index, target) {
			const geometry = this.geometry;
			const position = geometry.attributes.position;
			const morphPosition = geometry.morphAttributes.position;
			const morphTargetsRelative = geometry.morphTargetsRelative;
			target.fromBufferAttribute(position, index);
			const morphInfluences = this.morphTargetInfluences;
			if (morphPosition && morphInfluences) {
				_morphA.set(0, 0, 0);
				for (let i = 0, il = morphPosition.length; i < il; i++) {
					const influence = morphInfluences[i];
					const morphAttribute = morphPosition[i];
					if (influence === 0) continue;
					_tempA.fromBufferAttribute(morphAttribute, index);
					if (morphTargetsRelative) {
						_morphA.addScaledVector(_tempA, influence);
					} else {
						_morphA.addScaledVector(_tempA.sub(target), influence);
					}
				}
				target.add(_morphA);
			}
			if (this.isSkinnedMesh) {
				this.boneTransform(index, target);
			}
			return target;
		}
		raycast(raycaster, intersects) {
			const geometry = this.geometry;
			const material = this.material;
			const matrixWorld = this.matrixWorld;
			if (material === undefined) return;
			// Checking boundingSphere distance to ray
			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
			_sphere$3.copy(geometry.boundingSphere);
			_sphere$3.applyMatrix4(matrixWorld);
			_ray$2.copy(raycaster.ray).recast(raycaster.near);
			if (_sphere$3.containsPoint(_ray$2.origin) === false) {
				if (_ray$2.intersectSphere(_sphere$3, _sphereHitAt) === null) return;
				if (_ray$2.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;
			}
			//
			_inverseMatrix$2.copy(matrixWorld).invert();
			_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
			// Check boundingBox before continuing
			if (geometry.boundingBox !== null) {
				if (_ray$2.intersectsBox(geometry.boundingBox) === false) return;
			}
			let intersection;
			const index = geometry.index;
			const position = geometry.attributes.position;
			const uv = geometry.attributes.uv;
			const uv2 = geometry.attributes.uv2;
			const groups = geometry.groups;
			const drawRange = geometry.drawRange;
			if (index !== null) {
				// indexed buffer geometry
				if (Array.isArray(material)) {
					for (let i = 0, il = groups.length; i < il; i++) {
						const group = groups[i];
						const groupMaterial = material[group.materialIndex];
						const start = Math.max(group.start, drawRange.start);
						const end = Math.min(index.count, Math.min((group.start + group.count), (drawRange.start + drawRange.count)));
						for (let j = start, jl = end; j < jl; j += 3) {
							const a = index.getX(j);
							const b = index.getX(j + 1);
							const c = index.getX(j + 2);
							intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, uv, uv2, a, b, c);
							if (intersection) {
								intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push(intersection);
							}
						}
					}
				} else {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(index.count, (drawRange.start + drawRange.count));
					for (let i = start, il = end; i < il; i += 3) {
						const a = index.getX(i);
						const b = index.getX(i + 1);
						const c = index.getX(i + 2);
						intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, uv, uv2, a, b, c);
						if (intersection) {
							intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics
							intersects.push(intersection);
						}
					}
				}
			} else if (position !== undefined) {
				// non-indexed buffer geometry
				if (Array.isArray(material)) {
					for (let i = 0, il = groups.length; i < il; i++) {
						const group = groups[i];
						const groupMaterial = material[group.materialIndex];
						const start = Math.max(group.start, drawRange.start);
						const end = Math.min(position.count, Math.min((group.start + group.count), (drawRange.start + drawRange.count)));
						for (let j = start, jl = end; j < jl; j += 3) {
							const a = j;
							const b = j + 1;
							const c = j + 2;
							intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, uv, uv2, a, b, c);
							if (intersection) {
								intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push(intersection);
							}
						}
					}
				} else {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(position.count, (drawRange.start + drawRange.count));
					for (let i = start, il = end; i < il; i += 3) {
						const a = i;
						const b = i + 1;
						const c = i + 2;
						intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, uv, uv2, a, b, c);
						if (intersection) {
							intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics
							intersects.push(intersection);
						}
					}
				}
			}
		}
	}

	function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
		let intersect;
		if (material.side === BackSide) {
			intersect = ray.intersectTriangle(pC, pB, pA, true, point);
		} else {
			intersect = ray.intersectTriangle(pA, pB, pC, (material.side === FrontSide), point);
		}
		if (intersect === null) return null;
		_intersectionPointWorld.copy(point);
		_intersectionPointWorld.applyMatrix4(object.matrixWorld);
		const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
		if (distance < raycaster.near || distance > raycaster.far) return null;
		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		};
	}

	function checkBufferGeometryIntersection(object, material, raycaster, ray, uv, uv2, a, b, c) {
		object.getVertexPosition(a, _vA$1);
		object.getVertexPosition(b, _vB$1);
		object.getVertexPosition(c, _vC$1);
		const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
		if (intersection) {
			if (uv) {
				_uvA$1.fromBufferAttribute(uv, a);
				_uvB$1.fromBufferAttribute(uv, b);
				_uvC$1.fromBufferAttribute(uv, c);
				intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
			}
			if (uv2) {
				_uvA$1.fromBufferAttribute(uv2, a);
				_uvB$1.fromBufferAttribute(uv2, b);
				_uvC$1.fromBufferAttribute(uv2, c);
				intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
			}
			const face = {
				a: a,
				b: b,
				c: c,
				normal: new Vector3(),
				materialIndex: 0
			};
			Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
			intersection.face = face;
		}
		return intersection;
	}
	class BoxGeometry extends BufferGeometry {
		constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
			super();
			this.type = 'BoxGeometry';
			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};
			const scope = this;
			// segments
			widthSegments = Math.floor(widthSegments);
			heightSegments = Math.floor(heightSegments);
			depthSegments = Math.floor(depthSegments);
			// buffers
			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];
			// helper variables
			let numberOfVertices = 0;
			let groupStart = 0;
			// build each side of the box geometry
			buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
			buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
			buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
			buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
			buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
			buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
			// build geometry
			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
				const segmentWidth = width / gridX;
				const segmentHeight = height / gridY;
				const widthHalf = width / 2;
				const heightHalf = height / 2;
				const depthHalf = depth / 2;
				const gridX1 = gridX + 1;
				const gridY1 = gridY + 1;
				let vertexCounter = 0;
				let groupCount = 0;
				const vector = new Vector3();
				// generate vertices, normals and uvs
				for (let iy = 0; iy < gridY1; iy++) {
					const y = iy * segmentHeight - heightHalf;
					for (let ix = 0; ix < gridX1; ix++) {
						const x = ix * segmentWidth - widthHalf;
						// set values to correct vector component
						vector[u] = x * udir;
						vector[v] = y * vdir;
						vector[w] = depthHalf;
						// now apply vector to vertex buffer
						vertices.push(vector.x, vector.y, vector.z);
						// set values to correct vector component
						vector[u] = 0;
						vector[v] = 0;
						vector[w] = depth > 0 ? 1 : -1;
						// now apply vector to normal buffer
						normals.push(vector.x, vector.y, vector.z);
						// uvs
						uvs.push(ix / gridX);
						uvs.push(1 - (iy / gridY));
						// counters
						vertexCounter += 1;
					}
				}
				// indices
				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment
				for (let iy = 0; iy < gridY; iy++) {
					for (let ix = 0; ix < gridX; ix++) {
						const a = numberOfVertices + ix + gridX1 * iy;
						const b = numberOfVertices + ix + gridX1 * (iy + 1);
						const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
						const d = numberOfVertices + (ix + 1) + gridX1 * iy;
						// faces
						indices.push(a, b, d);
						indices.push(b, c, d);
						// increase counter
						groupCount += 6;
					}
				}
				// add a group to the geometry. this will ensure multi material support
				scope.addGroup(groupStart, groupCount, materialIndex);
				// calculate new start value for groups
				groupStart += groupCount;
				// update total number of vertices
				numberOfVertices += vertexCounter;
			}
		}
		copy(source) {
			super.copy(source);
			this.parameters = Object.assign({}, source.parameters);
			return this;
		}
		static fromJSON(data) {
			return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
		}
	}
	/**
	 * Uniform Utilities
	 */
	function cloneUniforms(src) {
		const dst = {};
		for (const u in src) {
			dst[u] = {};
			for (const p in src[u]) {
				const property = src[u][p];
				if (property && (property.isColor ||
						property.isMatrix3 || property.isMatrix4 ||
						property.isVector2 || property.isVector3 || property.isVector4 ||
						property.isTexture || property.isQuaternion)) {
					dst[u][p] = property.clone();
				} else if (Array.isArray(property)) {
					dst[u][p] = property.slice();
				} else {
					dst[u][p] = property;
				}
			}
		}
		return dst;
	}

	function mergeUniforms(uniforms) {
		const merged = {};
		for (let u = 0; u < uniforms.length; u++) {
			const tmp = cloneUniforms(uniforms[u]);
			for (const p in tmp) {
				merged[p] = tmp[p];
			}
		}
		return merged;
	}

	function cloneUniformsGroups(src) {
		const dst = [];
		for (let u = 0; u < src.length; u++) {
			dst.push(src[u].clone());
		}
		return dst;
	}

	function getUnlitUniformColorSpace(renderer) {
		if (renderer.getRenderTarget() === null) {
			// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
			return renderer.outputEncoding === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;
		}
		return LinearSRGBColorSpace;
	}
	// Legacy
	const UniformsUtils = {
		clone: cloneUniforms,
		merge: mergeUniforms
	};
	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
	class ShaderMaterial extends Material {
		constructor(parameters) {
			super();
			this.isShaderMaterial = true;
			this.type = 'ShaderMaterial';
			this.defines = {};
			this.uniforms = {};
			this.uniformsGroups = [];
			this.vertexShader = default_vertex;
			this.fragmentShader = default_fragment;
			this.linewidth = 1;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.fog = false; // set to use scene fog
			this.lights = false; // set to use scene lights
			this.clipping = false; // set to use user-defined clipping planes
			this.extensions = {
				derivatives: false, // set to use derivatives
				fragDepth: false, // set to use fragment depth values
				drawBuffers: false, // set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD
			};
			// When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.
			this.defaultAttributeValues = {
				'color': [1, 1, 1],
				'uv': [0, 0],
				'uv2': [0, 0]
			};
			this.index0AttributeName = undefined;
			this.uniformsNeedUpdate = false;
			this.glslVersion = null;
			if (parameters !== undefined) {
				this.setValues(parameters);
			}
		}
		copy(source) {
			super.copy(source);
			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;
			this.uniforms = cloneUniforms(source.uniforms);
			this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
			this.defines = Object.assign({}, source.defines);
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.fog = source.fog;
			this.lights = source.lights;
			this.clipping = source.clipping;
			this.extensions = Object.assign({}, source.extensions);
			this.glslVersion = source.glslVersion;
			return this;
		}
		toJSON(meta) {
			const data = super.toJSON(meta);
			data.glslVersion = this.glslVersion;
			data.uniforms = {};
			for (const name in this.uniforms) {
				const uniform = this.uniforms[name];
				const value = uniform.value;
				if (value && value.isTexture) {
					data.uniforms[name] = {
						type: 't',
						value: value.toJSON(meta).uuid
					};
				} else if (value && value.isColor) {
					data.uniforms[name] = {
						type: 'c',
						value: value.getHex()
					};
				} else if (value && value.isVector2) {
					data.uniforms[name] = {
						type: 'v2',
						value: value.toArray()
					};
				} else if (value && value.isVector3) {
					data.uniforms[name] = {
						type: 'v3',
						value: value.toArray()
					};
				} else if (value && value.isVector4) {
					data.uniforms[name] = {
						type: 'v4',
						value: value.toArray()
					};
				} else if (value && value.isMatrix3) {
					data.uniforms[name] = {
						type: 'm3',
						value: value.toArray()
					};
				} else if (value && value.isMatrix4) {
					data.uniforms[name] = {
						type: 'm4',
						value: value.toArray()
					};
				} else {
					data.uniforms[name] = {
						value: value
					};
					// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
				}
			}
			if (Object.keys(this.defines).length > 0) data.defines = this.defines;
			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;
			const extensions = {};
			for (const key in this.extensions) {
				if (this.extensions[key] === true) extensions[key] = true;
			}
			if (Object.keys(extensions).length > 0) data.extensions = extensions;
			return data;
		}
	}
	class Camera extends Object3D {
		constructor() {
			super();
			this.isCamera = true;
			this.type = 'Camera';
			this.matrixWorldInverse = new Matrix4();
			this.projectionMatrix = new Matrix4();
			this.projectionMatrixInverse = new Matrix4();
		}
		copy(source, recursive) {
			super.copy(source, recursive);
			this.matrixWorldInverse.copy(source.matrixWorldInverse);
			this.projectionMatrix.copy(source.projectionMatrix);
			this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
			return this;
		}
		getWorldDirection(target) {
			this.updateWorldMatrix(true, false);
			const e = this.matrixWorld.elements;
			return target.set(-e[8], -e[9], -e[10]).normalize();
		}
		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);
			this.matrixWorldInverse.copy(this.matrixWorld).invert();
		}
		updateWorldMatrix(updateParents, updateChildren) {
			super.updateWorldMatrix(updateParents, updateChildren);
			this.matrixWorldInverse.copy(this.matrixWorld).invert();
		}
		clone() {
			return new this.constructor().copy(this);
		}
	}
	class PerspectiveCamera extends Camera {
		constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
			super();
			this.isPerspectiveCamera = true;
			this.type = 'PerspectiveCamera';
			this.fov = fov;
			this.zoom = 1;
			this.near = near;
			this.far = far;
			this.focus = 10;
			this.aspect = aspect;
			this.view = null;
			this.filmGauge = 35; // width of the film (default in millimeters)
			this.filmOffset = 0; // horizontal film offset (same unit as gauge)
			this.updateProjectionMatrix();
		}
		copy(source, recursive) {
			super.copy(source, recursive);
			this.fov = source.fov;
			this.zoom = source.zoom;
			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;
			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign({}, source.view);
			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;
			return this;
		}
		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength(focalLength) {
			/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
			const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
			this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
			this.updateProjectionMatrix();
		}
		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength() {
			const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
			return 0.5 * this.getFilmHeight() / vExtentSlope;
		}
		getEffectiveFOV() {
			return RAD2DEG * 2 * Math.atan(
				Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
		}
		getFilmWidth() {
			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min(this.aspect, 1);
		}
		getFilmHeight() {
			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max(this.aspect, 1);
		}
		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   const w = 1920;
		 *   const h = 1080;
		 *   const fullWidth = w * 3;
		 *   const fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset(fullWidth, fullHeight, x, y, width, height) {
			this.aspect = fullWidth / fullHeight;
			if (this.view === null) {
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
			}
			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
			this.updateProjectionMatrix();
		}
		clearViewOffset() {
			if (this.view !== null) {
				this.view.enabled = false;
			}
			this.updateProjectionMatrix();
		}
		updateProjectionMatrix() {
			const near = this.near;
			let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
			let height = 2 * top;
			let width = this.aspect * height;
			let left = -0.5 * width;
			const view = this.view;
			if (this.view !== null && this.view.enabled) {
				const fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;
				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;
			}
			const skew = this.filmOffset;
			if (skew !== 0) left += near * skew / this.getFilmWidth();
			this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
			this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
		}
		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.fov = this.fov;
			data.object.zoom = this.zoom;
			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;
			data.object.aspect = this.aspect;
			if (this.view !== null) data.object.view = Object.assign({}, this.view);
			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;
			return data;
		}
	}
	const fov = -90; // negative fov is not an error
	const aspect = 1;
	class CubeCamera extends Object3D {
		constructor(near, far, renderTarget) {
			super();
			this.type = 'CubeCamera';
			this.renderTarget = renderTarget;
			const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
			cameraPX.layers = this.layers;
			cameraPX.up.set(0, 1, 0);
			cameraPX.lookAt(1, 0, 0);
			this.add(cameraPX);
			const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
			cameraNX.layers = this.layers;
			cameraNX.up.set(0, 1, 0);
			cameraNX.lookAt(-1, 0, 0);
			this.add(cameraNX);
			const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
			cameraPY.layers = this.layers;
			cameraPY.up.set(0, 0, -1);
			cameraPY.lookAt(0, 1, 0);
			this.add(cameraPY);
			const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
			cameraNY.layers = this.layers;
			cameraNY.up.set(0, 0, 1);
			cameraNY.lookAt(0, -1, 0);
			this.add(cameraNY);
			const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
			cameraPZ.layers = this.layers;
			cameraPZ.up.set(0, 1, 0);
			cameraPZ.lookAt(0, 0, 1);
			this.add(cameraPZ);
			const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
			cameraNZ.layers = this.layers;
			cameraNZ.up.set(0, 1, 0);
			cameraNZ.lookAt(0, 0, -1);
			this.add(cameraNZ);
		}
		update(renderer, scene) {
			if (this.parent === null) this.updateMatrixWorld();
			const renderTarget = this.renderTarget;
			const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
			const currentRenderTarget = renderer.getRenderTarget();
			const currentToneMapping = renderer.toneMapping;
			const currentXrEnabled = renderer.xr.enabled;
			renderer.toneMapping = NoToneMapping;
			renderer.xr.enabled = false;
			const generateMipmaps = renderTarget.texture.generateMipmaps;
			renderTarget.texture.generateMipmaps = false;
			renderer.setRenderTarget(renderTarget, 0);
			renderer.render(scene, cameraPX);
			renderer.setRenderTarget(renderTarget, 1);
			renderer.render(scene, cameraNX);
			renderer.setRenderTarget(renderTarget, 2);
			renderer.render(scene, cameraPY);
			renderer.setRenderTarget(renderTarget, 3);
			renderer.render(scene, cameraNY);
			renderer.setRenderTarget(renderTarget, 4);
			renderer.render(scene, cameraPZ);
			renderTarget.texture.generateMipmaps = generateMipmaps;
			renderer.setRenderTarget(renderTarget, 5);
			renderer.render(scene, cameraNZ);
			renderer.setRenderTarget(currentRenderTarget);
			renderer.toneMapping = currentToneMapping;
			renderer.xr.enabled = currentXrEnabled;
			renderTarget.texture.needsPMREMUpdate = true;
		}
	}
	class CubeTexture extends Texture {
		constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
			super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
			this.isCubeTexture = true;
			this.flipY = false;
		}
		get images() {
			return this.image;
		}
		set images(value) {
			this.image = value;
		}
	}
	class WebGLCubeRenderTarget extends WebGLRenderTarget {
		constructor(size = 1, options = {}) {
			super(size, size, options);
			this.isWebGLCubeRenderTarget = true;
			const image = {
				width: size,
				height: size,
				depth: 1
			};
			const images = [image, image, image, image, image, image];
			this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
			// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
			// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
			// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
			// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
			// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
			// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).
			this.texture.isRenderTargetTexture = true;
			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
		}
		fromEquirectangularTexture(renderer, texture) {
			this.texture.type = texture.type;
			this.texture.encoding = texture.encoding;
			this.texture.generateMipmaps = texture.generateMipmaps;
			this.texture.minFilter = texture.minFilter;
			this.texture.magFilter = texture.magFilter;
			const shader = {
				uniforms: {
					tEquirect: {
						value: null
					},
				},
				vertexShader: /* glsl */ `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
				fragmentShader: /* glsl */ `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
			};
			const geometry = new BoxGeometry(5, 5, 5);
			const material = new ShaderMaterial({
				name: 'CubemapFromEquirect',
				uniforms: cloneUniforms(shader.uniforms),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: BackSide,
				blending: NoBlending
			});
			material.uniforms.tEquirect.value = texture;
			const mesh = new Mesh(geometry, material);
			const currentMinFilter = texture.minFilter;
			// Avoid blurred poles
			if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
			const camera = new CubeCamera(1, 10, this);
			camera.update(renderer, mesh);
			texture.minFilter = currentMinFilter;
			mesh.geometry.dispose();
			mesh.material.dispose();
			return this;
		}
		clear(renderer, color, depth, stencil) {
			const currentRenderTarget = renderer.getRenderTarget();
			for (let i = 0; i < 6; i++) {
				renderer.setRenderTarget(this, i);
				renderer.clear(color, depth, stencil);
			}
			renderer.setRenderTarget(currentRenderTarget);
		}
	}
	const _vector1 = /*@__PURE__*/ new Vector3();
	const _vector2 = /*@__PURE__*/ new Vector3();
	const _normalMatrix = /*@__PURE__*/ new Matrix3();
	class Plane {
		constructor(normal = new Vector3(1, 0, 0), constant = 0) {
			this.isPlane = true;
			// normal is assumed to be normalized
			this.normal = normal;
			this.constant = constant;
		}
		set(normal, constant) {
			this.normal.copy(normal);
			this.constant = constant;
			return this;
		}
		setComponents(x, y, z, w) {
			this.normal.set(x, y, z);
			this.constant = w;
			return this;
		}
		setFromNormalAndCoplanarPoint(normal, point) {
			this.normal.copy(normal);
			this.constant = -point.dot(this.normal);
			return this;
		}
		setFromCoplanarPoints(a, b, c) {
			const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
			this.setFromNormalAndCoplanarPoint(normal, a);
			return this;
		}
		copy(plane) {
			this.normal.copy(plane.normal);
			this.constant = plane.constant;
			return this;
		}
		normalize() {
			// Note: will lead to a divide by zero if the plane is invalid.
			const inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar(inverseNormalLength);
			this.constant *= inverseNormalLength;
			return this;
		}
		negate() {
			this.constant *= -1;
			this.normal.negate();
			return this;
		}
		distanceToPoint(point) {
			return this.normal.dot(point) + this.constant;
		}
		distanceToSphere(sphere) {
			return this.distanceToPoint(sphere.center) - sphere.radius;
		}
		projectPoint(point, target) {
			return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
		}
		intersectLine(line, target) {
			const direction = line.delta(_vector1);
			const denominator = this.normal.dot(direction);
			if (denominator === 0) {
				// line is coplanar, return origin
				if (this.distanceToPoint(line.start) === 0) {
					return target.copy(line.start);
				}
				// Unsure if this is the correct method to handle this case.
				return null;
			}
			const t = -(line.start.dot(this.normal) + this.constant) / denominator;
			if (t < 0 || t > 1) {
				return null;
			}
			return target.copy(line.start).addScaledVector(direction, t);
		}
		intersectsLine(line) {
			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
			const startSign = this.distanceToPoint(line.start);
			const endSign = this.distanceToPoint(line.end);
			return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
		}
		intersectsBox(box) {
			return box.intersectsPlane(this);
		}
		intersectsSphere(sphere) {
			return sphere.intersectsPlane(this);
		}
		coplanarPoint(target) {
			return target.copy(this.normal).multiplyScalar(-this.constant);
		}
		applyMatrix4(matrix, optionalNormalMatrix) {
			const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
			const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
			const normal = this.normal.applyMatrix3(normalMatrix).normalize();
			this.constant = -referencePoint.dot(normal);
			return this;
		}
		translate(offset) {
			this.constant -= offset.dot(this.normal);
			return this;
		}
		equals(plane) {
			return plane.normal.equals(this.normal) && (plane.constant === this.constant);
		}
		clone() {
			return new this.constructor().copy(this);
		}
	}
	const _sphere$2 = /*@__PURE__*/ new Sphere();
	const _vector$7 = /*@__PURE__*/ new Vector3();
	class Frustum {
		constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
			this.planes = [p0, p1, p2, p3, p4, p5];
		}
		set(p0, p1, p2, p3, p4, p5) {
			const planes = this.planes;
			planes[0].copy(p0);
			planes[1].copy(p1);
			planes[2].copy(p2);
			planes[3].copy(p3);
			planes[4].copy(p4);
			planes[5].copy(p5);
			return this;
		}
		copy(frustum) {
			const planes = this.planes;
			for (let i = 0; i < 6; i++) {
				planes[i].copy(frustum.planes[i]);
			}
			return this;
		}
		setFromProjectionMatrix(m) {
			const planes = this.planes;
			const me = m.elements;
			const me0 = me[0],
				me1 = me[1],
				me2 = me[2],
				me3 = me[3];
			const me4 = me[4],
				me5 = me[5],
				me6 = me[6],
				me7 = me[7];
			const me8 = me[8],
				me9 = me[9],
				me10 = me[10],
				me11 = me[11];
			const me12 = me[12],
				me13 = me[13],
				me14 = me[14],
				me15 = me[15];
			planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
			planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
			planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
			planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
			planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
			planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
			return this;
		}
		intersectsObject(object) {
			const geometry = object.geometry;
			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
			_sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
			return this.intersectsSphere(_sphere$2);
		}
		intersectsSprite(sprite) {
			_sphere$2.center.set(0, 0, 0);
			_sphere$2.radius = 0.7071067811865476;
			_sphere$2.applyMatrix4(sprite.matrixWorld);
			return this.intersectsSphere(_sphere$2);
		}
		intersectsSphere(sphere) {
			const planes = this.planes;
			const center = sphere.center;
			const negRadius = -sphere.radius;
			for (let i = 0; i < 6; i++) {
				const distance = planes[i].distanceToPoint(center);
				if (distance < negRadius) {
					return false;
				}
			}
			return true;
		}
		intersectsBox(box) {
			const planes = this.planes;
			for (let i = 0; i < 6; i++) {
				const plane = planes[i];
				// corner at max distance
				_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
				if (plane.distanceToPoint(_vector$7) < 0) {
					return false;
				}
			}
			return true;
		}
		containsPoint(point) {
			const planes = this.planes;
			for (let i = 0; i < 6; i++) {
				if (planes[i].distanceToPoint(point) < 0) {
					return false;
				}
			}
			return true;
		}
		clone() {
			return new this.constructor().copy(this);
		}
	}

	function WebGLAnimation() {
		let context = null;
		let isAnimating = false;
		let animationLoop = null;
		let requestId = null;

		function onAnimationFrame(time, frame) {
			animationLoop(time, frame);
			requestId = context.requestAnimationFrame(onAnimationFrame);
		}
		return {
			start: function() {
				if (isAnimating === true) return;
				if (animationLoop === null) return;
				requestId = context.requestAnimationFrame(onAnimationFrame);
				isAnimating = true;
			},
			stop: function() {
				context.cancelAnimationFrame(requestId);
				isAnimating = false;
			},
			setAnimationLoop: function(callback) {
				animationLoop = callback;
			},
			setContext: function(value) {
				context = value;
			}
		};
	}

	function WebGLAttributes(gl, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;
		const buffers = new WeakMap();

		function createBuffer(attribute, bufferType) {
			const array = attribute.array;
			const usage = attribute.usage;
			const buffer = gl.createBuffer();
			gl.bindBuffer(bufferType, buffer);
			gl.bufferData(bufferType, array, usage);
			attribute.onUploadCallback();
			let type;
			if (array instanceof Float32Array) {
				type = gl.FLOAT;
			} else if (array instanceof Uint16Array) {
				if (attribute.isFloat16BufferAttribute) {
					if (isWebGL2) {
						type = gl.HALF_FLOAT;
					} else {
						throw new Error('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
					}
				} else {
					type = gl.UNSIGNED_SHORT;
				}
			} else if (array instanceof Int16Array) {
				type = gl.SHORT;
			} else if (array instanceof Uint32Array) {
				type = gl.UNSIGNED_INT;
			} else if (array instanceof Int32Array) {
				type = gl.INT;
			} else if (array instanceof Int8Array) {
				type = gl.BYTE;
			} else if (array instanceof Uint8Array) {
				type = gl.UNSIGNED_BYTE;
			} else if (array instanceof Uint8ClampedArray) {
				type = gl.UNSIGNED_BYTE;
			} else {
				throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + array);
			}
			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};
		}

		function updateBuffer(buffer, attribute, bufferType) {
			const array = attribute.array;
			const updateRange = attribute.updateRange;
			gl.bindBuffer(bufferType, buffer);
			if (updateRange.count === -1) {
				// Not using update ranges
				gl.bufferSubData(bufferType, 0, array);
			} else {
				if (isWebGL2) {
					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array, updateRange.offset, updateRange.count);
				} else {
					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
				}
				updateRange.count = -1; // reset range
			}
			attribute.onUploadCallback();
		}
		//
		function get(attribute) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			return buffers.get(attribute);
		}

		function remove(attribute) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			const data = buffers.get(attribute);
			if (data) {
				gl.deleteBuffer(data.buffer);
				buffers.delete(attribute);
			}
		}

		function update(attribute, bufferType) {
			if (attribute.isGLBufferAttribute) {
				const cached = buffers.get(attribute);
				if (!cached || cached.version < attribute.version) {
					buffers.set(attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					});
				}
				return;
			}
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			const data = buffers.get(attribute);
			if (data === undefined) {
				buffers.set(attribute, createBuffer(attribute, bufferType));
			} else if (data.version < attribute.version) {
				updateBuffer(data.buffer, attribute, bufferType);
				data.version = attribute.version;
			}
		}
		return {
			get: get,
			remove: remove,
			update: update
		};
	}
	class PlaneGeometry extends BufferGeometry {
		constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
			super();
			this.type = 'PlaneGeometry';
			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};
			const width_half = width / 2;
			const height_half = height / 2;
			const gridX = Math.floor(widthSegments);
			const gridY = Math.floor(heightSegments);
			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;
			const segment_width = width / gridX;
			const segment_height = height / gridY;
			//
			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];
			for (let iy = 0; iy < gridY1; iy++) {
				const y = iy * segment_height - height_half;
				for (let ix = 0; ix < gridX1; ix++) {
					const x = ix * segment_width - width_half;
					vertices.push(x, -y, 0);
					normals.push(0, 0, 1);
					uvs.push(ix / gridX);
					uvs.push(1 - (iy / gridY));
				}
			}
			for (let iy = 0; iy < gridY; iy++) {
				for (let ix = 0; ix < gridX; ix++) {
					const a = ix + gridX1 * iy;
					const b = ix + gridX1 * (iy + 1);
					const c = (ix + 1) + gridX1 * (iy + 1);
					const d = (ix + 1) + gridX1 * iy;
					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			}
			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}
		copy(source) {
			super.copy(source);
			this.parameters = Object.assign({}, source.parameters);
			return this;
		}
		static fromJSON(data) {
			return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
		}
	}
	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
	var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";
	var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";
	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";
	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
	var begin_vertex = "vec3 transformed = vec3( position );";
	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
	var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";
	var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";
	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
	var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";
	var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";
	var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";
	var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";
	var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";
	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";
	var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
	var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
	var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
	var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
	var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
	var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";
	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";
	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
	var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";
	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
	var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
	var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert";
	var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";
	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";
	var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
	var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon";
	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong";
	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";
	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";
	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
	var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";
	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
	var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
	var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
	var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";
	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";
	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";
	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";
	var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
	var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
	var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
	var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
	var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";
	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";
	var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
	var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";
	var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
	var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";
	var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
	var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
	var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
	var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
	var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
	var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
	var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif";
	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif";
	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
	var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
	var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif";
	var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, vec2 fullSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\t\n\t\tvec2 lodFudge = pow( 1.95, lod ) / fullSize;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec2 fullSize = vec2( textureSize( sampler, 0 ) );\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), fullSize, floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), fullSize, ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";
	var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
	var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
	var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
	const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
	const fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
	const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
	const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
	const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
	const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
	const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
	const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
	const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
	const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
	const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
	const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
	const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
	const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
	const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
	const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
	const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
	const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
	const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
	const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
	const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";
	const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
	const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";
	const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
	const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
	const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
	const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
	const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
	const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
	const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
	const ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		alphatest_pars_fragment: alphatest_pars_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		iridescence_fragment: iridescence_fragment,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_fragment: lights_lambert_fragment,
		lights_lambert_pars_fragment: lights_lambert_pars_fragment,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphcolor_vertex: morphcolor_vertex,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normal_pars_fragment: normal_pars_fragment,
		normal_pars_vertex: normal_pars_vertex,
		normal_vertex: normal_vertex,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment: clearcoat_pars_fragment,
		iridescence_pars_fragment: iridescence_pars_fragment,
		output_fragment: output_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		transmission_fragment: transmission_fragment,
		transmission_pars_fragment: transmission_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,
		background_vert: vertex$h,
		background_frag: fragment$h,
		backgroundCube_vert: vertex$g,
		backgroundCube_frag: fragment$g,
		cube_vert: vertex$f,
		cube_frag: fragment$f,
		depth_vert: vertex$e,
		depth_frag: fragment$e,
		distanceRGBA_vert: vertex$d,
		distanceRGBA_frag: fragment$d,
		equirect_vert: vertex$c,
		equirect_frag: fragment$c,
		linedashed_vert: vertex$b,
		linedashed_frag: fragment$b,
		meshbasic_vert: vertex$a,
		meshbasic_frag: fragment$a,
		meshlambert_vert: vertex$9,
		meshlambert_frag: fragment$9,
		meshmatcap_vert: vertex$8,
		meshmatcap_frag: fragment$8,
		meshnormal_vert: vertex$7,
		meshnormal_frag: fragment$7,
		meshphong_vert: vertex$6,
		meshphong_frag: fragment$6,
		meshphysical_vert: vertex$5,
		meshphysical_frag: fragment$5,
		meshtoon_vert: vertex$4,
		meshtoon_frag: fragment$4,
		points_vert: vertex$3,
		points_frag: fragment$3,
		shadow_vert: vertex$2,
		shadow_frag: fragment$2,
		sprite_vert: vertex$1,
		sprite_frag: fragment$1
	};
	/**
	 * Uniforms library for shared webgl shaders
	 */
	const UniformsLib = {
		common: {
			diffuse: {
				value: /*@__PURE__*/ new Color(0xffffff)
			},
			opacity: {
				value: 1.0
			},
			map: {
				value: null
			},
			uvTransform: {
				value: /*@__PURE__*/ new Matrix3()
			},
			uv2Transform: {
				value: /*@__PURE__*/ new Matrix3()
			},
			alphaMap: {
				value: null
			},
			alphaTest: {
				value: 0
			}
		},
		specularmap: {
			specularMap: {
				value: null
			},
		},
		envmap: {
			envMap: {
				value: null
			},
			flipEnvMap: {
				value: -1
			},
			reflectivity: {
				value: 1.0
			}, // basic, lambert, phong
			ior: {
				value: 1.5
			}, // physical
			refractionRatio: {
				value: 0.98
			}, // basic, lambert, phong
		},
		aomap: {
			aoMap: {
				value: null
			},
			aoMapIntensity: {
				value: 1
			}
		},
		lightmap: {
			lightMap: {
				value: null
			},
			lightMapIntensity: {
				value: 1
			}
		},
		emissivemap: {
			emissiveMap: {
				value: null
			}
		},
		bumpmap: {
			bumpMap: {
				value: null
			},
			bumpScale: {
				value: 1
			}
		},
		normalmap: {
			normalMap: {
				value: null
			},
			normalScale: {
				value: /*@__PURE__*/ new Vector2(1, 1)
			}
		},
		displacementmap: {
			displacementMap: {
				value: null
			},
			displacementScale: {
				value: 1
			},
			displacementBias: {
				value: 0
			}
		},
		roughnessmap: {
			roughnessMap: {
				value: null
			}
		},
		metalnessmap: {
			metalnessMap: {
				value: null
			}
		},
		gradientmap: {
			gradientMap: {
				value: null
			}
		},
		fog: {
			fogDensity: {
				value: 0.00025
			},
			fogNear: {
				value: 1
			},
			fogFar: {
				value: 2000
			},
			fogColor: {
				value: /*@__PURE__*/ new Color(0xffffff)
			}
		},
		lights: {
			ambientLightColor: {
				value: []
			},
			lightProbe: {
				value: []
			},
			directionalLights: {
				value: [],
				properties: {
					direction: {},
					color: {}
				}
			},
			directionalLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			directionalShadowMap: {
				value: []
			},
			directionalShadowMatrix: {
				value: []
			},
			spotLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {}
				}
			},
			spotLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			spotLightMap: {
				value: []
			},
			spotShadowMap: {
				value: []
			},
			spotLightMatrix: {
				value: []
			},
			pointLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					decay: {},
					distance: {}
				}
			},
			pointLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {}
				}
			},
			pointShadowMap: {
				value: []
			},
			pointShadowMatrix: {
				value: []
			},
			hemisphereLights: {
				value: [],
				properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				}
			},
			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				}
			},
			ltc_1: {
				value: null
			},
			ltc_2: {
				value: null
			}
		},
		points: {
			diffuse: {
				value: /*@__PURE__*/ new Color(0xffffff)
			},
			opacity: {
				value: 1.0
			},
			size: {
				value: 1.0
			},
			scale: {
				value: 1.0
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			alphaTest: {
				value: 0
			},
			uvTransform: {
				value: /*@__PURE__*/ new Matrix3()
			}
		},
		sprite: {
			diffuse: {
				value: /*@__PURE__*/ new Color(0xffffff)
			},
			opacity: {
				value: 1.0
			},
			center: {
				value: /*@__PURE__*/ new Vector2(0.5, 0.5)
			},
			rotation: {
				value: 0.0
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			alphaTest: {
				value: 0
			},
			uvTransform: {
				value: /*@__PURE__*/ new Matrix3()
			}
		}
	};
	const ShaderLib = {
		basic: {
			uniforms: /*@__PURE__*/ mergeUniforms([
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			]),
			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag
		},
		lambert: {
			uniforms: /*@__PURE__*/ mergeUniforms([
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: {
						value: /*@__PURE__*/ new Color(0x000000)
					}
				}
			]),
			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag
		},
		phong: {
			uniforms: /*@__PURE__*/ mergeUniforms([
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: {
						value: /*@__PURE__*/ new Color(0x000000)
					},
					specular: {
						value: /*@__PURE__*/ new Color(0x111111)
					},
					shininess: {
						value: 30
					}
				}
			]),
			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag
		},
		standard: {
			uniforms: /*@__PURE__*/ mergeUniforms([
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: {
						value: /*@__PURE__*/ new Color(0x000000)
					},
					roughness: {
						value: 1.0
					},
					metalness: {
						value: 0.0
					},
					envMapIntensity: {
						value: 1
					} // temporary
				}
			]),
			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag
		},
		toon: {
			uniforms: /*@__PURE__*/ mergeUniforms([
				UniformsLib.common,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: {
						value: /*@__PURE__*/ new Color(0x000000)
					}
				}
			]),
			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag
		},
		matcap: {
			uniforms: /*@__PURE__*/ mergeUniforms([
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				{
					matcap: {
						value: null
					}
				}
			]),
			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag
		},
		points: {
			uniforms: /*@__PURE__*/ mergeUniforms([
				UniformsLib.points,
				UniformsLib.fog
			]),
			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag
		},
		dashed: {
			uniforms: /*@__PURE__*/ mergeUniforms([
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: {
						value: 1
					},
					dashSize: {
						value: 1
					},
					totalSize: {
						value: 2
					}
				}
			]),
			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag
		},
		depth: {
			uniforms: /*@__PURE__*/ mergeUniforms([
				UniformsLib.common,
				UniformsLib.displacementmap
			]),
			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag
		},
		normal: {
			uniforms: /*@__PURE__*/ mergeUniforms([
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: {
						value: 1.0
					}
				}
			]),
			vertexShader: ShaderChunk.meshnormal_vert,
			fragmentShader: ShaderChunk.meshnormal_frag
		},
		sprite: {
			uniforms: /*@__PURE__*/ mergeUniforms([
				UniformsLib.sprite,
				UniformsLib.fog
			]),
			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag
		},
		background: {
			uniforms: {
				uvTransform: {
					value: /*@__PURE__*/ new Matrix3()
				},
				t2D: {
					value: null
				},
				backgroundIntensity: {
					value: 1
				}
			},
			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag
		},
		backgroundCube: {
			uniforms: {
				envMap: {
					value: null
				},
				flipEnvMap: {
					value: -1
				},
				backgroundBlurriness: {
					value: 0
				},
				backgroundIntensity: {
					value: 1
				}
			},
			vertexShader: ShaderChunk.backgroundCube_vert,
			fragmentShader: ShaderChunk.backgroundCube_frag
		},
		cube: {
			uniforms: {
				tCube: {
					value: null
				},
				tFlip: {
					value: -1
				},
				opacity: {
					value: 1.0
				}
			},
			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag
		},
		equirect: {
			uniforms: {
				tEquirect: {
					value: null
				},
			},
			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag
		},
		distanceRGBA: {
			uniforms: /*@__PURE__*/ mergeUniforms([
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: {
						value: /*@__PURE__*/ new Vector3()
					},
					nearDistance: {
						value: 1
					},
					farDistance: {
						value: 1000
					}
				}
			]),
			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag
		},
		shadow: {
			uniforms: /*@__PURE__*/ mergeUniforms([
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: {
						value: /*@__PURE__*/ new Color(0x00000)
					},
					opacity: {
						value: 1.0
					}
				},
			]),
			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag
		}
	};
	ShaderLib.physical = {
		uniforms: /*@__PURE__*/ mergeUniforms([
			ShaderLib.standard.uniforms,
			{
				clearcoat: {
					value: 0
				},
				clearcoatMap: {
					value: null
				},
				clearcoatRoughness: {
					value: 0
				},
				clearcoatRoughnessMap: {
					value: null
				},
				clearcoatNormalScale: {
					value: /*@__PURE__*/ new Vector2(1, 1)
				},
				clearcoatNormalMap: {
					value: null
				},
				iridescence: {
					value: 0
				},
				iridescenceMap: {
					value: null
				},
				iridescenceIOR: {
					value: 1.3
				},
				iridescenceThicknessMinimum: {
					value: 100
				},
				iridescenceThicknessMaximum: {
					value: 400
				},
				iridescenceThicknessMap: {
					value: null
				},
				sheen: {
					value: 0
				},
				sheenColor: {
					value: /*@__PURE__*/ new Color(0x000000)
				},
				sheenColorMap: {
					value: null
				},
				sheenRoughness: {
					value: 1
				},
				sheenRoughnessMap: {
					value: null
				},
				transmission: {
					value: 0
				},
				transmissionMap: {
					value: null
				},
				transmissionSamplerSize: {
					value: /*@__PURE__*/ new Vector2()
				},
				transmissionSamplerMap: {
					value: null
				},
				thickness: {
					value: 0
				},
				thicknessMap: {
					value: null
				},
				attenuationDistance: {
					value: 0
				},
				attenuationColor: {
					value: /*@__PURE__*/ new Color(0x000000)
				},
				specularIntensity: {
					value: 1
				},
				specularIntensityMap: {
					value: null
				},
				specularColor: {
					value: /*@__PURE__*/ new Color(1, 1, 1)
				},
				specularColorMap: {
					value: null
				},
			}
		]),
		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag
	};
	const _rgb = {
		r: 0,
		b: 0,
		g: 0
	};

	function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
		const clearColor = new Color(0x000000);
		let clearAlpha = alpha === true ? 0 : 1;
		let planeMesh;
		let boxMesh;
		let currentBackground = null;
		let currentBackgroundVersion = 0;
		let currentTonemapping = null;

		function render(renderList, scene) {
			let forceClear = false;
			let background = scene.isScene === true ? scene.background : null;
			if (background && background.isTexture) {
				const usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background
				background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
			}
			// Ignore background in AR
			// TODO: Reconsider this.
			const xr = renderer.xr;
			const session = xr.getSession && xr.getSession();
			if (session && session.environmentBlendMode === 'additive') {
				background = null;
			}
			if (background === null) {
				setClear(clearColor, clearAlpha);
			} else if (background && background.isColor) {
				setClear(background, 1);
				forceClear = true;
			}
			if (renderer.autoClear || forceClear) {
				renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
			}
			if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
				if (boxMesh === undefined) {
					boxMesh = new Mesh(
						new BoxGeometry(1, 1, 1),
						new ShaderMaterial({
							name: 'BackgroundCubeMaterial',
							uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
							vertexShader: ShaderLib.backgroundCube.vertexShader,
							fragmentShader: ShaderLib.backgroundCube.fragmentShader,
							side: BackSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						})
					);
					boxMesh.geometry.deleteAttribute('normal');
					boxMesh.geometry.deleteAttribute('uv');
					boxMesh.onBeforeRender = function(renderer, scene, camera) {
						this.matrixWorld.copyPosition(camera.matrixWorld);
					};
					// add "envMap" material property so the renderer can evaluate it like for built-in materials
					Object.defineProperty(boxMesh.material, 'envMap', {
						get: function() {
							return this.uniforms.envMap.value;
						}
					});
					objects.update(boxMesh);
				}
				boxMesh.material.uniforms.envMap.value = background;
				boxMesh.material.uniforms.flipEnvMap.value = (background.isCubeTexture && background.isRenderTargetTexture === false) ? -1 : 1;
				boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
				boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
				boxMesh.material.toneMapped = (background.encoding === sRGBEncoding) ? false : true;
				if (currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping) {
					boxMesh.material.needsUpdate = true;
					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;
				}
				boxMesh.layers.enableAll();
				// push to the pre-sorted opaque render list
				renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
			} else if (background && background.isTexture) {
				if (planeMesh === undefined) {
					planeMesh = new Mesh(
						new PlaneGeometry(2, 2),
						new ShaderMaterial({
							name: 'BackgroundMaterial',
							uniforms: cloneUniforms(ShaderLib.background.uniforms),
							vertexShader: ShaderLib.background.vertexShader,
							fragmentShader: ShaderLib.background.fragmentShader,
							side: FrontSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						})
					);
					planeMesh.geometry.deleteAttribute('normal');
					// add "map" material property so the renderer can evaluate it like for built-in materials
					Object.defineProperty(planeMesh.material, 'map', {
						get: function() {
							return this.uniforms.t2D.value;
						}
					});
					objects.update(planeMesh);
				}
				planeMesh.material.uniforms.t2D.value = background;
				planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
				planeMesh.material.toneMapped = (background.encoding === sRGBEncoding) ? false : true;
				if (background.matrixAutoUpdate === true) {
					background.updateMatrix();
				}
				planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
				if (currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping) {
					planeMesh.material.needsUpdate = true;
					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;
				}
				planeMesh.layers.enableAll();
				// push to the pre-sorted opaque render list
				renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
			}
		}

		function setClear(color, alpha) {
			color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
			state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha);
		}
		return {
			getClearColor: function() {
				return clearColor;
			},
			setClearColor: function(color, alpha = 1) {
				clearColor.set(color);
				clearAlpha = alpha;
				setClear(clearColor, clearAlpha);
			},
			getClearAlpha: function() {
				return clearAlpha;
			},
			setClearAlpha: function(alpha) {
				clearAlpha = alpha;
				setClear(clearColor, clearAlpha);
			},
			render: render
		};
	}

	function WebGLBindingStates(gl, extensions, attributes, capabilities) {
		const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
		const vaoAvailable = capabilities.isWebGL2 || extension !== null;
		const bindingStates = {};
		const defaultState = createBindingState(null);
		let currentState = defaultState;
		let forceUpdate = false;

		function setup(object, material, program, geometry, index) {
			let updateBuffers = false;
			if (vaoAvailable) {
				const state = getBindingState(geometry, program, material);
				if (currentState !== state) {
					currentState = state;
					bindVertexArrayObject(currentState.object);
				}
				updateBuffers = needsUpdate(object, geometry, program, index);
				if (updateBuffers) saveCache(object, geometry, program, index);
			} else {
				const wireframe = (material.wireframe === true);
				if (currentState.geometry !== geometry.id ||
					currentState.program !== program.id ||
					currentState.wireframe !== wireframe) {
					currentState.geometry = geometry.id;
					currentState.program = program.id;
					currentState.wireframe = wireframe;
					updateBuffers = true;
				}
			}
			if (index !== null) {
				attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
			}
			if (updateBuffers || forceUpdate) {
				forceUpdate = false;
				setupVertexAttributes(object, material, program, geometry);
				if (index !== null) {
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
				}
			}
		}

		function createVertexArrayObject() {
			if (capabilities.isWebGL2) return gl.createVertexArray();
			return extension.createVertexArrayOES();
		}

		function bindVertexArrayObject(vao) {
			if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
			return extension.bindVertexArrayOES(vao);
		}

		function deleteVertexArrayObject(vao) {
			if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
			return extension.deleteVertexArrayOES(vao);
		}

		function getBindingState(geometry, program, material) {
			const wireframe = (material.wireframe === true);
			let programMap = bindingStates[geometry.id];
			if (programMap === undefined) {
				programMap = {};
				bindingStates[geometry.id] = programMap;
			}
			let stateMap = programMap[program.id];
			if (stateMap === undefined) {
				stateMap = {};
				programMap[program.id] = stateMap;
			}
			let state = stateMap[wireframe];
			if (state === undefined) {
				state = createBindingState(createVertexArrayObject());
				stateMap[wireframe] = state;
			}
			return state;
		}

		function createBindingState(vao) {
			const newAttributes = [];
			const enabledAttributes = [];
			const attributeDivisors = [];
			for (let i = 0; i < maxVertexAttributes; i++) {
				newAttributes[i] = 0;
				enabledAttributes[i] = 0;
				attributeDivisors[i] = 0;
			}
			return {
				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,
				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null
			};
		}

		function needsUpdate(object, geometry, program, index) {
			const cachedAttributes = currentState.attributes;
			const geometryAttributes = geometry.attributes;
			let attributesNum = 0;
			const programAttributes = program.getAttributes();
			for (const name in programAttributes) {
				const programAttribute = programAttributes[name];
				if (programAttribute.location >= 0) {
					const cachedAttribute = cachedAttributes[name];
					let geometryAttribute = geometryAttributes[name];
					if (geometryAttribute === undefined) {
						if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
						if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;
					}
					if (cachedAttribute === undefined) return true;
					if (cachedAttribute.attribute !== geometryAttribute) return true;
					if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;
					attributesNum++;
				}
			}
			if (currentState.attributesNum !== attributesNum) return true;
			if (currentState.index !== index) return true;
			return false;
		}

		function saveCache(object, geometry, program, index) {
			const cache = {};
			const attributes = geometry.attributes;
			let attributesNum = 0;
			const programAttributes = program.getAttributes();
			for (const name in programAttributes) {
				const programAttribute = programAttributes[name];
				if (programAttribute.location >= 0) {
					let attribute = attributes[name];
					if (attribute === undefined) {
						if (name === 'instanceMatrix' && object.instanceMatrix) attribute = object.instanceMatrix;
						if (name === 'instanceColor' && object.instanceColor) attribute = object.instanceColor;
					}
					const data = {};
					data.attribute = attribute;
					if (attribute && attribute.data) {
						data.data = attribute.data;
					}
					cache[name] = data;
					attributesNum++;
				}
			}
			currentState.attributes = cache;
			currentState.attributesNum = attributesNum;
			currentState.index = index;
		}

		function initAttributes() {
			const newAttributes = currentState.newAttributes;
			for (let i = 0, il = newAttributes.length; i < il; i++) {
				newAttributes[i] = 0;
			}
		}

		function enableAttribute(attribute) {
			enableAttributeAndDivisor(attribute, 0);
		}

		function enableAttributeAndDivisor(attribute, meshPerAttribute) {
			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;
			const attributeDivisors = currentState.attributeDivisors;
			newAttributes[attribute] = 1;
			if (enabledAttributes[attribute] === 0) {
				gl.enableVertexAttribArray(attribute);
				enabledAttributes[attribute] = 1;
			}
			if (attributeDivisors[attribute] !== meshPerAttribute) {
				const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
				extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
				attributeDivisors[attribute] = meshPerAttribute;
			}
		}

		function disableUnusedAttributes() {
			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;
			for (let i = 0, il = enabledAttributes.length; i < il; i++) {
				if (enabledAttributes[i] !== newAttributes[i]) {
					gl.disableVertexAttribArray(i);
					enabledAttributes[i] = 0;
				}
			}
		}

		function vertexAttribPointer(index, size, type, normalized, stride, offset) {
			if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {
				gl.vertexAttribIPointer(index, size, type, stride, offset);
			} else {
				gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
			}
		}

		function setupVertexAttributes(object, material, program, geometry) {
			if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
				if (extensions.get('ANGLE_instanced_arrays') === null) return;
			}
			initAttributes();
			const geometryAttributes = geometry.attributes;
			const programAttributes = program.getAttributes();
			const materialDefaultAttributeValues = material.defaultAttributeValues;
			for (const name in programAttributes) {
				const programAttribute = programAttributes[name];
				if (programAttribute.location >= 0) {
					let geometryAttribute = geometryAttributes[name];
					if (geometryAttribute === undefined) {
						if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
						if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;
					}
					if (geometryAttribute !== undefined) {
						const normalized = geometryAttribute.normalized;
						const size = geometryAttribute.itemSize;
						const attribute = attributes.get(geometryAttribute);
						// TODO Attribute may not be available on context restore
						if (attribute === undefined) continue;
						const buffer = attribute.buffer;
						const type = attribute.type;
						const bytesPerElement = attribute.bytesPerElement;
						if (geometryAttribute.isInterleavedBufferAttribute) {
							const data = geometryAttribute.data;
							const stride = data.stride;
							const offset = geometryAttribute.offset;
							if (data.isInstancedInterleavedBuffer) {
								for (let i = 0; i < programAttribute.locationSize; i++) {
									enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
								}
								if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
									geometry._maxInstanceCount = data.meshPerAttribute * data.count;
								}
							} else {
								for (let i = 0; i < programAttribute.locationSize; i++) {
									enableAttribute(programAttribute.location + i);
								}
							}
							gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
							for (let i = 0; i < programAttribute.locationSize; i++) {
								vertexAttribPointer(
									programAttribute.location + i,
									size / programAttribute.locationSize,
									type,
									normalized,
									stride * bytesPerElement,
									(offset + (size / programAttribute.locationSize) * i) * bytesPerElement
								);
							}
						} else {
							if (geometryAttribute.isInstancedBufferAttribute) {
								for (let i = 0; i < programAttribute.locationSize; i++) {
									enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
								}
								if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
								}
							} else {
								for (let i = 0; i < programAttribute.locationSize; i++) {
									enableAttribute(programAttribute.location + i);
								}
							}
							gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
							for (let i = 0; i < programAttribute.locationSize; i++) {
								vertexAttribPointer(
									programAttribute.location + i,
									size / programAttribute.locationSize,
									type,
									normalized,
									size * bytesPerElement,
									(size / programAttribute.locationSize) * i * bytesPerElement
								);
							}
						}
					} else if (materialDefaultAttributeValues !== undefined) {
						const value = materialDefaultAttributeValues[name];
						if (value !== undefined) {
							switch (value.length) {
								case 2:
									gl.vertexAttrib2fv(programAttribute.location, value);
									break;
								case 3:
									gl.vertexAttrib3fv(programAttribute.location, value);
									break;
								case 4:
									gl.vertexAttrib4fv(programAttribute.location, value);
									break;
								default:
									gl.vertexAttrib1fv(programAttribute.location, value);
							}
						}
					}
				}
			}
			disableUnusedAttributes();
		}

		function dispose() {
			reset();
			for (const geometryId in bindingStates) {
				const programMap = bindingStates[geometryId];
				for (const programId in programMap) {
					const stateMap = programMap[programId];
					for (const wireframe in stateMap) {
						deleteVertexArrayObject(stateMap[wireframe].object);
						delete stateMap[wireframe];
					}
					delete programMap[programId];
				}
				delete bindingStates[geometryId];
			}
		}

		function releaseStatesOfGeometry(geometry) {
			if (bindingStates[geometry.id] === undefined) return;
			const programMap = bindingStates[geometry.id];
			for (const programId in programMap) {
				const stateMap = programMap[programId];
				for (const wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}
				delete programMap[programId];
			}
			delete bindingStates[geometry.id];
		}

		function releaseStatesOfProgram(program) {
			for (const geometryId in bindingStates) {
				const programMap = bindingStates[geometryId];
				if (programMap[program.id] === undefined) continue;
				const stateMap = programMap[program.id];
				for (const wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}
				delete programMap[program.id];
			}
		}

		function reset() {
			resetDefaultState();
			forceUpdate = true;
			if (currentState === defaultState) return;
			currentState = defaultState;
			bindVertexArrayObject(currentState.object);
		}
		// for backward-compatibility
		function resetDefaultState() {
			defaultState.geometry = null;
			defaultState.program = null;
			defaultState.wireframe = false;
		}
		return {
			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,
			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes
		};
	}

	function WebGLBufferRenderer(gl, extensions, info, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;
		let mode;

		function setMode(value) {
			mode = value;
		}

		function render(start, count) {
			gl.drawArrays(mode, start, count);
			info.update(count, mode, 1);
		}

		function renderInstances(start, count, primcount) {
			if (primcount === 0) return;
			let extension, methodName;
			if (isWebGL2) {
				extension = gl;
				methodName = 'drawArraysInstanced';
			} else {
				extension = extensions.get('ANGLE_instanced_arrays');
				methodName = 'drawArraysInstancedANGLE';
				if (extension === null) {
					console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}
			extension[methodName](mode, start, count, primcount);
			info.update(count, mode, primcount);
		}
		//
		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;
	}

	function WebGLCapabilities(gl, extensions, parameters) {
		let maxAnisotropy;

		function getMaxAnisotropy() {
			if (maxAnisotropy !== undefined) return maxAnisotropy;
			if (extensions.has('EXT_texture_filter_anisotropic') === true) {
				const extension = extensions.get('EXT_texture_filter_anisotropic');
				maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
			} else {
				maxAnisotropy = 0;
			}
			return maxAnisotropy;
		}

		function getMaxPrecision(precision) {
			if (precision === 'highp') {
				if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 &&
					gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
					return 'highp';
				}
				precision = 'mediump';
			}
			if (precision === 'mediump') {
				if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 &&
					gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
					return 'mediump';
				}
			}
			return 'lowp';
		}
		const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;
		let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		const maxPrecision = getMaxPrecision(precision);
		if (maxPrecision !== precision) {
			console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
			precision = maxPrecision;
		}
		const drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');
		const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
		const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
		const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
		const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
		const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
		const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
		const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
		const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
		const vertexTextures = maxVertexTextures > 0;
		const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');
		const floatVertexTextures = vertexTextures && floatFragmentTextures;
		const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
		return {
			isWebGL2: isWebGL2,
			drawBuffers: drawBuffers,
			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,
			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,
			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,
			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,
			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,
			maxSamples: maxSamples
		};
	}

	function WebGLClipping(properties) {
		const scope = this;
		let globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false;
		const plane = new Plane(),
			viewNormalMatrix = new Matrix3(),
			uniform = {
				value: null,
				needsUpdate: false
			};
		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;
		this.init = function(planes, enableLocalClipping) {
			const enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;
			localClippingEnabled = enableLocalClipping;
			numGlobalPlanes = planes.length;
			return enabled;
		};
		this.beginShadows = function() {
			renderingShadows = true;
			projectPlanes(null);
		};
		this.endShadows = function() {
			renderingShadows = false;
		};
		this.setGlobalState = function(planes, camera) {
			globalState = projectPlanes(planes, camera, 0);
		};
		this.setState = function(material, camera, useCache) {
			const planes = material.clippingPlanes,
				clipIntersection = material.clipIntersection,
				clipShadows = material.clipShadows;
			const materialProperties = properties.get(material);
			if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
				// there's no local clipping
				if (renderingShadows) {
					// there's no global clipping
					projectPlanes(null);
				} else {
					resetGlobalState();
				}
			} else {
				const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4;
				let dstArray = materialProperties.clippingState || null;
				uniform.value = dstArray; // ensure unique state
				dstArray = projectPlanes(planes, camera, lGlobal, useCache);
				for (let i = 0; i !== lGlobal; ++i) {
					dstArray[i] = globalState[i];
				}
				materialProperties.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;
			}
		};

		function resetGlobalState() {
			if (uniform.value !== globalState) {
				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;
			}
			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;
		}

		function projectPlanes(planes, camera, dstOffset, skipTransform) {
			const nPlanes = planes !== null ? planes.length : 0;
			let dstArray = null;
			if (nPlanes !== 0) {
				dstArray = uniform.value;
				if (skipTransform !== true || dstArray === null) {
					const flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;
					viewNormalMatrix.getNormalMatrix(viewMatrix);
					if (dstArray === null || dstArray.length < flatSize) {
						dstArray = new Float32Array(flatSize);
					}
					for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
						plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
						plane.normal.toArray(dstArray, i4);
						dstArray[i4 + 3] = plane.constant;
					}
				}
				uniform.value = dstArray;
				uniform.needsUpdate = true;
			}
			scope.numPlanes = nPlanes;
			scope.numIntersection = 0;
			return dstArray;
		}
	}

	function WebGLCubeMaps(renderer) {
		let cubemaps = new WeakMap();

		function mapTextureMapping(texture, mapping) {
			if (mapping === EquirectangularReflectionMapping) {
				texture.mapping = CubeReflectionMapping;
			} else if (mapping === EquirectangularRefractionMapping) {
				texture.mapping = CubeRefractionMapping;
			}
			return texture;
		}

		function get(texture) {
			if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
				const mapping = texture.mapping;
				if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
					if (cubemaps.has(texture)) {
						const cubemap = cubemaps.get(texture).texture;
						return mapTextureMapping(cubemap, texture.mapping);
					} else {
						const image = texture.image;
						if (image && image.height > 0) {
							const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
							renderTarget.fromEquirectangularTexture(renderer, texture);
							cubemaps.set(texture, renderTarget);
							texture.addEventListener('dispose', onTextureDispose);
							return mapTextureMapping(renderTarget.texture, texture.mapping);
						} else {
							// image not yet ready. try the conversion next frame
							return null;
						}
					}
				}
			}
			return texture;
		}

		function onTextureDispose(event) {
			const texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			const cubemap = cubemaps.get(texture);
			if (cubemap !== undefined) {
				cubemaps.delete(texture);
				cubemap.dispose();
			}
		}

		function dispose() {
			cubemaps = new WeakMap();
		}
		return {
			get: get,
			dispose: dispose
		};
	}
	class OrthographicCamera extends Camera {
		constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {
			super();
			this.isOrthographicCamera = true;
			this.type = 'OrthographicCamera';
			this.zoom = 1;
			this.view = null;
			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;
			this.near = near;
			this.far = far;
			this.updateProjectionMatrix();
		}
		copy(source, recursive) {
			super.copy(source, recursive);
			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;
			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign({}, source.view);
			return this;
		}
		setViewOffset(fullWidth, fullHeight, x, y, width, height) {
			if (this.view === null) {
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
			}
			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
			this.updateProjectionMatrix();
		}
		clearViewOffset() {
			if (this.view !== null) {
				this.view.enabled = false;
			}
			this.updateProjectionMatrix();
		}
		updateProjectionMatrix() {
			const dx = (this.right - this.left) / (2 * this.zoom);
			const dy = (this.top - this.bottom) / (2 * this.zoom);
			const cx = (this.right + this.left) / 2;
			const cy = (this.top + this.bottom) / 2;
			let left = cx - dx;
			let right = cx + dx;
			let top = cy + dy;
			let bottom = cy - dy;
			if (this.view !== null && this.view.enabled) {
				const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
				const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
				left += scaleW * this.view.offsetX;
				right = left + scaleW * this.view.width;
				top -= scaleH * this.view.offsetY;
				bottom = top - scaleH * this.view.height;
			}
			this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
			this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
		}
		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;
			if (this.view !== null) data.object.view = Object.assign({}, this.view);
			return data;
		}
	}
	const LOD_MIN = 4;
	// The standard deviations (radians) associated with the extra mips. These are
	// chosen to approximate a Trowbridge-Reitz distribution function times the
	// geometric shadowing function. These sigma values squared must match the
	// variance #defines in cube_uv_reflection_fragment.glsl.js.
	const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
	// The maximum length of the blur for loop. Smaller sigmas will use fewer
	// samples and exit early, but not recompile the shader.
	const MAX_SAMPLES = 20;
	const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
	const _clearColor = /*@__PURE__*/ new Color();
	let _oldTarget = null;
	// Golden Ratio
	const PHI = (1 + Math.sqrt(5)) / 2;
	const INV_PHI = 1 / PHI;
	// Vertices of a dodecahedron (except the opposites, which represent the
	// same axis), used as axis directions evenly spread on a sphere.
	const _axisDirections = [
		/*@__PURE__*/
		new Vector3(1, 1, 1),
		/*@__PURE__*/
		new Vector3(-1, 1, 1),
		/*@__PURE__*/
		new Vector3(1, 1, -1),
		/*@__PURE__*/
		new Vector3(-1, 1, -1),
		/*@__PURE__*/
		new Vector3(0, PHI, INV_PHI),
		/*@__PURE__*/
		new Vector3(0, PHI, -INV_PHI),
		/*@__PURE__*/
		new Vector3(INV_PHI, 0, PHI),
		/*@__PURE__*/
		new Vector3(-INV_PHI, 0, PHI),
		/*@__PURE__*/
		new Vector3(PHI, INV_PHI, 0),
		/*@__PURE__*/
		new Vector3(-PHI, INV_PHI, 0)
	];
	/**
	 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
	 * (PMREM) from a cubeMap environment texture. This allows different levels of
	 * blur to be quickly accessed based on material roughness. It is packed into a
	 * special CubeUV format that allows us to perform custom interpolation so that
	 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
	 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
	 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
	 * higher roughness levels. In this way we maintain resolution to smoothly
	 * interpolate diffuse lighting while limiting sampling computation.
	 *
	 * Paper: Fast, Accurate Image-Based Lighting
	 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
	 */
	class PMREMGenerator {
		constructor(renderer) {
			this._renderer = renderer;
			this._pingPongRenderTarget = null;
			this._lodMax = 0;
			this._cubeSize = 0;
			this._lodPlanes = [];
			this._sizeLods = [];
			this._sigmas = [];
			this._blurMaterial = null;
			this._cubemapMaterial = null;
			this._equirectMaterial = null;
			this._compileMaterial(this._blurMaterial);
		}
		/**
		 * Generates a PMREM from a supplied Scene, which can be faster than using an
		 * image if networking bandwidth is low. Optional sigma specifies a blur radius
		 * in radians to be applied to the scene before PMREM generation. Optional near
		 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
		 * is placed at the origin).
		 */
		fromScene(scene, sigma = 0, near = 0.1, far = 100) {
			_oldTarget = this._renderer.getRenderTarget();
			this._setSize(256);
			const cubeUVRenderTarget = this._allocateTargets();
			cubeUVRenderTarget.depthBuffer = true;
			this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
			if (sigma > 0) {
				this._blur(cubeUVRenderTarget, 0, 0, sigma);
			}
			this._applyPMREM(cubeUVRenderTarget);
			this._cleanup(cubeUVRenderTarget);
			return cubeUVRenderTarget;
		}
		/**
		 * Generates a PMREM from an equirectangular texture, which can be either LDR
		 * or HDR. The ideal input image size is 1k (1024 x 512),
		 * as this matches best with the 256 x 256 cubemap output.
		 */
		fromEquirectangular(equirectangular, renderTarget = null) {
			return this._fromTexture(equirectangular, renderTarget);
		}
		/**
		 * Generates a PMREM from an cubemap texture, which can be either LDR
		 * or HDR. The ideal input cube size is 256 x 256,
		 * as this matches best with the 256 x 256 cubemap output.
		 */
		fromCubemap(cubemap, renderTarget = null) {
			return this._fromTexture(cubemap, renderTarget);
		}
		/**
		 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		compileCubemapShader() {
			if (this._cubemapMaterial === null) {
				this._cubemapMaterial = _getCubemapMaterial();
				this._compileMaterial(this._cubemapMaterial);
			}
		}
		/**
		 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		compileEquirectangularShader() {
			if (this._equirectMaterial === null) {
				this._equirectMaterial = _getEquirectMaterial();
				this._compileMaterial(this._equirectMaterial);
			}
		}
		/**
		 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
		 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
		 * one of them will cause any others to also become unusable.
		 */
		dispose() {
			this._dispose();
			if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
			if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
		}
		// private interface
		_setSize(cubeSize) {
			this._lodMax = Math.floor(Math.log2(cubeSize));
			this._cubeSize = Math.pow(2, this._lodMax);
		}
		_dispose() {
			if (this._blurMaterial !== null) this._blurMaterial.dispose();
			if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
			for (let i = 0; i < this._lodPlanes.length; i++) {
				this._lodPlanes[i].dispose();
			}
		}
		_cleanup(outputTarget) {
			this._renderer.setRenderTarget(_oldTarget);
			outputTarget.scissorTest = false;
			_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
		}
		_fromTexture(texture, renderTarget) {
			if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
				this._setSize(texture.image.length === 0 ? 16 : (texture.image[0].width || texture.image[0].image.width));
			} else { // Equirectangular
				this._setSize(texture.image.width / 4);
			}
			_oldTarget = this._renderer.getRenderTarget();
			const cubeUVRenderTarget = renderTarget || this._allocateTargets();
			this._textureToCubeUV(texture, cubeUVRenderTarget);
			this._applyPMREM(cubeUVRenderTarget);
			this._cleanup(cubeUVRenderTarget);
			return cubeUVRenderTarget;
		}
		_allocateTargets() {
			const width = 3 * Math.max(this._cubeSize, 16 * 7);
			const height = 4 * this._cubeSize;
			const params = {
				magFilter: LinearFilter,
				minFilter: LinearFilter,
				generateMipmaps: false,
				type: HalfFloatType,
				format: RGBAFormat,
				encoding: LinearEncoding,
				depthBuffer: false
			};
			const cubeUVRenderTarget = _createRenderTarget(width, height, params);
			if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
				if (this._pingPongRenderTarget !== null) {
					this._dispose();
				}
				this._pingPongRenderTarget = _createRenderTarget(width, height, params);
				const {
					_lodMax
				} = this;
				({
					sizeLods: this._sizeLods,
					lodPlanes: this._lodPlanes,
					sigmas: this._sigmas
				} = _createPlanes(_lodMax));
				this._blurMaterial = _getBlurShader(_lodMax, width, height);
			}
			return cubeUVRenderTarget;
		}
		_compileMaterial(material) {
			const tmpMesh = new Mesh(this._lodPlanes[0], material);
			this._renderer.compile(tmpMesh, _flatCamera);
		}
		_sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
			const fov = 90;
			const aspect = 1;
			const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
			const upSign = [1, -1, 1, 1, 1, 1];
			const forwardSign = [1, 1, 1, -1, -1, -1];
			const renderer = this._renderer;
			const originalAutoClear = renderer.autoClear;
			const toneMapping = renderer.toneMapping;
			renderer.getClearColor(_clearColor);
			renderer.toneMapping = NoToneMapping;
			renderer.autoClear = false;
			const backgroundMaterial = new MeshBasicMaterial({
				name: 'PMREM.Background',
				side: BackSide,
				depthWrite: false,
				depthTest: false,
			});
			const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
			let useSolidColor = false;
			const background = scene.background;
			if (background) {
				if (background.isColor) {
					backgroundMaterial.color.copy(background);
					scene.background = null;
					useSolidColor = true;
				}
			} else {
				backgroundMaterial.color.copy(_clearColor);
				useSolidColor = true;
			}
			for (let i = 0; i < 6; i++) {
				const col = i % 3;
				if (col === 0) {
					cubeCamera.up.set(0, upSign[i], 0);
					cubeCamera.lookAt(forwardSign[i], 0, 0);
				} else if (col === 1) {
					cubeCamera.up.set(0, 0, upSign[i]);
					cubeCamera.lookAt(0, forwardSign[i], 0);
				} else {
					cubeCamera.up.set(0, upSign[i], 0);
					cubeCamera.lookAt(0, 0, forwardSign[i]);
				}
				const size = this._cubeSize;
				_setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
				renderer.setRenderTarget(cubeUVRenderTarget);
				if (useSolidColor) {
					renderer.render(backgroundBox, cubeCamera);
				}
				renderer.render(scene, cubeCamera);
			}
			backgroundBox.geometry.dispose();
			backgroundBox.material.dispose();
			renderer.toneMapping = toneMapping;
			renderer.autoClear = originalAutoClear;
			scene.background = background;
		}
		_textureToCubeUV(texture, cubeUVRenderTarget) {
			const renderer = this._renderer;
			const isCubeTexture = (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping);
			if (isCubeTexture) {
				if (this._cubemapMaterial === null) {
					this._cubemapMaterial = _getCubemapMaterial();
				}
				this._cubemapMaterial.uniforms.flipEnvMap.value = (texture.isRenderTargetTexture === false) ? -1 : 1;
			} else {
				if (this._equirectMaterial === null) {
					this._equirectMaterial = _getEquirectMaterial();
				}
			}
			const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
			const mesh = new Mesh(this._lodPlanes[0], material);
			const uniforms = material.uniforms;
			uniforms['envMap'].value = texture;
			const size = this._cubeSize;
			_setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
			renderer.setRenderTarget(cubeUVRenderTarget);
			renderer.render(mesh, _flatCamera);
		}
		_applyPMREM(cubeUVRenderTarget) {
			const renderer = this._renderer;
			const autoClear = renderer.autoClear;
			renderer.autoClear = false;
			for (let i = 1; i < this._lodPlanes.length; i++) {
				const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
				const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
				this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
			}
			renderer.autoClear = autoClear;
		}
		/**
		 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
		 * vertically and horizontally, but this breaks down on a cube. Here we apply
		 * the blur latitudinally (around the poles), and then longitudinally (towards
		 * the poles) to approximate the orthogonally-separable blur. It is least
		 * accurate at the poles, but still does a decent job.
		 */
		_blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
			const pingPongRenderTarget = this._pingPongRenderTarget;
			this._halfBlur(
				cubeUVRenderTarget,
				pingPongRenderTarget,
				lodIn,
				lodOut,
				sigma,
				'latitudinal',
				poleAxis);
			this._halfBlur(
				pingPongRenderTarget,
				cubeUVRenderTarget,
				lodOut,
				lodOut,
				sigma,
				'longitudinal',
				poleAxis);
		}
		_halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
			const renderer = this._renderer;
			const blurMaterial = this._blurMaterial;
			if (direction !== 'latitudinal' && direction !== 'longitudinal') {
				console.error(
					'blur direction must be either latitudinal or longitudinal!');
			}
			// Number of standard deviations at which to cut off the discrete approximation.
			const STANDARD_DEVIATIONS = 3;
			const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
			const blurUniforms = blurMaterial.uniforms;
			const pixels = this._sizeLods[lodIn] - 1;
			const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
			const sigmaPixels = sigmaRadians / radiansPerPixel;
			const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
			if (samples > MAX_SAMPLES) {
				console.warn(`sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}`);
			}
			const weights = [];
			let sum = 0;
			for (let i = 0; i < MAX_SAMPLES; ++i) {
				const x = i / sigmaPixels;
				const weight = Math.exp(-x * x / 2);
				weights.push(weight);
				if (i === 0) {
					sum += weight;
				} else if (i < samples) {
					sum += 2 * weight;
				}
			}
			for (let i = 0; i < weights.length; i++) {
				weights[i] = weights[i] / sum;
			}
			blurUniforms['envMap'].value = targetIn.texture;
			blurUniforms['samples'].value = samples;
			blurUniforms['weights'].value = weights;
			blurUniforms['latitudinal'].value = direction === 'latitudinal';
			if (poleAxis) {
				blurUniforms['poleAxis'].value = poleAxis;
			}
			const {
				_lodMax
			} = this;
			blurUniforms['dTheta'].value = radiansPerPixel;
			blurUniforms['mipInt'].value = _lodMax - lodIn;
			const outputSize = this._sizeLods[lodOut];
			const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
			const y = 4 * (this._cubeSize - outputSize);
			_setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
			renderer.setRenderTarget(targetOut);
			renderer.render(blurMesh, _flatCamera);
		}
	}

	function _createPlanes(lodMax) {
		const lodPlanes = [];
		const sizeLods = [];
		const sigmas = [];
		let lod = lodMax;
		const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
		for (let i = 0; i < totalLods; i++) {
			const sizeLod = Math.pow(2, lod);
			sizeLods.push(sizeLod);
			let sigma = 1.0 / sizeLod;
			if (i > lodMax - LOD_MIN) {
				sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
			} else if (i === 0) {
				sigma = 0;
			}
			sigmas.push(sigma);
			const texelSize = 1.0 / (sizeLod - 2);
			const min = -texelSize;
			const max = 1 + texelSize;
			const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
			const cubeFaces = 6;
			const vertices = 6;
			const positionSize = 3;
			const uvSize = 2;
			const faceIndexSize = 1;
			const position = new Float32Array(positionSize * vertices * cubeFaces);
			const uv = new Float32Array(uvSize * vertices * cubeFaces);
			const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
			for (let face = 0; face < cubeFaces; face++) {
				const x = (face % 3) * 2 / 3 - 1;
				const y = face > 2 ? 0 : -1;
				const coordinates = [
					x, y, 0,
					x + 2 / 3, y, 0,
					x + 2 / 3, y + 1, 0,
					x, y, 0,
					x + 2 / 3, y + 1, 0,
					x, y + 1, 0
				];
				position.set(coordinates, positionSize * vertices * face);
				uv.set(uv1, uvSize * vertices * face);
				const fill = [face, face, face, face, face, face];
				faceIndex.set(fill, faceIndexSize * vertices * face);
			}
			const planes = new BufferGeometry();
			planes.setAttribute('position', new BufferAttribute(position, positionSize));
			planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
			planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
			lodPlanes.push(planes);
			if (lod > LOD_MIN) {
				lod--;
			}
		}
		return {
			lodPlanes,
			sizeLods,
			sigmas
		};
	}

	function _createRenderTarget(width, height, params) {
		const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
		cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
		cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
		cubeUVRenderTarget.scissorTest = true;
		return cubeUVRenderTarget;
	}

	function _setViewport(target, x, y, width, height) {
		target.viewport.set(x, y, width, height);
		target.scissor.set(x, y, width, height);
	}

	function _getBlurShader(lodMax, width, height) {
		const weights = new Float32Array(MAX_SAMPLES);
		const poleAxis = new Vector3(0, 1, 0);
		const shaderMaterial = new ShaderMaterial({
			name: 'SphericalGaussianBlur',
			defines: {
				'n': MAX_SAMPLES,
				'CUBEUV_TEXEL_WIDTH': 1.0 / width,
				'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
				'CUBEUV_MAX_MIP': `${lodMax}.0`,
			},
			uniforms: {
				'envMap': {
					value: null
				},
				'samples': {
					value: 1
				},
				'weights': {
					value: weights
				},
				'latitudinal': {
					value: false
				},
				'dTheta': {
					value: 0
				},
				'mipInt': {
					value: 0
				},
				'poleAxis': {
					value: poleAxis
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader: /* glsl */ `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getEquirectMaterial() {
		return new ShaderMaterial({
			name: 'EquirectangularToCubeUV',
			uniforms: {
				'envMap': {
					value: null
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader: /* glsl */ `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
	}

	function _getCubemapMaterial() {
		return new ShaderMaterial({
			name: 'CubemapToCubeUV',
			uniforms: {
				'envMap': {
					value: null
				},
				'flipEnvMap': {
					value: -1
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader: /* glsl */ `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
	}

	function _getCommonVertexShader() {
		return /* glsl */ `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
	}

	function WebGLCubeUVMaps(renderer) {
		let cubeUVmaps = new WeakMap();
		let pmremGenerator = null;

		function get(texture) {
			if (texture && texture.isTexture) {
				const mapping = texture.mapping;
				const isEquirectMap = (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping);
				const isCubeMap = (mapping === CubeReflectionMapping || mapping === CubeRefractionMapping);
				// equirect/cube map to cubeUV conversion
				if (isEquirectMap || isCubeMap) {
					if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
						texture.needsPMREMUpdate = false;
						let renderTarget = cubeUVmaps.get(texture);
						if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
						renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
						cubeUVmaps.set(texture, renderTarget);
						return renderTarget.texture;
					} else {
						if (cubeUVmaps.has(texture)) {
							return cubeUVmaps.get(texture).texture;
						} else {
							const image = texture.image;
							if ((isEquirectMap && image && image.height > 0) || (isCubeMap && image && isCubeTextureComplete(image))) {
								if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
								const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
								cubeUVmaps.set(texture, renderTarget);
								texture.addEventListener('dispose', onTextureDispose);
								return renderTarget.texture;
							} else {
								// image not yet ready. try the conversion next frame
								return null;
							}
						}
					}
				}
			}
			return texture;
		}

		function isCubeTextureComplete(image) {
			let count = 0;
			const length = 6;
			for (let i = 0; i < length; i++) {
				if (image[i] !== undefined) count++;
			}
			return count === length;
		}

		function onTextureDispose(event) {
			const texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			const cubemapUV = cubeUVmaps.get(texture);
			if (cubemapUV !== undefined) {
				cubeUVmaps.delete(texture);
				cubemapUV.dispose();
			}
		}

		function dispose() {
			cubeUVmaps = new WeakMap();
			if (pmremGenerator !== null) {
				pmremGenerator.dispose();
				pmremGenerator = null;
			}
		}
		return {
			get: get,
			dispose: dispose
		};
	}

	function WebGLExtensions(gl) {
		const extensions = {};

		function getExtension(name) {
			if (extensions[name] !== undefined) {
				return extensions[name];
			}
			let extension;
			switch (name) {
				case 'WEBGL_depth_texture':
					extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
					break;
				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
					break;
				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
					break;
				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
					break;
				default:
					extension = gl.getExtension(name);
			}
			extensions[name] = extension;
			return extension;
		}
		return {
			has: function(name) {
				return getExtension(name) !== null;
			},
			init: function(capabilities) {
				if (capabilities.isWebGL2) {
					getExtension('EXT_color_buffer_float');
				} else {
					getExtension('WEBGL_depth_texture');
					getExtension('OES_texture_float');
					getExtension('OES_texture_half_float');
					getExtension('OES_texture_half_float_linear');
					getExtension('OES_standard_derivatives');
					getExtension('OES_element_index_uint');
					getExtension('OES_vertex_array_object');
					getExtension('ANGLE_instanced_arrays');
				}
				getExtension('OES_texture_float_linear');
				getExtension('EXT_color_buffer_half_float');
				getExtension('WEBGL_multisampled_render_to_texture');
			},
			get: function(name) {
				const extension = getExtension(name);
				if (extension === null) {
					console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
				}
				return extension;
			}
		};
	}

	function WebGLGeometries(gl, attributes, info, bindingStates) {
		const geometries = {};
		const wireframeAttributes = new WeakMap();

		function onGeometryDispose(event) {
			const geometry = event.target;
			if (geometry.index !== null) {
				attributes.remove(geometry.index);
			}
			for (const name in geometry.attributes) {
				attributes.remove(geometry.attributes[name]);
			}
			geometry.removeEventListener('dispose', onGeometryDispose);
			delete geometries[geometry.id];
			const attribute = wireframeAttributes.get(geometry);
			if (attribute) {
				attributes.remove(attribute);
				wireframeAttributes.delete(geometry);
			}
			bindingStates.releaseStatesOfGeometry(geometry);
			if (geometry.isInstancedBufferGeometry === true) {
				delete geometry._maxInstanceCount;
			}
			//
			info.memory.geometries--;
		}

		function get(object, geometry) {
			if (geometries[geometry.id] === true) return geometry;
			geometry.addEventListener('dispose', onGeometryDispose);
			geometries[geometry.id] = true;
			info.memory.geometries++;
			return geometry;
		}

		function update(geometry) {
			const geometryAttributes = geometry.attributes;
			// Updating index buffer in VAO now. See WebGLBindingStates.
			for (const name in geometryAttributes) {
				attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
			}
			// morph targets
			const morphAttributes = geometry.morphAttributes;
			for (const name in morphAttributes) {
				const array = morphAttributes[name];
				for (let i = 0, l = array.length; i < l; i++) {
					attributes.update(array[i], gl.ARRAY_BUFFER);
				}
			}
		}

		function updateWireframeAttribute(geometry) {
			const indices = [];
			const geometryIndex = geometry.index;
			const geometryPosition = geometry.attributes.position;
			let version = 0;
			if (geometryIndex !== null) {
				const array = geometryIndex.array;
				version = geometryIndex.version;
				for (let i = 0, l = array.length; i < l; i += 3) {
					const a = array[i + 0];
					const b = array[i + 1];
					const c = array[i + 2];
					indices.push(a, b, b, c, c, a);
				}
			} else {
				const array = geometryPosition.array;
				version = geometryPosition.version;
				for (let i = 0, l = (array.length / 3) - 1; i < l; i += 3) {
					const a = i + 0;
					const b = i + 1;
					const c = i + 2;
					indices.push(a, b, b, c, c, a);
				}
			}
			const attribute = new(arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
			attribute.version = version;
			// Updating index buffer in VAO now. See WebGLBindingStates
			//
			const previousAttribute = wireframeAttributes.get(geometry);
			if (previousAttribute) attributes.remove(previousAttribute);
			//
			wireframeAttributes.set(geometry, attribute);
		}

		function getWireframeAttribute(geometry) {
			const currentAttribute = wireframeAttributes.get(geometry);
			if (currentAttribute) {
				const geometryIndex = geometry.index;
				if (geometryIndex !== null) {
					// if the attribute is obsolete, create a new one
					if (currentAttribute.version < geometryIndex.version) {
						updateWireframeAttribute(geometry);
					}
				}
			} else {
				updateWireframeAttribute(geometry);
			}
			return wireframeAttributes.get(geometry);
		}
		return {
			get: get,
			update: update,
			getWireframeAttribute: getWireframeAttribute
		};
	}

	function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;
		let mode;

		function setMode(value) {
			mode = value;
		}
		let type, bytesPerElement;

		function setIndex(value) {
			type = value.type;
			bytesPerElement = value.bytesPerElement;
		}

		function render(start, count) {
			gl.drawElements(mode, count, type, start * bytesPerElement);
			info.update(count, mode, 1);
		}

		function renderInstances(start, count, primcount) {
			if (primcount === 0) return;
			let extension, methodName;
			if (isWebGL2) {
				extension = gl;
				methodName = 'drawElementsInstanced';
			} else {
				extension = extensions.get('ANGLE_instanced_arrays');
				methodName = 'drawElementsInstancedANGLE';
				if (extension === null) {
					console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}
			extension[methodName](mode, count, type, start * bytesPerElement, primcount);
			info.update(count, mode, primcount);
		}
		//
		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;
	}

	function WebGLInfo(gl) {
		const memory = {
			geometries: 0,
			textures: 0
		};
		const render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update(count, mode, instanceCount) {
			render.calls++;
			switch (mode) {
				case gl.TRIANGLES:
					render.triangles += instanceCount * (count / 3);
					break;
				case gl.LINES:
					render.lines += instanceCount * (count / 2);
					break;
				case gl.LINE_STRIP:
					render.lines += instanceCount * (count - 1);
					break;
				case gl.LINE_LOOP:
					render.lines += instanceCount * count;
					break;
				case gl.POINTS:
					render.points += instanceCount * count;
					break;
				default:
					console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
					break;
			}
		}

		function reset() {
			render.frame++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;
		}
		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};
	}

	function numericalSort(a, b) {
		return a[0] - b[0];
	}

	function absNumericalSort(a, b) {
		return Math.abs(b[1]) - Math.abs(a[1]);
	}

	function WebGLMorphtargets(gl, capabilities, textures) {
		const influencesList = {};
		const morphInfluences = new Float32Array(8);
		const morphTextures = new WeakMap();
		const morph = new Vector4();
		const workInfluences = [];
		for (let i = 0; i < 8; i++) {
			workInfluences[i] = [i, 0];
		}

		function update(object, geometry, program) {
			const objectInfluences = object.morphTargetInfluences;
			if (capabilities.isWebGL2 === true) {
				// instead of using attributes, the WebGL 2 code path encodes morph targets
				// into an array of data textures. Each layer represents a single morph target.
				const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
				const morphTargetsCount = (morphAttribute !== undefined) ? morphAttribute.length : 0;
				let entry = morphTextures.get(geometry);
				if (entry === undefined || entry.count !== morphTargetsCount) {
					if (entry !== undefined) entry.texture.dispose();
					const hasMorphPosition = geometry.morphAttributes.position !== undefined;
					const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
					const hasMorphColors = geometry.morphAttributes.color !== undefined;
					const morphTargets = geometry.morphAttributes.position || [];
					const morphNormals = geometry.morphAttributes.normal || [];
					const morphColors = geometry.morphAttributes.color || [];
					let vertexDataCount = 0;
					if (hasMorphPosition === true) vertexDataCount = 1;
					if (hasMorphNormals === true) vertexDataCount = 2;
					if (hasMorphColors === true) vertexDataCount = 3;
					let width = geometry.attributes.position.count * vertexDataCount;
					let height = 1;
					if (width > capabilities.maxTextureSize) {
						height = Math.ceil(width / capabilities.maxTextureSize);
						width = capabilities.maxTextureSize;
					}
					const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
					const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
					texture.type = FloatType;
					texture.needsUpdate = true;
					// fill buffer
					const vertexDataStride = vertexDataCount * 4;
					for (let i = 0; i < morphTargetsCount; i++) {
						const morphTarget = morphTargets[i];
						const morphNormal = morphNormals[i];
						const morphColor = morphColors[i];
						const offset = width * height * 4 * i;
						for (let j = 0; j < morphTarget.count; j++) {
							const stride = j * vertexDataStride;
							if (hasMorphPosition === true) {
								morph.fromBufferAttribute(morphTarget, j);
								buffer[offset + stride + 0] = morph.x;
								buffer[offset + stride + 1] = morph.y;
								buffer[offset + stride + 2] = morph.z;
								buffer[offset + stride + 3] = 0;
							}
							if (hasMorphNormals === true) {
								morph.fromBufferAttribute(morphNormal, j);
								buffer[offset + stride + 4] = morph.x;
								buffer[offset + stride + 5] = morph.y;
								buffer[offset + stride + 6] = morph.z;
								buffer[offset + stride + 7] = 0;
							}
							if (hasMorphColors === true) {
								morph.fromBufferAttribute(morphColor, j);
								buffer[offset + stride + 8] = morph.x;
								buffer[offset + stride + 9] = morph.y;
								buffer[offset + stride + 10] = morph.z;
								buffer[offset + stride + 11] = (morphColor.itemSize === 4) ? morph.w : 1;
							}
						}
					}
					entry = {
						count: morphTargetsCount,
						texture: texture,
						size: new Vector2(width, height)
					};
					morphTextures.set(geometry, entry);

					function disposeTexture() {
						texture.dispose();
						morphTextures.delete(geometry);
						geometry.removeEventListener('dispose', disposeTexture);
					}
					geometry.addEventListener('dispose', disposeTexture);
				}
				//
				let morphInfluencesSum = 0;
				for (let i = 0; i < objectInfluences.length; i++) {
					morphInfluencesSum += objectInfluences[i];
				}
				const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
				program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
				program.getUniforms().setValue(gl, 'morphTargetInfluences', objectInfluences);
				program.getUniforms().setValue(gl, 'morphTargetsTexture', entry.texture, textures);
				program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);
			} else {
				// When object doesn't have morph target influences defined, we treat it as a 0-length array
				// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
				const length = objectInfluences === undefined ? 0 : objectInfluences.length;
				let influences = influencesList[geometry.id];
				if (influences === undefined || influences.length !== length) {
					// initialise list
					influences = [];
					for (let i = 0; i < length; i++) {
						influences[i] = [i, 0];
					}
					influencesList[geometry.id] = influences;
				}
				// Collect influences
				for (let i = 0; i < length; i++) {
					const influence = influences[i];
					influence[0] = i;
					influence[1] = objectInfluences[i];
				}
				influences.sort(absNumericalSort);
				for (let i = 0; i < 8; i++) {
					if (i < length && influences[i][1]) {
						workInfluences[i][0] = influences[i][0];
						workInfluences[i][1] = influences[i][1];
					} else {
						workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
						workInfluences[i][1] = 0;
					}
				}
				workInfluences.sort(numericalSort);
				const morphTargets = geometry.morphAttributes.position;
				const morphNormals = geometry.morphAttributes.normal;
				let morphInfluencesSum = 0;
				for (let i = 0; i < 8; i++) {
					const influence = workInfluences[i];
					const index = influence[0];
					const value = influence[1];
					if (index !== Number.MAX_SAFE_INTEGER && value) {
						if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {
							geometry.setAttribute('morphTarget' + i, morphTargets[index]);
						}
						if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {
							geometry.setAttribute('morphNormal' + i, morphNormals[index]);
						}
						morphInfluences[i] = value;
						morphInfluencesSum += value;
					} else {
						if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {
							geometry.deleteAttribute('morphTarget' + i);
						}
						if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {
							geometry.deleteAttribute('morphNormal' + i);
						}
						morphInfluences[i] = 0;
					}
				}
				// GLSL shader uses formula baseinfluence * base + sum(target * influence)
				// This allows us to switch between absolute morphs and relative morphs without changing shader code
				// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
				const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
				program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
				program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
			}
		}
		return {
			update: update
		};
	}

	function WebGLObjects(gl, geometries, attributes, info) {
		let updateMap = new WeakMap();

		function update(object) {
			const frame = info.render.frame;
			const geometry = object.geometry;
			const buffergeometry = geometries.get(object, geometry);
			// Update once per frame
			if (updateMap.get(buffergeometry) !== frame) {
				geometries.update(buffergeometry);
				updateMap.set(buffergeometry, frame);
			}
			if (object.isInstancedMesh) {
				if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {
					object.addEventListener('dispose', onInstancedMeshDispose);
				}
				attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
				if (object.instanceColor !== null) {
					attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
				}
			}
			return buffergeometry;
		}

		function dispose() {
			updateMap = new WeakMap();
		}

		function onInstancedMeshDispose(event) {
			const instancedMesh = event.target;
			instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
			attributes.remove(instancedMesh.instanceMatrix);
			if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
		}
		return {
			update: update,
			dispose: dispose
		};
	}
	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */
	const emptyTexture = /*@__PURE__*/ new Texture();
	const emptyArrayTexture = /*@__PURE__*/ new DataArrayTexture();
	const empty3dTexture = /*@__PURE__*/ new Data3DTexture();
	const emptyCubeTexture = /*@__PURE__*/ new CubeTexture();
	// --- Utilities ---
	// Array Caches (provide typed arrays for temporary by size)
	const arrayCacheF32 = [];
	const arrayCacheI32 = [];
	// Float32Array caches used for uploading Matrix uniforms
	const mat4array = new Float32Array(16);
	const mat3array = new Float32Array(9);
	const mat2array = new Float32Array(4);
	// Flattening for arrays of vectors and matrices
	function flatten(array, nBlocks, blockSize) {
		const firstElem = array[0];
		if (firstElem <= 0 || firstElem > 0) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983
		const n = nBlocks * blockSize;
		let r = arrayCacheF32[n];
		if (r === undefined) {
			r = new Float32Array(n);
			arrayCacheF32[n] = r;
		}
		if (nBlocks !== 0) {
			firstElem.toArray(r, 0);
			for (let i = 1, offset = 0; i !== nBlocks; ++i) {
				offset += blockSize;
				array[i].toArray(r, offset);
			}
		}
		return r;
	}

	function arraysEqual(a, b) {
		if (a.length !== b.length) return false;
		for (let i = 0, l = a.length; i < l; i++) {
			if (a[i] !== b[i]) return false;
		}
		return true;
	}

	function copyArray(a, b) {
		for (let i = 0, l = b.length; i < l; i++) {
			a[i] = b[i];
		}
	}
	// Texture unit allocation
	function allocTexUnits(textures, n) {
		let r = arrayCacheI32[n];
		if (r === undefined) {
			r = new Int32Array(n);
			arrayCacheI32[n] = r;
		}
		for (let i = 0; i !== n; ++i) {
			r[i] = textures.allocateTextureUnit();
		}
		return r;
	}
	// --- Setters ---
	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.
	// Single scalar
	function setValueV1f(gl, v) {
		const cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1f(this.addr, v);
		cache[0] = v;
	}
	// Single float vector (from flat array or THREE.VectorN)
	function setValueV2f(gl, v) {
		const cache = this.cache;
		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y) {
				gl.uniform2f(this.addr, v.x, v.y);
				cache[0] = v.x;
				cache[1] = v.y;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform2fv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV3f(gl, v) {
		const cache = this.cache;
		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
				gl.uniform3f(this.addr, v.x, v.y, v.z);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
			}
		} else if (v.r !== undefined) {
			if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
				gl.uniform3f(this.addr, v.r, v.g, v.b);
				cache[0] = v.r;
				cache[1] = v.g;
				cache[2] = v.b;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform3fv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV4f(gl, v) {
		const cache = this.cache;
		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
				gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
				cache[3] = v.w;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform4fv(this.addr, v);
			copyArray(cache, v);
		}
	}
	// Single matrix (from flat array or THREE.MatrixN)
	function setValueM2(gl, v) {
		const cache = this.cache;
		const elements = v.elements;
		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix2fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat2array.set(elements);
			gl.uniformMatrix2fv(this.addr, false, mat2array);
			copyArray(cache, elements);
		}
	}

	function setValueM3(gl, v) {
		const cache = this.cache;
		const elements = v.elements;
		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix3fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat3array.set(elements);
			gl.uniformMatrix3fv(this.addr, false, mat3array);
			copyArray(cache, elements);
		}
	}

	function setValueM4(gl, v) {
		const cache = this.cache;
		const elements = v.elements;
		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix4fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat4array.set(elements);
			gl.uniformMatrix4fv(this.addr, false, mat4array);
			copyArray(cache, elements);
		}
	}
	// Single integer / boolean
	function setValueV1i(gl, v) {
		const cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1i(this.addr, v);
		cache[0] = v;
	}
	// Single integer / boolean vector (from flat array or THREE.VectorN)
	function setValueV2i(gl, v) {
		const cache = this.cache;
		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y) {
				gl.uniform2i(this.addr, v.x, v.y);
				cache[0] = v.x;
				cache[1] = v.y;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform2iv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV3i(gl, v) {
		const cache = this.cache;
		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
				gl.uniform3i(this.addr, v.x, v.y, v.z);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform3iv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV4i(gl, v) {
		const cache = this.cache;
		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
				gl.uniform4i(this.addr, v.x, v.y, v.z, v.w);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
				cache[3] = v.w;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform4iv(this.addr, v);
			copyArray(cache, v);
		}
	}
	// Single unsigned integer
	function setValueV1ui(gl, v) {
		const cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1ui(this.addr, v);
		cache[0] = v;
	}
	// Single unsigned integer vector (from flat array or THREE.VectorN)
	function setValueV2ui(gl, v) {
		const cache = this.cache;
		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y) {
				gl.uniform2ui(this.addr, v.x, v.y);
				cache[0] = v.x;
				cache[1] = v.y;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform2uiv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV3ui(gl, v) {
		const cache = this.cache;
		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
				gl.uniform3ui(this.addr, v.x, v.y, v.z);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform3uiv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV4ui(gl, v) {
		const cache = this.cache;
		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
				gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
				cache[3] = v.w;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform4uiv(this.addr, v);
			copyArray(cache, v);
		}
	}
	// Single texture (2D / Cube)
	function setValueT1(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();
		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}
		textures.setTexture2D(v || emptyTexture, unit);
	}

	function setValueT3D1(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();
		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}
		textures.setTexture3D(v || empty3dTexture, unit);
	}

	function setValueT6(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();
		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}
		textures.setTextureCube(v || emptyCubeTexture, unit);
	}

	function setValueT2DArray1(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();
		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}
		textures.setTexture2DArray(v || emptyArrayTexture, unit);
	}
	// Helper to pick the right setter for the singular case
	function getSingularSetter(type) {
		switch (type) {
			case 0x1406:
				return setValueV1f; // FLOAT
			case 0x8b50:
				return setValueV2f; // _VEC2
			case 0x8b51:
				return setValueV3f; // _VEC3
			case 0x8b52:
				return setValueV4f; // _VEC4
			case 0x8b5a:
				return setValueM2; // _MAT2
			case 0x8b5b:
				return setValueM3; // _MAT3
			case 0x8b5c:
				return setValueM4; // _MAT4
			case 0x1404:
			case 0x8b56:
				return setValueV1i; // INT, BOOL
			case 0x8b53:
			case 0x8b57:
				return setValueV2i; // _VEC2
			case 0x8b54:
			case 0x8b58:
				return setValueV3i; // _VEC3
			case 0x8b55:
			case 0x8b59:
				return setValueV4i; // _VEC4
			case 0x1405:
				return setValueV1ui; // UINT
			case 0x8dc6:
				return setValueV2ui; // _VEC2
			case 0x8dc7:
				return setValueV3ui; // _VEC3
			case 0x8dc8:
				return setValueV4ui; // _VEC4
			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1;
			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1;
			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6;
			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1;
		}
	}
	// Array of scalars
	function setValueV1fArray(gl, v) {
		gl.uniform1fv(this.addr, v);
	}
	// Array of vectors (from flat array or array of THREE.VectorN)
	function setValueV2fArray(gl, v) {
		const data = flatten(v, this.size, 2);
		gl.uniform2fv(this.addr, data);
	}

	function setValueV3fArray(gl, v) {
		const data = flatten(v, this.size, 3);
		gl.uniform3fv(this.addr, data);
	}

	function setValueV4fArray(gl, v) {
		const data = flatten(v, this.size, 4);
		gl.uniform4fv(this.addr, data);
	}
	// Array of matrices (from flat array or array of THREE.MatrixN)
	function setValueM2Array(gl, v) {
		const data = flatten(v, this.size, 4);
		gl.uniformMatrix2fv(this.addr, false, data);
	}

	function setValueM3Array(gl, v) {
		const data = flatten(v, this.size, 9);
		gl.uniformMatrix3fv(this.addr, false, data);
	}

	function setValueM4Array(gl, v) {
		const data = flatten(v, this.size, 16);
		gl.uniformMatrix4fv(this.addr, false, data);
	}
	// Array of integer / boolean
	function setValueV1iArray(gl, v) {
		gl.uniform1iv(this.addr, v);
	}
	// Array of integer / boolean vectors (from flat array)
	function setValueV2iArray(gl, v) {
		gl.uniform2iv(this.addr, v);
	}

	function setValueV3iArray(gl, v) {
		gl.uniform3iv(this.addr, v);
	}

	function setValueV4iArray(gl, v) {
		gl.uniform4iv(this.addr, v);
	}
	// Array of unsigned integer
	function setValueV1uiArray(gl, v) {
		gl.uniform1uiv(this.addr, v);
	}
	// Array of unsigned integer vectors (from flat array)
	function setValueV2uiArray(gl, v) {
		gl.uniform2uiv(this.addr, v);
	}

	function setValueV3uiArray(gl, v) {
		gl.uniform3uiv(this.addr, v);
	}

	function setValueV4uiArray(gl, v) {
		gl.uniform4uiv(this.addr, v);
	}
	// Array of textures (2D / 3D / Cube / 2DArray)
	function setValueT1Array(gl, v, textures) {
		const cache = this.cache;
		const n = v.length;
		const units = allocTexUnits(textures, n);
		if (!arraysEqual(cache, units)) {
			gl.uniform1iv(this.addr, units);
			copyArray(cache, units);
		}
		for (let i = 0; i !== n; ++i) {
			textures.setTexture2D(v[i] || emptyTexture, units[i]);
		}
	}

	function setValueT3DArray(gl, v, textures) {
		const cache = this.cache;
		const n = v.length;
		const units = allocTexUnits(textures, n);
		if (!arraysEqual(cache, units)) {
			gl.uniform1iv(this.addr, units);
			copyArray(cache, units);
		}
		for (let i = 0; i !== n; ++i) {
			textures.setTexture3D(v[i] || empty3dTexture, units[i]);
		}
	}

	function setValueT6Array(gl, v, textures) {
		const cache = this.cache;
		const n = v.length;
		const units = allocTexUnits(textures, n);
		if (!arraysEqual(cache, units)) {
			gl.uniform1iv(this.addr, units);
			copyArray(cache, units);
		}
		for (let i = 0; i !== n; ++i) {
			textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
		}
	}

	function setValueT2DArrayArray(gl, v, textures) {
		const cache = this.cache;
		const n = v.length;
		const units = allocTexUnits(textures, n);
		if (!arraysEqual(cache, units)) {
			gl.uniform1iv(this.addr, units);
			copyArray(cache, units);
		}
		for (let i = 0; i !== n; ++i) {
			textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
		}
	}
	// Helper to pick the right setter for a pure (bottom-level) array
	function getPureArraySetter(type) {
		switch (type) {
			case 0x1406:
				return setValueV1fArray; // FLOAT
			case 0x8b50:
				return setValueV2fArray; // _VEC2
			case 0x8b51:
				return setValueV3fArray; // _VEC3
			case 0x8b52:
				return setValueV4fArray; // _VEC4
			case 0x8b5a:
				return setValueM2Array; // _MAT2
			case 0x8b5b:
				return setValueM3Array; // _MAT3
			case 0x8b5c:
				return setValueM4Array; // _MAT4
			case 0x1404:
			case 0x8b56:
				return setValueV1iArray; // INT, BOOL
			case 0x8b53:
			case 0x8b57:
				return setValueV2iArray; // _VEC2
			case 0x8b54:
			case 0x8b58:
				return setValueV3iArray; // _VEC3
			case 0x8b55:
			case 0x8b59:
				return setValueV4iArray; // _VEC4
			case 0x1405:
				return setValueV1uiArray; // UINT
			case 0x8dc6:
				return setValueV2uiArray; // _VEC2
			case 0x8dc7:
				return setValueV3uiArray; // _VEC3
			case 0x8dc8:
				return setValueV4uiArray; // _VEC4
			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1Array;
			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3DArray;
			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6Array;
			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArrayArray;
		}
	}
	// --- Uniform Classes ---
	class SingleUniform {
		constructor(id, activeInfo, addr) {
			this.id = id;
			this.addr = addr;
			this.cache = [];
			this.setValue = getSingularSetter(activeInfo.type);
			// this.path = activeInfo.name; // DEBUG
		}
	}
	class PureArrayUniform {
		constructor(id, activeInfo, addr) {
			this.id = id;
			this.addr = addr;
			this.cache = [];
			this.size = activeInfo.size;
			this.setValue = getPureArraySetter(activeInfo.type);
			// this.path = activeInfo.name; // DEBUG
		}
	}
	class StructuredUniform {
		constructor(id) {
			this.id = id;
			this.seq = [];
			this.map = {};
		}
		setValue(gl, value, textures) {
			const seq = this.seq;
			for (let i = 0, n = seq.length; i !== n; ++i) {
				const u = seq[i];
				u.setValue(gl, value[u.id], textures);
			}
		}
	}
	// --- Top-level ---
	// Parser - builds up the property tree from the path strings
	const RePathPart = /(\w+)(\])?(\[|\.)?/g;
	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.
	function addUniform(container, uniformObject) {
		container.seq.push(uniformObject);
		container.map[uniformObject.id] = uniformObject;
	}

	function parseUniform(activeInfo, addr, container) {
		const path = activeInfo.name,
			pathLength = path.length;
		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;
		while (true) {
			const match = RePathPart.exec(path),
				matchEnd = RePathPart.lastIndex;
			let id = match[1];
			const idIsIndex = match[2] === ']',
				subscript = match[3];
			if (idIsIndex) id = id | 0; // convert to integer
			if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
				// bare name or "pure" bottom-level array "[0]" suffix
				addUniform(container, subscript === undefined ?
					new SingleUniform(id, activeInfo, addr) :
					new PureArrayUniform(id, activeInfo, addr));
				break;
			} else {
				// step into inner node / create it in case it doesn't exist
				const map = container.map;
				let next = map[id];
				if (next === undefined) {
					next = new StructuredUniform(id);
					addUniform(container, next);
				}
				container = next;
			}
		}
	}
	// Root Container
	class WebGLUniforms {
		constructor(gl, program) {
			this.seq = [];
			this.map = {};
			const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
			for (let i = 0; i < n; ++i) {
				const info = gl.getActiveUniform(program, i),
					addr = gl.getUniformLocation(program, info.name);
				parseUniform(info, addr, this);
			}
		}
		setValue(gl, name, value, textures) {
			const u = this.map[name];
			if (u !== undefined) u.setValue(gl, value, textures);
		}
		setOptional(gl, object, name) {
			const v = object[name];
			if (v !== undefined) this.setValue(gl, name, v);
		}
		static upload(gl, seq, values, textures) {
			for (let i = 0, n = seq.length; i !== n; ++i) {
				const u = seq[i],
					v = values[u.id];
				if (v.needsUpdate !== false) {
					// note: always updating when .needsUpdate is undefined
					u.setValue(gl, v.value, textures);
				}
			}
		}
		static seqWithValue(seq, values) {
			const r = [];
			for (let i = 0, n = seq.length; i !== n; ++i) {
				const u = seq[i];
				if (u.id in values) r.push(u);
			}
			return r;
		}
	}

	function WebGLShader(gl, type, string) {
		const shader = gl.createShader(type);
		gl.shaderSource(shader, string);
		gl.compileShader(shader);
		return shader;
	}
	let programIdCount = 0;

	function handleSource(string, errorLine) {
		const lines = string.split('\n');
		const lines2 = [];
		const from = Math.max(errorLine - 6, 0);
		const to = Math.min(errorLine + 6, lines.length);
		for (let i = from; i < to; i++) {
			const line = i + 1;
			lines2.push(`${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}`);
		}
		return lines2.join('\n');
	}

	function getEncodingComponents(encoding) {
		switch (encoding) {
			case LinearEncoding:
				return ['Linear', '( value )'];
			case sRGBEncoding:
				return ['sRGB', '( value )'];
			default:
				console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
				return ['Linear', '( value )'];
		}
	}

	function getShaderErrors(gl, shader, type) {
		const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
		const errors = gl.getShaderInfoLog(shader).trim();
		if (status && errors === '') return '';
		const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
		if (errorMatches) {
			// --enable-privileged-webgl-extension
			// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
			const errorLine = parseInt(errorMatches[1]);
			return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource(gl.getShaderSource(shader), errorLine);
		} else {
			return errors;
		}
	}

	function getTexelEncodingFunction(functionName, encoding) {
		const components = getEncodingComponents(encoding);
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
	}

	function getToneMappingFunction(functionName, toneMapping) {
		let toneMappingName;
		switch (toneMapping) {
			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;
			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;
			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;
			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;
			case CustomToneMapping:
				toneMappingName = 'Custom';
				break;
			default:
				console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
				toneMappingName = 'Linear';
		}
		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
	}

	function generateExtensions(parameters) {
		const chunks = [
			(parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical') ? '#extension GL_OES_standard_derivatives : enable' : '',
			(parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
			(parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers) ? '#extension GL_EXT_draw_buffers : require' : '',
			(parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		];
		return chunks.filter(filterEmptyLine).join('\n');
	}

	function generateDefines(defines) {
		const chunks = [];
		for (const name in defines) {
			const value = defines[name];
			if (value === false) continue;
			chunks.push('#define ' + name + ' ' + value);
		}
		return chunks.join('\n');
	}

	function fetchAttributeLocations(gl, program) {
		const attributes = {};
		const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
		for (let i = 0; i < n; i++) {
			const info = gl.getActiveAttrib(program, i);
			const name = info.name;
			let locationSize = 1;
			if (info.type === gl.FLOAT_MAT2) locationSize = 2;
			if (info.type === gl.FLOAT_MAT3) locationSize = 3;
			if (info.type === gl.FLOAT_MAT4) locationSize = 4;
			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
			attributes[name] = {
				type: info.type,
				location: gl.getAttribLocation(program, name),
				locationSize: locationSize
			};
		}
		return attributes;
	}

	function filterEmptyLine(string) {
		return string !== '';
	}

	function replaceLightNums(string, parameters) {
		const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
		return string
			.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)
			.replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)
			.replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps)
			.replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords)
			.replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights)
			.replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)
			.replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights)
			.replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows)
			.replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps)
			.replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows)
			.replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
	}

	function replaceClippingPlaneNums(string, parameters) {
		return string
			.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes)
			.replace(/UNION_CLIPPING_PLANES/g, (parameters.numClippingPlanes - parameters.numClipIntersection));
	}
	// Resolve Includes
	const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function resolveIncludes(string) {
		return string.replace(includePattern, includeReplacer);
	}

	function includeReplacer(match, include) {
		const string = ShaderChunk[include];
		if (string === undefined) {
			throw new Error('Can not resolve #include <' + include + '>');
		}
		return resolveIncludes(string);
	}
	// Unroll Loops
	const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function unrollLoops(string) {
		return string.replace(unrollLoopPattern, loopReplacer);
	}

	function loopReplacer(match, start, end, snippet) {
		let string = '';
		for (let i = parseInt(start); i < parseInt(end); i++) {
			string += snippet
				.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]')
				.replace(/UNROLLED_LOOP_INDEX/g, i);
		}
		return string;
	}
	//
	function generatePrecision(parameters) {
		let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';
		if (parameters.precision === 'highp') {
			precisionstring += '\n#define HIGH_PRECISION';
		} else if (parameters.precision === 'mediump') {
			precisionstring += '\n#define MEDIUM_PRECISION';
		} else if (parameters.precision === 'lowp') {
			precisionstring += '\n#define LOW_PRECISION';
		}
		return precisionstring;
	}

	function generateShadowMapTypeDefine(parameters) {
		let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
		if (parameters.shadowMapType === PCFShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
		} else if (parameters.shadowMapType === PCFSoftShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
		} else if (parameters.shadowMapType === VSMShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
		}
		return shadowMapTypeDefine;
	}

	function generateEnvMapTypeDefine(parameters) {
		let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		if (parameters.envMap) {
			switch (parameters.envMapMode) {
				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;
				case CubeUVReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;
			}
		}
		return envMapTypeDefine;
	}

	function generateEnvMapModeDefine(parameters) {
		let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		if (parameters.envMap) {
			switch (parameters.envMapMode) {
				case CubeRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;
			}
		}
		return envMapModeDefine;
	}

	function generateEnvMapBlendingDefine(parameters) {
		let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
		if (parameters.envMap) {
			switch (parameters.combine) {
				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;
				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;
				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;
			}
		}
		return envMapBlendingDefine;
	}

	function generateCubeUVSize(parameters) {
		const imageHeight = parameters.envMapCubeUVHeight;
		if (imageHeight === null) return null;
		const maxMip = Math.log2(imageHeight) - 2;
		const texelHeight = 1.0 / imageHeight;
		const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
		return {
			texelWidth,
			texelHeight,
			maxMip
		};
	}

	function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
		// TODO Send this event to Three.js DevTools
		// console.log( 'WebGLProgram', cacheKey );
		const gl = renderer.getContext();
		const defines = parameters.defines;
		let vertexShader = parameters.vertexShader;
		let fragmentShader = parameters.fragmentShader;
		const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
		const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
		const envMapModeDefine = generateEnvMapModeDefine(parameters);
		const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
		const envMapCubeUVSize = generateCubeUVSize(parameters);
		const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
		const customDefines = generateDefines(defines);
		const program = gl.createProgram();
		let prefixVertex, prefixFragment;
		let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';
		if (parameters.isRawShaderMaterial) {
			prefixVertex = [
				customDefines
			].filter(filterEmptyLine).join('\n');
			if (prefixVertex.length > 0) {
				prefixVertex += '\n';
			}
			prefixFragment = [
				customExtensions,
				customDefines
			].filter(filterEmptyLine).join('\n');
			if (prefixFragment.length > 0) {
				prefixFragment += '\n';
			}
		} else {
			prefixVertex = [
				generatePrecision(parameters),
				'#define SHADER_NAME ' + parameters.shaderName,
				customDefines,
				parameters.instancing ? '#define USE_INSTANCING' : '',
				parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
				(parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
				(parameters.useFog && parameters.fogExp2) ? '#define FOG_EXP2' : '',
				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				(parameters.normalMap && parameters.objectSpaceNormalMap) ? '#define OBJECTSPACE_NORMALMAP' : '',
				(parameters.normalMap && parameters.tangentSpaceNormalMap) ? '#define TANGENTSPACE_NORMALMAP' : '',
				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
				parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
				parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
				parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.transmission ? '#define USE_TRANSMISSION' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',
				parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
				parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',
				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUvs ? '#define USE_UV' : '',
				parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
				parameters.flatShading ? '#define FLAT_SHADED' : '',
				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				(parameters.morphColors && parameters.isWebGL2) ? '#define USE_MORPHCOLORS' : '',
				(parameters.morphTargetsCount > 0 && parameters.isWebGL2) ? '#define MORPHTARGETS_TEXTURE' : '',
				(parameters.morphTargetsCount > 0 && parameters.isWebGL2) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',
				(parameters.morphTargetsCount > 0 && parameters.isWebGL2) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',
				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				(parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth) ? '#define USE_LOGDEPTHBUF_EXT' : '',
				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',
				'#ifdef USE_INSTANCING',
				'	attribute mat4 instanceMatrix;',
				'#endif',
				'#ifdef USE_INSTANCING_COLOR',
				'	attribute vec3 instanceColor;',
				'#endif',
				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',
				'#ifdef USE_TANGENT',
				'	attribute vec4 tangent;',
				'#endif',
				'#if defined( USE_COLOR_ALPHA )',
				'	attribute vec4 color;',
				'#elif defined( USE_COLOR )',
				'	attribute vec3 color;',
				'#endif',
				'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',
				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',
				'	#ifdef USE_MORPHNORMALS',
				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',
				'	#else',
				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',
				'	#endif',
				'#endif',
				'#ifdef USE_SKINNING',
				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',
				'#endif',
				'\n'
			].filter(filterEmptyLine).join('\n');
			prefixFragment = [
				customExtensions,
				generatePrecision(parameters),
				'#define SHADER_NAME ' + parameters.shaderName,
				customDefines,
				(parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
				(parameters.useFog && parameters.fogExp2) ? '#define FOG_EXP2' : '',
				parameters.map ? '#define USE_MAP' : '',
				parameters.matcap ? '#define USE_MATCAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',
				envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',
				envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				(parameters.normalMap && parameters.objectSpaceNormalMap) ? '#define OBJECTSPACE_NORMALMAP' : '',
				(parameters.normalMap && parameters.tangentSpaceNormalMap) ? '#define TANGENTSPACE_NORMALMAP' : '',
				parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
				parameters.iridescence ? '#define USE_IRIDESCENCE' : '',
				parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
				parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
				parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.alphaTest ? '#define USE_ALPHATEST' : '',
				parameters.sheen ? '#define USE_SHEEN' : '',
				parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
				parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',
				parameters.transmission ? '#define USE_TRANSMISSION' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',
				parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUvs ? '#define USE_UV' : '',
				parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
				parameters.flatShading ? '#define FLAT_SHADED' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',
				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
				parameters.useLegacyLights ? '#define LEGACY_LIGHTS' : '',
				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				(parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth) ? '#define USE_LOGDEPTHBUF_EXT' : '',
				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',
				(parameters.toneMapping !== NoToneMapping) ? '#define TONE_MAPPING' : '',
				(parameters.toneMapping !== NoToneMapping) ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
				(parameters.toneMapping !== NoToneMapping) ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',
				parameters.dithering ? '#define DITHERING' : '',
				parameters.opaque ? '#define OPAQUE' : '',
				ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below
				getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding),
				parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',
				'\n'
			].filter(filterEmptyLine).join('\n');
		}
		vertexShader = resolveIncludes(vertexShader);
		vertexShader = replaceLightNums(vertexShader, parameters);
		vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
		fragmentShader = resolveIncludes(fragmentShader);
		fragmentShader = replaceLightNums(fragmentShader, parameters);
		fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
		vertexShader = unrollLoops(vertexShader);
		fragmentShader = unrollLoops(fragmentShader);
		if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
			// GLSL 3.0 conversion for built-in materials and ShaderMaterial
			versionString = '#version 300 es\n';
			prefixVertex = [
				'precision mediump sampler2DArray;',
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture'
			].join('\n') + '\n' + prefixVertex;
			prefixFragment = [
				'#define varying in',
				(parameters.glslVersion === GLSL3) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
				(parameters.glslVersion === GLSL3) ? '' : '#define gl_FragColor pc_fragColor',
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad'
			].join('\n') + '\n' + prefixFragment;
		}
		const vertexGlsl = versionString + prefixVertex + vertexShader;
		const fragmentGlsl = versionString + prefixFragment + fragmentShader;
		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );
		const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
		const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
		gl.attachShader(program, glVertexShader);
		gl.attachShader(program, glFragmentShader);
		// Force a particular attribute to index 0.
		if (parameters.index0AttributeName !== undefined) {
			gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
		} else if (parameters.morphTargets === true) {
			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation(program, 0, 'position');
		}
		gl.linkProgram(program);
		// check for link errors
		if (renderer.debug.checkShaderErrors) {
			const programLog = gl.getProgramInfoLog(program).trim();
			const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
			const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
			let runnable = true;
			let haveDiagnostics = true;
			if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
				runnable = false;
				const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
				const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
				console.error(
					'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
					'VALIDATE_STATUS ' + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + '\n\n' +
					'Program Info Log: ' + programLog + '\n' +
					vertexErrors + '\n' +
					fragmentErrors
				);
			} else if (programLog !== '') {
				console.warn('THREE.WebGLProgram: Program Info Log:', programLog);
			} else if (vertexLog === '' || fragmentLog === '') {
				haveDiagnostics = false;
			}
			if (haveDiagnostics) {
				this.diagnostics = {
					runnable: runnable,
					programLog: programLog,
					vertexShader: {
						log: vertexLog,
						prefix: prefixVertex
					},
					fragmentShader: {
						log: fragmentLog,
						prefix: prefixFragment
					}
				};
			}
		}
		// Clean up
		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );
		gl.deleteShader(glVertexShader);
		gl.deleteShader(glFragmentShader);
		// set up caching for uniform locations
		let cachedUniforms;
		this.getUniforms = function() {
			if (cachedUniforms === undefined) {
				cachedUniforms = new WebGLUniforms(gl, program);
			}
			return cachedUniforms;
		};
		// set up caching for attribute locations
		let cachedAttributes;
		this.getAttributes = function() {
			if (cachedAttributes === undefined) {
				cachedAttributes = fetchAttributeLocations(gl, program);
			}
			return cachedAttributes;
		};
		// free resource
		this.destroy = function() {
			bindingStates.releaseStatesOfProgram(this);
			gl.deleteProgram(program);
			this.program = undefined;
		};
		//
		this.name = parameters.shaderName;
		this.id = programIdCount++;
		this.cacheKey = cacheKey;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;
		return this;
	}
	let _id = 0;
	class WebGLShaderCache {
		constructor() {
			this.shaderCache = new Map();
			this.materialCache = new Map();
		}
		update(material) {
			const vertexShader = material.vertexShader;
			const fragmentShader = material.fragmentShader;
			const vertexShaderStage = this._getShaderStage(vertexShader);
			const fragmentShaderStage = this._getShaderStage(fragmentShader);
			const materialShaders = this._getShaderCacheForMaterial(material);
			if (materialShaders.has(vertexShaderStage) === false) {
				materialShaders.add(vertexShaderStage);
				vertexShaderStage.usedTimes++;
			}
			if (materialShaders.has(fragmentShaderStage) === false) {
				materialShaders.add(fragmentShaderStage);
				fragmentShaderStage.usedTimes++;
			}
			return this;
		}
		remove(material) {
			const materialShaders = this.materialCache.get(material);
			for (const shaderStage of materialShaders) {
				shaderStage.usedTimes--;
				if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);
			}
			this.materialCache.delete(material);
			return this;
		}
		getVertexShaderID(material) {
			return this._getShaderStage(material.vertexShader).id;
		}
		getFragmentShaderID(material) {
			return this._getShaderStage(material.fragmentShader).id;
		}
		dispose() {
			this.shaderCache.clear();
			this.materialCache.clear();
		}
		_getShaderCacheForMaterial(material) {
			const cache = this.materialCache;
			let set = cache.get(material);
			if (set === undefined) {
				set = new Set();
				cache.set(material, set);
			}
			return set;
		}
		_getShaderStage(code) {
			const cache = this.shaderCache;
			let stage = cache.get(code);
			if (stage === undefined) {
				stage = new WebGLShaderStage(code);
				cache.set(code, stage);
			}
			return stage;
		}
	}
	class WebGLShaderStage {
		constructor(code) {
			this.id = _id++;
			this.code = code;
			this.usedTimes = 0;
		}
	}

	function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
		const _programLayers = new Layers();
		const _customShaders = new WebGLShaderCache();
		const programs = [];
		const isWebGL2 = capabilities.isWebGL2;
		const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
		const vertexTextures = capabilities.vertexTextures;
		let precision = capabilities.precision;
		const shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};

		function getParameters(material, lights, shadows, scene, object) {
			const fog = scene.fog;
			const geometry = object.geometry;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
			const envMapCubeUVHeight = (!!envMap) && (envMap.mapping === CubeUVReflectionMapping) ? envMap.image.height : null;
			const shaderID = shaderIDs[material.type];
			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)
			if (material.precision !== null) {
				precision = capabilities.getMaxPrecision(material.precision);
				if (precision !== material.precision) {
					console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
				}
			}
			//
			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = (morphAttribute !== undefined) ? morphAttribute.length : 0;
			let morphTextureStride = 0;
			if (geometry.morphAttributes.position !== undefined) morphTextureStride = 1;
			if (geometry.morphAttributes.normal !== undefined) morphTextureStride = 2;
			if (geometry.morphAttributes.color !== undefined) morphTextureStride = 3;
			//
			let vertexShader, fragmentShader;
			let customVertexShaderID, customFragmentShaderID;
			if (shaderID) {
				const shader = ShaderLib[shaderID];
				vertexShader = shader.vertexShader;
				fragmentShader = shader.fragmentShader;
			} else {
				vertexShader = material.vertexShader;
				fragmentShader = material.fragmentShader;
				_customShaders.update(material);
				customVertexShaderID = _customShaders.getVertexShaderID(material);
				customFragmentShaderID = _customShaders.getFragmentShaderID(material);
			}
			const currentRenderTarget = renderer.getRenderTarget();
			const useAlphaTest = material.alphaTest > 0;
			const useClearcoat = material.clearcoat > 0;
			const useIridescence = material.iridescence > 0;
			const parameters = {
				isWebGL2: isWebGL2,
				shaderID: shaderID,
				shaderName: material.type,
				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,
				customVertexShaderID: customVertexShaderID,
				customFragmentShaderID: customFragmentShaderID,
				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,
				precision: precision,
				instancing: object.isInstancedMesh === true,
				instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
				supportsVertexTextures: vertexTextures,
				outputEncoding: (currentRenderTarget === null) ? renderer.outputEncoding : (currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding),
				map: !!material.map,
				matcap: !!material.matcap,
				envMap: !!envMap,
				envMapMode: envMap && envMap.mapping,
				envMapCubeUVHeight: envMapCubeUVHeight,
				lightMap: !!material.lightMap,
				aoMap: !!material.aoMap,
				emissiveMap: !!material.emissiveMap,
				bumpMap: !!material.bumpMap,
				normalMap: !!material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
				decodeVideoTexture: !!material.map && (material.map.isVideoTexture === true) && (material.map.encoding === sRGBEncoding),
				clearcoat: useClearcoat,
				clearcoatMap: useClearcoat && !!material.clearcoatMap,
				clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
				clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
				iridescence: useIridescence,
				iridescenceMap: useIridescence && !!material.iridescenceMap,
				iridescenceThicknessMap: useIridescence && !!material.iridescenceThicknessMap,
				displacementMap: !!material.displacementMap,
				roughnessMap: !!material.roughnessMap,
				metalnessMap: !!material.metalnessMap,
				specularMap: !!material.specularMap,
				specularIntensityMap: !!material.specularIntensityMap,
				specularColorMap: !!material.specularColorMap,
				opaque: material.transparent === false && material.blending === NormalBlending,
				alphaMap: !!material.alphaMap,
				alphaTest: useAlphaTest,
				gradientMap: !!material.gradientMap,
				sheen: material.sheen > 0,
				sheenColorMap: !!material.sheenColorMap,
				sheenRoughnessMap: !!material.sheenRoughnessMap,
				transmission: material.transmission > 0,
				transmissionMap: !!material.transmissionMap,
				thicknessMap: !!material.thicknessMap,
				combine: material.combine,
				vertexTangents: (!!material.normalMap && !!geometry.attributes.tangent),
				vertexColors: material.vertexColors,
				vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
				vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
				uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
				fog: !!fog,
				useFog: material.fog === true,
				fogExp2: (fog && fog.isFogExp2),
				flatShading: !!material.flatShading,
				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: logarithmicDepthBuffer,
				skinning: object.isSkinnedMesh === true,
				morphTargets: geometry.morphAttributes.position !== undefined,
				morphNormals: geometry.morphAttributes.normal !== undefined,
				morphColors: geometry.morphAttributes.color !== undefined,
				morphTargetsCount: morphTargetsCount,
				morphTextureStride: morphTextureStride,
				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numSpotLightMaps: lights.spotLightMap.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,
				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,
				numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,
				dithering: material.dithering,
				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,
				toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
				useLegacyLights: renderer.useLegacyLights,
				premultipliedAlpha: material.premultipliedAlpha,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,
				useDepthPacking: !!material.depthPacking,
				depthPacking: material.depthPacking || 0,
				index0AttributeName: material.index0AttributeName,
				extensionDerivatives: material.extensions && material.extensions.derivatives,
				extensionFragDepth: material.extensions && material.extensions.fragDepth,
				extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
				extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
				rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
				rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
				rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
				customProgramCacheKey: material.customProgramCacheKey()
			};
			return parameters;
		}

		function getProgramCacheKey(parameters) {
			const array = [];
			if (parameters.shaderID) {
				array.push(parameters.shaderID);
			} else {
				array.push(parameters.customVertexShaderID);
				array.push(parameters.customFragmentShaderID);
			}
			if (parameters.defines !== undefined) {
				for (const name in parameters.defines) {
					array.push(name);
					array.push(parameters.defines[name]);
				}
			}
			if (parameters.isRawShaderMaterial === false) {
				getProgramCacheKeyParameters(array, parameters);
				getProgramCacheKeyBooleans(array, parameters);
				array.push(renderer.outputEncoding);
			}
			array.push(parameters.customProgramCacheKey);
			return array.join();
		}

		function getProgramCacheKeyParameters(array, parameters) {
			array.push(parameters.precision);
			array.push(parameters.outputEncoding);
			array.push(parameters.envMapMode);
			array.push(parameters.envMapCubeUVHeight);
			array.push(parameters.combine);
			array.push(parameters.vertexUvs);
			array.push(parameters.fogExp2);
			array.push(parameters.sizeAttenuation);
			array.push(parameters.morphTargetsCount);
			array.push(parameters.morphAttributeCount);
			array.push(parameters.numDirLights);
			array.push(parameters.numPointLights);
			array.push(parameters.numSpotLights);
			array.push(parameters.numSpotLightMaps);
			array.push(parameters.numHemiLights);
			array.push(parameters.numRectAreaLights);
			array.push(parameters.numDirLightShadows);
			array.push(parameters.numPointLightShadows);
			array.push(parameters.numSpotLightShadows);
			array.push(parameters.numSpotLightShadowsWithMaps);
			array.push(parameters.shadowMapType);
			array.push(parameters.toneMapping);
			array.push(parameters.numClippingPlanes);
			array.push(parameters.numClipIntersection);
			array.push(parameters.depthPacking);
		}

		function getProgramCacheKeyBooleans(array, parameters) {
			_programLayers.disableAll();
			if (parameters.isWebGL2)
				_programLayers.enable(0);
			if (parameters.supportsVertexTextures)
				_programLayers.enable(1);
			if (parameters.instancing)
				_programLayers.enable(2);
			if (parameters.instancingColor)
				_programLayers.enable(3);
			if (parameters.map)
				_programLayers.enable(4);
			if (parameters.matcap)
				_programLayers.enable(5);
			if (parameters.envMap)
				_programLayers.enable(6);
			if (parameters.lightMap)
				_programLayers.enable(7);
			if (parameters.aoMap)
				_programLayers.enable(8);
			if (parameters.emissiveMap)
				_programLayers.enable(9);
			if (parameters.bumpMap)
				_programLayers.enable(10);
			if (parameters.normalMap)
				_programLayers.enable(11);
			if (parameters.objectSpaceNormalMap)
				_programLayers.enable(12);
			if (parameters.tangentSpaceNormalMap)
				_programLayers.enable(13);
			if (parameters.clearcoat)
				_programLayers.enable(14);
			if (parameters.clearcoatMap)
				_programLayers.enable(15);
			if (parameters.clearcoatRoughnessMap)
				_programLayers.enable(16);
			if (parameters.clearcoatNormalMap)
				_programLayers.enable(17);
			if (parameters.iridescence)
				_programLayers.enable(18);
			if (parameters.iridescenceMap)
				_programLayers.enable(19);
			if (parameters.iridescenceThicknessMap)
				_programLayers.enable(20);
			if (parameters.displacementMap)
				_programLayers.enable(21);
			if (parameters.specularMap)
				_programLayers.enable(22);
			if (parameters.roughnessMap)
				_programLayers.enable(23);
			if (parameters.metalnessMap)
				_programLayers.enable(24);
			if (parameters.gradientMap)
				_programLayers.enable(25);
			if (parameters.alphaMap)
				_programLayers.enable(26);
			if (parameters.alphaTest)
				_programLayers.enable(27);
			if (parameters.vertexColors)
				_programLayers.enable(28);
			if (parameters.vertexAlphas)
				_programLayers.enable(29);
			if (parameters.vertexUvs)
				_programLayers.enable(30);
			if (parameters.vertexTangents)
				_programLayers.enable(31);
			if (parameters.uvsVertexOnly)
				_programLayers.enable(32);
			array.push(_programLayers.mask);
			_programLayers.disableAll();
			if (parameters.fog)
				_programLayers.enable(0);
			if (parameters.useFog)
				_programLayers.enable(1);
			if (parameters.flatShading)
				_programLayers.enable(2);
			if (parameters.logarithmicDepthBuffer)
				_programLayers.enable(3);
			if (parameters.skinning)
				_programLayers.enable(4);
			if (parameters.morphTargets)
				_programLayers.enable(5);
			if (parameters.morphNormals)
				_programLayers.enable(6);
			if (parameters.morphColors)
				_programLayers.enable(7);
			if (parameters.premultipliedAlpha)
				_programLayers.enable(8);
			if (parameters.shadowMapEnabled)
				_programLayers.enable(9);
			if (parameters.useLegacyLights)
				_programLayers.enable(10);
			if (parameters.doubleSided)
				_programLayers.enable(11);
			if (parameters.flipSided)
				_programLayers.enable(12);
			if (parameters.useDepthPacking)
				_programLayers.enable(13);
			if (parameters.dithering)
				_programLayers.enable(14);
			if (parameters.specularIntensityMap)
				_programLayers.enable(15);
			if (parameters.specularColorMap)
				_programLayers.enable(16);
			if (parameters.transmission)
				_programLayers.enable(17);
			if (parameters.transmissionMap)
				_programLayers.enable(18);
			if (parameters.thicknessMap)
				_programLayers.enable(19);
			if (parameters.sheen)
				_programLayers.enable(20);
			if (parameters.sheenColorMap)
				_programLayers.enable(21);
			if (parameters.sheenRoughnessMap)
				_programLayers.enable(22);
			if (parameters.decodeVideoTexture)
				_programLayers.enable(23);
			if (parameters.opaque)
				_programLayers.enable(24);
			array.push(_programLayers.mask);
		}

		function getUniforms(material) {
			const shaderID = shaderIDs[material.type];
			let uniforms;
			if (shaderID) {
				const shader = ShaderLib[shaderID];
				uniforms = UniformsUtils.clone(shader.uniforms);
			} else {
				uniforms = material.uniforms;
			}
			return uniforms;
		}

		function acquireProgram(parameters, cacheKey) {
			let program;
			// Check if code has been already compiled
			for (let p = 0, pl = programs.length; p < pl; p++) {
				const preexistingProgram = programs[p];
				if (preexistingProgram.cacheKey === cacheKey) {
					program = preexistingProgram;
					++program.usedTimes;
					break;
				}
			}
			if (program === undefined) {
				program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
				programs.push(program);
			}
			return program;
		}

		function releaseProgram(program) {
			if (--program.usedTimes === 0) {
				// Remove from unordered set
				const i = programs.indexOf(program);
				programs[i] = programs[programs.length - 1];
				programs.pop();
				// Free WebGL resources
				program.destroy();
			}
		}

		function releaseShaderCache(material) {
			_customShaders.remove(material);
		}

		function dispose() {
			_customShaders.dispose();
		}
		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			releaseShaderCache: releaseShaderCache,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs,
			dispose: dispose
		};
	}

	function WebGLProperties() {
		let properties = new WeakMap();

		function get(object) {
			let map = properties.get(object);
			if (map === undefined) {
				map = {};
				properties.set(object, map);
			}
			return map;
		}

		function remove(object) {
			properties.delete(object);
		}

		function update(object, key, value) {
			properties.get(object)[key] = value;
		}

		function dispose() {
			properties = new WeakMap();
		}
		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};
	}

	function painterSortStable(a, b) {
		if (a.groupOrder !== b.groupOrder) {
			return a.groupOrder - b.groupOrder;
		} else if (a.renderOrder !== b.renderOrder) {
			return a.renderOrder - b.renderOrder;
		} else if (a.material.id !== b.material.id) {
			return a.material.id - b.material.id;
		} else if (a.z !== b.z) {
			return a.z - b.z;
		} else {
			return a.id - b.id;
		}
	}

	function reversePainterSortStable(a, b) {
		if (a.groupOrder !== b.groupOrder) {
			return a.groupOrder - b.groupOrder;
		} else if (a.renderOrder !== b.renderOrder) {
			return a.renderOrder - b.renderOrder;
		} else if (a.z !== b.z) {
			return b.z - a.z;
		} else {
			return a.id - b.id;
		}
	}

	function WebGLRenderList() {
		const renderItems = [];
		let renderItemsIndex = 0;
		const opaque = [];
		const transmissive = [];
		const transparent = [];

		function init() {
			renderItemsIndex = 0;
			opaque.length = 0;
			transmissive.length = 0;
			transparent.length = 0;
		}

		function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
			let renderItem = renderItems[renderItemsIndex];
			if (renderItem === undefined) {
				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};
				renderItems[renderItemsIndex] = renderItem;
			} else {
				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;
			}
			renderItemsIndex++;
			return renderItem;
		}

		function push(object, geometry, material, groupOrder, z, group) {
			const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
			if (material.transmission > 0.0) {
				transmissive.push(renderItem);
			} else if (material.transparent === true) {
				transparent.push(renderItem);
			} else {
				opaque.push(renderItem);
			}
		}

		function unshift(object, geometry, material, groupOrder, z, group) {
			const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
			if (material.transmission > 0.0) {
				transmissive.unshift(renderItem);
			} else if (material.transparent === true) {
				transparent.unshift(renderItem);
			} else {
				opaque.unshift(renderItem);
			}
		}

		function sort(customOpaqueSort, customTransparentSort) {
			if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
			if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
			if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
		}

		function finish() {
			// Clear references from inactive renderItems in the list
			for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
				const renderItem = renderItems[i];
				if (renderItem.id === null) break;
				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.group = null;
			}
		}
		return {
			opaque: opaque,
			transmissive: transmissive,
			transparent: transparent,
			init: init,
			push: push,
			unshift: unshift,
			finish: finish,
			sort: sort
		};
	}

	function WebGLRenderLists() {
		let lists = new WeakMap();

		function get(scene, renderCallDepth) {
			const listArray = lists.get(scene);
			let list;
			if (listArray === undefined) {
				list = new WebGLRenderList();
				lists.set(scene, [list]);
			} else {
				if (renderCallDepth >= listArray.length) {
					list = new WebGLRenderList();
					listArray.push(list);
				} else {
					list = listArray[renderCallDepth];
				}
			}
			return list;
		}

		function dispose() {
			lists = new WeakMap();
		}
		return {
			get: get,
			dispose: dispose
		};
	}

	function UniformsCache() {
		const lights = {};
		return {
			get: function(light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id];
				}
				let uniforms;
				switch (light.type) {
					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color()
						};
						break;
					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;
					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						};
						break;
					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;
					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						};
						break;
				}
				lights[light.id] = uniforms;
				return uniforms;
			}
		};
	}

	function ShadowUniformsCache() {
		const lights = {};
		return {
			get: function(light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id];
				}
				let uniforms;
				switch (light.type) {
					case 'DirectionalLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;
					case 'SpotLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;
					case 'PointLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;
						// TODO (abelnation): set RectAreaLight shadow uniforms
				}
				lights[light.id] = uniforms;
				return uniforms;
			}
		};
	}
	let nextVersion = 0;

	function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
		return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
	}

	function WebGLLights(extensions, capabilities) {
		const cache = new UniformsCache();
		const shadowCache = ShadowUniformsCache();
		const state = {
			version: 0,
			hash: {
				directionalLength: -1,
				pointLength: -1,
				spotLength: -1,
				rectAreaLength: -1,
				hemiLength: -1,
				numDirectionalShadows: -1,
				numPointShadows: -1,
				numSpotShadows: -1,
				numSpotMaps: -1
			},
			ambient: [0, 0, 0],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotLightMap: [],
			spotShadow: [],
			spotShadowMap: [],
			spotLightMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: [],
			numSpotLightShadowsWithMaps: 0
		};
		for (let i = 0; i < 9; i++) state.probe.push(new Vector3());
		const vector3 = new Vector3();
		const matrix4 = new Matrix4();
		const matrix42 = new Matrix4();

		function setup(lights, useLegacyLights) {
			let r = 0,
				g = 0,
				b = 0;
			for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);
			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;
			let numDirectionalShadows = 0;
			let numPointShadows = 0;
			let numSpotShadows = 0;
			let numSpotMaps = 0;
			let numSpotShadowsWithMaps = 0;
			// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
			lights.sort(shadowCastingAndTexturingLightsFirst);
			// artist-friendly light intensity scaling factor
			const scaleFactor = (useLegacyLights === true) ? Math.PI : 1;
			for (let i = 0, l = lights.length; i < l; i++) {
				const light = lights[i];
				const color = light.color;
				const intensity = light.intensity;
				const distance = light.distance;
				const shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null;
				if (light.isAmbientLight) {
					r += color.r * intensity * scaleFactor;
					g += color.g * intensity * scaleFactor;
					b += color.b * intensity * scaleFactor;
				} else if (light.isLightProbe) {
					for (let j = 0; j < 9; j++) {
						state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
					}
				} else if (light.isDirectionalLight) {
					const uniforms = cache.get(light);
					uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
					if (light.castShadow) {
						const shadow = light.shadow;
						const shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						state.directionalShadow[directionalLength] = shadowUniforms;
						state.directionalShadowMap[directionalLength] = shadowMap;
						state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
						numDirectionalShadows++;
					}
					state.directional[directionalLength] = uniforms;
					directionalLength++;
				} else if (light.isSpotLight) {
					const uniforms = cache.get(light);
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
					uniforms.distance = distance;
					uniforms.coneCos = Math.cos(light.angle);
					uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
					uniforms.decay = light.decay;
					state.spot[spotLength] = uniforms;
					const shadow = light.shadow;
					if (light.map) {
						state.spotLightMap[numSpotMaps] = light.map;
						numSpotMaps++;
						// make sure the lightMatrix is up to date
						// TODO : do it if required only
						shadow.updateMatrices(light);
						if (light.castShadow) numSpotShadowsWithMaps++;
					}
					state.spotLightMatrix[spotLength] = shadow.matrix;
					if (light.castShadow) {
						const shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						state.spotShadow[spotLength] = shadowUniforms;
						state.spotShadowMap[spotLength] = shadowMap;
						numSpotShadows++;
					}
					spotLength++;
				} else if (light.isRectAreaLight) {
					const uniforms = cache.get(light);
					uniforms.color.copy(color).multiplyScalar(intensity);
					uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
					uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
					state.rectArea[rectAreaLength] = uniforms;
					rectAreaLength++;
				} else if (light.isPointLight) {
					const uniforms = cache.get(light);
					uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;
					if (light.castShadow) {
						const shadow = light.shadow;
						const shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						shadowUniforms.shadowCameraNear = shadow.camera.near;
						shadowUniforms.shadowCameraFar = shadow.camera.far;
						state.pointShadow[pointLength] = shadowUniforms;
						state.pointShadowMap[pointLength] = shadowMap;
						state.pointShadowMatrix[pointLength] = light.shadow.matrix;
						numPointShadows++;
					}
					state.point[pointLength] = uniforms;
					pointLength++;
				} else if (light.isHemisphereLight) {
					const uniforms = cache.get(light);
					uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
					uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
					state.hemi[hemiLength] = uniforms;
					hemiLength++;
				}
			}
			if (rectAreaLength > 0) {
				if (capabilities.isWebGL2) {
					// WebGL 2
					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
				} else {
					// WebGL 1
					if (extensions.has('OES_texture_float_linear') === true) {
						state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
						state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
					} else if (extensions.has('OES_texture_half_float_linear') === true) {
						state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
						state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
					} else {
						console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
					}
				}
			}
			state.ambient[0] = r;
			state.ambient[1] = g;
			state.ambient[2] = b;
			const hash = state.hash;
			if (hash.directionalLength !== directionalLength ||
				hash.pointLength !== pointLength ||
				hash.spotLength !== spotLength ||
				hash.rectAreaLength !== rectAreaLength ||
				hash.hemiLength !== hemiLength ||
				hash.numDirectionalShadows !== numDirectionalShadows ||
				hash.numPointShadows !== numPointShadows ||
				hash.numSpotShadows !== numSpotShadows ||
				hash.numSpotMaps !== numSpotMaps) {
				state.directional.length = directionalLength;
				state.spot.length = spotLength;
				state.rectArea.length = rectAreaLength;
				state.point.length = pointLength;
				state.hemi.length = hemiLength;
				state.directionalShadow.length = numDirectionalShadows;
				state.directionalShadowMap.length = numDirectionalShadows;
				state.pointShadow.length = numPointShadows;
				state.pointShadowMap.length = numPointShadows;
				state.spotShadow.length = numSpotShadows;
				state.spotShadowMap.length = numSpotShadows;
				state.directionalShadowMatrix.length = numDirectionalShadows;
				state.pointShadowMatrix.length = numPointShadows;
				state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
				state.spotLightMap.length = numSpotMaps;
				state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
				hash.directionalLength = directionalLength;
				hash.pointLength = pointLength;
				hash.spotLength = spotLength;
				hash.rectAreaLength = rectAreaLength;
				hash.hemiLength = hemiLength;
				hash.numDirectionalShadows = numDirectionalShadows;
				hash.numPointShadows = numPointShadows;
				hash.numSpotShadows = numSpotShadows;
				hash.numSpotMaps = numSpotMaps;
				state.version = nextVersion++;
			}
		}

		function setupView(lights, camera) {
			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;
			const viewMatrix = camera.matrixWorldInverse;
			for (let i = 0, l = lights.length; i < l; i++) {
				const light = lights[i];
				if (light.isDirectionalLight) {
					const uniforms = state.directional[directionalLength];
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					vector3.setFromMatrixPosition(light.target.matrixWorld);
					uniforms.direction.sub(vector3);
					uniforms.direction.transformDirection(viewMatrix);
					directionalLength++;
				} else if (light.isSpotLight) {
					const uniforms = state.spot[spotLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix);
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					vector3.setFromMatrixPosition(light.target.matrixWorld);
					uniforms.direction.sub(vector3);
					uniforms.direction.transformDirection(viewMatrix);
					spotLength++;
				} else if (light.isRectAreaLight) {
					const uniforms = state.rectArea[rectAreaLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix);
					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy(light.matrixWorld);
					matrix4.premultiply(viewMatrix);
					matrix42.extractRotation(matrix4);
					uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
					uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
					uniforms.halfWidth.applyMatrix4(matrix42);
					uniforms.halfHeight.applyMatrix4(matrix42);
					rectAreaLength++;
				} else if (light.isPointLight) {
					const uniforms = state.point[pointLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix);
					pointLength++;
				} else if (light.isHemisphereLight) {
					const uniforms = state.hemi[hemiLength];
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					uniforms.direction.transformDirection(viewMatrix);
					hemiLength++;
				}
			}
		}
		return {
			setup: setup,
			setupView: setupView,
			state: state
		};
	}

	function WebGLRenderState(extensions, capabilities) {
		const lights = new WebGLLights(extensions, capabilities);
		const lightsArray = [];
		const shadowsArray = [];

		function init() {
			lightsArray.length = 0;
			shadowsArray.length = 0;
		}

		function pushLight(light) {
			lightsArray.push(light);
		}

		function pushShadow(shadowLight) {
			shadowsArray.push(shadowLight);
		}

		function setupLights(useLegacyLights) {
			lights.setup(lightsArray, useLegacyLights);
		}

		function setupLightsView(camera) {
			lights.setupView(lightsArray, camera);
		}
		const state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,
			lights: lights
		};
		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,
			pushLight: pushLight,
			pushShadow: pushShadow
		};
	}

	function WebGLRenderStates(extensions, capabilities) {
		let renderStates = new WeakMap();

		function get(scene, renderCallDepth = 0) {
			const renderStateArray = renderStates.get(scene);
			let renderState;
			if (renderStateArray === undefined) {
				renderState = new WebGLRenderState(extensions, capabilities);
				renderStates.set(scene, [renderState]);
			} else {
				if (renderCallDepth >= renderStateArray.length) {
					renderState = new WebGLRenderState(extensions, capabilities);
					renderStateArray.push(renderState);
				} else {
					renderState = renderStateArray[renderCallDepth];
				}
			}
			return renderState;
		}

		function dispose() {
			renderStates = new WeakMap();
		}
		return {
			get: get,
			dispose: dispose
		};
	}
	class MeshDepthMaterial extends Material {
		constructor(parameters) {
			super();
			this.isMeshDepthMaterial = true;
			this.type = 'MeshDepthMaterial';
			this.depthPacking = BasicDepthPacking;
			this.map = null;
			this.alphaMap = null;
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.setValues(parameters);
		}
		copy(source) {
			super.copy(source);
			this.depthPacking = source.depthPacking;
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			return this;
		}
	}
	class MeshDistanceMaterial extends Material {
		constructor(parameters) {
			super();
			this.isMeshDistanceMaterial = true;
			this.type = 'MeshDistanceMaterial';
			this.referencePosition = new Vector3();
			this.nearDistance = 1;
			this.farDistance = 1000;
			this.map = null;
			this.alphaMap = null;
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.setValues(parameters);
		}
		copy(source) {
			super.copy(source);
			this.referencePosition.copy(source.referencePosition);
			this.nearDistance = source.nearDistance;
			this.farDistance = source.farDistance;
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			return this;
		}
	}
	const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
	const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

	function WebGLShadowMap(_renderer, _objects, _capabilities) {
		let _frustum = new Frustum();
		const _shadowMapSize = new Vector2(),
			_viewportSize = new Vector2(),
			_viewport = new Vector4(),
			_depthMaterial = new MeshDepthMaterial({
				depthPacking: RGBADepthPacking
			}),
			_distanceMaterial = new MeshDistanceMaterial(),
			_materialCache = {},
			_maxTextureSize = _capabilities.maxTextureSize;
		const shadowSide = {
			[FrontSide]: BackSide,
			[BackSide]: FrontSide,
			[DoubleSide]: DoubleSide
		};
		const shadowMaterialVertical = new ShaderMaterial({
			defines: {
				VSM_SAMPLES: 8
			},
			uniforms: {
				shadow_pass: {
					value: null
				},
				resolution: {
					value: new Vector2()
				},
				radius: {
					value: 4.0
				}
			},
			vertexShader: vertex,
			fragmentShader: fragment
		});
		const shadowMaterialHorizontal = shadowMaterialVertical.clone();
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
		const fullScreenTri = new BufferGeometry();
		fullScreenTri.setAttribute(
			'position',
			new BufferAttribute(
				new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
				3
			)
		);
		const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
		const scope = this;
		this.enabled = false;
		this.autoUpdate = true;
		this.needsUpdate = false;
		this.type = PCFShadowMap;
		this.render = function(lights, scene, camera) {
			if (scope.enabled === false) return;
			if (scope.autoUpdate === false && scope.needsUpdate === false) return;
			if (lights.length === 0) return;
			const currentRenderTarget = _renderer.getRenderTarget();
			const activeCubeFace = _renderer.getActiveCubeFace();
			const activeMipmapLevel = _renderer.getActiveMipmapLevel();
			const _state = _renderer.state;
			// Set GL state for depth map.
			_state.setBlending(NoBlending);
			_state.buffers.color.setClear(1, 1, 1, 1);
			_state.buffers.depth.setTest(true);
			_state.setScissorTest(false);
			// render depth map
			for (let i = 0, il = lights.length; i < il; i++) {
				const light = lights[i];
				const shadow = light.shadow;
				if (shadow === undefined) {
					console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
					continue;
				}
				if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
				_shadowMapSize.copy(shadow.mapSize);
				const shadowFrameExtents = shadow.getFrameExtents();
				_shadowMapSize.multiply(shadowFrameExtents);
				_viewportSize.copy(shadow.mapSize);
				if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
					if (_shadowMapSize.x > _maxTextureSize) {
						_viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
						shadow.mapSize.x = _viewportSize.x;
					}
					if (_shadowMapSize.y > _maxTextureSize) {
						_viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
						shadow.mapSize.y = _viewportSize.y;
					}
				}
				if (shadow.map === null) {
					const pars = (this.type !== VSMShadowMap) ? {
						minFilter: NearestFilter,
						magFilter: NearestFilter
					} : {};
					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.map.texture.name = light.name + '.shadowMap';
					shadow.camera.updateProjectionMatrix();
				}
				_renderer.setRenderTarget(shadow.map);
				_renderer.clear();
				const viewportCount = shadow.getViewportCount();
				for (let vp = 0; vp < viewportCount; vp++) {
					const viewport = shadow.getViewport(vp);
					_viewport.set(
						_viewportSize.x * viewport.x,
						_viewportSize.y * viewport.y,
						_viewportSize.x * viewport.z,
						_viewportSize.y * viewport.w
					);
					_state.viewport(_viewport);
					shadow.updateMatrices(light, vp);
					_frustum = shadow.getFrustum();
					renderObject(scene, camera, shadow.camera, light, this.type);
				}
				// do blur pass for VSM
				if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
					VSMPass(shadow, camera);
				}
				shadow.needsUpdate = false;
			}
			scope.needsUpdate = false;
			_renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
		};

		function VSMPass(shadow, camera) {
			const geometry = _objects.update(fullScreenMesh);
			if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
				shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
				shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
				shadowMaterialVertical.needsUpdate = true;
				shadowMaterialHorizontal.needsUpdate = true;
			}
			if (shadow.mapPass === null) {
				shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
			}
			// vertical pass
			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialVertical.uniforms.radius.value = shadow.radius;
			_renderer.setRenderTarget(shadow.mapPass);
			_renderer.clear();
			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
			// horizontal pass
			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
			_renderer.setRenderTarget(shadow.map);
			_renderer.clear();
			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
		}

		function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
			let result = null;
			const customMaterial = (light.isPointLight === true) ? object.customDistanceMaterial : object.customDepthMaterial;
			if (customMaterial !== undefined) {
				result = customMaterial;
			} else {
				result = (light.isPointLight === true) ? _distanceMaterial : _depthMaterial;
				if ((_renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0) ||
					(material.displacementMap && material.displacementScale !== 0) ||
					(material.alphaMap && material.alphaTest > 0) ||
					(material.map && material.alphaTest > 0)) {
					// in this case we need a unique material instance reflecting the
					// appropriate state
					const keyA = result.uuid,
						keyB = material.uuid;
					let materialsForVariant = _materialCache[keyA];
					if (materialsForVariant === undefined) {
						materialsForVariant = {};
						_materialCache[keyA] = materialsForVariant;
					}
					let cachedMaterial = materialsForVariant[keyB];
					if (cachedMaterial === undefined) {
						cachedMaterial = result.clone();
						materialsForVariant[keyB] = cachedMaterial;
					}
					result = cachedMaterial;
				}
			}
			result.visible = material.visible;
			result.wireframe = material.wireframe;
			if (type === VSMShadowMap) {
				result.side = (material.shadowSide !== null) ? material.shadowSide : material.side;
			} else {
				result.side = (material.shadowSide !== null) ? material.shadowSide : shadowSide[material.side];
			}
			result.alphaMap = material.alphaMap;
			result.alphaTest = material.alphaTest;
			result.map = material.map;
			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;
			result.displacementMap = material.displacementMap;
			result.displacementScale = material.displacementScale;
			result.displacementBias = material.displacementBias;
			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;
			if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
				result.referencePosition.setFromMatrixPosition(light.matrixWorld);
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;
			}
			return result;
		}

		function renderObject(object, camera, shadowCamera, light, type) {
			if (object.visible === false) return;
			const visible = object.layers.test(camera.layers);
			if (visible && (object.isMesh || object.isLine || object.isPoints)) {
				if ((object.castShadow || (object.receiveShadow && type === VSMShadowMap)) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
					object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
					const geometry = _objects.update(object);
					const material = object.material;
					if (Array.isArray(material)) {
						const groups = geometry.groups;
						for (let k = 0, kl = groups.length; k < kl; k++) {
							const group = groups[k];
							const groupMaterial = material[group.materialIndex];
							if (groupMaterial && groupMaterial.visible) {
								const depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
								_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
							}
						}
					} else if (material.visible) {
						const depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);
						_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
					}
				}
			}
			const children = object.children;
			for (let i = 0, l = children.length; i < l; i++) {
				renderObject(children[i], camera, shadowCamera, light, type);
			}
		}
	}

	function WebGLState(gl, extensions, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;

		function ColorBuffer() {
			let locked = false;
			const color = new Vector4();
			let currentColorMask = null;
			const currentColorClear = new Vector4(0, 0, 0, 0);
			return {
				setMask: function(colorMask) {
					if (currentColorMask !== colorMask && !locked) {
						gl.colorMask(colorMask, colorMask, colorMask, colorMask);
						currentColorMask = colorMask;
					}
				},
				setLocked: function(lock) {
					locked = lock;
				},
				setClear: function(r, g, b, a, premultipliedAlpha) {
					if (premultipliedAlpha === true) {
						r *= a;
						g *= a;
						b *= a;
					}
					color.set(r, g, b, a);
					if (currentColorClear.equals(color) === false) {
						gl.clearColor(r, g, b, a);
						currentColorClear.copy(color);
					}
				},
				reset: function() {
					locked = false;
					currentColorMask = null;
					currentColorClear.set(-1, 0, 0, 0); // set to invalid state
				}
			};
		}

		function DepthBuffer() {
			let locked = false;
			let currentDepthMask = null;
			let currentDepthFunc = null;
			let currentDepthClear = null;
			return {
				setTest: function(depthTest) {
					if (depthTest) {
						enable(gl.DEPTH_TEST);
					} else {
						disable(gl.DEPTH_TEST);
					}
				},
				setMask: function(depthMask) {
					if (currentDepthMask !== depthMask && !locked) {
						gl.depthMask(depthMask);
						currentDepthMask = depthMask;
					}
				},
				setFunc: function(depthFunc) {
					if (currentDepthFunc !== depthFunc) {
						switch (depthFunc) {
							case NeverDepth:
								gl.depthFunc(gl.NEVER);
								break;
							case AlwaysDepth:
								gl.depthFunc(gl.ALWAYS);
								break;
							case LessDepth:
								gl.depthFunc(gl.LESS);
								break;
							case LessEqualDepth:
								gl.depthFunc(gl.LEQUAL);
								break;
							case EqualDepth:
								gl.depthFunc(gl.EQUAL);
								break;
							case GreaterEqualDepth:
								gl.depthFunc(gl.GEQUAL);
								break;
							case GreaterDepth:
								gl.depthFunc(gl.GREATER);
								break;
							case NotEqualDepth:
								gl.depthFunc(gl.NOTEQUAL);
								break;
							default:
								gl.depthFunc(gl.LEQUAL);
						}
						currentDepthFunc = depthFunc;
					}
				},
				setLocked: function(lock) {
					locked = lock;
				},
				setClear: function(depth) {
					if (currentDepthClear !== depth) {
						gl.clearDepth(depth);
						currentDepthClear = depth;
					}
				},
				reset: function() {
					locked = false;
					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;
				}
			};
		}

		function StencilBuffer() {
			let locked = false;
			let currentStencilMask = null;
			let currentStencilFunc = null;
			let currentStencilRef = null;
			let currentStencilFuncMask = null;
			let currentStencilFail = null;
			let currentStencilZFail = null;
			let currentStencilZPass = null;
			let currentStencilClear = null;
			return {
				setTest: function(stencilTest) {
					if (!locked) {
						if (stencilTest) {
							enable(gl.STENCIL_TEST);
						} else {
							disable(gl.STENCIL_TEST);
						}
					}
				},
				setMask: function(stencilMask) {
					if (currentStencilMask !== stencilMask && !locked) {
						gl.stencilMask(stencilMask);
						currentStencilMask = stencilMask;
					}
				},
				setFunc: function(stencilFunc, stencilRef, stencilMask) {
					if (currentStencilFunc !== stencilFunc ||
						currentStencilRef !== stencilRef ||
						currentStencilFuncMask !== stencilMask) {
						gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;
					}
				},
				setOp: function(stencilFail, stencilZFail, stencilZPass) {
					if (currentStencilFail !== stencilFail ||
						currentStencilZFail !== stencilZFail ||
						currentStencilZPass !== stencilZPass) {
						gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;
					}
				},
				setLocked: function(lock) {
					locked = lock;
				},
				setClear: function(stencil) {
					if (currentStencilClear !== stencil) {
						gl.clearStencil(stencil);
						currentStencilClear = stencil;
					}
				},
				reset: function() {
					locked = false;
					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;
				}
			};
		}
		//
		const colorBuffer = new ColorBuffer();
		const depthBuffer = new DepthBuffer();
		const stencilBuffer = new StencilBuffer();
		const uboBindings = new WeakMap();
		const uboProgramMap = new WeakMap();
		let enabledCapabilities = {};
		let currentBoundFramebuffers = {};
		let currentDrawbuffers = new WeakMap();
		let defaultDrawbuffers = [];
		let currentProgram = null;
		let currentBlendingEnabled = false;
		let currentBlending = null;
		let currentBlendEquation = null;
		let currentBlendSrc = null;
		let currentBlendDst = null;
		let currentBlendEquationAlpha = null;
		let currentBlendSrcAlpha = null;
		let currentBlendDstAlpha = null;
		let currentPremultipledAlpha = false;
		let currentFlipSided = null;
		let currentCullFace = null;
		let currentLineWidth = null;
		let currentPolygonOffsetFactor = null;
		let currentPolygonOffsetUnits = null;
		const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
		let lineWidthAvailable = false;
		let version = 0;
		const glVersion = gl.getParameter(gl.VERSION);
		if (glVersion.indexOf('WebGL') !== -1) {
			version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
			lineWidthAvailable = (version >= 1.0);
		} else if (glVersion.indexOf('OpenGL ES') !== -1) {
			version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
			lineWidthAvailable = (version >= 2.0);
		}
		let currentTextureSlot = null;
		let currentBoundTextures = {};
		const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
		const viewportParam = gl.getParameter(gl.VIEWPORT);
		const currentScissor = new Vector4().fromArray(scissorParam);
		const currentViewport = new Vector4().fromArray(viewportParam);

		function createTexture(type, target, count) {
			const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
			const texture = gl.createTexture();
			gl.bindTexture(type, texture);
			gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			for (let i = 0; i < count; i++) {
				gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
			}
			return texture;
		}
		const emptyTextures = {};
		emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
		emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
		// init
		colorBuffer.setClear(0, 0, 0, 1);
		depthBuffer.setClear(1);
		stencilBuffer.setClear(0);
		enable(gl.DEPTH_TEST);
		depthBuffer.setFunc(LessEqualDepth);
		setFlipSided(false);
		setCullFace(CullFaceBack);
		enable(gl.CULL_FACE);
		setBlending(NoBlending);
		//
		function enable(id) {
			if (enabledCapabilities[id] !== true) {
				gl.enable(id);
				enabledCapabilities[id] = true;
			}
		}

		function disable(id) {
			if (enabledCapabilities[id] !== false) {
				gl.disable(id);
				enabledCapabilities[id] = false;
			}
		}

		function bindFramebuffer(target, framebuffer) {
			if (currentBoundFramebuffers[target] !== framebuffer) {
				gl.bindFramebuffer(target, framebuffer);
				currentBoundFramebuffers[target] = framebuffer;
				if (isWebGL2) {
					// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER
					if (target === gl.DRAW_FRAMEBUFFER) {
						currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
					}
					if (target === gl.FRAMEBUFFER) {
						currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
					}
				}
				return true;
			}
			return false;
		}

		function drawBuffers(renderTarget, framebuffer) {
			let drawBuffers = defaultDrawbuffers;
			let needsUpdate = false;
			if (renderTarget) {
				drawBuffers = currentDrawbuffers.get(framebuffer);
				if (drawBuffers === undefined) {
					drawBuffers = [];
					currentDrawbuffers.set(framebuffer, drawBuffers);
				}
				if (renderTarget.isWebGLMultipleRenderTargets) {
					const textures = renderTarget.texture;
					if (drawBuffers.length !== textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {
						for (let i = 0, il = textures.length; i < il; i++) {
							drawBuffers[i] = gl.COLOR_ATTACHMENT0 + i;
						}
						drawBuffers.length = textures.length;
						needsUpdate = true;
					}
				} else {
					if (drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {
						drawBuffers[0] = gl.COLOR_ATTACHMENT0;
						needsUpdate = true;
					}
				}
			} else {
				if (drawBuffers[0] !== gl.BACK) {
					drawBuffers[0] = gl.BACK;
					needsUpdate = true;
				}
			}
			if (needsUpdate) {
				if (capabilities.isWebGL2) {
					gl.drawBuffers(drawBuffers);
				} else {
					extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(drawBuffers);
				}
			}
		}

		function useProgram(program) {
			if (currentProgram !== program) {
				gl.useProgram(program);
				currentProgram = program;
				return true;
			}
			return false;
		}
		const equationToGL = {
			[AddEquation]: gl.FUNC_ADD,
			[SubtractEquation]: gl.FUNC_SUBTRACT,
			[ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
		};
		if (isWebGL2) {
			equationToGL[MinEquation] = gl.MIN;
			equationToGL[MaxEquation] = gl.MAX;
		} else {
			const extension = extensions.get('EXT_blend_minmax');
			if (extension !== null) {
				equationToGL[MinEquation] = extension.MIN_EXT;
				equationToGL[MaxEquation] = extension.MAX_EXT;
			}
		}
		const factorToGL = {
			[ZeroFactor]: gl.ZERO,
			[OneFactor]: gl.ONE,
			[SrcColorFactor]: gl.SRC_COLOR,
			[SrcAlphaFactor]: gl.SRC_ALPHA,
			[SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
			[DstColorFactor]: gl.DST_COLOR,
			[DstAlphaFactor]: gl.DST_ALPHA,
			[OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
			[OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
			[OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
			[OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
		};

		function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
			if (blending === NoBlending) {
				if (currentBlendingEnabled === true) {
					disable(gl.BLEND);
					currentBlendingEnabled = false;
				}
				return;
			}
			if (currentBlendingEnabled === false) {
				enable(gl.BLEND);
				currentBlendingEnabled = true;
			}
			if (blending !== CustomBlending) {
				if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
					if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
						gl.blendEquation(gl.FUNC_ADD);
						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;
					}
					if (premultipliedAlpha) {
						switch (blending) {
							case NormalBlending:
								gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
								break;
							case AdditiveBlending:
								gl.blendFunc(gl.ONE, gl.ONE);
								break;
							case SubtractiveBlending:
								gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
								break;
							case MultiplyBlending:
								gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
								break;
							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending);
								break;
						}
					} else {
						switch (blending) {
							case NormalBlending:
								gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
								break;
							case AdditiveBlending:
								gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
								break;
							case SubtractiveBlending:
								gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
								break;
							case MultiplyBlending:
								gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
								break;
							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending);
								break;
						}
					}
					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;
					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;
				}
				return;
			}
			// custom blending
			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;
			if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
				gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;
			}
			if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
				gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;
			}
			currentBlending = blending;
			currentPremultipledAlpha = false;
		}

		function setMaterial(material, frontFaceCW) {
			material.side === DoubleSide ?
				disable(gl.CULL_FACE) :
				enable(gl.CULL_FACE);
			let flipSided = (material.side === BackSide);
			if (frontFaceCW) flipSided = !flipSided;
			setFlipSided(flipSided);
			(material.blending === NormalBlending && material.transparent === false) ?
			setBlending(NoBlending): setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
			depthBuffer.setFunc(material.depthFunc);
			depthBuffer.setTest(material.depthTest);
			depthBuffer.setMask(material.depthWrite);
			colorBuffer.setMask(material.colorWrite);
			const stencilWrite = material.stencilWrite;
			stencilBuffer.setTest(stencilWrite);
			if (stencilWrite) {
				stencilBuffer.setMask(material.stencilWriteMask);
				stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
				stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
			}
			setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
			material.alphaToCoverage === true ?
				enable(gl.SAMPLE_ALPHA_TO_COVERAGE) :
				disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
		}
		//
		function setFlipSided(flipSided) {
			if (currentFlipSided !== flipSided) {
				if (flipSided) {
					gl.frontFace(gl.CW);
				} else {
					gl.frontFace(gl.CCW);
				}
				currentFlipSided = flipSided;
			}
		}

		function setCullFace(cullFace) {
			if (cullFace !== CullFaceNone) {
				enable(gl.CULL_FACE);
				if (cullFace !== currentCullFace) {
					if (cullFace === CullFaceBack) {
						gl.cullFace(gl.BACK);
					} else if (cullFace === CullFaceFront) {
						gl.cullFace(gl.FRONT);
					} else {
						gl.cullFace(gl.FRONT_AND_BACK);
					}
				}
			} else {
				disable(gl.CULL_FACE);
			}
			currentCullFace = cullFace;
		}

		function setLineWidth(width) {
			if (width !== currentLineWidth) {
				if (lineWidthAvailable) gl.lineWidth(width);
				currentLineWidth = width;
			}
		}

		function setPolygonOffset(polygonOffset, factor, units) {
			if (polygonOffset) {
				enable(gl.POLYGON_OFFSET_FILL);
				if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
					gl.polygonOffset(factor, units);
					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;
				}
			} else {
				disable(gl.POLYGON_OFFSET_FILL);
			}
		}

		function setScissorTest(scissorTest) {
			if (scissorTest) {
				enable(gl.SCISSOR_TEST);
			} else {
				disable(gl.SCISSOR_TEST);
			}
		}
		// texture
		function activeTexture(webglSlot) {
			if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;
			if (currentTextureSlot !== webglSlot) {
				gl.activeTexture(webglSlot);
				currentTextureSlot = webglSlot;
			}
		}

		function bindTexture(webglType, webglTexture, webglSlot) {
			if (webglSlot === undefined) {
				if (currentTextureSlot === null) {
					webglSlot = gl.TEXTURE0 + maxTextures - 1;
				} else {
					webglSlot = currentTextureSlot;
				}
			}
			let boundTexture = currentBoundTextures[webglSlot];
			if (boundTexture === undefined) {
				boundTexture = {
					type: undefined,
					texture: undefined
				};
				currentBoundTextures[webglSlot] = boundTexture;
			}
			if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
				if (currentTextureSlot !== webglSlot) {
					gl.activeTexture(webglSlot);
					currentTextureSlot = webglSlot;
				}
				gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;
			}
		}

		function unbindTexture() {
			const boundTexture = currentBoundTextures[currentTextureSlot];
			if (boundTexture !== undefined && boundTexture.type !== undefined) {
				gl.bindTexture(boundTexture.type, null);
				boundTexture.type = undefined;
				boundTexture.texture = undefined;
			}
		}

		function compressedTexImage2D() {
			try {
				gl.compressedTexImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function compressedTexImage3D() {
			try {
				gl.compressedTexImage3D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texSubImage2D() {
			try {
				gl.texSubImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texSubImage3D() {
			try {
				gl.texSubImage3D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function compressedTexSubImage2D() {
			try {
				gl.compressedTexSubImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function compressedTexSubImage3D() {
			try {
				gl.compressedTexSubImage3D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texStorage2D() {
			try {
				gl.texStorage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texStorage3D() {
			try {
				gl.texStorage3D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texImage2D() {
			try {
				gl.texImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texImage3D() {
			try {
				gl.texImage3D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}
		//
		function scissor(scissor) {
			if (currentScissor.equals(scissor) === false) {
				gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
				currentScissor.copy(scissor);
			}
		}

		function viewport(viewport) {
			if (currentViewport.equals(viewport) === false) {
				gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
				currentViewport.copy(viewport);
			}
		}

		function updateUBOMapping(uniformsGroup, program) {
			let mapping = uboProgramMap.get(program);
			if (mapping === undefined) {
				mapping = new WeakMap();
				uboProgramMap.set(program, mapping);
			}
			let blockIndex = mapping.get(uniformsGroup);
			if (blockIndex === undefined) {
				blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
				mapping.set(uniformsGroup, blockIndex);
			}
		}

		function uniformBlockBinding(uniformsGroup, program) {
			const mapping = uboProgramMap.get(program);
			const blockIndex = mapping.get(uniformsGroup);
			if (uboBindings.get(program) !== blockIndex) {
				// bind shader specific block index to global block point
				gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
				uboBindings.set(program, blockIndex);
			}
		}
		//
		function reset() {
			// reset state
			gl.disable(gl.BLEND);
			gl.disable(gl.CULL_FACE);
			gl.disable(gl.DEPTH_TEST);
			gl.disable(gl.POLYGON_OFFSET_FILL);
			gl.disable(gl.SCISSOR_TEST);
			gl.disable(gl.STENCIL_TEST);
			gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
			gl.blendEquation(gl.FUNC_ADD);
			gl.blendFunc(gl.ONE, gl.ZERO);
			gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
			gl.colorMask(true, true, true, true);
			gl.clearColor(0, 0, 0, 0);
			gl.depthMask(true);
			gl.depthFunc(gl.LESS);
			gl.clearDepth(1);
			gl.stencilMask(0xffffffff);
			gl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);
			gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
			gl.clearStencil(0);
			gl.cullFace(gl.BACK);
			gl.frontFace(gl.CCW);
			gl.polygonOffset(0, 0);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			if (isWebGL2 === true) {
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
			}
			gl.useProgram(null);
			gl.lineWidth(1);
			gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
			// reset internals
			enabledCapabilities = {};
			currentTextureSlot = null;
			currentBoundTextures = {};
			currentBoundFramebuffers = {};
			currentDrawbuffers = new WeakMap();
			defaultDrawbuffers = [];
			currentProgram = null;
			currentBlendingEnabled = false;
			currentBlending = null;
			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;
			currentPremultipledAlpha = false;
			currentFlipSided = null;
			currentCullFace = null;
			currentLineWidth = null;
			currentPolygonOffsetFactor = null;
			currentPolygonOffsetUnits = null;
			currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
			currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();
		}
		return {
			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},
			enable: enable,
			disable: disable,
			bindFramebuffer: bindFramebuffer,
			drawBuffers: drawBuffers,
			useProgram: useProgram,
			setBlending: setBlending,
			setMaterial: setMaterial,
			setFlipSided: setFlipSided,
			setCullFace: setCullFace,
			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,
			setScissorTest: setScissorTest,
			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			compressedTexImage3D: compressedTexImage3D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,
			updateUBOMapping: updateUBOMapping,
			uniformBlockBinding: uniformBlockBinding,
			texStorage2D: texStorage2D,
			texStorage3D: texStorage3D,
			texSubImage2D: texSubImage2D,
			texSubImage3D: texSubImage3D,
			compressedTexSubImage2D: compressedTexSubImage2D,
			compressedTexSubImage3D: compressedTexSubImage3D,
			scissor: scissor,
			viewport: viewport,
			reset: reset
		};
	}

	function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
		const isWebGL2 = capabilities.isWebGL2;
		const maxTextures = capabilities.maxTextures;
		const maxCubemapSize = capabilities.maxCubemapSize;
		const maxTextureSize = capabilities.maxTextureSize;
		const maxSamples = capabilities.maxSamples;
		const multisampledRTTExt = extensions.has('WEBGL_multisampled_render_to_texture') ? extensions.get('WEBGL_multisampled_render_to_texture') : null;
		const supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test(navigator.userAgent);
		const _videoTextures = new WeakMap();
		let _canvas;
		const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source
		// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
		let useOffscreenCanvas = false;
		try {
			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
				// eslint-disable-next-line compat/compat
				&&
				(new OffscreenCanvas(1, 1).getContext('2d')) !== null;
		} catch (err) {
			// Ignore any errors
		}

		function createCanvas(width, height) {
			// Use OffscreenCanvas when available. Specially needed in web workers
			return useOffscreenCanvas ?
				// eslint-disable-next-line compat/compat
				new OffscreenCanvas(width, height) : createElementNS('canvas');
		}

		function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
			let scale = 1;
			// handle case if texture exceeds max size
			if (image.width > maxSize || image.height > maxSize) {
				scale = maxSize / Math.max(image.width, image.height);
			}
			// only perform resize if necessary
			if (scale < 1 || needsPowerOfTwo === true) {
				// only perform resize for certain image types
				if ((typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||
					(typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||
					(typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)) {
					const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
					const width = floor(scale * image.width);
					const height = floor(scale * image.height);
					if (_canvas === undefined) _canvas = createCanvas(width, height);
					// cube textures can't reuse the same canvas
					const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
					canvas.width = width;
					canvas.height = height;
					const context = canvas.getContext('2d');
					context.drawImage(image, 0, 0, width, height);
					console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
					return canvas;
				} else {
					if ('data' in image) {
						console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
					}
					return image;
				}
			}
			return image;
		}

		function isPowerOfTwo$1(image) {
			return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
		}

		function textureNeedsPowerOfTwo(texture) {
			if (isWebGL2) return false;
			return (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) ||
				(texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter);
		}

		function textureNeedsGenerateMipmaps(texture, supportsMips) {
			return texture.generateMipmaps && supportsMips &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
		}

		function generateMipmap(target) {
			_gl.generateMipmap(target);
		}

		function getInternalFormat(internalFormatName, glFormat, glType, encoding, forceLinearEncoding = false) {
			if (isWebGL2 === false) return glFormat;
			if (internalFormatName !== null) {
				if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
				console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
			}
			let internalFormat = glFormat;
			if (glFormat === _gl.RED) {
				if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
			}
			if (glFormat === _gl.RG) {
				if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;
			}
			if (glFormat === _gl.RGBA) {
				if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = (encoding === sRGBEncoding && forceLinearEncoding === false) ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
				if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;
				if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;
			}
			if (internalFormat === _gl.R16F || internalFormat === _gl.R32F ||
				internalFormat === _gl.RG16F || internalFormat === _gl.RG32F ||
				internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
				extensions.get('EXT_color_buffer_float');
			}
			return internalFormat;
		}

		function getMipLevels(texture, image, supportsMips) {
			if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || (texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter)) {
				return Math.log2(Math.max(image.width, image.height)) + 1;
			} else if (texture.mipmaps !== undefined && texture.mipmaps.length > 0) {
				// user-defined mipmaps
				return texture.mipmaps.length;
			} else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
				return image.mipmaps.length;
			} else {
				// texture without mipmaps (only base level)
				return 1;
			}
		}
		// Fallback filters for non-power-of-2 textures
		function filterFallback(f) {
			if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
				return _gl.NEAREST;
			}
			return _gl.LINEAR;
		}
		//
		function onTextureDispose(event) {
			const texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			deallocateTexture(texture);
			if (texture.isVideoTexture) {
				_videoTextures.delete(texture);
			}
		}

		function onRenderTargetDispose(event) {
			const renderTarget = event.target;
			renderTarget.removeEventListener('dispose', onRenderTargetDispose);
			deallocateRenderTarget(renderTarget);
		}
		//
		function deallocateTexture(texture) {
			const textureProperties = properties.get(texture);
			if (textureProperties.__webglInit === undefined) return;
			// check if it's necessary to remove the WebGLTexture object
			const source = texture.source;
			const webglTextures = _sources.get(source);
			if (webglTextures) {
				const webglTexture = webglTextures[textureProperties.__cacheKey];
				webglTexture.usedTimes--;
				// the WebGLTexture object is not used anymore, remove it
				if (webglTexture.usedTimes === 0) {
					deleteTexture(texture);
				}
				// remove the weak map entry if no WebGLTexture uses the source anymore
				if (Object.keys(webglTextures).length === 0) {
					_sources.delete(source);
				}
			}
			properties.remove(texture);
		}

		function deleteTexture(texture) {
			const textureProperties = properties.get(texture);
			_gl.deleteTexture(textureProperties.__webglTexture);
			const source = texture.source;
			const webglTextures = _sources.get(source);
			delete webglTextures[textureProperties.__cacheKey];
			info.memory.textures--;
		}

		function deallocateRenderTarget(renderTarget) {
			const texture = renderTarget.texture;
			const renderTargetProperties = properties.get(renderTarget);
			const textureProperties = properties.get(texture);
			if (textureProperties.__webglTexture !== undefined) {
				_gl.deleteTexture(textureProperties.__webglTexture);
				info.memory.textures--;
			}
			if (renderTarget.depthTexture) {
				renderTarget.depthTexture.dispose();
			}
			if (renderTarget.isWebGLCubeRenderTarget) {
				for (let i = 0; i < 6; i++) {
					_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
					if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
				}
			} else {
				_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
				if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
				if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
				if (renderTargetProperties.__webglColorRenderbuffer) {
					for (let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++) {
						if (renderTargetProperties.__webglColorRenderbuffer[i]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);
					}
				}
				if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
			}
			if (renderTarget.isWebGLMultipleRenderTargets) {
				for (let i = 0, il = texture.length; i < il; i++) {
					const attachmentProperties = properties.get(texture[i]);
					if (attachmentProperties.__webglTexture) {
						_gl.deleteTexture(attachmentProperties.__webglTexture);
						info.memory.textures--;
					}
					properties.remove(texture[i]);
				}
			}
			properties.remove(texture);
			properties.remove(renderTarget);
		}
		//
		let textureUnits = 0;

		function resetTextureUnits() {
			textureUnits = 0;
		}

		function allocateTextureUnit() {
			const textureUnit = textureUnits;
			if (textureUnit >= maxTextures) {
				console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
			}
			textureUnits += 1;
			return textureUnit;
		}

		function getTextureCacheKey(texture) {
			const array = [];
			array.push(texture.wrapS);
			array.push(texture.wrapT);
			array.push(texture.wrapR || 0);
			array.push(texture.magFilter);
			array.push(texture.minFilter);
			array.push(texture.anisotropy);
			array.push(texture.internalFormat);
			array.push(texture.format);
			array.push(texture.type);
			array.push(texture.generateMipmaps);
			array.push(texture.premultiplyAlpha);
			array.push(texture.flipY);
			array.push(texture.unpackAlignment);
			array.push(texture.encoding);
			return array.join();
		}
		//
		function setTexture2D(texture, slot) {
			const textureProperties = properties.get(texture);
			if (texture.isVideoTexture) updateVideoTexture(texture);
			if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
				const image = texture.image;
				if (image === null) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but no image data found.');
				} else if (image.complete === false) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
				} else {
					uploadTexture(textureProperties, texture, slot);
					return;
				}
			}
			state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
		}

		function setTexture2DArray(texture, slot) {
			const textureProperties = properties.get(texture);
			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot);
				return;
			}
			state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
		}

		function setTexture3D(texture, slot) {
			const textureProperties = properties.get(texture);
			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot);
				return;
			}
			state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
		}

		function setTextureCube(texture, slot) {
			const textureProperties = properties.get(texture);
			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadCubeTexture(textureProperties, texture, slot);
				return;
			}
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
		}
		const wrappingToGL = {
			[RepeatWrapping]: _gl.REPEAT,
			[ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
			[MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
		};
		const filterToGL = {
			[NearestFilter]: _gl.NEAREST,
			[NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
			[NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
			[LinearFilter]: _gl.LINEAR,
			[LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
			[LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
		};

		function setTextureParameters(textureType, texture, supportsMips) {
			if (supportsMips) {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
				if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
					_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
				}
				_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
				_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
			} else {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
				if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
					_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
				}
				if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
				}
				_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
				_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
				if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
				}
			}
			if (extensions.has('EXT_texture_filter_anisotropic') === true) {
				const extension = extensions.get('EXT_texture_filter_anisotropic');
				if (texture.magFilter === NearestFilter) return;
				if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;
				if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2
				if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false)) return; // verify extension for WebGL 1 only
				if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
					_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
					properties.get(texture).__currentAnisotropy = texture.anisotropy;
				}
			}
		}

		function initTexture(textureProperties, texture) {
			let forceUpload = false;
			if (textureProperties.__webglInit === undefined) {
				textureProperties.__webglInit = true;
				texture.addEventListener('dispose', onTextureDispose);
			}
			// create Source <-> WebGLTextures mapping if necessary
			const source = texture.source;
			let webglTextures = _sources.get(source);
			if (webglTextures === undefined) {
				webglTextures = {};
				_sources.set(source, webglTextures);
			}
			// check if there is already a WebGLTexture object for the given texture parameters
			const textureCacheKey = getTextureCacheKey(texture);
			if (textureCacheKey !== textureProperties.__cacheKey) {
				// if not, create a new instance of WebGLTexture
				if (webglTextures[textureCacheKey] === undefined) {
					// create new entry
					webglTextures[textureCacheKey] = {
						texture: _gl.createTexture(),
						usedTimes: 0
					};
					info.memory.textures++;
					// when a new instance of WebGLTexture was created, a texture upload is required
					// even if the image contents are identical
					forceUpload = true;
				}
				webglTextures[textureCacheKey].usedTimes++;
				// every time the texture cache key changes, it's necessary to check if an instance of
				// WebGLTexture can be deleted in order to avoid a memory leak.
				const webglTexture = webglTextures[textureProperties.__cacheKey];
				if (webglTexture !== undefined) {
					webglTextures[textureProperties.__cacheKey].usedTimes--;
					if (webglTexture.usedTimes === 0) {
						deleteTexture(texture);
					}
				}
				// store references to cache key and WebGLTexture object
				textureProperties.__cacheKey = textureCacheKey;
				textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
			}
			return forceUpload;
		}

		function uploadTexture(textureProperties, texture, slot) {
			let textureType = _gl.TEXTURE_2D;
			if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;
			if (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;
			const forceUpload = initTexture(textureProperties, texture);
			const source = texture.source;
			state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
			const sourceProperties = properties.get(source);
			if (source.version !== sourceProperties.__version || forceUpload === true) {
				state.activeTexture(_gl.TEXTURE0 + slot);
				_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
				_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
				_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
				_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
				const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
				let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
				image = verifyColorSpace(texture, image);
				const supportsMips = isPowerOfTwo$1(image) || isWebGL2,
					glFormat = utils.convert(texture.format, texture.encoding);
				let glType = utils.convert(texture.type),
					glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);
				setTextureParameters(textureType, texture, supportsMips);
				let mipmap;
				const mipmaps = texture.mipmaps;
				const useTexStorage = (isWebGL2 && texture.isVideoTexture !== true);
				const allocateMemory = (sourceProperties.__version === undefined) || (forceUpload === true);
				const levels = getMipLevels(texture, image, supportsMips);
				if (texture.isDepthTexture) {
					// populate depth texture with dummy data
					glInternalFormat = _gl.DEPTH_COMPONENT;
					if (isWebGL2) {
						if (texture.type === FloatType) {
							glInternalFormat = _gl.DEPTH_COMPONENT32F;
						} else if (texture.type === UnsignedIntType) {
							glInternalFormat = _gl.DEPTH_COMPONENT24;
						} else if (texture.type === UnsignedInt248Type) {
							glInternalFormat = _gl.DEPTH24_STENCIL8;
						} else {
							glInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D
						}
					} else {
						if (texture.type === FloatType) {
							console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
						}
					}
					// validation checks for WebGL 1
					if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
							console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
							texture.type = UnsignedIntType;
							glType = utils.convert(texture.type);
						}
					}
					if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
						// Depth stencil textures need the DEPTH_STENCIL internal format
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						glInternalFormat = _gl.DEPTH_STENCIL;
						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if (texture.type !== UnsignedInt248Type) {
							console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
							texture.type = UnsignedInt248Type;
							glType = utils.convert(texture.type);
						}
					}
					//
					if (allocateMemory) {
						if (useTexStorage) {
							state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
						} else {
							state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
						}
					}
				} else if (texture.isDataTexture) {
					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels
					if (mipmaps.length > 0 && supportsMips) {
						if (useTexStorage && allocateMemory) {
							state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
						}
						for (let i = 0, il = mipmaps.length; i < il; i++) {
							mipmap = mipmaps[i];
							if (useTexStorage) {
								state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
							} else {
								state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
							}
						}
						texture.generateMipmaps = false;
					} else {
						if (useTexStorage) {
							if (allocateMemory) {
								state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
							}
							state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
						} else {
							state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
						}
					}
				} else if (texture.isCompressedTexture) {
					if (texture.isCompressedArrayTexture) {
						if (useTexStorage && allocateMemory) {
							state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
						}
						for (let i = 0, il = mipmaps.length; i < il; i++) {
							mipmap = mipmaps[i];
							if (texture.format !== RGBAFormat) {
								if (glFormat !== null) {
									if (useTexStorage) {
										state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0);
									} else {
										state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
									}
								} else {
									console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
								}
							} else {
								if (useTexStorage) {
									state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
								} else {
									state.texImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
								}
							}
						}
					} else {
						if (useTexStorage && allocateMemory) {
							state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
						}
						for (let i = 0, il = mipmaps.length; i < il; i++) {
							mipmap = mipmaps[i];
							if (texture.format !== RGBAFormat) {
								if (glFormat !== null) {
									if (useTexStorage) {
										state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
									} else {
										state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
									}
								} else {
									console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
								}
							} else {
								if (useTexStorage) {
									state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
								} else {
									state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
								}
							}
						}
					}
				} else if (texture.isDataArrayTexture) {
					if (useTexStorage) {
						if (allocateMemory) {
							state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
						}
						state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
					} else {
						state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
					}
				} else if (texture.isData3DTexture) {
					if (useTexStorage) {
						if (allocateMemory) {
							state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
						}
						state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
					} else {
						state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
					}
				} else if (texture.isFramebufferTexture) {
					if (allocateMemory) {
						if (useTexStorage) {
							state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
						} else {
							let width = image.width,
								height = image.height;
							for (let i = 0; i < levels; i++) {
								state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null);
								width >>= 1;
								height >>= 1;
							}
						}
					}
				} else {
					// regular Texture (image, video, canvas)
					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels
					if (mipmaps.length > 0 && supportsMips) {
						if (useTexStorage && allocateMemory) {
							state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
						}
						for (let i = 0, il = mipmaps.length; i < il; i++) {
							mipmap = mipmaps[i];
							if (useTexStorage) {
								state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap);
							} else {
								state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
							}
						}
						texture.generateMipmaps = false;
					} else {
						if (useTexStorage) {
							if (allocateMemory) {
								state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
							}
							state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
						} else {
							state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
						}
					}
				}
				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					generateMipmap(textureType);
				}
				sourceProperties.__version = source.version;
				if (texture.onUpdate) texture.onUpdate(texture);
			}
			textureProperties.__version = texture.version;
		}

		function uploadCubeTexture(textureProperties, texture, slot) {
			if (texture.image.length !== 6) return;
			const forceUpload = initTexture(textureProperties, texture);
			const source = texture.source;
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
			const sourceProperties = properties.get(source);
			if (source.version !== sourceProperties.__version || forceUpload === true) {
				state.activeTexture(_gl.TEXTURE0 + slot);
				_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
				_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
				_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
				_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
				const isCompressed = (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
				const isDataTexture = (texture.image[0] && texture.image[0].isDataTexture);
				const cubeImage = [];
				for (let i = 0; i < 6; i++) {
					if (!isCompressed && !isDataTexture) {
						cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
					} else {
						cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
					}
					cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
				}
				const image = cubeImage[0],
					supportsMips = isPowerOfTwo$1(image) || isWebGL2,
					glFormat = utils.convert(texture.format, texture.encoding),
					glType = utils.convert(texture.type),
					glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
				const useTexStorage = (isWebGL2 && texture.isVideoTexture !== true);
				const allocateMemory = (sourceProperties.__version === undefined) || (forceUpload === true);
				let levels = getMipLevels(texture, image, supportsMips);
				setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
				let mipmaps;
				if (isCompressed) {
					if (useTexStorage && allocateMemory) {
						state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
					}
					for (let i = 0; i < 6; i++) {
						mipmaps = cubeImage[i].mipmaps;
						for (let j = 0; j < mipmaps.length; j++) {
							const mipmap = mipmaps[j];
							if (texture.format !== RGBAFormat) {
								if (glFormat !== null) {
									if (useTexStorage) {
										state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
									} else {
										state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
									}
								} else {
									console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
								}
							} else {
								if (useTexStorage) {
									state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
								} else {
									state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
								}
							}
						}
					}
				} else {
					mipmaps = texture.mipmaps;
					if (useTexStorage && allocateMemory) {
						// TODO: Uniformly handle mipmap definitions
						// Normal textures and compressed cube textures define base level + mips with their mipmap array
						// Uncompressed cube textures use their mipmap array only for mips (no base level)
						if (mipmaps.length > 0) levels++;
						state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
					}
					for (let i = 0; i < 6; i++) {
						if (isDataTexture) {
							if (useTexStorage) {
								state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);
							} else {
								state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
							}
							for (let j = 0; j < mipmaps.length; j++) {
								const mipmap = mipmaps[j];
								const mipmapImage = mipmap.image[i].image;
								if (useTexStorage) {
									state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
								} else {
									state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
								}
							}
						} else {
							if (useTexStorage) {
								state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[i]);
							} else {
								state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
							}
							for (let j = 0; j < mipmaps.length; j++) {
								const mipmap = mipmaps[j];
								if (useTexStorage) {
									state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);
								} else {
									state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
								}
							}
						}
					}
				}
				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					// We assume images for cube map have the same size.
					generateMipmap(_gl.TEXTURE_CUBE_MAP);
				}
				sourceProperties.__version = source.version;
				if (texture.onUpdate) texture.onUpdate(texture);
			}
			textureProperties.__version = texture.version;
		}
		// Render targets
		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
			const glFormat = utils.convert(texture.format, texture.encoding);
			const glType = utils.convert(texture.type);
			const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
			const renderTargetProperties = properties.get(renderTarget);
			if (!renderTargetProperties.__hasExternalTextures) {
				if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
					state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
				} else {
					state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
				}
			}
			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
			if (useMultisampledRTT(renderTarget)) {
				multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
			} else if (textureTarget === _gl.TEXTURE_2D || (textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z)) { // see #24753
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
			}
			state.bindFramebuffer(_gl.FRAMEBUFFER, null);
		}
		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
			_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
			if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
				let glInternalFormat = _gl.DEPTH_COMPONENT16;
				if (isMultisample || useMultisampledRTT(renderTarget)) {
					const depthTexture = renderTarget.depthTexture;
					if (depthTexture && depthTexture.isDepthTexture) {
						if (depthTexture.type === FloatType) {
							glInternalFormat = _gl.DEPTH_COMPONENT32F;
						} else if (depthTexture.type === UnsignedIntType) {
							glInternalFormat = _gl.DEPTH_COMPONENT24;
						}
					}
					const samples = getRenderTargetSamples(renderTarget);
					if (useMultisampledRTT(renderTarget)) {
						multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
					} else {
						_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
					}
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
				}
				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
			} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
				const samples = getRenderTargetSamples(renderTarget);
				if (isMultisample && useMultisampledRTT(renderTarget) === false) {
					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
				} else if (useMultisampledRTT(renderTarget)) {
					multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
				}
				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
			} else {
				const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
				for (let i = 0; i < textures.length; i++) {
					const texture = textures[i];
					const glFormat = utils.convert(texture.format, texture.encoding);
					const glType = utils.convert(texture.type);
					const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
					const samples = getRenderTargetSamples(renderTarget);
					if (isMultisample && useMultisampledRTT(renderTarget) === false) {
						_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
					} else if (useMultisampledRTT(renderTarget)) {
						multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
					} else {
						_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
					}
				}
			}
			_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
		}
		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture(framebuffer, renderTarget) {
			const isCube = (renderTarget && renderTarget.isWebGLCubeRenderTarget);
			if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
			if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
				throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
			}
			// upload an empty depth texture with framebuffer size
			if (!properties.get(renderTarget.depthTexture).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height) {
				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;
			}
			setTexture2D(renderTarget.depthTexture, 0);
			const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
			const samples = getRenderTargetSamples(renderTarget);
			if (renderTarget.depthTexture.format === DepthFormat) {
				if (useMultisampledRTT(renderTarget)) {
					multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
				} else {
					_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
				}
			} else if (renderTarget.depthTexture.format === DepthStencilFormat) {
				if (useMultisampledRTT(renderTarget)) {
					multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
				} else {
					_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
				}
			} else {
				throw new Error('Unknown depthTexture format');
			}
		}
		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer(renderTarget) {
			const renderTargetProperties = properties.get(renderTarget);
			const isCube = (renderTarget.isWebGLCubeRenderTarget === true);
			if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
				if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
				setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
			} else {
				if (isCube) {
					renderTargetProperties.__webglDepthbuffer = [];
					for (let i = 0; i < 6; i++) {
						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
						renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
						setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
					}
				} else {
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
				}
			}
			state.bindFramebuffer(_gl.FRAMEBUFFER, null);
		}
		// rebind framebuffer with external textures
		function rebindTextures(renderTarget, colorTexture, depthTexture) {
			const renderTargetProperties = properties.get(renderTarget);
			if (colorTexture !== undefined) {
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
			}
			if (depthTexture !== undefined) {
				setupDepthRenderbuffer(renderTarget);
			}
		}
		// Set up GL resources for the render target
		function setupRenderTarget(renderTarget) {
			const texture = renderTarget.texture;
			const renderTargetProperties = properties.get(renderTarget);
			const textureProperties = properties.get(texture);
			renderTarget.addEventListener('dispose', onRenderTargetDispose);
			if (renderTarget.isWebGLMultipleRenderTargets !== true) {
				if (textureProperties.__webglTexture === undefined) {
					textureProperties.__webglTexture = _gl.createTexture();
				}
				textureProperties.__version = texture.version;
				info.memory.textures++;
			}
			const isCube = (renderTarget.isWebGLCubeRenderTarget === true);
			const isMultipleRenderTargets = (renderTarget.isWebGLMultipleRenderTargets === true);
			const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
			// Setup framebuffer
			if (isCube) {
				renderTargetProperties.__webglFramebuffer = [];
				for (let i = 0; i < 6; i++) {
					renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
				}
			} else {
				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
				if (isMultipleRenderTargets) {
					if (capabilities.drawBuffers) {
						const textures = renderTarget.texture;
						for (let i = 0, il = textures.length; i < il; i++) {
							const attachmentProperties = properties.get(textures[i]);
							if (attachmentProperties.__webglTexture === undefined) {
								attachmentProperties.__webglTexture = _gl.createTexture();
								info.memory.textures++;
							}
						}
					} else {
						console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');
					}
				}
				if ((isWebGL2 && renderTarget.samples > 0) && useMultisampledRTT(renderTarget) === false) {
					const textures = isMultipleRenderTargets ? texture : [texture];
					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					renderTargetProperties.__webglColorRenderbuffer = [];
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
					for (let i = 0; i < textures.length; i++) {
						const texture = textures[i];
						renderTargetProperties.__webglColorRenderbuffer[i] = _gl.createRenderbuffer();
						_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
						const glFormat = utils.convert(texture.format, texture.encoding);
						const glType = utils.convert(texture.type);
						const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, renderTarget.isXRRenderTarget === true);
						const samples = getRenderTargetSamples(renderTarget);
						_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
						_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
					}
					_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
					if (renderTarget.depthBuffer) {
						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
					}
					state.bindFramebuffer(_gl.FRAMEBUFFER, null);
				}
			}
			// Setup color buffer
			if (isCube) {
				state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
				setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
				for (let i = 0; i < 6; i++) {
					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
				}
				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					generateMipmap(_gl.TEXTURE_CUBE_MAP);
				}
				state.unbindTexture();
			} else if (isMultipleRenderTargets) {
				const textures = renderTarget.texture;
				for (let i = 0, il = textures.length; i < il; i++) {
					const attachment = textures[i];
					const attachmentProperties = properties.get(attachment);
					state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
					setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D);
					if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
						generateMipmap(_gl.TEXTURE_2D);
					}
				}
				state.unbindTexture();
			} else {
				let glTextureType = _gl.TEXTURE_2D;
				if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
					if (isWebGL2) {
						glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
					} else {
						console.error('THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.');
					}
				}
				state.bindTexture(glTextureType, textureProperties.__webglTexture);
				setTextureParameters(glTextureType, texture, supportsMips);
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);
				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					generateMipmap(glTextureType);
				}
				state.unbindTexture();
			}
			// Setup depth and stencil buffers
			if (renderTarget.depthBuffer) {
				setupDepthRenderbuffer(renderTarget);
			}
		}

		function updateRenderTargetMipmap(renderTarget) {
			const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
			const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
			for (let i = 0, il = textures.length; i < il; i++) {
				const texture = textures[i];
				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
					const webglTexture = properties.get(texture).__webglTexture;
					state.bindTexture(target, webglTexture);
					generateMipmap(target);
					state.unbindTexture();
				}
			}
		}

		function updateMultisampleRenderTarget(renderTarget) {
			if ((isWebGL2 && renderTarget.samples > 0) && useMultisampledRTT(renderTarget) === false) {
				const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [renderTarget.texture];
				const width = renderTarget.width;
				const height = renderTarget.height;
				let mask = _gl.COLOR_BUFFER_BIT;
				const invalidationArray = [];
				const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
				const renderTargetProperties = properties.get(renderTarget);
				const isMultipleRenderTargets = (renderTarget.isWebGLMultipleRenderTargets === true);
				// If MRT we need to remove FBO attachments
				if (isMultipleRenderTargets) {
					for (let i = 0; i < textures.length; i++) {
						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
						_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null);
						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
						_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0);
					}
				}
				state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
				state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
				for (let i = 0; i < textures.length; i++) {
					invalidationArray.push(_gl.COLOR_ATTACHMENT0 + i);
					if (renderTarget.depthBuffer) {
						invalidationArray.push(depthStyle);
					}
					const ignoreDepthValues = (renderTargetProperties.__ignoreDepthValues !== undefined) ? renderTargetProperties.__ignoreDepthValues : false;
					if (ignoreDepthValues === false) {
						if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
						if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
					}
					if (isMultipleRenderTargets) {
						_gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
					}
					if (ignoreDepthValues === true) {
						_gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, [depthStyle]);
						_gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
					}
					if (isMultipleRenderTargets) {
						const webglTexture = properties.get(textures[i]).__webglTexture;
						_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
					}
					_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
					if (supportsInvalidateFramebuffer) {
						_gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArray);
					}
				}
				state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
				state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
				// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
				if (isMultipleRenderTargets) {
					for (let i = 0; i < textures.length; i++) {
						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
						_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
						const webglTexture = properties.get(textures[i]).__webglTexture;
						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
						_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0);
					}
				}
				state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
			}
		}

		function getRenderTargetSamples(renderTarget) {
			return Math.min(maxSamples, renderTarget.samples);
		}

		function useMultisampledRTT(renderTarget) {
			const renderTargetProperties = properties.get(renderTarget);
			return isWebGL2 && renderTarget.samples > 0 && extensions.has('WEBGL_multisampled_render_to_texture') === true && renderTargetProperties.__useRenderToTexture !== false;
		}

		function updateVideoTexture(texture) {
			const frame = info.render.frame;
			// Check the last frame we updated the VideoTexture
			if (_videoTextures.get(texture) !== frame) {
				_videoTextures.set(texture, frame);
				texture.update();
			}
		}

		function verifyColorSpace(texture, image) {
			const encoding = texture.encoding;
			const format = texture.format;
			const type = texture.type;
			if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat) return image;
			if (encoding !== LinearEncoding) {
				// sRGB
				if (encoding === sRGBEncoding) {
					if (isWebGL2 === false) {
						// in WebGL 1, try to use EXT_sRGB extension and unsized formats
						if (extensions.has('EXT_sRGB') === true && format === RGBAFormat) {
							texture.format = _SRGBAFormat;
							// it's not possible to generate mips in WebGL 1 with this extension
							texture.minFilter = LinearFilter;
							texture.generateMipmaps = false;
						} else {
							// slow fallback (CPU decode)
							image = ImageUtils.sRGBToLinear(image);
						}
					} else {
						// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format
						if (format !== RGBAFormat || type !== UnsignedByteType) {
							console.warn('THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.');
						}
					}
				} else {
					console.error('THREE.WebGLTextures: Unsupported texture encoding:', encoding);
				}
			}
			return image;
		}
		//
		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;
		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.rebindTextures = rebindTextures;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
		this.setupDepthRenderbuffer = setupDepthRenderbuffer;
		this.setupFrameBufferTexture = setupFrameBufferTexture;
		this.useMultisampledRTT = useMultisampledRTT;
	}

	function WebGLUtils(gl, extensions, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;

		function convert(p, encoding = null) {
			let extension;
			if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
			if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
			if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
			if (p === ByteType) return gl.BYTE;
			if (p === ShortType) return gl.SHORT;
			if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
			if (p === IntType) return gl.INT;
			if (p === UnsignedIntType) return gl.UNSIGNED_INT;
			if (p === FloatType) return gl.FLOAT;
			if (p === HalfFloatType) {
				if (isWebGL2) return gl.HALF_FLOAT;
				extension = extensions.get('OES_texture_half_float');
				if (extension !== null) {
					return extension.HALF_FLOAT_OES;
				} else {
					return null;
				}
			}
			if (p === AlphaFormat) return gl.ALPHA;
			if (p === RGBAFormat) return gl.RGBA;
			if (p === LuminanceFormat) return gl.LUMINANCE;
			if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
			if (p === DepthFormat) return gl.DEPTH_COMPONENT;
			if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
			// WebGL 1 sRGB fallback
			if (p === _SRGBAFormat) {
				extension = extensions.get('EXT_sRGB');
				if (extension !== null) {
					return extension.SRGB_ALPHA_EXT;
				} else {
					return null;
				}
			}
			// WebGL2 formats.
			if (p === RedFormat) return gl.RED;
			if (p === RedIntegerFormat) return gl.RED_INTEGER;
			if (p === RGFormat) return gl.RG;
			if (p === RGIntegerFormat) return gl.RG_INTEGER;
			if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;
			// S3TC
			if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
				if (encoding === sRGBEncoding) {
					extension = extensions.get('WEBGL_compressed_texture_s3tc_srgb');
					if (extension !== null) {
						if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
						if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
						if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
						if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
					} else {
						return null;
					}
				} else {
					extension = extensions.get('WEBGL_compressed_texture_s3tc');
					if (extension !== null) {
						if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
						if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
						if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
						if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
					} else {
						return null;
					}
				}
			}
			// PVRTC
			if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_pvrtc');
				if (extension !== null) {
					if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
				} else {
					return null;
				}
			}
			// ETC1
			if (p === RGB_ETC1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc1');
				if (extension !== null) {
					return extension.COMPRESSED_RGB_ETC1_WEBGL;
				} else {
					return null;
				}
			}
			// ETC2
			if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc');
				if (extension !== null) {
					if (p === RGB_ETC2_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
					if (p === RGBA_ETC2_EAC_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
				} else {
					return null;
				}
			}
			// ASTC
			if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
				extension = extensions.get('WEBGL_compressed_texture_astc');
				if (extension !== null) {
					if (p === RGBA_ASTC_4x4_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
					if (p === RGBA_ASTC_5x4_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
					if (p === RGBA_ASTC_5x5_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
					if (p === RGBA_ASTC_6x5_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
					if (p === RGBA_ASTC_6x6_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
					if (p === RGBA_ASTC_8x5_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
					if (p === RGBA_ASTC_8x6_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
					if (p === RGBA_ASTC_8x8_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
					if (p === RGBA_ASTC_10x5_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
					if (p === RGBA_ASTC_10x6_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
					if (p === RGBA_ASTC_10x8_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
					if (p === RGBA_ASTC_10x10_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
					if (p === RGBA_ASTC_12x10_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
					if (p === RGBA_ASTC_12x12_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
				} else {
					return null;
				}
			}
			// BPTC
			if (p === RGBA_BPTC_Format) {
				extension = extensions.get('EXT_texture_compression_bptc');
				if (extension !== null) {
					if (p === RGBA_BPTC_Format) return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
				} else {
					return null;
				}
			}
			// RGTC
			if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {
				extension = extensions.get('EXT_texture_compression_rgtc');
				if (extension !== null) {
					if (p === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
					if (p === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
					if (p === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
					if (p === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
				} else {
					return null;
				}
			}
			//
			if (p === UnsignedInt248Type) {
				if (isWebGL2) return gl.UNSIGNED_INT_24_8;
				extension = extensions.get('WEBGL_depth_texture');
				if (extension !== null) {
					return extension.UNSIGNED_INT_24_8_WEBGL;
				} else {
					return null;
				}
			}
			// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)
			return (gl[p] !== undefined) ? gl[p] : null;
		}
		return {
			convert: convert
		};
	}
	class ArrayCamera extends PerspectiveCamera {
		constructor(array = []) {
			super();
			this.isArrayCamera = true;
			this.cameras = array;
		}
	}
	class Group extends Object3D {
		constructor() {
			super();
			this.isGroup = true;
			this.type = 'Group';
		}
	}
	const _moveEvent = {
		type: 'move'
	};
	class WebXRController {
		constructor() {
			this._targetRay = null;
			this._grip = null;
			this._hand = null;
		}
		getHandSpace() {
			if (this._hand === null) {
				this._hand = new Group();
				this._hand.matrixAutoUpdate = false;
				this._hand.visible = false;
				this._hand.joints = {};
				this._hand.inputState = {
					pinching: false
				};
			}
			return this._hand;
		}
		getTargetRaySpace() {
			if (this._targetRay === null) {
				this._targetRay = new Group();
				this._targetRay.matrixAutoUpdate = false;
				this._targetRay.visible = false;
				this._targetRay.hasLinearVelocity = false;
				this._targetRay.linearVelocity = new Vector3();
				this._targetRay.hasAngularVelocity = false;
				this._targetRay.angularVelocity = new Vector3();
			}
			return this._targetRay;
		}
		getGripSpace() {
			if (this._grip === null) {
				this._grip = new Group();
				this._grip.matrixAutoUpdate = false;
				this._grip.visible = false;
				this._grip.hasLinearVelocity = false;
				this._grip.linearVelocity = new Vector3();
				this._grip.hasAngularVelocity = false;
				this._grip.angularVelocity = new Vector3();
			}
			return this._grip;
		}
		dispatchEvent(event) {
			if (this._targetRay !== null) {
				this._targetRay.dispatchEvent(event);
			}
			if (this._grip !== null) {
				this._grip.dispatchEvent(event);
			}
			if (this._hand !== null) {
				this._hand.dispatchEvent(event);
			}
			return this;
		}
		connect(inputSource) {
			if (inputSource && inputSource.hand) {
				const hand = this._hand;
				if (hand) {
					for (const inputjoint of inputSource.hand.values()) {
						// Initialize hand with joints when connected
						this._getHandJoint(hand, inputjoint);
					}
				}
			}
			this.dispatchEvent({
				type: 'connected',
				data: inputSource
			});
			return this;
		}
		disconnect(inputSource) {
			this.dispatchEvent({
				type: 'disconnected',
				data: inputSource
			});
			if (this._targetRay !== null) {
				this._targetRay.visible = false;
			}
			if (this._grip !== null) {
				this._grip.visible = false;
			}
			if (this._hand !== null) {
				this._hand.visible = false;
			}
			return this;
		}
		update(inputSource, frame, referenceSpace) {
			let inputPose = null;
			let gripPose = null;
			let handPose = null;
			const targetRay = this._targetRay;
			const grip = this._grip;
			const hand = this._hand;
			if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
				if (hand && inputSource.hand) {
					handPose = true;
					for (const inputjoint of inputSource.hand.values()) {
						// Update the joints groups with the XRJoint poses
						const jointPose = frame.getJointPose(inputjoint, referenceSpace);
						// The transform of this joint will be updated with the joint pose on each frame
						const joint = this._getHandJoint(hand, inputjoint);
						if (jointPose !== null) {
							joint.matrix.fromArray(jointPose.transform.matrix);
							joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
							joint.jointRadius = jointPose.radius;
						}
						joint.visible = jointPose !== null;
					}
					// Custom events
					// Check pinchz
					const indexTip = hand.joints['index-finger-tip'];
					const thumbTip = hand.joints['thumb-tip'];
					const distance = indexTip.position.distanceTo(thumbTip.position);
					const distanceToPinch = 0.02;
					const threshold = 0.005;
					if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
						hand.inputState.pinching = false;
						this.dispatchEvent({
							type: 'pinchend',
							handedness: inputSource.handedness,
							target: this
						});
					} else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
						hand.inputState.pinching = true;
						this.dispatchEvent({
							type: 'pinchstart',
							handedness: inputSource.handedness,
							target: this
						});
					}
				} else {
					if (grip !== null && inputSource.gripSpace) {
						gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
						if (gripPose !== null) {
							grip.matrix.fromArray(gripPose.transform.matrix);
							grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
							if (gripPose.linearVelocity) {
								grip.hasLinearVelocity = true;
								grip.linearVelocity.copy(gripPose.linearVelocity);
							} else {
								grip.hasLinearVelocity = false;
							}
							if (gripPose.angularVelocity) {
								grip.hasAngularVelocity = true;
								grip.angularVelocity.copy(gripPose.angularVelocity);
							} else {
								grip.hasAngularVelocity = false;
							}
						}
					}
				}
				if (targetRay !== null) {
					inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
					// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
					if (inputPose === null && gripPose !== null) {
						inputPose = gripPose;
					}
					if (inputPose !== null) {
						targetRay.matrix.fromArray(inputPose.transform.matrix);
						targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
						if (inputPose.linearVelocity) {
							targetRay.hasLinearVelocity = true;
							targetRay.linearVelocity.copy(inputPose.linearVelocity);
						} else {
							targetRay.hasLinearVelocity = false;
						}
						if (inputPose.angularVelocity) {
							targetRay.hasAngularVelocity = true;
							targetRay.angularVelocity.copy(inputPose.angularVelocity);
						} else {
							targetRay.hasAngularVelocity = false;
						}
						this.dispatchEvent(_moveEvent);
					}
				}
			}
			if (targetRay !== null) {
				targetRay.visible = (inputPose !== null);
			}
			if (grip !== null) {
				grip.visible = (gripPose !== null);
			}
			if (hand !== null) {
				hand.visible = (handPose !== null);
			}
			return this;
		}
		// private method
		_getHandJoint(hand, inputjoint) {
			if (hand.joints[inputjoint.jointName] === undefined) {
				const joint = new Group();
				joint.matrixAutoUpdate = false;
				joint.visible = false;
				hand.joints[inputjoint.jointName] = joint;
				hand.add(joint);
			}
			return hand.joints[inputjoint.jointName];
		}
	}
	class DepthTexture extends Texture {
		constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
			format = format !== undefined ? format : DepthFormat;
			if (format !== DepthFormat && format !== DepthStencilFormat) {
				throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
			}
			if (type === undefined && format === DepthFormat) type = UnsignedIntType;
			if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
			this.isDepthTexture = true;
			this.image = {
				width: width,
				height: height
			};
			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
			this.flipY = false;
			this.generateMipmaps = false;
		}
	}
	class WebXRManager extends EventDispatcher {
		constructor(renderer, gl) {
			super();
			const scope = this;
			let session = null;
			let framebufferScaleFactor = 1.0;
			let referenceSpace = null;
			let referenceSpaceType = 'local-floor';
			// Set default foveation to maximum.
			let foveation = 1.0;
			let customReferenceSpace = null;
			let pose = null;
			let glBinding = null;
			let glProjLayer = null;
			let glBaseLayer = null;
			let xrFrame = null;
			const attributes = gl.getContextAttributes();
			let initialRenderTarget = null;
			let newRenderTarget = null;
			const controllers = [];
			const controllerInputSources = [];
			const planes = new Set();
			const planesLastChangedTimes = new Map();
			//
			const cameraL = new PerspectiveCamera();
			cameraL.layers.enable(1);
			cameraL.viewport = new Vector4();
			const cameraR = new PerspectiveCamera();
			cameraR.layers.enable(2);
			cameraR.viewport = new Vector4();
			const cameras = [cameraL, cameraR];
			const cameraVR = new ArrayCamera();
			cameraVR.layers.enable(1);
			cameraVR.layers.enable(2);
			let _currentDepthNear = null;
			let _currentDepthFar = null;
			//
			this.cameraAutoUpdate = true;
			this.enabled = false;
			this.isPresenting = false;
			this.getController = function(index) {
				let controller = controllers[index];
				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}
				return controller.getTargetRaySpace();
			};
			this.getControllerGrip = function(index) {
				let controller = controllers[index];
				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}
				return controller.getGripSpace();
			};
			this.getHand = function(index) {
				let controller = controllers[index];
				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}
				return controller.getHandSpace();
			};
			//
			function onSessionEvent(event) {
				const controllerIndex = controllerInputSources.indexOf(event.inputSource);
				if (controllerIndex === -1) {
					return;
				}
				const controller = controllers[controllerIndex];
				if (controller !== undefined) {
					controller.dispatchEvent({
						type: event.type,
						data: event.inputSource
					});
				}
			}

			function onSessionEnd() {
				session.removeEventListener('select', onSessionEvent);
				session.removeEventListener('selectstart', onSessionEvent);
				session.removeEventListener('selectend', onSessionEvent);
				session.removeEventListener('squeeze', onSessionEvent);
				session.removeEventListener('squeezestart', onSessionEvent);
				session.removeEventListener('squeezeend', onSessionEvent);
				session.removeEventListener('end', onSessionEnd);
				session.removeEventListener('inputsourceschange', onInputSourcesChange);
				for (let i = 0; i < controllers.length; i++) {
					const inputSource = controllerInputSources[i];
					if (inputSource === null) continue;
					controllerInputSources[i] = null;
					controllers[i].disconnect(inputSource);
				}
				_currentDepthNear = null;
				_currentDepthFar = null;
				// restore framebuffer/rendering state
				renderer.setRenderTarget(initialRenderTarget);
				glBaseLayer = null;
				glProjLayer = null;
				glBinding = null;
				session = null;
				newRenderTarget = null;
				//
				animation.stop();
				scope.isPresenting = false;
				scope.dispatchEvent({
					type: 'sessionend'
				});
			}
			this.setFramebufferScaleFactor = function(value) {
				framebufferScaleFactor = value;
				if (scope.isPresenting === true) {
					console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
				}
			};
			this.setReferenceSpaceType = function(value) {
				referenceSpaceType = value;
				if (scope.isPresenting === true) {
					console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
				}
			};
			this.getReferenceSpace = function() {
				return customReferenceSpace || referenceSpace;
			};
			this.setReferenceSpace = function(space) {
				customReferenceSpace = space;
			};
			this.getBaseLayer = function() {
				return glProjLayer !== null ? glProjLayer : glBaseLayer;
			};
			this.getBinding = function() {
				return glBinding;
			};
			this.getFrame = function() {
				return xrFrame;
			};
			this.getSession = function() {
				return session;
			};
			this.setSession = async function(value) {
				session = value;
				if (session !== null) {
					initialRenderTarget = renderer.getRenderTarget();
					session.addEventListener('select', onSessionEvent);
					session.addEventListener('selectstart', onSessionEvent);
					session.addEventListener('selectend', onSessionEvent);
					session.addEventListener('squeeze', onSessionEvent);
					session.addEventListener('squeezestart', onSessionEvent);
					session.addEventListener('squeezeend', onSessionEvent);
					session.addEventListener('end', onSessionEnd);
					session.addEventListener('inputsourceschange', onInputSourcesChange);
					if (attributes.xrCompatible !== true) {
						await gl.makeXRCompatible();
					}
					if ((session.renderState.layers === undefined) || (renderer.capabilities.isWebGL2 === false)) {
						const layerInit = {
							antialias: (session.renderState.layers === undefined) ? attributes.antialias : true,
							alpha: attributes.alpha,
							depth: attributes.depth,
							stencil: attributes.stencil,
							framebufferScaleFactor: framebufferScaleFactor
						};
						glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
						session.updateRenderState({
							baseLayer: glBaseLayer
						});
						newRenderTarget = new WebGLRenderTarget(
							glBaseLayer.framebufferWidth,
							glBaseLayer.framebufferHeight, {
								format: RGBAFormat,
								type: UnsignedByteType,
								encoding: renderer.outputEncoding,
								stencilBuffer: attributes.stencil
							}
						);
					} else {
						let depthFormat = null;
						let depthType = null;
						let glDepthFormat = null;
						if (attributes.depth) {
							glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
							depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
							depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
						}
						const projectionlayerInit = {
							colorFormat: gl.RGBA8,
							depthFormat: glDepthFormat,
							scaleFactor: framebufferScaleFactor
						};
						glBinding = new XRWebGLBinding(session, gl);
						glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
						session.updateRenderState({
							layers: [glProjLayer]
						});
						newRenderTarget = new WebGLRenderTarget(
							glProjLayer.textureWidth,
							glProjLayer.textureHeight, {
								format: RGBAFormat,
								type: UnsignedByteType,
								depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),
								stencilBuffer: attributes.stencil,
								encoding: renderer.outputEncoding,
								samples: attributes.antialias ? 4 : 0
							});
						const renderTargetProperties = renderer.properties.get(newRenderTarget);
						renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
					}
					newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278
					this.setFoveation(foveation);
					customReferenceSpace = null;
					referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
					animation.setContext(session);
					animation.start();
					scope.isPresenting = true;
					scope.dispatchEvent({
						type: 'sessionstart'
					});
				}
			};

			function onInputSourcesChange(event) {
				// Notify disconnected
				for (let i = 0; i < event.removed.length; i++) {
					const inputSource = event.removed[i];
					const index = controllerInputSources.indexOf(inputSource);
					if (index >= 0) {
						controllerInputSources[index] = null;
						controllers[index].disconnect(inputSource);
					}
				}
				// Notify connected
				for (let i = 0; i < event.added.length; i++) {
					const inputSource = event.added[i];
					let controllerIndex = controllerInputSources.indexOf(inputSource);
					if (controllerIndex === -1) {
						// Assign input source a controller that currently has no input source
						for (let i = 0; i < controllers.length; i++) {
							if (i >= controllerInputSources.length) {
								controllerInputSources.push(inputSource);
								controllerIndex = i;
								break;
							} else if (controllerInputSources[i] === null) {
								controllerInputSources[i] = inputSource;
								controllerIndex = i;
								break;
							}
						}
						// If all controllers do currently receive input we ignore new ones
						if (controllerIndex === -1) break;
					}
					const controller = controllers[controllerIndex];
					if (controller) {
						controller.connect(inputSource);
					}
				}
			}
			//
			const cameraLPos = new Vector3();
			const cameraRPos = new Vector3();
			/**
			 * Assumes 2 cameras that are parallel and share an X-axis, and that
			 * the cameras' projection and world matrices have already been set.
			 * And that near and far planes are identical for both cameras.
			 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			 */
			function setProjectionFromUnion(camera, cameraL, cameraR) {
				cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
				cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
				const ipd = cameraLPos.distanceTo(cameraRPos);
				const projL = cameraL.projectionMatrix.elements;
				const projR = cameraR.projectionMatrix.elements;
				// VR systems will have identical far and near planes, and
				// most likely identical top and bottom frustum extents.
				// Use the left camera for these values.
				const near = projL[14] / (projL[10] - 1);
				const far = projL[14] / (projL[10] + 1);
				const topFov = (projL[9] + 1) / projL[5];
				const bottomFov = (projL[9] - 1) / projL[5];
				const leftFov = (projL[8] - 1) / projL[0];
				const rightFov = (projR[8] + 1) / projR[0];
				const left = near * leftFov;
				const right = near * rightFov;
				// Calculate the new camera's position offset from the
				// left camera. xOffset should be roughly half `ipd`.
				const zOffset = ipd / (-leftFov + rightFov);
				const xOffset = zOffset * -leftFov;
				// TODO: Better way to apply this offset?
				cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
				camera.translateX(xOffset);
				camera.translateZ(zOffset);
				camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
				camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
				// Find the union of the frustum values of the cameras and scale
				// the values so that the near plane's position does not change in world space,
				// although must now be relative to the new union camera.
				const near2 = near + zOffset;
				const far2 = far + zOffset;
				const left2 = left - xOffset;
				const right2 = right + (ipd - xOffset);
				const top2 = topFov * far / far2 * near2;
				const bottom2 = bottomFov * far / far2 * near2;
				camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
			}

			function updateCamera(camera, parent) {
				if (parent === null) {
					camera.matrixWorld.copy(camera.matrix);
				} else {
					camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
				}
				camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
			}
			this.updateCamera = function(camera) {
				if (session === null) return;
				cameraVR.near = cameraR.near = cameraL.near = camera.near;
				cameraVR.far = cameraR.far = cameraL.far = camera.far;
				if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
					// Note that the new renderState won't apply until the next frame. See #18320
					session.updateRenderState({
						depthNear: cameraVR.near,
						depthFar: cameraVR.far
					});
					_currentDepthNear = cameraVR.near;
					_currentDepthFar = cameraVR.far;
				}
				const parent = camera.parent;
				const cameras = cameraVR.cameras;
				updateCamera(cameraVR, parent);
				for (let i = 0; i < cameras.length; i++) {
					updateCamera(cameras[i], parent);
				}
				cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
				// update user camera and its children
				camera.matrix.copy(cameraVR.matrix);
				camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
				const children = camera.children;
				for (let i = 0, l = children.length; i < l; i++) {
					children[i].updateMatrixWorld(true);
				}
				// update projection matrix for proper view frustum culling
				if (cameras.length === 2) {
					setProjectionFromUnion(cameraVR, cameraL, cameraR);
				} else {
					// assume single camera setup (AR)
					cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
				}
			};
			this.getCamera = function() {
				return cameraVR;
			};
			this.getFoveation = function() {
				if (glProjLayer === null && glBaseLayer === null) {
					return undefined;
				}
				return foveation;
			};
			this.setFoveation = function(value) {
				// 0 = no foveation = full resolution
				// 1 = maximum foveation = the edges render at lower resolution
				foveation = value;
				if (glProjLayer !== null) {
					glProjLayer.fixedFoveation = value;
				}
				if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {
					glBaseLayer.fixedFoveation = value;
				}
			};
			this.getPlanes = function() {
				return planes;
			};
			// Animation Loop
			let onAnimationFrameCallback = null;

			function onAnimationFrame(time, frame) {
				pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
				xrFrame = frame;
				if (pose !== null) {
					const views = pose.views;
					if (glBaseLayer !== null) {
						renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
						renderer.setRenderTarget(newRenderTarget);
					}
					let cameraVRNeedsUpdate = false;
					// check if it's necessary to rebuild cameraVR's camera list
					if (views.length !== cameraVR.cameras.length) {
						cameraVR.cameras.length = 0;
						cameraVRNeedsUpdate = true;
					}
					for (let i = 0; i < views.length; i++) {
						const view = views[i];
						let viewport = null;
						if (glBaseLayer !== null) {
							viewport = glBaseLayer.getViewport(view);
						} else {
							const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
							viewport = glSubImage.viewport;
							// For side-by-side projection, we only produce a single texture for both eyes.
							if (i === 0) {
								renderer.setRenderTargetTextures(
									newRenderTarget,
									glSubImage.colorTexture,
									glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture);
								renderer.setRenderTarget(newRenderTarget);
							}
						}
						let camera = cameras[i];
						if (camera === undefined) {
							camera = new PerspectiveCamera();
							camera.layers.enable(i);
							camera.viewport = new Vector4();
							cameras[i] = camera;
						}
						camera.matrix.fromArray(view.transform.matrix);
						camera.projectionMatrix.fromArray(view.projectionMatrix);
						camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
						if (i === 0) {
							cameraVR.matrix.copy(camera.matrix);
						}
						if (cameraVRNeedsUpdate === true) {
							cameraVR.cameras.push(camera);
						}
					}
				}
				//
				for (let i = 0; i < controllers.length; i++) {
					const inputSource = controllerInputSources[i];
					const controller = controllers[i];
					if (inputSource !== null && controller !== undefined) {
						controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
					}
				}
				if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
				if (frame.detectedPlanes) {
					scope.dispatchEvent({
						type: 'planesdetected',
						data: frame.detectedPlanes
					});
					let planesToRemove = null;
					for (const plane of planes) {
						if (!frame.detectedPlanes.has(plane)) {
							if (planesToRemove === null) {
								planesToRemove = [];
							}
							planesToRemove.push(plane);
						}
					}
					if (planesToRemove !== null) {
						for (const plane of planesToRemove) {
							planes.delete(plane);
							planesLastChangedTimes.delete(plane);
							scope.dispatchEvent({
								type: 'planeremoved',
								data: plane
							});
						}
					}
					for (const plane of frame.detectedPlanes) {
						if (!planes.has(plane)) {
							planes.add(plane);
							planesLastChangedTimes.set(plane, frame.lastChangedTime);
							scope.dispatchEvent({
								type: 'planeadded',
								data: plane
							});
						} else {
							const lastKnownTime = planesLastChangedTimes.get(plane);
							if (plane.lastChangedTime > lastKnownTime) {
								planesLastChangedTimes.set(plane, plane.lastChangedTime);
								scope.dispatchEvent({
									type: 'planechanged',
									data: plane
								});
							}
						}
					}
				}
				xrFrame = null;
			}
			const animation = new WebGLAnimation();
			animation.setAnimationLoop(onAnimationFrame);
			this.setAnimationLoop = function(callback) {
				onAnimationFrameCallback = callback;
			};
			this.dispose = function() {};
		}
	}

	function WebGLMaterials(renderer, properties) {
		function refreshFogUniforms(uniforms, fog) {
			fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
			if (fog.isFog) {
				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
			} else if (fog.isFogExp2) {
				uniforms.fogDensity.value = fog.density;
			}
		}

		function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
			if (material.isMeshBasicMaterial) {
				refreshUniformsCommon(uniforms, material);
			} else if (material.isMeshLambertMaterial) {
				refreshUniformsCommon(uniforms, material);
			} else if (material.isMeshToonMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsToon(uniforms, material);
			} else if (material.isMeshPhongMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsPhong(uniforms, material);
			} else if (material.isMeshStandardMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsStandard(uniforms, material);
				if (material.isMeshPhysicalMaterial) {
					refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
				}
			} else if (material.isMeshMatcapMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsMatcap(uniforms, material);
			} else if (material.isMeshDepthMaterial) {
				refreshUniformsCommon(uniforms, material);
			} else if (material.isMeshDistanceMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsDistance(uniforms, material);
			} else if (material.isMeshNormalMaterial) {
				refreshUniformsCommon(uniforms, material);
			} else if (material.isLineBasicMaterial) {
				refreshUniformsLine(uniforms, material);
				if (material.isLineDashedMaterial) {
					refreshUniformsDash(uniforms, material);
				}
			} else if (material.isPointsMaterial) {
				refreshUniformsPoints(uniforms, material, pixelRatio, height);
			} else if (material.isSpriteMaterial) {
				refreshUniformsSprites(uniforms, material);
			} else if (material.isShadowMaterial) {
				uniforms.color.value.copy(material.color);
				uniforms.opacity.value = material.opacity;
			} else if (material.isShaderMaterial) {
				material.uniformsNeedUpdate = false; // #15581
			}
		}

		function refreshUniformsCommon(uniforms, material) {
			uniforms.opacity.value = material.opacity;
			if (material.color) {
				uniforms.diffuse.value.copy(material.color);
			}
			if (material.emissive) {
				uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
			}
			if (material.map) {
				uniforms.map.value = material.map;
			}
			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			}
			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}
			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}
			if (material.specularMap) {
				uniforms.specularMap.value = material.specularMap;
			}
			if (material.alphaTest > 0) {
				uniforms.alphaTest.value = material.alphaTest;
			}
			const envMap = properties.get(material).envMap;
			if (envMap) {
				uniforms.envMap.value = envMap;
				uniforms.flipEnvMap.value = (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) ? -1 : 1;
				uniforms.reflectivity.value = material.reflectivity;
				uniforms.ior.value = material.ior;
				uniforms.refractionRatio.value = material.refractionRatio;
			}
			if (material.lightMap) {
				uniforms.lightMap.value = material.lightMap;
				// artist-friendly light intensity scaling factor
				const scaleFactor = (renderer.useLegacyLights === true) ? Math.PI : 1;
				uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
			}
			if (material.aoMap) {
				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;
			}
			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. displacementMap map
			// 4. normal map
			// 5. bump map
			// 6. roughnessMap map
			// 7. metalnessMap map
			// 8. alphaMap map
			// 9. emissiveMap map
			// 10. clearcoat map
			// 11. clearcoat normal map
			// 12. clearcoat roughnessMap map
			// 13. iridescence map
			// 14. iridescence thickness map
			// 15. specular intensity map
			// 16. specular tint map
			// 17. transmission map
			// 18. thickness map
			let uvScaleMap;
			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.specularMap) {
				uvScaleMap = material.specularMap;
			} else if (material.displacementMap) {
				uvScaleMap = material.displacementMap;
			} else if (material.normalMap) {
				uvScaleMap = material.normalMap;
			} else if (material.bumpMap) {
				uvScaleMap = material.bumpMap;
			} else if (material.roughnessMap) {
				uvScaleMap = material.roughnessMap;
			} else if (material.metalnessMap) {
				uvScaleMap = material.metalnessMap;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			} else if (material.emissiveMap) {
				uvScaleMap = material.emissiveMap;
			} else if (material.clearcoatMap) {
				uvScaleMap = material.clearcoatMap;
			} else if (material.clearcoatNormalMap) {
				uvScaleMap = material.clearcoatNormalMap;
			} else if (material.clearcoatRoughnessMap) {
				uvScaleMap = material.clearcoatRoughnessMap;
			} else if (material.iridescenceMap) {
				uvScaleMap = material.iridescenceMap;
			} else if (material.iridescenceThicknessMap) {
				uvScaleMap = material.iridescenceThicknessMap;
			} else if (material.specularIntensityMap) {
				uvScaleMap = material.specularIntensityMap;
			} else if (material.specularColorMap) {
				uvScaleMap = material.specularColorMap;
			} else if (material.transmissionMap) {
				uvScaleMap = material.transmissionMap;
			} else if (material.thicknessMap) {
				uvScaleMap = material.thicknessMap;
			} else if (material.sheenColorMap) {
				uvScaleMap = material.sheenColorMap;
			} else if (material.sheenRoughnessMap) {
				uvScaleMap = material.sheenRoughnessMap;
			}
			if (uvScaleMap !== undefined) {
				// backwards compatibility
				if (uvScaleMap.isWebGLRenderTarget) {
					uvScaleMap = uvScaleMap.texture;
				}
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}
				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			}
			// uv repeat and offset setting priorities for uv2
			// 1. ao map
			// 2. light map
			let uv2ScaleMap;
			if (material.aoMap) {
				uv2ScaleMap = material.aoMap;
			} else if (material.lightMap) {
				uv2ScaleMap = material.lightMap;
			}
			if (uv2ScaleMap !== undefined) {
				// backwards compatibility
				if (uv2ScaleMap.isWebGLRenderTarget) {
					uv2ScaleMap = uv2ScaleMap.texture;
				}
				if (uv2ScaleMap.matrixAutoUpdate === true) {
					uv2ScaleMap.updateMatrix();
				}
				uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
			}
		}

		function refreshUniformsLine(uniforms, material) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
		}

		function refreshUniformsDash(uniforms, material) {
			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
		}

		function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * pixelRatio;
			uniforms.scale.value = height * 0.5;
			if (material.map) {
				uniforms.map.value = material.map;
			}
			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			}
			if (material.alphaTest > 0) {
				uniforms.alphaTest.value = material.alphaTest;
			}
			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map
			let uvScaleMap;
			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			}
			if (uvScaleMap !== undefined) {
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}
				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			}
		}

		function refreshUniformsSprites(uniforms, material) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;
			if (material.map) {
				uniforms.map.value = material.map;
			}
			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			}
			if (material.alphaTest > 0) {
				uniforms.alphaTest.value = material.alphaTest;
			}
			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map
			let uvScaleMap;
			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			}
			if (uvScaleMap !== undefined) {
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}
				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			}
		}

		function refreshUniformsPhong(uniforms, material) {
			uniforms.specular.value.copy(material.specular);
			uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )
		}

		function refreshUniformsToon(uniforms, material) {
			if (material.gradientMap) {
				uniforms.gradientMap.value = material.gradientMap;
			}
		}

		function refreshUniformsStandard(uniforms, material) {
			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;
			if (material.roughnessMap) {
				uniforms.roughnessMap.value = material.roughnessMap;
			}
			if (material.metalnessMap) {
				uniforms.metalnessMap.value = material.metalnessMap;
			}
			const envMap = properties.get(material).envMap;
			if (envMap) {
				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;
			}
		}

		function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
			uniforms.ior.value = material.ior; // also part of uniforms common
			if (material.sheen > 0) {
				uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
				uniforms.sheenRoughness.value = material.sheenRoughness;
				if (material.sheenColorMap) {
					uniforms.sheenColorMap.value = material.sheenColorMap;
				}
				if (material.sheenRoughnessMap) {
					uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
				}
			}
			if (material.clearcoat > 0) {
				uniforms.clearcoat.value = material.clearcoat;
				uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
				if (material.clearcoatMap) {
					uniforms.clearcoatMap.value = material.clearcoatMap;
				}
				if (material.clearcoatRoughnessMap) {
					uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
				}
				if (material.clearcoatNormalMap) {
					uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
					uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
					if (material.side === BackSide) {
						uniforms.clearcoatNormalScale.value.negate();
					}
				}
			}
			if (material.iridescence > 0) {
				uniforms.iridescence.value = material.iridescence;
				uniforms.iridescenceIOR.value = material.iridescenceIOR;
				uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
				uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
				if (material.iridescenceMap) {
					uniforms.iridescenceMap.value = material.iridescenceMap;
				}
				if (material.iridescenceThicknessMap) {
					uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
				}
			}
			if (material.transmission > 0) {
				uniforms.transmission.value = material.transmission;
				uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
				uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
				if (material.transmissionMap) {
					uniforms.transmissionMap.value = material.transmissionMap;
				}
				uniforms.thickness.value = material.thickness;
				if (material.thicknessMap) {
					uniforms.thicknessMap.value = material.thicknessMap;
				}
				uniforms.attenuationDistance.value = material.attenuationDistance;
				uniforms.attenuationColor.value.copy(material.attenuationColor);
			}
			uniforms.specularIntensity.value = material.specularIntensity;
			uniforms.specularColor.value.copy(material.specularColor);
			if (material.specularIntensityMap) {
				uniforms.specularIntensityMap.value = material.specularIntensityMap;
			}
			if (material.specularColorMap) {
				uniforms.specularColorMap.value = material.specularColorMap;
			}
		}

		function refreshUniformsMatcap(uniforms, material) {
			if (material.matcap) {
				uniforms.matcap.value = material.matcap;
			}
		}

		function refreshUniformsDistance(uniforms, material) {
			uniforms.referencePosition.value.copy(material.referencePosition);
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;
		}
		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		};
	}

	function WebGLUniformsGroups(gl, info, capabilities, state) {
		let buffers = {};
		let updateList = {};
		let allocatedBindingPoints = [];
		const maxBindingPoints = (capabilities.isWebGL2) ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0; // binding points are global whereas block indices are per shader program
		function bind(uniformsGroup, program) {
			const webglProgram = program.program;
			state.uniformBlockBinding(uniformsGroup, webglProgram);
		}

		function update(uniformsGroup, program) {
			let buffer = buffers[uniformsGroup.id];
			if (buffer === undefined) {
				prepareUniformsGroup(uniformsGroup);
				buffer = createBuffer(uniformsGroup);
				buffers[uniformsGroup.id] = buffer;
				uniformsGroup.addEventListener('dispose', onUniformsGroupsDispose);
			}
			// ensure to update the binding points/block indices mapping for this program
			const webglProgram = program.program;
			state.updateUBOMapping(uniformsGroup, webglProgram);
			// update UBO once per frame
			const frame = info.render.frame;
			if (updateList[uniformsGroup.id] !== frame) {
				updateBufferData(uniformsGroup);
				updateList[uniformsGroup.id] = frame;
			}
		}

		function createBuffer(uniformsGroup) {
			// the setup of an UBO is independent of a particular shader program but global
			const bindingPointIndex = allocateBindingPointIndex();
			uniformsGroup.__bindingPointIndex = bindingPointIndex;
			const buffer = gl.createBuffer();
			const size = uniformsGroup.__size;
			const usage = uniformsGroup.usage;
			gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
			gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
			gl.bindBuffer(gl.UNIFORM_BUFFER, null);
			gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);
			return buffer;
		}

		function allocateBindingPointIndex() {
			for (let i = 0; i < maxBindingPoints; i++) {
				if (allocatedBindingPoints.indexOf(i) === -1) {
					allocatedBindingPoints.push(i);
					return i;
				}
			}
			console.error('THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.');
			return 0;
		}

		function updateBufferData(uniformsGroup) {
			const buffer = buffers[uniformsGroup.id];
			const uniforms = uniformsGroup.uniforms;
			const cache = uniformsGroup.__cache;
			gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
			for (let i = 0, il = uniforms.length; i < il; i++) {
				const uniform = uniforms[i];
				// partly update the buffer if necessary
				if (hasUniformChanged(uniform, i, cache) === true) {
					const offset = uniform.__offset;
					const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
					let arrayOffset = 0;
					for (let i = 0; i < values.length; i++) {
						const value = values[i];
						const info = getUniformSize(value);
						if (typeof value === 'number') {
							uniform.__data[0] = value;
							gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data);
						} else if (value.isMatrix3) {
							// manually converting 3x3 to 3x4
							uniform.__data[0] = value.elements[0];
							uniform.__data[1] = value.elements[1];
							uniform.__data[2] = value.elements[2];
							uniform.__data[3] = value.elements[0];
							uniform.__data[4] = value.elements[3];
							uniform.__data[5] = value.elements[4];
							uniform.__data[6] = value.elements[5];
							uniform.__data[7] = value.elements[0];
							uniform.__data[8] = value.elements[6];
							uniform.__data[9] = value.elements[7];
							uniform.__data[10] = value.elements[8];
							uniform.__data[11] = value.elements[0];
						} else {
							value.toArray(uniform.__data, arrayOffset);
							arrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT;
						}
					}
					gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
				}
			}
			gl.bindBuffer(gl.UNIFORM_BUFFER, null);
		}

		function hasUniformChanged(uniform, index, cache) {
			const value = uniform.value;
			if (cache[index] === undefined) {
				// cache entry does not exist so far
				if (typeof value === 'number') {
					cache[index] = value;
				} else {
					const values = Array.isArray(value) ? value : [value];
					const tempValues = [];
					for (let i = 0; i < values.length; i++) {
						tempValues.push(values[i].clone());
					}
					cache[index] = tempValues;
				}
				return true;
			} else {
				// compare current value with cached entry
				if (typeof value === 'number') {
					if (cache[index] !== value) {
						cache[index] = value;
						return true;
					}
				} else {
					const cachedObjects = Array.isArray(cache[index]) ? cache[index] : [cache[index]];
					const values = Array.isArray(value) ? value : [value];
					for (let i = 0; i < cachedObjects.length; i++) {
						const cachedObject = cachedObjects[i];
						if (cachedObject.equals(values[i]) === false) {
							cachedObject.copy(values[i]);
							return true;
						}
					}
				}
			}
			return false;
		}

		function prepareUniformsGroup(uniformsGroup) {
			// determine total buffer size according to the STD140 layout
			// Hint: STD140 is the only supported layout in WebGL 2
			const uniforms = uniformsGroup.uniforms;
			let offset = 0; // global buffer offset in bytes
			const chunkSize = 16; // size of a chunk in bytes
			let chunkOffset = 0; // offset within a single chunk in bytes
			for (let i = 0, l = uniforms.length; i < l; i++) {
				const uniform = uniforms[i];
				const infos = {
					boundary: 0, // bytes
					storage: 0 // bytes
				};
				const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
				for (let j = 0, jl = values.length; j < jl; j++) {
					const value = values[j];
					const info = getUniformSize(value);
					infos.boundary += info.boundary;
					infos.storage += info.storage;
				}
				// the following two properties will be used for partial buffer updates
				uniform.__data = new Float32Array(infos.storage / Float32Array.BYTES_PER_ELEMENT);
				uniform.__offset = offset;
				//
				if (i > 0) {
					chunkOffset = offset % chunkSize;
					const remainingSizeInChunk = chunkSize - chunkOffset;
					// check for chunk overflow
					if (chunkOffset !== 0 && (remainingSizeInChunk - infos.boundary) < 0) {
						// add padding and adjust offset
						offset += (chunkSize - chunkOffset);
						uniform.__offset = offset;
					}
				}
				offset += infos.storage;
			}
			// ensure correct final padding
			chunkOffset = offset % chunkSize;
			if (chunkOffset > 0) offset += (chunkSize - chunkOffset);
			//
			uniformsGroup.__size = offset;
			uniformsGroup.__cache = {};
			return this;
		}

		function getUniformSize(value) {
			const info = {
				boundary: 0, // bytes
				storage: 0 // bytes
			};
			// determine sizes according to STD140
			if (typeof value === 'number') {
				// float/int
				info.boundary = 4;
				info.storage = 4;
			} else if (value.isVector2) {
				// vec2
				info.boundary = 8;
				info.storage = 8;
			} else if (value.isVector3 || value.isColor) {
				// vec3
				info.boundary = 16;
				info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes
			} else if (value.isVector4) {
				// vec4
				info.boundary = 16;
				info.storage = 16;
			} else if (value.isMatrix3) {
				// mat3 (in STD140 a 3x3 matrix is represented as 3x4)
				info.boundary = 48;
				info.storage = 48;
			} else if (value.isMatrix4) {
				// mat4
				info.boundary = 64;
				info.storage = 64;
			} else if (value.isTexture) {
				console.warn('THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.');
			} else {
				console.warn('THREE.WebGLRenderer: Unsupported uniform value type.', value);
			}
			return info;
		}

		function onUniformsGroupsDispose(event) {
			const uniformsGroup = event.target;
			uniformsGroup.removeEventListener('dispose', onUniformsGroupsDispose);
			const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
			allocatedBindingPoints.splice(index, 1);
			gl.deleteBuffer(buffers[uniformsGroup.id]);
			delete buffers[uniformsGroup.id];
			delete updateList[uniformsGroup.id];
		}

		function dispose() {
			for (const id in buffers) {
				gl.deleteBuffer(buffers[id]);
			}
			allocatedBindingPoints = [];
			buffers = {};
			updateList = {};
		}
		return {
			bind: bind,
			update: update,
			dispose: dispose
		};
	}

	function createCanvasElement() {
		const canvas = createElementNS('canvas');
		canvas.style.display = 'block';
		return canvas;
	}

	function WebGLRenderer(parameters = {}) {
		this.isWebGLRenderer = true;
		const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
			_context = parameters.context !== undefined ? parameters.context : null,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
			_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;
		let _alpha;
		if (_context !== null) {
			_alpha = _context.getContextAttributes().alpha;
		} else {
			_alpha = parameters.alpha !== undefined ? parameters.alpha : false;
		}
		let currentRenderList = null;
		let currentRenderState = null;
		// render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its list and state isolated from the parent render call.
		const renderListStack = [];
		const renderStateStack = [];
		// public properties
		this.domElement = _canvas;
		// Debug configuration container
		this.debug = {
			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true
		};
		// clearing
		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;
		// scene graph
		this.sortObjects = true;
		// user-defined clipping
		this.clippingPlanes = [];
		this.localClippingEnabled = false;
		// physically based shading
		this.outputEncoding = LinearEncoding;
		// physical lights
		this.useLegacyLights = true;
		// tone mapping
		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0;
		// internal properties
		const _this = this;
		let _isContextLost = false;
		// internal state cache
		let _currentActiveCubeFace = 0;
		let _currentActiveMipmapLevel = 0;
		let _currentRenderTarget = null;
		let _currentMaterialId = -1;
		let _currentCamera = null;
		const _currentViewport = new Vector4();
		const _currentScissor = new Vector4();
		let _currentScissorTest = null;
		//
		let _width = _canvas.width;
		let _height = _canvas.height;
		let _pixelRatio = 1;
		let _opaqueSort = null;
		let _transparentSort = null;
		const _viewport = new Vector4(0, 0, _width, _height);
		const _scissor = new Vector4(0, 0, _width, _height);
		let _scissorTest = false;
		// frustum
		const _frustum = new Frustum();
		// clipping
		let _clippingEnabled = false;
		let _localClippingEnabled = false;
		// transmission
		let _transmissionRenderTarget = null;
		// camera matrices cache
		const _projScreenMatrix = new Matrix4();
		const _vector3 = new Vector3();
		const _emptyScene = {
			background: null,
			fog: null,
			environment: null,
			overrideMaterial: null,
			isScene: true
		};

		function getTargetPixelRatio() {
			return _currentRenderTarget === null ? _pixelRatio : 1;
		}
		// initialize
		let _gl = _context;

		function getContext(contextNames, contextAttributes) {
			for (let i = 0; i < contextNames.length; i++) {
				const contextName = contextNames[i];
				const context = _canvas.getContext(contextName, contextAttributes);
				if (context !== null) return context;
			}
			return null;
		}
		try {
			const contextAttributes = {
				alpha: true,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference,
				failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
			};
			// OffscreenCanvas does not have setAttribute, see #22811
			if ('setAttribute' in _canvas) _canvas.setAttribute('data-engine', `three.js r${REVISION}`);
			// event listeners must be registered before WebGL context is created, see #12753
			_canvas.addEventListener('webglcontextlost', onContextLost, false);
			_canvas.addEventListener('webglcontextrestored', onContextRestore, false);
			_canvas.addEventListener('webglcontextcreationerror', onContextCreationError, false);
			if (_gl === null) {
				const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];
				if (_this.isWebGL1Renderer === true) {
					contextNames.shift();
				}
				_gl = getContext(contextNames, contextAttributes);
				if (_gl === null) {
					if (getContext(contextNames)) {
						throw new Error('Error creating WebGL context with your selected attributes.');
					} else {
						throw new Error('Error creating WebGL context.');
					}
				}
			}
			// Some experimental-webgl implementations do not have getShaderPrecisionFormat
			if (_gl.getShaderPrecisionFormat === undefined) {
				_gl.getShaderPrecisionFormat = function() {
					return {
						'rangeMin': 1,
						'rangeMax': 1,
						'precision': 1
					};
				};
			}
		} catch (error) {
			console.error('THREE.WebGLRenderer: ' + error.message);
			throw error;
		}
		let extensions, capabilities, state, info;
		let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
		let programCache, materials, renderLists, renderStates, clipping, shadowMap;
		let background, morphtargets, bufferRenderer, indexedBufferRenderer;
		let utils, bindingStates, uniformsGroups;

		function initGLContext() {
			extensions = new WebGLExtensions(_gl);
			capabilities = new WebGLCapabilities(_gl, extensions, parameters);
			extensions.init(capabilities);
			utils = new WebGLUtils(_gl, extensions, capabilities);
			state = new WebGLState(_gl, extensions, capabilities);
			info = new WebGLInfo(_gl);
			properties = new WebGLProperties();
			textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
			cubemaps = new WebGLCubeMaps(_this);
			cubeuvmaps = new WebGLCubeUVMaps(_this);
			attributes = new WebGLAttributes(_gl, capabilities);
			bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
			geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
			objects = new WebGLObjects(_gl, geometries, attributes, info);
			morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
			clipping = new WebGLClipping(properties);
			programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
			materials = new WebGLMaterials(_this, properties);
			renderLists = new WebGLRenderLists();
			renderStates = new WebGLRenderStates(extensions, capabilities);
			background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, _premultipliedAlpha);
			shadowMap = new WebGLShadowMap(_this, objects, capabilities);
			uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
			bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
			indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
			info.programs = programCache.programs;
			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.shadowMap = shadowMap;
			_this.state = state;
			_this.info = info;
		}
		initGLContext();
		// xr
		const xr = new WebXRManager(_this, _gl);
		this.xr = xr;
		// API
		this.getContext = function() {
			return _gl;
		};
		this.getContextAttributes = function() {
			return _gl.getContextAttributes();
		};
		this.forceContextLoss = function() {
			const extension = extensions.get('WEBGL_lose_context');
			if (extension) extension.loseContext();
		};
		this.forceContextRestore = function() {
			const extension = extensions.get('WEBGL_lose_context');
			if (extension) extension.restoreContext();
		};
		this.getPixelRatio = function() {
			return _pixelRatio;
		};
		this.setPixelRatio = function(value) {
			if (value === undefined) return;
			_pixelRatio = value;
			this.setSize(_width, _height, false);
		};
		this.getSize = function(target) {
			return target.set(_width, _height);
		};
		this.setSize = function(width, height, updateStyle = true) {
			if (xr.isPresenting) {
				console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
				return;
			}
			_width = width;
			_height = height;
			_canvas.width = Math.floor(width * _pixelRatio);
			_canvas.height = Math.floor(height * _pixelRatio);
			if (updateStyle === true) {
				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';
			}
			this.setViewport(0, 0, width, height);
		};
		this.getDrawingBufferSize = function(target) {
			return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
		};
		this.setDrawingBufferSize = function(width, height, pixelRatio) {
			_width = width;
			_height = height;
			_pixelRatio = pixelRatio;
			_canvas.width = Math.floor(width * pixelRatio);
			_canvas.height = Math.floor(height * pixelRatio);
			this.setViewport(0, 0, width, height);
		};
		this.getCurrentViewport = function(target) {
			return target.copy(_currentViewport);
		};
		this.getViewport = function(target) {
			return target.copy(_viewport);
		};
		this.setViewport = function(x, y, width, height) {
			if (x.isVector4) {
				_viewport.set(x.x, x.y, x.z, x.w);
			} else {
				_viewport.set(x, y, width, height);
			}
			state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
		};
		this.getScissor = function(target) {
			return target.copy(_scissor);
		};
		this.setScissor = function(x, y, width, height) {
			if (x.isVector4) {
				_scissor.set(x.x, x.y, x.z, x.w);
			} else {
				_scissor.set(x, y, width, height);
			}
			state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
		};
		this.getScissorTest = function() {
			return _scissorTest;
		};
		this.setScissorTest = function(boolean) {
			state.setScissorTest(_scissorTest = boolean);
		};
		this.setOpaqueSort = function(method) {
			_opaqueSort = method;
		};
		this.setTransparentSort = function(method) {
			_transparentSort = method;
		};
		// Clearing
		this.getClearColor = function(target) {
			return target.copy(background.getClearColor());
		};
		this.setClearColor = function() {
			background.setClearColor.apply(background, arguments);
		};
		this.getClearAlpha = function() {
			return background.getClearAlpha();
		};
		this.setClearAlpha = function() {
			background.setClearAlpha.apply(background, arguments);
		};
		this.clear = function(color = true, depth = true, stencil = true) {
			let bits = 0;
			if (color) bits |= _gl.COLOR_BUFFER_BIT;
			if (depth) bits |= _gl.DEPTH_BUFFER_BIT;
			if (stencil) bits |= _gl.STENCIL_BUFFER_BIT;
			_gl.clear(bits);
		};
		this.clearColor = function() {
			this.clear(true, false, false);
		};
		this.clearDepth = function() {
			this.clear(false, true, false);
		};
		this.clearStencil = function() {
			this.clear(false, false, true);
		};
		//
		this.dispose = function() {
			_canvas.removeEventListener('webglcontextlost', onContextLost, false);
			_canvas.removeEventListener('webglcontextrestored', onContextRestore, false);
			_canvas.removeEventListener('webglcontextcreationerror', onContextCreationError, false);
			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			cubemaps.dispose();
			cubeuvmaps.dispose();
			objects.dispose();
			bindingStates.dispose();
			uniformsGroups.dispose();
			programCache.dispose();
			xr.dispose();
			xr.removeEventListener('sessionstart', onXRSessionStart);
			xr.removeEventListener('sessionend', onXRSessionEnd);
			if (_transmissionRenderTarget) {
				_transmissionRenderTarget.dispose();
				_transmissionRenderTarget = null;
			}
			animation.stop();
		};
		// Events
		function onContextLost(event) {
			event.preventDefault();
			console.log('THREE.WebGLRenderer: Context Lost.');
			_isContextLost = true;
		}

		function onContextRestore( /* event */ ) {
			console.log('THREE.WebGLRenderer: Context Restored.');
			_isContextLost = false;
			const infoAutoReset = info.autoReset;
			const shadowMapEnabled = shadowMap.enabled;
			const shadowMapAutoUpdate = shadowMap.autoUpdate;
			const shadowMapNeedsUpdate = shadowMap.needsUpdate;
			const shadowMapType = shadowMap.type;
			initGLContext();
			info.autoReset = infoAutoReset;
			shadowMap.enabled = shadowMapEnabled;
			shadowMap.autoUpdate = shadowMapAutoUpdate;
			shadowMap.needsUpdate = shadowMapNeedsUpdate;
			shadowMap.type = shadowMapType;
		}

		function onContextCreationError(event) {
			console.error('THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage);
		}

		function onMaterialDispose(event) {
			const material = event.target;
			material.removeEventListener('dispose', onMaterialDispose);
			deallocateMaterial(material);
		}
		// Buffer deallocation
		function deallocateMaterial(material) {
			releaseMaterialProgramReferences(material);
			properties.remove(material);
		}

		function releaseMaterialProgramReferences(material) {
			const programs = properties.get(material).programs;
			if (programs !== undefined) {
				programs.forEach(function(program) {
					programCache.releaseProgram(program);
				});
				if (material.isShaderMaterial) {
					programCache.releaseShaderCache(material);
				}
			}
		}
		// Buffer rendering
		this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
			if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)
			const frontFaceCW = (object.isMesh && object.matrixWorld.determinant() < 0);
			const program = setProgram(camera, scene, geometry, material, object);
			state.setMaterial(material, frontFaceCW);
			//
			let index = geometry.index;
			let rangeFactor = 1;
			if (material.wireframe === true) {
				index = geometries.getWireframeAttribute(geometry);
				rangeFactor = 2;
			}
			//
			const drawRange = geometry.drawRange;
			const position = geometry.attributes.position;
			let drawStart = drawRange.start * rangeFactor;
			let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
			if (group !== null) {
				drawStart = Math.max(drawStart, group.start * rangeFactor);
				drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
			}
			if (index !== null) {
				drawStart = Math.max(drawStart, 0);
				drawEnd = Math.min(drawEnd, index.count);
			} else if (position !== undefined && position !== null) {
				drawStart = Math.max(drawStart, 0);
				drawEnd = Math.min(drawEnd, position.count);
			}
			const drawCount = drawEnd - drawStart;
			if (drawCount < 0 || drawCount === Infinity) return;
			//
			bindingStates.setup(object, material, program, geometry, index);
			let attribute;
			let renderer = bufferRenderer;
			if (index !== null) {
				attribute = attributes.get(index);
				renderer = indexedBufferRenderer;
				renderer.setIndex(attribute);
			}
			//
			if (object.isMesh) {
				if (material.wireframe === true) {
					state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
					renderer.setMode(_gl.LINES);
				} else {
					renderer.setMode(_gl.TRIANGLES);
				}
			} else if (object.isLine) {
				let lineWidth = material.linewidth;
				if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material
				state.setLineWidth(lineWidth * getTargetPixelRatio());
				if (object.isLineSegments) {
					renderer.setMode(_gl.LINES);
				} else if (object.isLineLoop) {
					renderer.setMode(_gl.LINE_LOOP);
				} else {
					renderer.setMode(_gl.LINE_STRIP);
				}
			} else if (object.isPoints) {
				renderer.setMode(_gl.POINTS);
			} else if (object.isSprite) {
				renderer.setMode(_gl.TRIANGLES);
			}
			if (object.isInstancedMesh) {
				renderer.renderInstances(drawStart, drawCount, object.count);
			} else if (geometry.isInstancedBufferGeometry) {
				const maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;
				const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
				renderer.renderInstances(drawStart, drawCount, instanceCount);
			} else {
				renderer.render(drawStart, drawCount);
			}
		};
		// Compile
		this.compile = function(scene, camera) {
			function prepare(material, scene, object) {
				if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
					material.side = BackSide;
					material.needsUpdate = true;
					getProgram(material, scene, object);
					material.side = FrontSide;
					material.needsUpdate = true;
					getProgram(material, scene, object);
					material.side = DoubleSide;
				} else {
					getProgram(material, scene, object);
				}
			}
			currentRenderState = renderStates.get(scene);
			currentRenderState.init();
			renderStateStack.push(currentRenderState);
			scene.traverseVisible(function(object) {
				if (object.isLight && object.layers.test(camera.layers)) {
					currentRenderState.pushLight(object);
					if (object.castShadow) {
						currentRenderState.pushShadow(object);
					}
				}
			});
			currentRenderState.setupLights(_this.useLegacyLights);
			scene.traverse(function(object) {
				const material = object.material;
				if (material) {
					if (Array.isArray(material)) {
						for (let i = 0; i < material.length; i++) {
							const material2 = material[i];
							prepare(material2, scene, object);
						}
					} else {
						prepare(material, scene, object);
					}
				}
			});
			renderStateStack.pop();
			currentRenderState = null;
		};
		// Animation Loop
		let onAnimationFrameCallback = null;

		function onAnimationFrame(time) {
			if (onAnimationFrameCallback) onAnimationFrameCallback(time);
		}

		function onXRSessionStart() {
			animation.stop();
		}

		function onXRSessionEnd() {
			animation.start();
		}
		const animation = new WebGLAnimation();
		animation.setAnimationLoop(onAnimationFrame);
		if (typeof self !== 'undefined') animation.setContext(self);
		this.setAnimationLoop = function(callback) {
			onAnimationFrameCallback = callback;
			xr.setAnimationLoop(callback);
			(callback === null) ? animation.stop(): animation.start();
		};
		xr.addEventListener('sessionstart', onXRSessionStart);
		xr.addEventListener('sessionend', onXRSessionEnd);
		// Rendering
		this.render = function(scene, camera) {
			if (camera !== undefined && camera.isCamera !== true) {
				console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
				return;
			}
			if (_isContextLost === true) return;
			// update scene graph
			if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
			// update camera matrices and frustum
			if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
			if (xr.enabled === true && xr.isPresenting === true) {
				if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
				camera = xr.getCamera(); // use XR camera for rendering
			}
			//
			if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
			currentRenderState = renderStates.get(scene, renderStateStack.length);
			currentRenderState.init();
			renderStateStack.push(currentRenderState);
			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
			_frustum.setFromProjectionMatrix(_projScreenMatrix);
			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
			currentRenderList = renderLists.get(scene, renderListStack.length);
			currentRenderList.init();
			renderListStack.push(currentRenderList);
			projectObject(scene, camera, 0, _this.sortObjects);
			currentRenderList.finish();
			if (_this.sortObjects === true) {
				currentRenderList.sort(_opaqueSort, _transparentSort);
			}
			//
			if (_clippingEnabled === true) clipping.beginShadows();
			const shadowsArray = currentRenderState.state.shadowsArray;
			shadowMap.render(shadowsArray, scene, camera);
			if (_clippingEnabled === true) clipping.endShadows();
			//
			if (this.info.autoReset === true) this.info.reset();
			//
			background.render(currentRenderList, scene);
			// render scene
			currentRenderState.setupLights(_this.useLegacyLights);
			if (camera.isArrayCamera) {
				const cameras = camera.cameras;
				for (let i = 0, l = cameras.length; i < l; i++) {
					const camera2 = cameras[i];
					renderScene(currentRenderList, scene, camera2, camera2.viewport);
				}
			} else {
				renderScene(currentRenderList, scene, camera);
			}
			//
			if (_currentRenderTarget !== null) {
				// resolve multisample renderbuffers to a single-sample texture if necessary
				textures.updateMultisampleRenderTarget(_currentRenderTarget);
				// Generate mipmap if we're using any kind of mipmap filtering
				textures.updateRenderTargetMipmap(_currentRenderTarget);
			}
			//
			if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
			// _gl.finish();
			bindingStates.resetDefaultState();
			_currentMaterialId = -1;
			_currentCamera = null;
			renderStateStack.pop();
			if (renderStateStack.length > 0) {
				currentRenderState = renderStateStack[renderStateStack.length - 1];
			} else {
				currentRenderState = null;
			}
			renderListStack.pop();
			if (renderListStack.length > 0) {
				currentRenderList = renderListStack[renderListStack.length - 1];
			} else {
				currentRenderList = null;
			}
		};

		function projectObject(object, camera, groupOrder, sortObjects) {
			if (object.visible === false) return;
			const visible = object.layers.test(camera.layers);
			if (visible) {
				if (object.isGroup) {
					groupOrder = object.renderOrder;
				} else if (object.isLOD) {
					if (object.autoUpdate === true) object.update(camera);
				} else if (object.isLight) {
					currentRenderState.pushLight(object);
					if (object.castShadow) {
						currentRenderState.pushShadow(object);
					}
				} else if (object.isSprite) {
					if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld)
								.applyMatrix4(_projScreenMatrix);
						}
						const geometry = objects.update(object);
						const material = object.material;
						if (material.visible) {
							currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
						}
					}
				} else if (object.isMesh || object.isLine || object.isPoints) {
					if (object.isSkinnedMesh) {
						// update skeleton only once in a frame
						if (object.skeleton.frame !== info.render.frame) {
							object.skeleton.update();
							object.skeleton.frame = info.render.frame;
						}
					}
					if (!object.frustumCulled || _frustum.intersectsObject(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld)
								.applyMatrix4(_projScreenMatrix);
						}
						const geometry = objects.update(object);
						const material = object.material;
						if (Array.isArray(material)) {
							const groups = geometry.groups;
							for (let i = 0, l = groups.length; i < l; i++) {
								const group = groups[i];
								const groupMaterial = material[group.materialIndex];
								if (groupMaterial && groupMaterial.visible) {
									currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
								}
							}
						} else if (material.visible) {
							currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
						}
					}
				}
			}
			const children = object.children;
			for (let i = 0, l = children.length; i < l; i++) {
				projectObject(children[i], camera, groupOrder, sortObjects);
			}
		}

		function renderScene(currentRenderList, scene, camera, viewport) {
			const opaqueObjects = currentRenderList.opaque;
			const transmissiveObjects = currentRenderList.transmissive;
			const transparentObjects = currentRenderList.transparent;
			currentRenderState.setupLightsView(camera);
			if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
			if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, scene, camera);
			if (viewport) state.viewport(_currentViewport.copy(viewport));
			if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
			if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
			if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
			// Ensure depth buffer writing is enabled so it can be cleared on next render
			state.buffers.depth.setTest(true);
			state.buffers.depth.setMask(true);
			state.buffers.color.setMask(true);
			state.setPolygonOffset(false);
		}

		function renderTransmissionPass(opaqueObjects, scene, camera) {
			const isWebGL2 = capabilities.isWebGL2;
			if (_transmissionRenderTarget === null) {
				_transmissionRenderTarget = new WebGLRenderTarget(1024, 1024, {
					generateMipmaps: true,
					type: extensions.has('EXT_color_buffer_half_float') ? HalfFloatType : UnsignedByteType,
					minFilter: LinearMipmapLinearFilter,
					samples: (isWebGL2 && _antialias === true) ? 4 : 0
				});
			}
			//
			const currentRenderTarget = _this.getRenderTarget();
			_this.setRenderTarget(_transmissionRenderTarget);
			_this.clear();
			// Turn off the features which can affect the frag color for opaque objects pass.
			// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
			const currentToneMapping = _this.toneMapping;
			_this.toneMapping = NoToneMapping;
			renderObjects(opaqueObjects, scene, camera);
			_this.toneMapping = currentToneMapping;
			textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
			textures.updateRenderTargetMipmap(_transmissionRenderTarget);
			_this.setRenderTarget(currentRenderTarget);
		}

		function renderObjects(renderList, scene, camera) {
			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
			for (let i = 0, l = renderList.length; i < l; i++) {
				const renderItem = renderList[i];
				const object = renderItem.object;
				const geometry = renderItem.geometry;
				const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
				const group = renderItem.group;
				if (object.layers.test(camera.layers)) {
					renderObject(object, scene, camera, geometry, material, group);
				}
			}
		}

		function renderObject(object, scene, camera, geometry, material, group) {
			object.onBeforeRender(_this, scene, camera, geometry, material, group);
			object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
			object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
			material.onBeforeRender(_this, scene, camera, geometry, object, group);
			if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
				material.side = BackSide;
				material.needsUpdate = true;
				_this.renderBufferDirect(camera, scene, geometry, material, object, group);
				material.side = FrontSide;
				material.needsUpdate = true;
				_this.renderBufferDirect(camera, scene, geometry, material, object, group);
				material.side = DoubleSide;
			} else {
				_this.renderBufferDirect(camera, scene, geometry, material, object, group);
			}
			object.onAfterRender(_this, scene, camera, geometry, material, group);
		}

		function getProgram(material, scene, object) {
			if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
			const materialProperties = properties.get(material);
			const lights = currentRenderState.state.lights;
			const shadowsArray = currentRenderState.state.shadowsArray;
			const lightsStateVersion = lights.state.version;
			const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
			const programCacheKey = programCache.getProgramCacheKey(parameters);
			let programs = materialProperties.programs;
			// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change
			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.fog = scene.fog;
			materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
			if (programs === undefined) {
				// new material
				material.addEventListener('dispose', onMaterialDispose);
				programs = new Map();
				materialProperties.programs = programs;
			}
			let program = programs.get(programCacheKey);
			if (program !== undefined) {
				// early out if program and light state is identical
				if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
					updateCommonMaterialProperties(material, parameters);
					return program;
				}
			} else {
				parameters.uniforms = programCache.getUniforms(material);
				material.onBuild(object, parameters, _this);
				material.onBeforeCompile(parameters, _this);
				program = programCache.acquireProgram(parameters, programCacheKey);
				programs.set(programCacheKey, program);
				materialProperties.uniforms = parameters.uniforms;
			}
			const uniforms = materialProperties.uniforms;
			if ((!material.isShaderMaterial && !material.isRawShaderMaterial) || material.clipping === true) {
				uniforms.clippingPlanes = clipping.uniform;
			}
			updateCommonMaterialProperties(material, parameters);
			// store the light setup it was created for
			materialProperties.needsLights = materialNeedsLights(material);
			materialProperties.lightsStateVersion = lightsStateVersion;
			if (materialProperties.needsLights) {
				// wire up the material to this renderer's lighting state
				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.lightProbe.value = lights.state.probe;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.spotLightShadows.value = lights.state.spotShadow;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
				uniforms.pointLights.value = lights.state.point;
				uniforms.pointLightShadows.value = lights.state.pointShadow;
				uniforms.hemisphereLights.value = lights.state.hemi;
				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
				uniforms.spotLightMap.value = lights.state.spotLightMap;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms
			}
			const progUniforms = program.getUniforms();
			const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
			materialProperties.currentProgram = program;
			materialProperties.uniformsList = uniformsList;
			return program;
		}

		function updateCommonMaterialProperties(material, parameters) {
			const materialProperties = properties.get(material);
			materialProperties.outputEncoding = parameters.outputEncoding;
			materialProperties.instancing = parameters.instancing;
			materialProperties.skinning = parameters.skinning;
			materialProperties.morphTargets = parameters.morphTargets;
			materialProperties.morphNormals = parameters.morphNormals;
			materialProperties.morphColors = parameters.morphColors;
			materialProperties.morphTargetsCount = parameters.morphTargetsCount;
			materialProperties.numClippingPlanes = parameters.numClippingPlanes;
			materialProperties.numIntersection = parameters.numClipIntersection;
			materialProperties.vertexAlphas = parameters.vertexAlphas;
			materialProperties.vertexTangents = parameters.vertexTangents;
			materialProperties.toneMapping = parameters.toneMapping;
		}

		function setProgram(camera, scene, geometry, material, object) {
			if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
			textures.resetTextureUnits();
			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const encoding = (_currentRenderTarget === null) ? _this.outputEncoding : (_currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding);
			const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
			const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
			const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
			const morphTargets = !!geometry.morphAttributes.position;
			const morphNormals = !!geometry.morphAttributes.normal;
			const morphColors = !!geometry.morphAttributes.color;
			const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;
			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = (morphAttribute !== undefined) ? morphAttribute.length : 0;
			const materialProperties = properties.get(material);
			const lights = currentRenderState.state.lights;
			if (_clippingEnabled === true) {
				if (_localClippingEnabled === true || camera !== _currentCamera) {
					const useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;
					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					clipping.setState(material, camera, useCache);
				}
			}
			//
			let needsProgramChange = false;
			if (material.version === materialProperties.__version) {
				if (materialProperties.needsLights && (materialProperties.lightsStateVersion !== lights.state.version)) {
					needsProgramChange = true;
				} else if (materialProperties.outputEncoding !== encoding) {
					needsProgramChange = true;
				} else if (object.isInstancedMesh && materialProperties.instancing === false) {
					needsProgramChange = true;
				} else if (!object.isInstancedMesh && materialProperties.instancing === true) {
					needsProgramChange = true;
				} else if (object.isSkinnedMesh && materialProperties.skinning === false) {
					needsProgramChange = true;
				} else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
					needsProgramChange = true;
				} else if (materialProperties.envMap !== envMap) {
					needsProgramChange = true;
				} else if (material.fog === true && materialProperties.fog !== fog) {
					needsProgramChange = true;
				} else if (materialProperties.numClippingPlanes !== undefined &&
					(materialProperties.numClippingPlanes !== clipping.numPlanes ||
						materialProperties.numIntersection !== clipping.numIntersection)) {
					needsProgramChange = true;
				} else if (materialProperties.vertexAlphas !== vertexAlphas) {
					needsProgramChange = true;
				} else if (materialProperties.vertexTangents !== vertexTangents) {
					needsProgramChange = true;
				} else if (materialProperties.morphTargets !== morphTargets) {
					needsProgramChange = true;
				} else if (materialProperties.morphNormals !== morphNormals) {
					needsProgramChange = true;
				} else if (materialProperties.morphColors !== morphColors) {
					needsProgramChange = true;
				} else if (materialProperties.toneMapping !== toneMapping) {
					needsProgramChange = true;
				} else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
					needsProgramChange = true;
				}
			} else {
				needsProgramChange = true;
				materialProperties.__version = material.version;
			}
			//
			let program = materialProperties.currentProgram;
			if (needsProgramChange === true) {
				program = getProgram(material, scene, object);
			}
			let refreshProgram = false;
			let refreshMaterial = false;
			let refreshLights = false;
			const p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.uniforms;
			if (state.useProgram(program.program)) {
				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;
			}
			if (material.id !== _currentMaterialId) {
				_currentMaterialId = material.id;
				refreshMaterial = true;
			}
			if (refreshProgram || _currentCamera !== camera) {
				p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
				if (capabilities.logarithmicDepthBuffer) {
					p_uniforms.setValue(_gl, 'logDepthBufFC',
						2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
				}
				if (_currentCamera !== camera) {
					_currentCamera = camera;
					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:
					refreshMaterial = true; // set to true on material change
					refreshLights = true; // remains set until update done
				}
				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)
				if (material.isShaderMaterial ||
					material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshStandardMaterial ||
					material.envMap) {
					const uCamPos = p_uniforms.map.cameraPosition;
					if (uCamPos !== undefined) {
						uCamPos.setValue(_gl,
							_vector3.setFromMatrixPosition(camera.matrixWorld));
					}
				}
				if (material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial) {
					p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
				}
				if (material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ||
					material.isShadowMaterial ||
					object.isSkinnedMesh) {
					p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
				}
			}
			// skinning and morph target uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone and morph texture must go before other textures
			// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures
			if (object.isSkinnedMesh) {
				p_uniforms.setOptional(_gl, object, 'bindMatrix');
				p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
				const skeleton = object.skeleton;
				if (skeleton) {
					if (capabilities.floatVertexTextures) {
						if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
						p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
						p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
					} else {
						console.warn('THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.');
					}
				}
			}
			const morphAttributes = geometry.morphAttributes;
			if (morphAttributes.position !== undefined || morphAttributes.normal !== undefined || (morphAttributes.color !== undefined && capabilities.isWebGL2 === true)) {
				morphtargets.update(object, geometry, program);
			}
			if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
			}
			// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512
			if (material.isMeshGouraudMaterial && material.envMap !== null) {
				m_uniforms.envMap.value = envMap;
				m_uniforms.flipEnvMap.value = (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) ? -1 : 1;
			}
			if (refreshMaterial) {
				p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
				if (materialProperties.needsLights) {
					// the current material requires lighting info
					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required
					markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
				}
				// refresh uniforms common to several materials
				if (fog && material.fog === true) {
					materials.refreshFogUniforms(m_uniforms, fog);
				}
				materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
			}
			if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
				material.uniformsNeedUpdate = false;
			}
			if (material.isSpriteMaterial) {
				p_uniforms.setValue(_gl, 'center', object.center);
			}
			// common matrices
			p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
			p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
			p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
			// UBOs
			if (material.isShaderMaterial || material.isRawShaderMaterial) {
				const groups = material.uniformsGroups;
				for (let i = 0, l = groups.length; i < l; i++) {
					if (capabilities.isWebGL2) {
						const group = groups[i];
						uniformsGroups.update(group, program);
						uniformsGroups.bind(group, program);
					} else {
						console.warn('THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.');
					}
				}
			}
			return program;
		}
		// If uniforms are marked as clean, they don't need to be loaded to the GPU.
		function markUniformsLightsNeedsUpdate(uniforms, value) {
			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;
			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;
		}

		function materialNeedsLights(material) {
			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial || material.isShadowMaterial ||
				(material.isShaderMaterial && material.lights === true);
		}
		this.getActiveCubeFace = function() {
			return _currentActiveCubeFace;
		};
		this.getActiveMipmapLevel = function() {
			return _currentActiveMipmapLevel;
		};
		this.getRenderTarget = function() {
			return _currentRenderTarget;
		};
		this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
			properties.get(renderTarget.texture).__webglTexture = colorTexture;
			properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
			const renderTargetProperties = properties.get(renderTarget);
			renderTargetProperties.__hasExternalTextures = true;
			if (renderTargetProperties.__hasExternalTextures) {
				renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;
				if (!renderTargetProperties.__autoAllocateDepthBuffer) {
					// The multisample_render_to_texture extension doesn't work properly if there
					// are midframe flushes and an external depth buffer. Disable use of the extension.
					if (extensions.has('WEBGL_multisampled_render_to_texture') === true) {
						console.warn('THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided');
						renderTargetProperties.__useRenderToTexture = false;
					}
				}
			}
		};
		this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
			const renderTargetProperties = properties.get(renderTarget);
			renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
			renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;
		};
		this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;
			let useDefaultFramebuffer = true;
			let framebuffer = null;
			let isCube = false;
			let isRenderTarget3D = false;
			if (renderTarget) {
				const renderTargetProperties = properties.get(renderTarget);
				if (renderTargetProperties.__useDefaultFramebuffer !== undefined) {
					// We need to make sure to rebind the framebuffer.
					state.bindFramebuffer(_gl.FRAMEBUFFER, null);
					useDefaultFramebuffer = false;
				} else if (renderTargetProperties.__webglFramebuffer === undefined) {
					textures.setupRenderTarget(renderTarget);
				} else if (renderTargetProperties.__hasExternalTextures) {
					// Color and depth texture must be rebound in order for the swapchain to update.
					textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
				}
				const texture = renderTarget.texture;
				if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
					isRenderTarget3D = true;
				}
				const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
				if (renderTarget.isWebGLCubeRenderTarget) {
					framebuffer = __webglFramebuffer[activeCubeFace];
					isCube = true;
				} else if ((capabilities.isWebGL2 && renderTarget.samples > 0) && textures.useMultisampledRTT(renderTarget) === false) {
					framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
				} else {
					framebuffer = __webglFramebuffer;
				}
				_currentViewport.copy(renderTarget.viewport);
				_currentScissor.copy(renderTarget.scissor);
				_currentScissorTest = renderTarget.scissorTest;
			} else {
				_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
				_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
				_currentScissorTest = _scissorTest;
			}
			const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
			if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
				state.drawBuffers(renderTarget, framebuffer);
			}
			state.viewport(_currentViewport);
			state.scissor(_currentScissor);
			state.setScissorTest(_currentScissorTest);
			if (isCube) {
				const textureProperties = properties.get(renderTarget.texture);
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
			} else if (isRenderTarget3D) {
				const textureProperties = properties.get(renderTarget.texture);
				const layer = activeCubeFace || 0;
				_gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
			}
			_currentMaterialId = -1; // reset current material to ensure correct uniform bindings
		};
		this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
			if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
				console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
				return;
			}
			let framebuffer = properties.get(renderTarget).__webglFramebuffer;
			if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
				framebuffer = framebuffer[activeCubeFaceIndex];
			}
			if (framebuffer) {
				state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
				try {
					const texture = renderTarget.texture;
					const textureFormat = texture.format;
					const textureType = texture.type;
					if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
						return;
					}
					const halfFloatSupportedByExt = (textureType === HalfFloatType) && (extensions.has('EXT_color_buffer_half_float') || (capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float')));
					if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
						!(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
						!halfFloatSupportedByExt) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
						return;
					}
					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
					if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {
						_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
					}
				} finally {
					// restore framebuffer of current render target if necessary
					const framebuffer = (_currentRenderTarget !== null) ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
					state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
				}
			}
		};
		this.copyFramebufferToTexture = function(position, texture, level = 0) {
			const levelScale = Math.pow(2, -level);
			const width = Math.floor(texture.image.width * levelScale);
			const height = Math.floor(texture.image.height * levelScale);
			textures.setTexture2D(texture, 0);
			_gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height);
			state.unbindTexture();
		};
		this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
			const width = srcTexture.image.width;
			const height = srcTexture.image.height;
			const glFormat = utils.convert(dstTexture.format);
			const glType = utils.convert(dstTexture.type);
			textures.setTexture2D(dstTexture, 0);
			// As another texture upload may have changed pixelStorei
			// parameters, make sure they are correct for the dstTexture
			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
			if (srcTexture.isDataTexture) {
				_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
			} else {
				if (srcTexture.isCompressedTexture) {
					_gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
				} else {
					_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
				}
			}
			// Generate mipmaps only when copying level 0
			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
			state.unbindTexture();
		};
		this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
			if (_this.isWebGL1Renderer) {
				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');
				return;
			}
			const width = sourceBox.max.x - sourceBox.min.x + 1;
			const height = sourceBox.max.y - sourceBox.min.y + 1;
			const depth = sourceBox.max.z - sourceBox.min.z + 1;
			const glFormat = utils.convert(dstTexture.format);
			const glType = utils.convert(dstTexture.type);
			let glTarget;
			if (dstTexture.isData3DTexture) {
				textures.setTexture3D(dstTexture, 0);
				glTarget = _gl.TEXTURE_3D;
			} else if (dstTexture.isDataArrayTexture) {
				textures.setTexture2DArray(dstTexture, 0);
				glTarget = _gl.TEXTURE_2D_ARRAY;
			} else {
				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');
				return;
			}
			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
			const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
			const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
			const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
			const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
			const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
			const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
			_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);
			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);
			_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);
			if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
				_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
			} else {
				if (srcTexture.isCompressedArrayTexture) {
					console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');
					_gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
				} else {
					_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
				}
			}
			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);
			_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);
			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);
			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);
			_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages);
			// Generate mipmaps only when copying level 0
			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
			state.unbindTexture();
		};
		this.initTexture = function(texture) {
			if (texture.isCubeTexture) {
				textures.setTextureCube(texture, 0);
			} else if (texture.isData3DTexture) {
				textures.setTexture3D(texture, 0);
			} else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
				textures.setTexture2DArray(texture, 0);
			} else {
				textures.setTexture2D(texture, 0);
			}
			state.unbindTexture();
		};
		this.resetState = function() {
			_currentActiveCubeFace = 0;
			_currentActiveMipmapLevel = 0;
			_currentRenderTarget = null;
			state.reset();
			bindingStates.reset();
		};
		if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
			__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
				detail: this
			}));
		}
	}
	Object.defineProperties(WebGLRenderer.prototype, {
		// @deprecated since r150
		physicallyCorrectLights: {
			get: function() {
				console.warn('THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.');
				return !this.useLegacyLights;
			},
			set: function(value) {
				console.warn('THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.');
				this.useLegacyLights = !value;
			}
		}
	});
	class WebGL1Renderer extends WebGLRenderer {}
	WebGL1Renderer.prototype.isWebGL1Renderer = true;
	class FogExp2 {
		constructor(color, density = 0.00025) {
			this.isFogExp2 = true;
			this.name = '';
			this.color = new Color(color);
			this.density = density;
		}
		clone() {
			return new FogExp2(this.color, this.density);
		}
		toJSON( /* meta */ ) {
			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};
		}
	}
	class Fog {
		constructor(color, near = 1, far = 1000) {
			this.isFog = true;
			this.name = '';
			this.color = new Color(color);
			this.near = near;
			this.far = far;
		}
		clone() {
			return new Fog(this.color, this.near, this.far);
		}
		toJSON( /* meta */ ) {
			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};
		}
	}
	class Scene extends Object3D {
		constructor() {
			super();
			this.isScene = true;
			this.type = 'Scene';
			this.background = null;
			this.environment = null;
			this.fog = null;
			this.backgroundBlurriness = 0;
			this.backgroundIntensity = 1;
			this.overrideMaterial = null;
			if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
				__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
					detail: this
				}));
			}
		}
		copy(source, recursive) {
			super.copy(source, recursive);
			if (source.background !== null) this.background = source.background.clone();
			if (source.environment !== null) this.environment = source.environment.clone();
			if (source.fog !== null) this.fog = source.fog.clone();
			this.backgroundBlurriness = source.backgroundBlurriness;
			this.backgroundIntensity = source.backgroundIntensity;
			if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			return this;
		}
		toJSON(meta) {
			const data = super.toJSON(meta);
			if (this.fog !== null) data.object.fog = this.fog.toJSON();
			if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;
			if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;
			return data;
		}
		// @deprecated
		get autoUpdate() {
			console.warn('THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.');
			return this.matrixWorldAutoUpdate;
		}
		set autoUpdate(value) {
			console.warn('THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.');
			this.matrixWorldAutoUpdate = value;
		}
	}
	class InterleavedBuffer {
		constructor(array, stride) {
			this.isInterleavedBuffer = true;
			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;
			this.usage = StaticDrawUsage;
			this.updateRange = {
				offset: 0,
				count: -1
			};
			this.version = 0;
			this.uuid = generateUUID();
		}
		onUploadCallback() {}
		set needsUpdate(value) {
			if (value === true) this.version++;
		}
		setUsage(value) {
			this.usage = value;
			return this;
		}
		copy(source) {
			this.array = new source.array.constructor(source.array);
			this.count = source.count;
			this.stride = source.stride;
			this.usage = source.usage;
			return this;
		}
		copyAt(index1, attribute, index2) {
			index1 *= this.stride;
			index2 *= attribute.stride;
			for (let i = 0, l = this.stride; i < l; i++) {
				this.array[index1 + i] = attribute.array[index2 + i];
			}
			return this;
		}
		set(value, offset = 0) {
			this.array.set(value, offset);
			return this;
		}
		clone(data) {
			if (data.arrayBuffers === undefined) {
				data.arrayBuffers = {};
			}
			if (this.array.buffer._uuid === undefined) {
				this.array.buffer._uuid = generateUUID();
			}
			if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
				data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
			}
			const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
			const ib = new this.constructor(array, this.stride);
			ib.setUsage(this.usage);
			return ib;
		}
		onUpload(callback) {
			this.onUploadCallback = callback;
			return this;
		}
		toJSON(data) {
			if (data.arrayBuffers === undefined) {
				data.arrayBuffers = {};
			}
			// generate UUID for array buffer if necessary
			if (this.array.buffer._uuid === undefined) {
				this.array.buffer._uuid = generateUUID();
			}
			if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
				data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
			}
			//
			return {
				uuid: this.uuid,
				buffer: this.array.buffer._uuid,
				type: this.array.constructor.name,
				stride: this.stride
			};
		}
	}
	const _vector$6 = /*@__PURE__*/ new Vector3();
	class InterleavedBufferAttribute {
		constructor(interleavedBuffer, itemSize, offset, normalized = false) {
			this.isInterleavedBufferAttribute = true;
			this.name = '';
			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;
			this.normalized = normalized;
		}
		get count() {
			return this.data.count;
		}
		get array() {
			return this.data.array;
		}
		set needsUpdate(value) {
			this.data.needsUpdate = value;
		}
		applyMatrix4(m) {
			for (let i = 0, l = this.data.count; i < l; i++) {
				_vector$6.fromBufferAttribute(this, i);
				_vector$6.applyMatrix4(m);
				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}
			return this;
		}
		applyNormalMatrix(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$6.fromBufferAttribute(this, i);
				_vector$6.applyNormalMatrix(m);
				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}
			return this;
		}
		transformDirection(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$6.fromBufferAttribute(this, i);
				_vector$6.transformDirection(m);
				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}
			return this;
		}
		setX(index, x) {
			if (this.normalized) x = normalize(x, this.array);
			this.data.array[index * this.data.stride + this.offset] = x;
			return this;
		}
		setY(index, y) {
			if (this.normalized) y = normalize(y, this.array);
			this.data.array[index * this.data.stride + this.offset + 1] = y;
			return this;
		}
		setZ(index, z) {
			if (this.normalized) z = normalize(z, this.array);
			this.data.array[index * this.data.stride + this.offset + 2] = z;
			return this;
		}
		setW(index, w) {
			if (this.normalized) w = normalize(w, this.array);
			this.data.array[index * this.data.stride + this.offset + 3] = w;
			return this;
		}
		getX(index) {
			let x = this.data.array[index * this.data.stride + this.offset];
			if (this.normalized) x = denormalize(x, this.array);
			return x;
		}
		getY(index) {
			let y = this.data.array[index * this.data.stride + this.offset + 1];
			if (this.normalized) y = denormalize(y, this.array);
			return y;
		}
		getZ(index) {
			let z = this.data.array[index * this.data.stride + this.offset + 2];
			if (this.normalized) z = denormalize(z, this.array);
			return z;
		}
		getW(index) {
			let w = this.data.array[index * this.data.stride + this.offset + 3];
			if (this.normalized) w = denormalize(w, this.array);
			return w;
		}
		setXY(index, x, y) {
			index = index * this.data.stride + this.offset;
			if (this.normalized) {
				x = normalize(x, this.array);
				y = normalize(y, this.array);
			}
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			return this;
		}
		setXYZ(index, x, y, z) {
			index = index * this.data.stride + this.offset;
			if (this.normalized) {
				x = normalize(x, this.array);
				y = normalize(y, this.array);
				z = normalize(z, this.array);
			}
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;
			return this;
		}
		setXYZW(index, x, y, z, w) {
			index = index * this.data.stride + this.offset;
			if (this.normalized) {
				x = normalize(x, this.array);
				y = normalize(y, this.array);
				z = normalize(z, this.array);
				w = normalize(w, this.array);
			}
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;
			this.data.array[index + 3] = w;
			return this;
		}
		clone(data) {
			if (data === undefined) {
				console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.');
				const array = [];
				for (let i = 0; i < this.count; i++) {
					const index = i * this.data.stride + this.offset;
					for (let j = 0; j < this.itemSize; j++) {
						array.push(this.data.array[index + j]);
					}
				}
				return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
			} else {
				if (data.interleavedBuffers === undefined) {
					data.interleavedBuffers = {};
				}
				if (data.interleavedBuffers[this.data.uuid] === undefined) {
					data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
				}
				return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
			}
		}
		toJSON(data) {
			if (data === undefined) {
				console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.');
				const array = [];
				for (let i = 0; i < this.count; i++) {
					const index = i * this.data.stride + this.offset;
					for (let j = 0; j < this.itemSize; j++) {
						array.push(this.data.array[index + j]);
					}
				}
				// de-interleave data and save it as an ordinary buffer attribute for now
				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: array,
					normalized: this.normalized
				};
			} else {
				// save as true interleaved attribute
				if (data.interleavedBuffers === undefined) {
					data.interleavedBuffers = {};
				}
				if (data.interleavedBuffers[this.data.uuid] === undefined) {
					data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
				}
				return {
					isInterleavedBufferAttribute: true,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized
				};
			}
		}
	}
	class SpriteMaterial extends Material {
		constructor(parameters) {
			super();
			this.isSpriteMaterial = true;
			this.type = 'SpriteMaterial';
			this.color = new Color(0xffffff);
			this.map = null;
			this.alphaMap = null;
			this.rotation = 0;
			this.sizeAttenuation = true;
			this.transparent = true;
			this.fog = true;
			this.setValues(parameters);
		}
		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.rotation = source.rotation;
			this.sizeAttenuation = source.sizeAttenuation;
			this.fog = source.fog;
			return this;
		}
	}
	let _geometry;
	const _intersectPoint = /*@__PURE__*/ new Vector3();
	const _worldScale = /*@__PURE__*/ new Vector3();
	const _mvPosition = /*@__PURE__*/ new Vector3();
	const _alignedPosition = /*@__PURE__*/ new Vector2();
	const _rotatedPosition = /*@__PURE__*/ new Vector2();
	const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();
	const _vA = /*@__PURE__*/ new Vector3();
	const _vB = /*@__PURE__*/ new Vector3();
	const _vC = /*@__PURE__*/ new Vector3();
	const _uvA = /*@__PURE__*/ new Vector2();
	const _uvB = /*@__PURE__*/ new Vector2();
	const _uvC = /*@__PURE__*/ new Vector2();
	class Sprite extends Object3D {
		constructor(material) {
			super();
			this.isSprite = true;
			this.type = 'Sprite';
			if (_geometry === undefined) {
				_geometry = new BufferGeometry();
				const float32Array = new Float32Array([
					-0.5, -0.5, 0, 0, 0,
					0.5, -0.5, 0, 1, 0,
					0.5, 0.5, 0, 1, 1,
					-0.5, 0.5, 0, 0, 1
				]);
				const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
				_geometry.setIndex([0, 1, 2, 0, 2, 3]);
				_geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
				_geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
			}
			this.geometry = _geometry;
			this.material = (material !== undefined) ? material : new SpriteMaterial();
			this.center = new Vector2(0.5, 0.5);
		}
		raycast(raycaster, intersects) {
			if (raycaster.camera === null) {
				console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
			}
			_worldScale.setFromMatrixScale(this.matrixWorld);
			_viewWorldMatrix.copy(raycaster.camera.matrixWorld);
			this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
			_mvPosition.setFromMatrixPosition(this.modelViewMatrix);
			if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
				_worldScale.multiplyScalar(-_mvPosition.z);
			}
			const rotation = this.material.rotation;
			let sin, cos;
			if (rotation !== 0) {
				cos = Math.cos(rotation);
				sin = Math.sin(rotation);
			}
			const center = this.center;
			transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
			transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
			transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
			_uvA.set(0, 0);
			_uvB.set(1, 0);
			_uvC.set(1, 1);
			// check first triangle
			let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
			if (intersect === null) {
				// check second triangle
				transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
				_uvB.set(0, 1);
				intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
				if (intersect === null) {
					return;
				}
			}
			const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
			if (distance < raycaster.near || distance > raycaster.far) return;
			intersects.push({
				distance: distance,
				point: _intersectPoint.clone(),
				uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
				face: null,
				object: this
			});
		}
		copy(source, recursive) {
			super.copy(source, recursive);
			if (source.center !== undefined) this.center.copy(source.center);
			this.material = source.material;
			return this;
		}
	}

	function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
		// compute position in camera space
		_alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
		// to check if rotation is not zero
		if (sin !== undefined) {
			_rotatedPosition.x = (cos * _alignedPosition.x) - (sin * _alignedPosition.y);
			_rotatedPosition.y = (sin * _alignedPosition.x) + (cos * _alignedPosition.y);
		} else {
			_rotatedPosition.copy(_alignedPosition);
		}
		vertexPosition.copy(mvPosition);
		vertexPosition.x += _rotatedPosition.x;
		vertexPosition.y += _rotatedPosition.y;
		// transform to world space
		vertexPosition.applyMatrix4(_viewWorldMatrix);
	}
	const _v1$2 = /*@__PURE__*/ new Vector3();
	const _v2$1 = /*@__PURE__*/ new Vector3();
	class LOD extends Object3D {
		constructor() {
			super();
			this._currentLevel = 0;
			this.type = 'LOD';
			Object.defineProperties(this, {
				levels: {
					enumerable: true,
					value: []
				},
				isLOD: {
					value: true,
				}
			});
			this.autoUpdate = true;
		}
		copy(source) {
			super.copy(source, false);
			const levels = source.levels;
			for (let i = 0, l = levels.length; i < l; i++) {
				const level = levels[i];
				this.addLevel(level.object.clone(), level.distance, level.hysteresis);
			}
			this.autoUpdate = source.autoUpdate;
			return this;
		}
		addLevel(object, distance = 0, hysteresis = 0) {
			distance = Math.abs(distance);
			const levels = this.levels;
			let l;
			for (l = 0; l < levels.length; l++) {
				if (distance < levels[l].distance) {
					break;
				}
			}
			levels.splice(l, 0, {
				distance: distance,
				hysteresis: hysteresis,
				object: object
			});
			this.add(object);
			return this;
		}
		getCurrentLevel() {
			return this._currentLevel;
		}
		getObjectForDistance(distance) {
			const levels = this.levels;
			if (levels.length > 0) {
				let i, l;
				for (i = 1, l = levels.length; i < l; i++) {
					let levelDistance = levels[i].distance;
					if (levels[i].object.visible) {
						levelDistance -= levelDistance * levels[i].hysteresis;
					}
					if (distance < levelDistance) {
						break;
					}
				}
				return levels[i - 1].object;
			}
			return null;
		}
		raycast(raycaster, intersects) {
			const levels = this.levels;
			if (levels.length > 0) {
				_v1$2.setFromMatrixPosition(this.matrixWorld);
				const distance = raycaster.ray.origin.distanceTo(_v1$2);
				this.getObjectForDistance(distance).raycast(raycaster, intersects);
			}
		}
		update(camera) {
			const levels = this.levels;
			if (levels.length > 1) {
				_v1$2.setFromMatrixPosition(camera.matrixWorld);
				_v2$1.setFromMatrixPosition(this.matrixWorld);
				const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
				levels[0].object.visible = true;
				let i, l;
				for (i = 1, l = levels.length; i < l; i++) {
					let levelDistance = levels[i].distance;
					if (levels[i].object.visible) {
						levelDistance -= levelDistance * levels[i].hysteresis;
					}
					if (distance >= levelDistance) {
						levels[i - 1].object.visible = false;
						levels[i].object.visible = true;
					} else {
						break;
					}
				}
				this._currentLevel = i - 1;
				for (; i < l; i++) {
					levels[i].object.visible = false;
				}
			}
		}
		toJSON(meta) {
			const data = super.toJSON(meta);
			if (this.autoUpdate === false) data.object.autoUpdate = false;
			data.object.levels = [];
			const levels = this.levels;
			for (let i = 0, l = levels.length; i < l; i++) {
				const level = levels[i];
				data.object.levels.push({
					object: level.object.uuid,
					distance: level.distance,
					hysteresis: level.hysteresis
				});
			}
			return data;
		}
	}
	const _basePosition = /*@__PURE__*/ new Vector3();
	const _skinIndex = /*@__PURE__*/ new Vector4();
	const _skinWeight = /*@__PURE__*/ new Vector4();
	const _vector$5 = /*@__PURE__*/ new Vector3();
	const _matrix = /*@__PURE__*/ new Matrix4();
	class SkinnedMesh extends Mesh {
		constructor(geometry, material) {
			super(geometry, material);
			this.isSkinnedMesh = true;
			this.type = 'SkinnedMesh';
			this.bindMode = 'attached';
			this.bindMatrix = new Matrix4();
			this.bindMatrixInverse = new Matrix4();
		}
		copy(source, recursive) {
			super.copy(source, recursive);
			this.bindMode = source.bindMode;
			this.bindMatrix.copy(source.bindMatrix);
			this.bindMatrixInverse.copy(source.bindMatrixInverse);
			this.skeleton = source.skeleton;
			return this;
		}
		bind(skeleton, bindMatrix) {
			this.skeleton = skeleton;
			if (bindMatrix === undefined) {
				this.updateMatrixWorld(true);
				this.skeleton.calculateInverses();
				bindMatrix = this.matrixWorld;
			}
			this.bindMatrix.copy(bindMatrix);
			this.bindMatrixInverse.copy(bindMatrix).invert();
		}
		pose() {
			this.skeleton.pose();
		}
		normalizeSkinWeights() {
			const vector = new Vector4();
			const skinWeight = this.geometry.attributes.skinWeight;
			for (let i = 0, l = skinWeight.count; i < l; i++) {
				vector.fromBufferAttribute(skinWeight, i);
				const scale = 1.0 / vector.manhattanLength();
				if (scale !== Infinity) {
					vector.multiplyScalar(scale);
				} else {
					vector.set(1, 0, 0, 0); // do something reasonable
				}
				skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
			}
		}
		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);
			if (this.bindMode === 'attached') {
				this.bindMatrixInverse.copy(this.matrixWorld).invert();
			} else if (this.bindMode === 'detached') {
				this.bindMatrixInverse.copy(this.bindMatrix).invert();
			} else {
				console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
			}
		}
		boneTransform(index, target) {
			const skeleton = this.skeleton;
			const geometry = this.geometry;
			_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
			_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
			_basePosition.copy(target).applyMatrix4(this.bindMatrix);
			target.set(0, 0, 0);
			for (let i = 0; i < 4; i++) {
				const weight = _skinWeight.getComponent(i);
				if (weight !== 0) {
					const boneIndex = _skinIndex.getComponent(i);
					_matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
					target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
				}
			}
			return target.applyMatrix4(this.bindMatrixInverse);
		}
	}
	class Bone extends Object3D {
		constructor() {
			super();
			this.isBone = true;
			this.type = 'Bone';
		}
	}
	class DataTexture extends Texture {
		constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
			this.isDataTexture = true;
			this.image = {
				data: data,
				width: width,
				height: height
			};
			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;
		}
	}
	const _offsetMatrix = /*@__PURE__*/ new Matrix4();
	const _identityMatrix = /*@__PURE__*/ new Matrix4();
	class Skeleton {
		constructor(bones = [], boneInverses = []) {
			this.uuid = generateUUID();
			this.bones = bones.slice(0);
			this.boneInverses = boneInverses;
			this.boneMatrices = null;
			this.boneTexture = null;
			this.boneTextureSize = 0;
			this.frame = -1;
			this.init();
		}
		init() {
			const bones = this.bones;
			const boneInverses = this.boneInverses;
			this.boneMatrices = new Float32Array(bones.length * 16);
			// calculate inverse bone matrices if necessary
			if (boneInverses.length === 0) {
				this.calculateInverses();
			} else {
				// handle special case
				if (bones.length !== boneInverses.length) {
					console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
					this.boneInverses = [];
					for (let i = 0, il = this.bones.length; i < il; i++) {
						this.boneInverses.push(new Matrix4());
					}
				}
			}
		}
		calculateInverses() {
			this.boneInverses.length = 0;
			for (let i = 0, il = this.bones.length; i < il; i++) {
				const inverse = new Matrix4();
				if (this.bones[i]) {
					inverse.copy(this.bones[i].matrixWorld).invert();
				}
				this.boneInverses.push(inverse);
			}
		}
		pose() {
			// recover the bind-time world matrices
			for (let i = 0, il = this.bones.length; i < il; i++) {
				const bone = this.bones[i];
				if (bone) {
					bone.matrixWorld.copy(this.boneInverses[i]).invert();
				}
			}
			// compute the local matrices, positions, rotations and scales
			for (let i = 0, il = this.bones.length; i < il; i++) {
				const bone = this.bones[i];
				if (bone) {
					if (bone.parent && bone.parent.isBone) {
						bone.matrix.copy(bone.parent.matrixWorld).invert();
						bone.matrix.multiply(bone.matrixWorld);
					} else {
						bone.matrix.copy(bone.matrixWorld);
					}
					bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
				}
			}
		}
		update() {
			const bones = this.bones;
			const boneInverses = this.boneInverses;
			const boneMatrices = this.boneMatrices;
			const boneTexture = this.boneTexture;
			// flatten bone matrices to array
			for (let i = 0, il = bones.length; i < il; i++) {
				// compute the offset between the current and the original transform
				const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
				_offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
				_offsetMatrix.toArray(boneMatrices, i * 16);
			}
			if (boneTexture !== null) {
				boneTexture.needsUpdate = true;
			}
		}
		clone() {
			return new Skeleton(this.bones, this.boneInverses);
		}
		computeBoneTexture() {
			// layout (1 matrix = 4 pixels)
			//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
			//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
			//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
			//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
			let size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix
			size = ceilPowerOfTwo(size);
			size = Math.max(size, 4);
			const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
			boneMatrices.set(this.boneMatrices); // copy current values
			const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
			boneTexture.needsUpdate = true;
			this.boneMatrices = boneMatrices;
			this.boneTexture = boneTexture;
			this.boneTextureSize = size;
			return this;
		}
		getBoneByName(name) {
			for (let i = 0, il = this.bones.length; i < il; i++) {
				const bone = this.bones[i];
				if (bone.name === name) {
					return bone;
				}
			}
			return undefined;
		}
		dispose() {
			if (this.boneTexture !== null) {
				this.boneTexture.dispose();
				this.boneTexture = null;
			}
		}
		fromJSON(json, bones) {
			this.uuid = json.uuid;
			for (let i = 0, l = json.bones.length; i < l; i++) {
				const uuid = json.bones[i];
				let bone = bones[uuid];
				if (bone === undefined) {
					console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
					bone = new Bone();
				}
				this.bones.push(bone);
				this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
			}
			this.init();
			return this;
		}
		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'Skeleton',
					generator: 'Skeleton.toJSON'
				},
				bones: [],
				boneInverses: []
			};
			data.uuid = this.uuid;
			const bones = this.bones;
			const boneInverses = this.boneInverses;
			for (let i = 0, l = bones.length; i < l; i++) {
				const bone = bones[i];
				data.bones.push(bone.uuid);
				const boneInverse = boneInverses[i];
				data.boneInverses.push(boneInverse.toArray());
			}
			return data;
		}
	}
	class InstancedBufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized, meshPerAttribute = 1) {
			super(array, itemSize, normalized);
			this.isInstancedBufferAttribute = true;
			this.meshPerAttribute = meshPerAttribute;
		}
		copy(source) {
			super.copy(source);
			this.meshPerAttribute = source.meshPerAttribute;
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			data.meshPerAttribute = this.meshPerAttribute;
			data.isInstancedBufferAttribute = true;
			return data;
		}
	}
	const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
	const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();
	const _instanceIntersects = [];
	const _identity = /*@__PURE__*/ new Matrix4();
	const _mesh = /*@__PURE__*/ new Mesh();
	class InstancedMesh extends Mesh {
		constructor(geometry, material, count) {
			super(geometry, material);
			this.isInstancedMesh = true;
			this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
			this.instanceColor = null;
			this.count = count;
			this.frustumCulled = false;
			for (let i = 0; i < count; i++) {
				this.setMatrixAt(i, _identity);
			}
		}
		copy(source, recursive) {
			super.copy(source, recursive);
			this.instanceMatrix.copy(source.instanceMatrix);
			if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
			this.count = source.count;
			return this;
		}
		getColorAt(index, color) {
			color.fromArray(this.instanceColor.array, index * 3);
		}
		getMatrixAt(index, matrix) {
			matrix.fromArray(this.instanceMatrix.array, index * 16);
		}
		raycast(raycaster, intersects) {
			const matrixWorld = this.matrixWorld;
			const raycastTimes = this.count;
			_mesh.geometry = this.geometry;
			_mesh.material = this.material;
			if (_mesh.material === undefined) return;
			for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
				// calculate the world matrix for each instance
				this.getMatrixAt(instanceId, _instanceLocalMatrix);
				_instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
				// the mesh represents this single instance
				_mesh.matrixWorld = _instanceWorldMatrix;
				_mesh.raycast(raycaster, _instanceIntersects);
				// process the result of raycast
				for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
					const intersect = _instanceIntersects[i];
					intersect.instanceId = instanceId;
					intersect.object = this;
					intersects.push(intersect);
				}
				_instanceIntersects.length = 0;
			}
		}
		setColorAt(index, color) {
			if (this.instanceColor === null) {
				this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
			}
			color.toArray(this.instanceColor.array, index * 3);
		}
		setMatrixAt(index, matrix) {
			matrix.toArray(this.instanceMatrix.array, index * 16);
		}
		updateMorphTargets() {}
		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}
	}
	class LineBasicMaterial extends Material {
		constructor(parameters) {
			super();
			this.isLineBasicMaterial = true;
			this.type = 'LineBasicMaterial';
			this.color = new Color(0xffffff);
			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';
			this.fog = true;
			this.setValues(parameters);
		}
		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;
			this.fog = source.fog;
			return this;
		}
	}
	const _start$1 = /*@__PURE__*/ new Vector3();
	const _end$1 = /*@__PURE__*/ new Vector3();
	const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
	const _ray$1 = /*@__PURE__*/ new Ray();
	const _sphere$1 = /*@__PURE__*/ new Sphere();
	class Line extends Object3D {
		constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
			super();
			this.isLine = true;
			this.type = 'Line';
			this.geometry = geometry;
			this.material = material;
			this.updateMorphTargets();
		}
		copy(source, recursive) {
			super.copy(source, recursive);
			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		}
		computeLineDistances() {
			const geometry = this.geometry;
			// we assume non-indexed geometry
			if (geometry.index === null) {
				const positionAttribute = geometry.attributes.position;
				const lineDistances = [0];
				for (let i = 1, l = positionAttribute.count; i < l; i++) {
					_start$1.fromBufferAttribute(positionAttribute, i - 1);
					_end$1.fromBufferAttribute(positionAttribute, i);
					lineDistances[i] = lineDistances[i - 1];
					lineDistances[i] += _start$1.distanceTo(_end$1);
				}
				geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
			} else {
				console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
			}
			return this;
		}
		raycast(raycaster, intersects) {
			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Line.threshold;
			const drawRange = geometry.drawRange;
			// Checking boundingSphere distance to ray
			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
			_sphere$1.copy(geometry.boundingSphere);
			_sphere$1.applyMatrix4(matrixWorld);
			_sphere$1.radius += threshold;
			if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;
			//
			_inverseMatrix$1.copy(matrixWorld).invert();
			_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
			const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
			const localThresholdSq = localThreshold * localThreshold;
			const vStart = new Vector3();
			const vEnd = new Vector3();
			const interSegment = new Vector3();
			const interRay = new Vector3();
			const step = this.isLineSegments ? 2 : 1;
			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;
			if (index !== null) {
				const start = Math.max(0, drawRange.start);
				const end = Math.min(index.count, (drawRange.start + drawRange.count));
				for (let i = start, l = end - 1; i < l; i += step) {
					const a = index.getX(i);
					const b = index.getX(i + 1);
					vStart.fromBufferAttribute(positionAttribute, a);
					vEnd.fromBufferAttribute(positionAttribute, b);
					const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
					if (distSq > localThresholdSq) continue;
					interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
					const distance = raycaster.ray.origin.distanceTo(interRay);
					if (distance < raycaster.near || distance > raycaster.far) continue;
					intersects.push({
						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4(this.matrixWorld),
						index: i,
						face: null,
						faceIndex: null,
						object: this
					});
				}
			} else {
				const start = Math.max(0, drawRange.start);
				const end = Math.min(positionAttribute.count, (drawRange.start + drawRange.count));
				for (let i = start, l = end - 1; i < l; i += step) {
					vStart.fromBufferAttribute(positionAttribute, i);
					vEnd.fromBufferAttribute(positionAttribute, i + 1);
					const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
					if (distSq > localThresholdSq) continue;
					interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
					const distance = raycaster.ray.origin.distanceTo(interRay);
					if (distance < raycaster.near || distance > raycaster.far) continue;
					intersects.push({
						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4(this.matrixWorld),
						index: i,
						face: null,
						faceIndex: null,
						object: this
					});
				}
			}
		}
		updateMorphTargets() {
			const geometry = this.geometry;
			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys(morphAttributes);
			if (keys.length > 0) {
				const morphAttribute = morphAttributes[keys[0]];
				if (morphAttribute !== undefined) {
					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};
					for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
						const name = morphAttribute[m].name || String(m);
						this.morphTargetInfluences.push(0);
						this.morphTargetDictionary[name] = m;
					}
				}
			}
		}
	}
	const _start = /*@__PURE__*/ new Vector3();
	const _end = /*@__PURE__*/ new Vector3();
	class LineSegments extends Line {
		constructor(geometry, material) {
			super(geometry, material);
			this.isLineSegments = true;
			this.type = 'LineSegments';
		}
		computeLineDistances() {
			const geometry = this.geometry;
			// we assume non-indexed geometry
			if (geometry.index === null) {
				const positionAttribute = geometry.attributes.position;
				const lineDistances = [];
				for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
					_start.fromBufferAttribute(positionAttribute, i);
					_end.fromBufferAttribute(positionAttribute, i + 1);
					lineDistances[i] = (i === 0) ? 0 : lineDistances[i - 1];
					lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
				}
				geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
			} else {
				console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
			}
			return this;
		}
	}
	class LineLoop extends Line {
		constructor(geometry, material) {
			super(geometry, material);
			this.isLineLoop = true;
			this.type = 'LineLoop';
		}
	}
	class PointsMaterial extends Material {
		constructor(parameters) {
			super();
			this.isPointsMaterial = true;
			this.type = 'PointsMaterial';
			this.color = new Color(0xffffff);
			this.map = null;
			this.alphaMap = null;
			this.size = 1;
			this.sizeAttenuation = true;
			this.fog = true;
			this.setValues(parameters);
		}
		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;
			this.fog = source.fog;
			return this;
		}
	}
	const _inverseMatrix = /*@__PURE__*/ new Matrix4();
	const _ray = /*@__PURE__*/ new Ray();
	const _sphere = /*@__PURE__*/ new Sphere();
	const _position$2 = /*@__PURE__*/ new Vector3();
	class Points extends Object3D {
		constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
			super();
			this.isPoints = true;
			this.type = 'Points';
			this.geometry = geometry;
			this.material = material;
			this.updateMorphTargets();
		}
		copy(source, recursive) {
			super.copy(source, recursive);
			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		}
		raycast(raycaster, intersects) {
			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Points.threshold;
			const drawRange = geometry.drawRange;
			// Checking boundingSphere distance to ray
			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
			_sphere.copy(geometry.boundingSphere);
			_sphere.applyMatrix4(matrixWorld);
			_sphere.radius += threshold;
			if (raycaster.ray.intersectsSphere(_sphere) === false) return;
			//
			_inverseMatrix.copy(matrixWorld).invert();
			_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
			const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
			const localThresholdSq = localThreshold * localThreshold;
			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;
			if (index !== null) {
				const start = Math.max(0, drawRange.start);
				const end = Math.min(index.count, (drawRange.start + drawRange.count));
				for (let i = start, il = end; i < il; i++) {
					const a = index.getX(i);
					_position$2.fromBufferAttribute(positionAttribute, a);
					testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
				}
			} else {
				const start = Math.max(0, drawRange.start);
				const end = Math.min(positionAttribute.count, (drawRange.start + drawRange.count));
				for (let i = start, l = end; i < l; i++) {
					_position$2.fromBufferAttribute(positionAttribute, i);
					testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
				}
			}
		}
		updateMorphTargets() {
			const geometry = this.geometry;
			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys(morphAttributes);
			if (keys.length > 0) {
				const morphAttribute = morphAttributes[keys[0]];
				if (morphAttribute !== undefined) {
					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};
					for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
						const name = morphAttribute[m].name || String(m);
						this.morphTargetInfluences.push(0);
						this.morphTargetDictionary[name] = m;
					}
				}
			}
		}
	}

	function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
		const rayPointDistanceSq = _ray.distanceSqToPoint(point);
		if (rayPointDistanceSq < localThresholdSq) {
			const intersectPoint = new Vector3();
			_ray.closestPointToPoint(point, intersectPoint);
			intersectPoint.applyMatrix4(matrixWorld);
			const distance = raycaster.ray.origin.distanceTo(intersectPoint);
			if (distance < raycaster.near || distance > raycaster.far) return;
			intersects.push({
				distance: distance,
				distanceToRay: Math.sqrt(rayPointDistanceSq),
				point: intersectPoint,
				index: index,
				face: null,
				object: object
			});
		}
	}
	class VideoTexture extends Texture {
		constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
			super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
			this.isVideoTexture = true;
			this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
			this.generateMipmaps = false;
			const scope = this;

			function updateVideo() {
				scope.needsUpdate = true;
				video.requestVideoFrameCallback(updateVideo);
			}
			if ('requestVideoFrameCallback' in video) {
				video.requestVideoFrameCallback(updateVideo);
			}
		}
		clone() {
			return new this.constructor(this.image).copy(this);
		}
		update() {
			const video = this.image;
			const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;
			if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
				this.needsUpdate = true;
			}
		}
	}
	class FramebufferTexture extends Texture {
		constructor(width, height, format) {
			super({
				width,
				height
			});
			this.isFramebufferTexture = true;
			this.format = format;
			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;
			this.generateMipmaps = false;
			this.needsUpdate = true;
		}
	}
	class CompressedTexture extends Texture {
		constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
			this.isCompressedTexture = true;
			this.image = {
				width: width,
				height: height
			};
			this.mipmaps = mipmaps;
			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )
			this.flipY = false;
			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files
			this.generateMipmaps = false;
		}
	}
	class CompressedArrayTexture extends CompressedTexture {
		constructor(mipmaps, width, height, depth, format, type) {
			super(mipmaps, width, height, format, type);
			this.isCompressedArrayTexture = true;
			this.image.depth = depth;
			this.wrapR = ClampToEdgeWrapping;
		}
	}
	class CanvasTexture extends Texture {
		constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
			super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
			this.isCanvasTexture = true;
			this.needsUpdate = true;
		}
	}
	/**
	 * Extensible curve object.
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/
	class Curve {
		constructor() {
			this.type = 'Curve';
			this.arcLengthDivisions = 200;
		}
		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]
		getPoint( /* t, optionalTarget */ ) {
			console.warn('THREE.Curve: .getPoint() not implemented.');
			return null;
		}
		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]
		getPointAt(u, optionalTarget) {
			const t = this.getUtoTmapping(u);
			return this.getPoint(t, optionalTarget);
		}
		// Get sequence of points using getPoint( t )
		getPoints(divisions = 5) {
			const points = [];
			for (let d = 0; d <= divisions; d++) {
				points.push(this.getPoint(d / divisions));
			}
			return points;
		}
		// Get sequence of points using getPointAt( u )
		getSpacedPoints(divisions = 5) {
			const points = [];
			for (let d = 0; d <= divisions; d++) {
				points.push(this.getPointAt(d / divisions));
			}
			return points;
		}
		// Get total curve arc length
		getLength() {
			const lengths = this.getLengths();
			return lengths[lengths.length - 1];
		}
		// Get list of cumulative segment lengths
		getLengths(divisions = this.arcLengthDivisions) {
			if (this.cacheArcLengths &&
				(this.cacheArcLengths.length === divisions + 1) &&
				!this.needsUpdate) {
				return this.cacheArcLengths;
			}
			this.needsUpdate = false;
			const cache = [];
			let current, last = this.getPoint(0);
			let sum = 0;
			cache.push(0);
			for (let p = 1; p <= divisions; p++) {
				current = this.getPoint(p / divisions);
				sum += current.distanceTo(last);
				cache.push(sum);
				last = current;
			}
			this.cacheArcLengths = cache;
			return cache; // { sums: cache, sum: sum }; Sum is in the last element.
		}
		updateArcLengths() {
			this.needsUpdate = true;
			this.getLengths();
		}
		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
		getUtoTmapping(u, distance) {
			const arcLengths = this.getLengths();
			let i = 0;
			const il = arcLengths.length;
			let targetArcLength; // The targeted u distance value to get
			if (distance) {
				targetArcLength = distance;
			} else {
				targetArcLength = u * arcLengths[il - 1];
			}
			// binary search for the index with largest value smaller than target u distance
			let low = 0,
				high = il - 1,
				comparison;
			while (low <= high) {
				i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
				comparison = arcLengths[i] - targetArcLength;
				if (comparison < 0) {
					low = i + 1;
				} else if (comparison > 0) {
					high = i - 1;
				} else {
					high = i;
					break;
					// DONE
				}
			}
			i = high;
			if (arcLengths[i] === targetArcLength) {
				return i / (il - 1);
			}
			// we could get finer grain at lengths, or use simple interpolation between two points
			const lengthBefore = arcLengths[i];
			const lengthAfter = arcLengths[i + 1];
			const segmentLength = lengthAfter - lengthBefore;
			// determine where we are between the 'before' and 'after' points
			const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
			// add that fractional amount to t
			const t = (i + segmentFraction) / (il - 1);
			return t;
		}
		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation
		getTangent(t, optionalTarget) {
			const delta = 0.0001;
			let t1 = t - delta;
			let t2 = t + delta;
			// Capping in case of danger
			if (t1 < 0) t1 = 0;
			if (t2 > 1) t2 = 1;
			const pt1 = this.getPoint(t1);
			const pt2 = this.getPoint(t2);
			const tangent = optionalTarget || ((pt1.isVector2) ? new Vector2() : new Vector3());
			tangent.copy(pt2).sub(pt1).normalize();
			return tangent;
		}
		getTangentAt(u, optionalTarget) {
			const t = this.getUtoTmapping(u);
			return this.getTangent(t, optionalTarget);
		}
		computeFrenetFrames(segments, closed) {
			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
			const normal = new Vector3();
			const tangents = [];
			const normals = [];
			const binormals = [];
			const vec = new Vector3();
			const mat = new Matrix4();
			// compute the tangent vectors for each segment on the curve
			for (let i = 0; i <= segments; i++) {
				const u = i / segments;
				tangents[i] = this.getTangentAt(u, new Vector3());
			}
			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component
			normals[0] = new Vector3();
			binormals[0] = new Vector3();
			let min = Number.MAX_VALUE;
			const tx = Math.abs(tangents[0].x);
			const ty = Math.abs(tangents[0].y);
			const tz = Math.abs(tangents[0].z);
			if (tx <= min) {
				min = tx;
				normal.set(1, 0, 0);
			}
			if (ty <= min) {
				min = ty;
				normal.set(0, 1, 0);
			}
			if (tz <= min) {
				normal.set(0, 0, 1);
			}
			vec.crossVectors(tangents[0], normal).normalize();
			normals[0].crossVectors(tangents[0], vec);
			binormals[0].crossVectors(tangents[0], normals[0]);
			// compute the slowly-varying normal and binormal vectors for each segment on the curve
			for (let i = 1; i <= segments; i++) {
				normals[i] = normals[i - 1].clone();
				binormals[i] = binormals[i - 1].clone();
				vec.crossVectors(tangents[i - 1], tangents[i]);
				if (vec.length() > Number.EPSILON) {
					vec.normalize();
					const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors
					normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
				}
				binormals[i].crossVectors(tangents[i], normals[i]);
			}
			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
			if (closed === true) {
				let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
				theta /= segments;
				if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
					theta = -theta;
				}
				for (let i = 1; i <= segments; i++) {
					// twist a little...
					normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
					binormals[i].crossVectors(tangents[i], normals[i]);
				}
			}
			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};
		}
		clone() {
			return new this.constructor().copy(this);
		}
		copy(source) {
			this.arcLengthDivisions = source.arcLengthDivisions;
			return this;
		}
		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};
			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;
			return data;
		}
		fromJSON(json) {
			this.arcLengthDivisions = json.arcLengthDivisions;
			return this;
		}
	}
	class EllipseCurve extends Curve {
		constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
			super();
			this.isEllipseCurve = true;
			this.type = 'EllipseCurve';
			this.aX = aX;
			this.aY = aY;
			this.xRadius = xRadius;
			this.yRadius = yRadius;
			this.aStartAngle = aStartAngle;
			this.aEndAngle = aEndAngle;
			this.aClockwise = aClockwise;
			this.aRotation = aRotation;
		}
		getPoint(t, optionalTarget) {
			const point = optionalTarget || new Vector2();
			const twoPi = Math.PI * 2;
			let deltaAngle = this.aEndAngle - this.aStartAngle;
			const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
			// ensures that deltaAngle is 0 .. 2 PI
			while (deltaAngle < 0) deltaAngle += twoPi;
			while (deltaAngle > twoPi) deltaAngle -= twoPi;
			if (deltaAngle < Number.EPSILON) {
				if (samePoints) {
					deltaAngle = 0;
				} else {
					deltaAngle = twoPi;
				}
			}
			if (this.aClockwise === true && !samePoints) {
				if (deltaAngle === twoPi) {
					deltaAngle = -twoPi;
				} else {
					deltaAngle = deltaAngle - twoPi;
				}
			}
			const angle = this.aStartAngle + t * deltaAngle;
			let x = this.aX + this.xRadius * Math.cos(angle);
			let y = this.aY + this.yRadius * Math.sin(angle);
			if (this.aRotation !== 0) {
				const cos = Math.cos(this.aRotation);
				const sin = Math.sin(this.aRotation);
				const tx = x - this.aX;
				const ty = y - this.aY;
				// Rotate the point about the center of the ellipse.
				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;
			}
			return point.set(x, y);
		}
		copy(source) {
			super.copy(source);
			this.aX = source.aX;
			this.aY = source.aY;
			this.xRadius = source.xRadius;
			this.yRadius = source.yRadius;
			this.aStartAngle = source.aStartAngle;
			this.aEndAngle = source.aEndAngle;
			this.aClockwise = source.aClockwise;
			this.aRotation = source.aRotation;
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			data.aX = this.aX;
			data.aY = this.aY;
			data.xRadius = this.xRadius;
			data.yRadius = this.yRadius;
			data.aStartAngle = this.aStartAngle;
			data.aEndAngle = this.aEndAngle;
			data.aClockwise = this.aClockwise;
			data.aRotation = this.aRotation;
			return data;
		}
		fromJSON(json) {
			super.fromJSON(json);
			this.aX = json.aX;
			this.aY = json.aY;
			this.xRadius = json.xRadius;
			this.yRadius = json.yRadius;
			this.aStartAngle = json.aStartAngle;
			this.aEndAngle = json.aEndAngle;
			this.aClockwise = json.aClockwise;
			this.aRotation = json.aRotation;
			return this;
		}
	}
	class ArcCurve extends EllipseCurve {
		constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
			this.isArcCurve = true;
			this.type = 'ArcCurve';
		}
	}
	/**
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */
	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/
	function CubicPoly() {
		let c0 = 0,
			c1 = 0,
			c2 = 0,
			c3 = 0;
		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		function init(x0, x1, t0, t1) {
			c0 = x0;
			c1 = t0;
			c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;
		}
		return {
			initCatmullRom: function(x0, x1, x2, x3, tension) {
				init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
			},
			initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
				// compute tangents when parameterized in [t1,t2]
				let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
				let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;
				init(x1, x2, t1, t2);
			},
			calc: function(t) {
				const t2 = t * t;
				const t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;
			}
		};
	}
	//
	const tmp = /*@__PURE__*/ new Vector3();
	const px = /*@__PURE__*/ new CubicPoly();
	const py = /*@__PURE__*/ new CubicPoly();
	const pz = /*@__PURE__*/ new CubicPoly();
	class CatmullRomCurve3 extends Curve {
		constructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {
			super();
			this.isCatmullRomCurve3 = true;
			this.type = 'CatmullRomCurve3';
			this.points = points;
			this.closed = closed;
			this.curveType = curveType;
			this.tension = tension;
		}
		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;
			const points = this.points;
			const l = points.length;
			const p = (l - (this.closed ? 0 : 1)) * t;
			let intPoint = Math.floor(p);
			let weight = p - intPoint;
			if (this.closed) {
				intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
			} else if (weight === 0 && intPoint === l - 1) {
				intPoint = l - 2;
				weight = 1;
			}
			let p0, p3; // 4 points (p1 & p2 defined below)
			if (this.closed || intPoint > 0) {
				p0 = points[(intPoint - 1) % l];
			} else {
				// extrapolate first point
				tmp.subVectors(points[0], points[1]).add(points[0]);
				p0 = tmp;
			}
			const p1 = points[intPoint % l];
			const p2 = points[(intPoint + 1) % l];
			if (this.closed || intPoint + 2 < l) {
				p3 = points[(intPoint + 2) % l];
			} else {
				// extrapolate last point
				tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
				p3 = tmp;
			}
			if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
				// init Centripetal / Chordal Catmull-Rom
				const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
				let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
				let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
				let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
				// safety check for repeated points
				if (dt1 < 1e-4) dt1 = 1.0;
				if (dt0 < 1e-4) dt0 = dt1;
				if (dt2 < 1e-4) dt2 = dt1;
				px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
				py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
				pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
			} else if (this.curveType === 'catmullrom') {
				px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
				py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
				pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
			}
			point.set(
				px.calc(weight),
				py.calc(weight),
				pz.calc(weight)
			);
			return point;
		}
		copy(source) {
			super.copy(source);
			this.points = [];
			for (let i = 0, l = source.points.length; i < l; i++) {
				const point = source.points[i];
				this.points.push(point.clone());
			}
			this.closed = source.closed;
			this.curveType = source.curveType;
			this.tension = source.tension;
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			data.points = [];
			for (let i = 0, l = this.points.length; i < l; i++) {
				const point = this.points[i];
				data.points.push(point.toArray());
			}
			data.closed = this.closed;
			data.curveType = this.curveType;
			data.tension = this.tension;
			return data;
		}
		fromJSON(json) {
			super.fromJSON(json);
			this.points = [];
			for (let i = 0, l = json.points.length; i < l; i++) {
				const point = json.points[i];
				this.points.push(new Vector3().fromArray(point));
			}
			this.closed = json.closed;
			this.curveType = json.curveType;
			this.tension = json.tension;
			return this;
		}
	}
	/**
	 * Bezier Curves formulas obtained from
	 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
	 */
	function CatmullRom(t, p0, p1, p2, p3) {
		const v0 = (p2 - p0) * 0.5;
		const v1 = (p3 - p1) * 0.5;
		const t2 = t * t;
		const t3 = t * t2;
		return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
	}
	//
	function QuadraticBezierP0(t, p) {
		const k = 1 - t;
		return k * k * p;
	}

	function QuadraticBezierP1(t, p) {
		return 2 * (1 - t) * t * p;
	}

	function QuadraticBezierP2(t, p) {
		return t * t * p;
	}

	function QuadraticBezier(t, p0, p1, p2) {
		return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) +
			QuadraticBezierP2(t, p2);
	}
	//
	function CubicBezierP0(t, p) {
		const k = 1 - t;
		return k * k * k * p;
	}

	function CubicBezierP1(t, p) {
		const k = 1 - t;
		return 3 * k * k * t * p;
	}

	function CubicBezierP2(t, p) {
		return 3 * (1 - t) * t * t * p;
	}

	function CubicBezierP3(t, p) {
		return t * t * t * p;
	}

	function CubicBezier(t, p0, p1, p2, p3) {
		return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) +
			CubicBezierP3(t, p3);
	}
	class CubicBezierCurve extends Curve {
		constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
			super();
			this.isCubicBezierCurve = true;
			this.type = 'CubicBezierCurve';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
		}
		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;
			const v0 = this.v0,
				v1 = this.v1,
				v2 = this.v2,
				v3 = this.v3;
			point.set(
				CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
				CubicBezier(t, v0.y, v1.y, v2.y, v3.y)
			);
			return point;
		}
		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			this.v3.copy(source.v3);
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();
			return data;
		}
		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			this.v3.fromArray(json.v3);
			return this;
		}
	}
	class CubicBezierCurve3 extends Curve {
		constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
			super();
			this.isCubicBezierCurve3 = true;
			this.type = 'CubicBezierCurve3';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
		}
		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;
			const v0 = this.v0,
				v1 = this.v1,
				v2 = this.v2,
				v3 = this.v3;
			point.set(
				CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
				CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
				CubicBezier(t, v0.z, v1.z, v2.z, v3.z)
			);
			return point;
		}
		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			this.v3.copy(source.v3);
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();
			return data;
		}
		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			this.v3.fromArray(json.v3);
			return this;
		}
	}
	class LineCurve extends Curve {
		constructor(v1 = new Vector2(), v2 = new Vector2()) {
			super();
			this.isLineCurve = true;
			this.type = 'LineCurve';
			this.v1 = v1;
			this.v2 = v2;
		}
		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;
			if (t === 1) {
				point.copy(this.v2);
			} else {
				point.copy(this.v2).sub(this.v1);
				point.multiplyScalar(t).add(this.v1);
			}
			return point;
		}
		// Line curve is linear, so we can overwrite default getPointAt
		getPointAt(u, optionalTarget) {
			return this.getPoint(u, optionalTarget);
		}
		getTangent(t, optionalTarget = new Vector2()) {
			return optionalTarget.subVectors(this.v2, this.v1).normalize();
		}
		getTangentAt(u, optionalTarget) {
			return this.getTangent(u, optionalTarget);
		}
		copy(source) {
			super.copy(source);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}
		fromJSON(json) {
			super.fromJSON(json);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}
	}
	class LineCurve3 extends Curve {
		constructor(v1 = new Vector3(), v2 = new Vector3()) {
			super();
			this.isLineCurve3 = true;
			this.type = 'LineCurve3';
			this.v1 = v1;
			this.v2 = v2;
		}
		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;
			if (t === 1) {
				point.copy(this.v2);
			} else {
				point.copy(this.v2).sub(this.v1);
				point.multiplyScalar(t).add(this.v1);
			}
			return point;
		}
		// Line curve is linear, so we can overwrite default getPointAt
		getPointAt(u, optionalTarget) {
			return this.getPoint(u, optionalTarget);
		}
		getTangent(t, optionalTarget = new Vector3()) {
			return optionalTarget.subVectors(this.v2, this.v1).normalize();
		}
		getTangentAt(u, optionalTarget) {
			return this.getTangent(u, optionalTarget);
		}
		copy(source) {
			super.copy(source);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}
		fromJSON(json) {
			super.fromJSON(json);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}
	}
	class QuadraticBezierCurve extends Curve {
		constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
			super();
			this.isQuadraticBezierCurve = true;
			this.type = 'QuadraticBezierCurve';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
		}
		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;
			const v0 = this.v0,
				v1 = this.v1,
				v2 = this.v2;
			point.set(
				QuadraticBezier(t, v0.x, v1.x, v2.x),
				QuadraticBezier(t, v0.y, v1.y, v2.y)
			);
			return point;
		}
		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}
		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}
	}
	class QuadraticBezierCurve3 extends Curve {
		constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
			super();
			this.isQuadraticBezierCurve3 = true;
			this.type = 'QuadraticBezierCurve3';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
		}
		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;
			const v0 = this.v0,
				v1 = this.v1,
				v2 = this.v2;
			point.set(
				QuadraticBezier(t, v0.x, v1.x, v2.x),
				QuadraticBezier(t, v0.y, v1.y, v2.y),
				QuadraticBezier(t, v0.z, v1.z, v2.z)
			);
			return point;
		}
		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}
		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}
	}
	class SplineCurve extends Curve {
		constructor(points = []) {
			super();
			this.isSplineCurve = true;
			this.type = 'SplineCurve';
			this.points = points;
		}
		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;
			const points = this.points;
			const p = (points.length - 1) * t;
			const intPoint = Math.floor(p);
			const weight = p - intPoint;
			const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
			const p1 = points[intPoint];
			const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
			const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
			point.set(
				CatmullRom(weight, p0.x, p1.x, p2.x, p3.x),
				CatmullRom(weight, p0.y, p1.y, p2.y, p3.y)
			);
			return point;
		}
		copy(source) {
			super.copy(source);
			this.points = [];
			for (let i = 0, l = source.points.length; i < l; i++) {
				const point = source.points[i];
				this.points.push(point.clone());
			}
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			data.points = [];
			for (let i = 0, l = this.points.length; i < l; i++) {
				const point = this.points[i];
				data.points.push(point.toArray());
			}
			return data;
		}
		fromJSON(json) {
			super.fromJSON(json);
			this.points = [];
			for (let i = 0, l = json.points.length; i < l; i++) {
				const point = json.points[i];
				this.points.push(new Vector2().fromArray(point));
			}
			return this;
		}
	}
	var Curves = /*#__PURE__*/ Object.freeze({
		__proto__: null,
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});
	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/
	class CurvePath extends Curve {
		constructor() {
			super();
			this.type = 'CurvePath';
			this.curves = [];
			this.autoClose = false; // Automatically closes the path
		}
		add(curve) {
			this.curves.push(curve);
		}
		closePath() {
			// Add a line curve if start and end of lines are not connected
			const startPoint = this.curves[0].getPoint(0);
			const endPoint = this.curves[this.curves.length - 1].getPoint(1);
			if (!startPoint.equals(endPoint)) {
				this.curves.push(new LineCurve(endPoint, startPoint));
			}
		}
		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:
		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')
		getPoint(t, optionalTarget) {
			const d = t * this.getLength();
			const curveLengths = this.getCurveLengths();
			let i = 0;
			// To think about boundaries points.
			while (i < curveLengths.length) {
				if (curveLengths[i] >= d) {
					const diff = curveLengths[i] - d;
					const curve = this.curves[i];
					const segmentLength = curve.getLength();
					const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
					return curve.getPointAt(u, optionalTarget);
				}
				i++;
			}
			return null;
			// loop where sum != 0, sum > d , sum+1 <d
		}
		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength
		getLength() {
			const lens = this.getCurveLengths();
			return lens[lens.length - 1];
		}
		// cacheLengths must be recalculated.
		updateArcLengths() {
			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();
		}
		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.
		getCurveLengths() {
			// We use cache values if curves and cache array are same length
			if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
				return this.cacheLengths;
			}
			// Get length of sub-curve
			// Push sums into cached array
			const lengths = [];
			let sums = 0;
			for (let i = 0, l = this.curves.length; i < l; i++) {
				sums += this.curves[i].getLength();
				lengths.push(sums);
			}
			this.cacheLengths = lengths;
			return lengths;
		}
		getSpacedPoints(divisions = 40) {
			const points = [];
			for (let i = 0; i <= divisions; i++) {
				points.push(this.getPoint(i / divisions));
			}
			if (this.autoClose) {
				points.push(points[0]);
			}
			return points;
		}
		getPoints(divisions = 12) {
			const points = [];
			let last;
			for (let i = 0, curves = this.curves; i < curves.length; i++) {
				const curve = curves[i];
				const resolution = curve.isEllipseCurve ? divisions * 2 :
					(curve.isLineCurve || curve.isLineCurve3) ? 1 :
					curve.isSplineCurve ? divisions * curve.points.length :
					divisions;
				const pts = curve.getPoints(resolution);
				for (let j = 0; j < pts.length; j++) {
					const point = pts[j];
					if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates
					points.push(point);
					last = point;
				}
			}
			if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
				points.push(points[0]);
			}
			return points;
		}
		copy(source) {
			super.copy(source);
			this.curves = [];
			for (let i = 0, l = source.curves.length; i < l; i++) {
				const curve = source.curves[i];
				this.curves.push(curve.clone());
			}
			this.autoClose = source.autoClose;
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			data.autoClose = this.autoClose;
			data.curves = [];
			for (let i = 0, l = this.curves.length; i < l; i++) {
				const curve = this.curves[i];
				data.curves.push(curve.toJSON());
			}
			return data;
		}
		fromJSON(json) {
			super.fromJSON(json);
			this.autoClose = json.autoClose;
			this.curves = [];
			for (let i = 0, l = json.curves.length; i < l; i++) {
				const curve = json.curves[i];
				this.curves.push(new Curves[curve.type]().fromJSON(curve));
			}
			return this;
		}
	}
	class Path extends CurvePath {
		constructor(points) {
			super();
			this.type = 'Path';
			this.currentPoint = new Vector2();
			if (points) {
				this.setFromPoints(points);
			}
		}
		setFromPoints(points) {
			this.moveTo(points[0].x, points[0].y);
			for (let i = 1, l = points.length; i < l; i++) {
				this.lineTo(points[i].x, points[i].y);
			}
			return this;
		}
		moveTo(x, y) {
			this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
			return this;
		}
		lineTo(x, y) {
			const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
			this.curves.push(curve);
			this.currentPoint.set(x, y);
			return this;
		}
		quadraticCurveTo(aCPx, aCPy, aX, aY) {
			const curve = new QuadraticBezierCurve(
				this.currentPoint.clone(),
				new Vector2(aCPx, aCPy),
				new Vector2(aX, aY)
			);
			this.curves.push(curve);
			this.currentPoint.set(aX, aY);
			return this;
		}
		bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			const curve = new CubicBezierCurve(
				this.currentPoint.clone(),
				new Vector2(aCP1x, aCP1y),
				new Vector2(aCP2x, aCP2y),
				new Vector2(aX, aY)
			);
			this.curves.push(curve);
			this.currentPoint.set(aX, aY);
			return this;
		}
		splineThru(pts /*Array of Vector*/ ) {
			const npts = [this.currentPoint.clone()].concat(pts);
			const curve = new SplineCurve(npts);
			this.curves.push(curve);
			this.currentPoint.copy(pts[pts.length - 1]);
			return this;
		}
		arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;
			this.absarc(aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise);
			return this;
		}
		absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
			return this;
		}
		ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;
			this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
			return this;
		}
		absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
			if (this.curves.length > 0) {
				// if a previous curve is present, attempt to join
				const firstPoint = curve.getPoint(0);
				if (!firstPoint.equals(this.currentPoint)) {
					this.lineTo(firstPoint.x, firstPoint.y);
				}
			}
			this.curves.push(curve);
			const lastPoint = curve.getPoint(1);
			this.currentPoint.copy(lastPoint);
			return this;
		}
		copy(source) {
			super.copy(source);
			this.currentPoint.copy(source.currentPoint);
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			data.currentPoint = this.currentPoint.toArray();
			return data;
		}
		fromJSON(json) {
			super.fromJSON(json);
			this.currentPoint.fromArray(json.currentPoint);
			return this;
		}
	}
	class LatheGeometry extends BufferGeometry {
		constructor(points = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
			super();
			this.type = 'LatheGeometry';
			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};
			segments = Math.floor(segments);
			// clamp phiLength so it's in range of [ 0, 2PI ]
			phiLength = clamp(phiLength, 0, Math.PI * 2);
			// buffers
			const indices = [];
			const vertices = [];
			const uvs = [];
			const initNormals = [];
			const normals = [];
			// helper variables
			const inverseSegments = 1.0 / segments;
			const vertex = new Vector3();
			const uv = new Vector2();
			const normal = new Vector3();
			const curNormal = new Vector3();
			const prevNormal = new Vector3();
			let dx = 0;
			let dy = 0;
			// pre-compute normals for initial "meridian"
			for (let j = 0; j <= (points.length - 1); j++) {
				switch (j) {
					case 0: // special handling for 1st vertex on path
						dx = points[j + 1].x - points[j].x;
						dy = points[j + 1].y - points[j].y;
						normal.x = dy * 1.0;
						normal.y = -dx;
						normal.z = dy * 0.0;
						prevNormal.copy(normal);
						normal.normalize();
						initNormals.push(normal.x, normal.y, normal.z);
						break;
					case (points.length - 1): // special handling for last Vertex on path
						initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
						break;
					default: // default handling for all vertices in between
						dx = points[j + 1].x - points[j].x;
						dy = points[j + 1].y - points[j].y;
						normal.x = dy * 1.0;
						normal.y = -dx;
						normal.z = dy * 0.0;
						curNormal.copy(normal);
						normal.x += prevNormal.x;
						normal.y += prevNormal.y;
						normal.z += prevNormal.z;
						normal.normalize();
						initNormals.push(normal.x, normal.y, normal.z);
						prevNormal.copy(curNormal);
				}
			}
			// generate vertices, uvs and normals
			for (let i = 0; i <= segments; i++) {
				const phi = phiStart + i * inverseSegments * phiLength;
				const sin = Math.sin(phi);
				const cos = Math.cos(phi);
				for (let j = 0; j <= (points.length - 1); j++) {
					// vertex
					vertex.x = points[j].x * sin;
					vertex.y = points[j].y;
					vertex.z = points[j].x * cos;
					vertices.push(vertex.x, vertex.y, vertex.z);
					// uv
					uv.x = i / segments;
					uv.y = j / (points.length - 1);
					uvs.push(uv.x, uv.y);
					// normal
					const x = initNormals[3 * j + 0] * sin;
					const y = initNormals[3 * j + 1];
					const z = initNormals[3 * j + 0] * cos;
					normals.push(x, y, z);
				}
			}
			// indices
			for (let i = 0; i < segments; i++) {
				for (let j = 0; j < (points.length - 1); j++) {
					const base = j + i * points.length;
					const a = base;
					const b = base + points.length;
					const c = base + points.length + 1;
					const d = base + 1;
					// faces
					indices.push(a, b, d);
					indices.push(c, d, b);
				}
			}
			// build geometry
			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
		}
		copy(source) {
			super.copy(source);
			this.parameters = Object.assign({}, source.parameters);
			return this;
		}
		static fromJSON(data) {
			return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
		}
	}
	class CapsuleGeometry extends LatheGeometry {
		constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8) {
			const path = new Path();
			path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
			path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
			super(path.getPoints(capSegments), radialSegments);
			this.type = 'CapsuleGeometry';
			this.parameters = {
				radius: radius,
				height: length,
				capSegments: capSegments,
				radialSegments: radialSegments,
			};
		}
		static fromJSON(data) {
			return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
		}
	}
	class CircleGeometry extends BufferGeometry {
		constructor(radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2) {
			super();
			this.type = 'CircleGeometry';
			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			segments = Math.max(3, segments);
			// buffers
			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];
			// helper variables
			const vertex = new Vector3();
			const uv = new Vector2();
			// center point
			vertices.push(0, 0, 0);
			normals.push(0, 0, 1);
			uvs.push(0.5, 0.5);
			for (let s = 0, i = 3; s <= segments; s++, i += 3) {
				const segment = thetaStart + s / segments * thetaLength;
				// vertex
				vertex.x = radius * Math.cos(segment);
				vertex.y = radius * Math.sin(segment);
				vertices.push(vertex.x, vertex.y, vertex.z);
				// normal
				normals.push(0, 0, 1);
				// uvs
				uv.x = (vertices[i] / radius + 1) / 2;
				uv.y = (vertices[i + 1] / radius + 1) / 2;
				uvs.push(uv.x, uv.y);
			}
			// indices
			for (let i = 1; i <= segments; i++) {
				indices.push(i, i + 1, 0);
			}
			// build geometry
			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}
		copy(source) {
			super.copy(source);
			this.parameters = Object.assign({}, source.parameters);
			return this;
		}
		static fromJSON(data) {
			return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
		}
	}
	class CylinderGeometry extends BufferGeometry {
		constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
			super();
			this.type = 'CylinderGeometry';
			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			const scope = this;
			radialSegments = Math.floor(radialSegments);
			heightSegments = Math.floor(heightSegments);
			// buffers
			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];
			// helper variables
			let index = 0;
			const indexArray = [];
			const halfHeight = height / 2;
			let groupStart = 0;
			// generate geometry
			generateTorso();
			if (openEnded === false) {
				if (radiusTop > 0) generateCap(true);
				if (radiusBottom > 0) generateCap(false);
			}
			// build geometry
			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			function generateTorso() {
				const normal = new Vector3();
				const vertex = new Vector3();
				let groupCount = 0;
				// this will be used to calculate the normal
				const slope = (radiusBottom - radiusTop) / height;
				// generate vertices, normals and uvs
				for (let y = 0; y <= heightSegments; y++) {
					const indexRow = [];
					const v = y / heightSegments;
					// calculate the radius of the current row
					const radius = v * (radiusBottom - radiusTop) + radiusTop;
					for (let x = 0; x <= radialSegments; x++) {
						const u = x / radialSegments;
						const theta = u * thetaLength + thetaStart;
						const sinTheta = Math.sin(theta);
						const cosTheta = Math.cos(theta);
						// vertex
						vertex.x = radius * sinTheta;
						vertex.y = -v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push(vertex.x, vertex.y, vertex.z);
						// normal
						normal.set(sinTheta, slope, cosTheta).normalize();
						normals.push(normal.x, normal.y, normal.z);
						// uv
						uvs.push(u, 1 - v);
						// save index of vertex in respective row
						indexRow.push(index++);
					}
					// now save vertices of the row in our index array
					indexArray.push(indexRow);
				}
				// generate indices
				for (let x = 0; x < radialSegments; x++) {
					for (let y = 0; y < heightSegments; y++) {
						// we use the index array to access the correct indices
						const a = indexArray[y][x];
						const b = indexArray[y + 1][x];
						const c = indexArray[y + 1][x + 1];
						const d = indexArray[y][x + 1];
						// faces
						indices.push(a, b, d);
						indices.push(b, c, d);
						// update group counter
						groupCount += 6;
					}
				}
				// add a group to the geometry. this will ensure multi material support
				scope.addGroup(groupStart, groupCount, 0);
				// calculate new start value for groups
				groupStart += groupCount;
			}

			function generateCap(top) {
				// save the index of the first center vertex
				const centerIndexStart = index;
				const uv = new Vector2();
				const vertex = new Vector3();
				let groupCount = 0;
				const radius = (top === true) ? radiusTop : radiusBottom;
				const sign = (top === true) ? 1 : -1;
				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment
				for (let x = 1; x <= radialSegments; x++) {
					// vertex
					vertices.push(0, halfHeight * sign, 0);
					// normal
					normals.push(0, sign, 0);
					// uv
					uvs.push(0.5, 0.5);
					// increase index
					index++;
				}
				// save the index of the last center vertex
				const centerIndexEnd = index;
				// now we generate the surrounding vertices, normals and uvs
				for (let x = 0; x <= radialSegments; x++) {
					const u = x / radialSegments;
					const theta = u * thetaLength + thetaStart;
					const cosTheta = Math.cos(theta);
					const sinTheta = Math.sin(theta);
					// vertex
					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push(vertex.x, vertex.y, vertex.z);
					// normal
					normals.push(0, sign, 0);
					// uv
					uv.x = (cosTheta * 0.5) + 0.5;
					uv.y = (sinTheta * 0.5 * sign) + 0.5;
					uvs.push(uv.x, uv.y);
					// increase index
					index++;
				}
				// generate indices
				for (let x = 0; x < radialSegments; x++) {
					const c = centerIndexStart + x;
					const i = centerIndexEnd + x;
					if (top === true) {
						// face top
						indices.push(i, i + 1, c);
					} else {
						// face bottom
						indices.push(i + 1, i, c);
					}
					groupCount += 3;
				}
				// add a group to the geometry. this will ensure multi material support
				scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
				// calculate new start value for groups
				groupStart += groupCount;
			}
		}
		copy(source) {
			super.copy(source);
			this.parameters = Object.assign({}, source.parameters);
			return this;
		}
		static fromJSON(data) {
			return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
		}
	}
	class ConeGeometry extends CylinderGeometry {
		constructor(radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
			super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
			this.type = 'ConeGeometry';
			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
		}
		static fromJSON(data) {
			return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
		}
	}
	class PolyhedronGeometry extends BufferGeometry {
		constructor(vertices = [], indices = [], radius = 1, detail = 0) {
			super();
			this.type = 'PolyhedronGeometry';
			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};
			// default buffer data
			const vertexBuffer = [];
			const uvBuffer = [];
			// the subdivision creates the vertex buffer data
			subdivide(detail);
			// all vertices should lie on a conceptual sphere with a given radius
			applyRadius(radius);
			// finally, create the uv data
			generateUVs();
			// build non-indexed geometry
			this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
			this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
			if (detail === 0) {
				this.computeVertexNormals(); // flat normals
			} else {
				this.normalizeNormals(); // smooth normals
			}
			// helper functions
			function subdivide(detail) {
				const a = new Vector3();
				const b = new Vector3();
				const c = new Vector3();
				// iterate over all faces and apply a subdivision with the given detail value
				for (let i = 0; i < indices.length; i += 3) {
					// get the vertices of the face
					getVertexByIndex(indices[i + 0], a);
					getVertexByIndex(indices[i + 1], b);
					getVertexByIndex(indices[i + 2], c);
					// perform subdivision
					subdivideFace(a, b, c, detail);
				}
			}

			function subdivideFace(a, b, c, detail) {
				const cols = detail + 1;
				// we use this multidimensional array as a data structure for creating the subdivision
				const v = [];
				// construct all of the vertices for this subdivision
				for (let i = 0; i <= cols; i++) {
					v[i] = [];
					const aj = a.clone().lerp(c, i / cols);
					const bj = b.clone().lerp(c, i / cols);
					const rows = cols - i;
					for (let j = 0; j <= rows; j++) {
						if (j === 0 && i === cols) {
							v[i][j] = aj;
						} else {
							v[i][j] = aj.clone().lerp(bj, j / rows);
						}
					}
				}
				// construct all of the faces
				for (let i = 0; i < cols; i++) {
					for (let j = 0; j < 2 * (cols - i) - 1; j++) {
						const k = Math.floor(j / 2);
						if (j % 2 === 0) {
							pushVertex(v[i][k + 1]);
							pushVertex(v[i + 1][k]);
							pushVertex(v[i][k]);
						} else {
							pushVertex(v[i][k + 1]);
							pushVertex(v[i + 1][k + 1]);
							pushVertex(v[i + 1][k]);
						}
					}
				}
			}

			function applyRadius(radius) {
				const vertex = new Vector3();
				// iterate over the entire buffer and apply the radius to each vertex
				for (let i = 0; i < vertexBuffer.length; i += 3) {
					vertex.x = vertexBuffer[i + 0];
					vertex.y = vertexBuffer[i + 1];
					vertex.z = vertexBuffer[i + 2];
					vertex.normalize().multiplyScalar(radius);
					vertexBuffer[i + 0] = vertex.x;
					vertexBuffer[i + 1] = vertex.y;
					vertexBuffer[i + 2] = vertex.z;
				}
			}

			function generateUVs() {
				const vertex = new Vector3();
				for (let i = 0; i < vertexBuffer.length; i += 3) {
					vertex.x = vertexBuffer[i + 0];
					vertex.y = vertexBuffer[i + 1];
					vertex.z = vertexBuffer[i + 2];
					const u = azimuth(vertex) / 2 / Math.PI + 0.5;
					const v = inclination(vertex) / Math.PI + 0.5;
					uvBuffer.push(u, 1 - v);
				}
				correctUVs();
				correctSeam();
			}

			function correctSeam() {
				// handle case when face straddles the seam, see #3269
				for (let i = 0; i < uvBuffer.length; i += 6) {
					// uv data of a single face
					const x0 = uvBuffer[i + 0];
					const x1 = uvBuffer[i + 2];
					const x2 = uvBuffer[i + 4];
					const max = Math.max(x0, x1, x2);
					const min = Math.min(x0, x1, x2);
					// 0.9 is somewhat arbitrary
					if (max > 0.9 && min < 0.1) {
						if (x0 < 0.2) uvBuffer[i + 0] += 1;
						if (x1 < 0.2) uvBuffer[i + 2] += 1;
						if (x2 < 0.2) uvBuffer[i + 4] += 1;
					}
				}
			}

			function pushVertex(vertex) {
				vertexBuffer.push(vertex.x, vertex.y, vertex.z);
			}

			function getVertexByIndex(index, vertex) {
				const stride = index * 3;
				vertex.x = vertices[stride + 0];
				vertex.y = vertices[stride + 1];
				vertex.z = vertices[stride + 2];
			}

			function correctUVs() {
				const a = new Vector3();
				const b = new Vector3();
				const c = new Vector3();
				const centroid = new Vector3();
				const uvA = new Vector2();
				const uvB = new Vector2();
				const uvC = new Vector2();
				for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
					a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
					b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
					c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
					uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
					uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
					uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
					centroid.copy(a).add(b).add(c).divideScalar(3);
					const azi = azimuth(centroid);
					correctUV(uvA, j + 0, a, azi);
					correctUV(uvB, j + 2, b, azi);
					correctUV(uvC, j + 4, c, azi);
				}
			}

			function correctUV(uv, stride, vector, azimuth) {
				if ((azimuth < 0) && (uv.x === 1)) {
					uvBuffer[stride] = uv.x - 1;
				}
				if ((vector.x === 0) && (vector.z === 0)) {
					uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
				}
			}
			// Angle around the Y axis, counter-clockwise when looking from above.
			function azimuth(vector) {
				return Math.atan2(vector.z, -vector.x);
			}
			// Angle above the XZ plane.
			function inclination(vector) {
				return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
			}
		}
		copy(source) {
			super.copy(source);
			this.parameters = Object.assign({}, source.parameters);
			return this;
		}
		static fromJSON(data) {
			return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
		}
	}
	class DodecahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const t = (1 + Math.sqrt(5)) / 2;
			const r = 1 / t;
			const vertices = [
				// (±1, ±1, ±1)
				-1, -1, -1, -1, -1, 1,
				-1, 1, -1, -1, 1, 1,
				1, -1, -1, 1, -1, 1,
				1, 1, -1, 1, 1, 1,
				// (0, ±1/φ, ±φ)
				0, -r, -t, 0, -r, t,
				0, r, -t, 0, r, t,
				// (±1/φ, ±φ, 0)
				-r, -t, 0, -r, t, 0,
				r, -t, 0, r, t, 0,
				// (±φ, 0, ±1/φ)
				-t, 0, -r, t, 0, -r,
				-t, 0, r, t, 0, r
			];
			const indices = [
				3, 11, 7, 3, 7, 15, 3, 15, 13,
				7, 19, 17, 7, 17, 6, 7, 6, 15,
				17, 4, 8, 17, 8, 10, 17, 10, 6,
				8, 0, 16, 8, 16, 2, 8, 2, 10,
				0, 12, 1, 0, 1, 18, 0, 18, 16,
				6, 10, 2, 6, 2, 13, 6, 13, 15,
				2, 16, 18, 2, 18, 3, 2, 3, 13,
				18, 1, 9, 18, 9, 11, 18, 11, 3,
				4, 14, 12, 4, 12, 0, 4, 0, 8,
				11, 9, 5, 11, 5, 19, 11, 19, 7,
				19, 5, 14, 19, 14, 4, 19, 4, 17,
				1, 12, 14, 1, 14, 5, 1, 5, 9
			];
			super(vertices, indices, radius, detail);
			this.type = 'DodecahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}
		static fromJSON(data) {
			return new DodecahedronGeometry(data.radius, data.detail);
		}
	}
	const _v0 = /*@__PURE__*/ new Vector3();
	const _v1$1 = /*@__PURE__*/ new Vector3();
	const _normal = /*@__PURE__*/ new Vector3();
	const _triangle = /*@__PURE__*/ new Triangle();
	class EdgesGeometry extends BufferGeometry {
		constructor(geometry = null, thresholdAngle = 1) {
			super();
			this.type = 'EdgesGeometry';
			this.parameters = {
				geometry: geometry,
				thresholdAngle: thresholdAngle
			};
			if (geometry !== null) {
				const precisionPoints = 4;
				const precision = Math.pow(10, precisionPoints);
				const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
				const indexAttr = geometry.getIndex();
				const positionAttr = geometry.getAttribute('position');
				const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
				const indexArr = [0, 0, 0];
				const vertKeys = ['a', 'b', 'c'];
				const hashes = new Array(3);
				const edgeData = {};
				const vertices = [];
				for (let i = 0; i < indexCount; i += 3) {
					if (indexAttr) {
						indexArr[0] = indexAttr.getX(i);
						indexArr[1] = indexAttr.getX(i + 1);
						indexArr[2] = indexAttr.getX(i + 2);
					} else {
						indexArr[0] = i;
						indexArr[1] = i + 1;
						indexArr[2] = i + 2;
					}
					const {
						a,
						b,
						c
					} = _triangle;
					a.fromBufferAttribute(positionAttr, indexArr[0]);
					b.fromBufferAttribute(positionAttr, indexArr[1]);
					c.fromBufferAttribute(positionAttr, indexArr[2]);
					_triangle.getNormal(_normal);
					// create hashes for the edge from the vertices
					hashes[0] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;
					hashes[1] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;
					hashes[2] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;
					// skip degenerate triangles
					if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
						continue;
					}
					// iterate over every edge
					for (let j = 0; j < 3; j++) {
						// get the first and next vertex making up the edge
						const jNext = (j + 1) % 3;
						const vecHash0 = hashes[j];
						const vecHash1 = hashes[jNext];
						const v0 = _triangle[vertKeys[j]];
						const v1 = _triangle[vertKeys[jNext]];
						const hash = `${ vecHash0 }_${ vecHash1 }`;
						const reverseHash = `${ vecHash1 }_${ vecHash0 }`;
						if (reverseHash in edgeData && edgeData[reverseHash]) {
							// if we found a sibling edge add it into the vertex array if
							// it meets the angle threshold and delete the edge from the map.
							if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
								vertices.push(v0.x, v0.y, v0.z);
								vertices.push(v1.x, v1.y, v1.z);
							}
							edgeData[reverseHash] = null;
						} else if (!(hash in edgeData)) {
							// if we've already got an edge here then skip adding a new one
							edgeData[hash] = {
								index0: indexArr[j],
								index1: indexArr[jNext],
								normal: _normal.clone(),
							};
						}
					}
				}
				// iterate over all remaining, unmatched edges and add them to the vertex array
				for (const key in edgeData) {
					if (edgeData[key]) {
						const {
							index0,
							index1
						} = edgeData[key];
						_v0.fromBufferAttribute(positionAttr, index0);
						_v1$1.fromBufferAttribute(positionAttr, index1);
						vertices.push(_v0.x, _v0.y, _v0.z);
						vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
					}
				}
				this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			}
		}
		copy(source) {
			super.copy(source);
			this.parameters = Object.assign({}, source.parameters);
			return this;
		}
	}
	class Shape extends Path {
		constructor(points) {
			super(points);
			this.uuid = generateUUID();
			this.type = 'Shape';
			this.holes = [];
		}
		getPointsHoles(divisions) {
			const holesPts = [];
			for (let i = 0, l = this.holes.length; i < l; i++) {
				holesPts[i] = this.holes[i].getPoints(divisions);
			}
			return holesPts;
		}
		// get points of shape and holes (keypoints based on segments parameter)
		extractPoints(divisions) {
			return {
				shape: this.getPoints(divisions),
				holes: this.getPointsHoles(divisions)
			};
		}
		copy(source) {
			super.copy(source);
			this.holes = [];
			for (let i = 0, l = source.holes.length; i < l; i++) {
				const hole = source.holes[i];
				this.holes.push(hole.clone());
			}
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			data.uuid = this.uuid;
			data.holes = [];
			for (let i = 0, l = this.holes.length; i < l; i++) {
				const hole = this.holes[i];
				data.holes.push(hole.toJSON());
			}
			return data;
		}
		fromJSON(json) {
			super.fromJSON(json);
			this.uuid = json.uuid;
			this.holes = [];
			for (let i = 0, l = json.holes.length; i < l; i++) {
				const hole = json.holes[i];
				this.holes.push(new Path().fromJSON(hole));
			}
			return this;
		}
	}
	/**
	 * Port from https://github.com/mapbox/earcut (v2.2.4)
	 */
	const Earcut = {
		triangulate: function(data, holeIndices, dim = 2) {
			const hasHoles = holeIndices && holeIndices.length;
			const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
			let outerNode = linkedList(data, 0, outerLen, dim, true);
			const triangles = [];
			if (!outerNode || outerNode.next === outerNode.prev) return triangles;
			let minX, minY, maxX, maxY, x, y, invSize;
			if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
			// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
			if (data.length > 80 * dim) {
				minX = maxX = data[0];
				minY = maxY = data[1];
				for (let i = dim; i < outerLen; i += dim) {
					x = data[i];
					y = data[i + 1];
					if (x < minX) minX = x;
					if (y < minY) minY = y;
					if (x > maxX) maxX = x;
					if (y > maxY) maxY = y;
				}
				// minX, minY and invSize are later used to transform coords into integers for z-order calculation
				invSize = Math.max(maxX - minX, maxY - minY);
				invSize = invSize !== 0 ? 32767 / invSize : 0;
			}
			earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
			return triangles;
		}
	};
	// create a circular doubly linked list from polygon points in the specified winding order
	function linkedList(data, start, end, dim, clockwise) {
		let i, last;
		if (clockwise === (signedArea(data, start, end, dim) > 0)) {
			for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
		} else {
			for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
		}
		if (last && equals(last, last.next)) {
			removeNode(last);
			last = last.next;
		}
		return last;
	}
	// eliminate colinear or duplicate points
	function filterPoints(start, end) {
		if (!start) return start;
		if (!end) end = start;
		let p = start,
			again;
		do {
			again = false;
			if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
				removeNode(p);
				p = end = p.prev;
				if (p === p.next) break;
				again = true;
			} else {
				p = p.next;
			}
		} while (again || p !== end);
		return end;
	}
	// main ear slicing loop which triangulates a polygon (given as a linked list)
	function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
		if (!ear) return;
		// interlink polygon nodes in z-order
		if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
		let stop = ear,
			prev, next;
		// iterate through ears, slicing them one by one
		while (ear.prev !== ear.next) {
			prev = ear.prev;
			next = ear.next;
			if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
				// cut off the triangle
				triangles.push(prev.i / dim | 0);
				triangles.push(ear.i / dim | 0);
				triangles.push(next.i / dim | 0);
				removeNode(ear);
				// skipping the next vertex leads to less sliver triangles
				ear = next.next;
				stop = next.next;
				continue;
			}
			ear = next;
			// if we looped through the whole remaining polygon and can't find any more ears
			if (ear === stop) {
				// try filtering points and slicing again
				if (!pass) {
					earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
					// if this didn't work, try curing all small self-intersections locally
				} else if (pass === 1) {
					ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
					earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
					// as a last resort, try splitting the remaining polygon into two
				} else if (pass === 2) {
					splitEarcut(ear, triangles, dim, minX, minY, invSize);
				}
				break;
			}
		}
	}
	// check whether a polygon node forms a valid ear with adjacent nodes
	function isEar(ear) {
		const a = ear.prev,
			b = ear,
			c = ear.next;
		if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
		// now make sure we don't have other points inside the potential ear
		const ax = a.x,
			bx = b.x,
			cx = c.x,
			ay = a.y,
			by = b.y,
			cy = c.y;
		// triangle bbox; min & max are calculated like this for speed
		const x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
			y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
			x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
			y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);
		let p = c.next;
		while (p !== a) {
			if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
				pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
				area(p.prev, p, p.next) >= 0) return false;
			p = p.next;
		}
		return true;
	}

	function isEarHashed(ear, minX, minY, invSize) {
		const a = ear.prev,
			b = ear,
			c = ear.next;
		if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
		const ax = a.x,
			bx = b.x,
			cx = c.x,
			ay = a.y,
			by = b.y,
			cy = c.y;
		// triangle bbox; min & max are calculated like this for speed
		const x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
			y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
			x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
			y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);
		// z-order range for the current triangle bbox;
		const minZ = zOrder(x0, y0, minX, minY, invSize),
			maxZ = zOrder(x1, y1, minX, minY, invSize);
		let p = ear.prevZ,
			n = ear.nextZ;
		// look for points inside the triangle in both directions
		while (p && p.z >= minZ && n && n.z <= maxZ) {
			if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
				pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.prevZ;
			if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
				pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
			n = n.nextZ;
		}
		// look for remaining points in decreasing z-order
		while (p && p.z >= minZ) {
			if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
				pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.prevZ;
		}
		// look for remaining points in increasing z-order
		while (n && n.z <= maxZ) {
			if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
				pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
			n = n.nextZ;
		}
		return true;
	}
	// go through all polygon nodes and cure small local self-intersections
	function cureLocalIntersections(start, triangles, dim) {
		let p = start;
		do {
			const a = p.prev,
				b = p.next.next;
			if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
				triangles.push(a.i / dim | 0);
				triangles.push(p.i / dim | 0);
				triangles.push(b.i / dim | 0);
				// remove two nodes involved
				removeNode(p);
				removeNode(p.next);
				p = start = b;
			}
			p = p.next;
		} while (p !== start);
		return filterPoints(p);
	}
	// try splitting polygon into two and triangulate them independently
	function splitEarcut(start, triangles, dim, minX, minY, invSize) {
		// look for a valid diagonal that divides the polygon into two
		let a = start;
		do {
			let b = a.next.next;
			while (b !== a.prev) {
				if (a.i !== b.i && isValidDiagonal(a, b)) {
					// split the polygon in two by the diagonal
					let c = splitPolygon(a, b);
					// filter colinear points around the cuts
					a = filterPoints(a, a.next);
					c = filterPoints(c, c.next);
					// run earcut on each half
					earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
					earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
					return;
				}
				b = b.next;
			}
			a = a.next;
		} while (a !== start);
	}
	// link every hole into the outer loop, producing a single-ring polygon without holes
	function eliminateHoles(data, holeIndices, outerNode, dim) {
		const queue = [];
		let i, len, start, end, list;
		for (i = 0, len = holeIndices.length; i < len; i++) {
			start = holeIndices[i] * dim;
			end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
			list = linkedList(data, start, end, dim, false);
			if (list === list.next) list.steiner = true;
			queue.push(getLeftmost(list));
		}
		queue.sort(compareX);
		// process holes from left to right
		for (i = 0; i < queue.length; i++) {
			outerNode = eliminateHole(queue[i], outerNode);
		}
		return outerNode;
	}

	function compareX(a, b) {
		return a.x - b.x;
	}
	// find a bridge between vertices that connects hole with an outer ring and link it
	function eliminateHole(hole, outerNode) {
		const bridge = findHoleBridge(hole, outerNode);
		if (!bridge) {
			return outerNode;
		}
		const bridgeReverse = splitPolygon(bridge, hole);
		// filter collinear points around the cuts
		filterPoints(bridgeReverse, bridgeReverse.next);
		return filterPoints(bridge, bridge.next);
	}
	// David Eberly's algorithm for finding a bridge between hole and outer polygon
	function findHoleBridge(hole, outerNode) {
		let p = outerNode,
			qx = -Infinity,
			m;
		const hx = hole.x,
			hy = hole.y;
		// find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point
		do {
			if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
				const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
				if (x <= hx && x > qx) {
					qx = x;
					m = p.x < p.next.x ? p : p.next;
					if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
				}
			}
			p = p.next;
		} while (p !== outerNode);
		if (!m) return null;
		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point
		const stop = m,
			mx = m.x,
			my = m.y;
		let tanMin = Infinity,
			tan;
		p = m;
		do {
			if (hx >= p.x && p.x >= mx && hx !== p.x &&
				pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
				tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
				if (locallyInside(p, hole) && (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
					m = p;
					tanMin = tan;
				}
			}
			p = p.next;
		} while (p !== stop);
		return m;
	}
	// whether sector in vertex m contains sector in vertex p in the same coordinates
	function sectorContainsSector(m, p) {
		return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
	}
	// interlink polygon nodes in z-order
	function indexCurve(start, minX, minY, invSize) {
		let p = start;
		do {
			if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;
		} while (p !== start);
		p.prevZ.nextZ = null;
		p.prevZ = null;
		sortLinked(p);
	}
	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
	function sortLinked(list) {
		let i, p, q, e, tail, numMerges, pSize, qSize,
			inSize = 1;
		do {
			p = list;
			list = null;
			tail = null;
			numMerges = 0;
			while (p) {
				numMerges++;
				q = p;
				pSize = 0;
				for (i = 0; i < inSize; i++) {
					pSize++;
					q = q.nextZ;
					if (!q) break;
				}
				qSize = inSize;
				while (pSize > 0 || (qSize > 0 && q)) {
					if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
						e = p;
						p = p.nextZ;
						pSize--;
					} else {
						e = q;
						q = q.nextZ;
						qSize--;
					}
					if (tail) tail.nextZ = e;
					else list = e;
					e.prevZ = tail;
					tail = e;
				}
				p = q;
			}
			tail.nextZ = null;
			inSize *= 2;
		} while (numMerges > 1);
		return list;
	}
	// z-order of a point given coords and inverse of the longer side of data bbox
	function zOrder(x, y, minX, minY, invSize) {
		// coords are transformed into non-negative 15-bit integer range
		x = (x - minX) * invSize | 0;
		y = (y - minY) * invSize | 0;
		x = (x | (x << 8)) & 0x00FF00FF;
		x = (x | (x << 4)) & 0x0F0F0F0F;
		x = (x | (x << 2)) & 0x33333333;
		x = (x | (x << 1)) & 0x55555555;
		y = (y | (y << 8)) & 0x00FF00FF;
		y = (y | (y << 4)) & 0x0F0F0F0F;
		y = (y | (y << 2)) & 0x33333333;
		y = (y | (y << 1)) & 0x55555555;
		return x | (y << 1);
	}
	// find the leftmost node of a polygon ring
	function getLeftmost(start) {
		let p = start,
			leftmost = start;
		do {
			if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
			p = p.next;
		} while (p !== start);
		return leftmost;
	}
	// check if a point lies within a convex triangle
	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
		return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
			(ax - px) * (by - py) >= (bx - px) * (ay - py) &&
			(bx - px) * (cy - py) >= (cx - px) * (by - py);
	}
	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
	function isValidDiagonal(a, b) {
		return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
			(locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
				(area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
				equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
	}
	// signed area of a triangle
	function area(p, q, r) {
		return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	}
	// check if two points are equal
	function equals(p1, p2) {
		return p1.x === p2.x && p1.y === p2.y;
	}
	// check if two segments intersect
	function intersects(p1, q1, p2, q2) {
		const o1 = sign(area(p1, q1, p2));
		const o2 = sign(area(p1, q1, q2));
		const o3 = sign(area(p2, q2, p1));
		const o4 = sign(area(p2, q2, q1));
		if (o1 !== o2 && o3 !== o4) return true; // general case
		if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
		if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
		if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
		if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
		return false;
	}
	// for collinear points p, q, r, check if point q lies on segment pr
	function onSegment(p, q, r) {
		return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
	}

	function sign(num) {
		return num > 0 ? 1 : num < 0 ? -1 : 0;
	}
	// check if a polygon diagonal intersects any polygon segments
	function intersectsPolygon(a, b) {
		let p = a;
		do {
			if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
				intersects(p, p.next, a, b)) return true;
			p = p.next;
		} while (p !== a);
		return false;
	}
	// check if a polygon diagonal is locally inside the polygon
	function locallyInside(a, b) {
		return area(a.prev, a, a.next) < 0 ?
			area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
			area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	}
	// check if the middle point of a polygon diagonal is inside the polygon
	function middleInside(a, b) {
		let p = a,
			inside = false;
		const px = (a.x + b.x) / 2,
			py = (a.y + b.y) / 2;
		do {
			if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
				(px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
				inside = !inside;
			p = p.next;
		} while (p !== a);
		return inside;
	}
	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring
	function splitPolygon(a, b) {
		const a2 = new Node(a.i, a.x, a.y),
			b2 = new Node(b.i, b.x, b.y),
			an = a.next,
			bp = b.prev;
		a.next = b;
		b.prev = a;
		a2.next = an;
		an.prev = a2;
		b2.next = a2;
		a2.prev = b2;
		bp.next = b2;
		b2.prev = bp;
		return b2;
	}
	// create a node and optionally link it with previous one (in a circular doubly linked list)
	function insertNode(i, x, y, last) {
		const p = new Node(i, x, y);
		if (!last) {
			p.prev = p;
			p.next = p;
		} else {
			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;
		}
		return p;
	}

	function removeNode(p) {
		p.next.prev = p.prev;
		p.prev.next = p.next;
		if (p.prevZ) p.prevZ.nextZ = p.nextZ;
		if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}

	function Node(i, x, y) {
		// vertex index in coordinates array
		this.i = i;
		// vertex coordinates
		this.x = x;
		this.y = y;
		// previous and next vertex nodes in a polygon ring
		this.prev = null;
		this.next = null;
		// z-order curve value
		this.z = 0;
		// previous and next nodes in z-order
		this.prevZ = null;
		this.nextZ = null;
		// indicates whether this is a steiner point
		this.steiner = false;
	}

	function signedArea(data, start, end, dim) {
		let sum = 0;
		for (let i = start, j = end - dim; i < end; i += dim) {
			sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
			j = i;
		}
		return sum;
	}
	class ShapeUtils {
		// calculate area of the contour polygon
		static area(contour) {
			const n = contour.length;
			let a = 0.0;
			for (let p = n - 1, q = 0; q < n; p = q++) {
				a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
			}
			return a * 0.5;
		}
		static isClockWise(pts) {
			return ShapeUtils.area(pts) < 0;
		}
		static triangulateShape(contour, holes) {
			const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
			const holeIndices = []; // array of hole indices
			const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
			removeDupEndPts(contour);
			addContour(vertices, contour);
			//
			let holeIndex = contour.length;
			holes.forEach(removeDupEndPts);
			for (let i = 0; i < holes.length; i++) {
				holeIndices.push(holeIndex);
				holeIndex += holes[i].length;
				addContour(vertices, holes[i]);
			}
			//
			const triangles = Earcut.triangulate(vertices, holeIndices);
			//
			for (let i = 0; i < triangles.length; i += 3) {
				faces.push(triangles.slice(i, i + 3));
			}
			return faces;
		}
	}

	function removeDupEndPts(points) {
		const l = points.length;
		if (l > 2 && points[l - 1].equals(points[0])) {
			points.pop();
		}
	}

	function addContour(vertices, contour) {
		for (let i = 0; i < contour.length; i++) {
			vertices.push(contour[i].x);
			vertices.push(contour[i].y);
		}
	}
	/**
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  depth: <float>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
	 *  bevelOffset: <float>, // how far from shape outline does bevel start
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *
	 *  UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */
	class ExtrudeGeometry extends BufferGeometry {
		constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
			super();
			this.type = 'ExtrudeGeometry';
			this.parameters = {
				shapes: shapes,
				options: options
			};
			shapes = Array.isArray(shapes) ? shapes : [shapes];
			const scope = this;
			const verticesArray = [];
			const uvArray = [];
			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];
				addShape(shape);
			}
			// build geometry
			this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
			this.computeVertexNormals();
			// functions
			function addShape(shape) {
				const placeholder = [];
				// options
				const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
				const steps = options.steps !== undefined ? options.steps : 1;
				const depth = options.depth !== undefined ? options.depth : 1;
				let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
				let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
				let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
				let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
				let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
				const extrudePath = options.extrudePath;
				const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;
				//
				let extrudePts, extrudeByPath = false;
				let splineTube, binormal, normal, position2;
				if (extrudePath) {
					extrudePts = extrudePath.getSpacedPoints(steps);
					extrudeByPath = true;
					bevelEnabled = false; // bevels not supported for path extrusion
					// SETUP TNB variables
					// TODO1 - have a .isClosed in spline?
					splineTube = extrudePath.computeFrenetFrames(steps, false);
					// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
					binormal = new Vector3();
					normal = new Vector3();
					position2 = new Vector3();
				}
				// Safeguards if bevels are not enabled
				if (!bevelEnabled) {
					bevelSegments = 0;
					bevelThickness = 0;
					bevelSize = 0;
					bevelOffset = 0;
				}
				// Variables initialization
				const shapePoints = shape.extractPoints(curveSegments);
				let vertices = shapePoints.shape;
				const holes = shapePoints.holes;
				const reverse = !ShapeUtils.isClockWise(vertices);
				if (reverse) {
					vertices = vertices.reverse();
					// Maybe we should also check if holes are in the opposite direction, just to be safe ...
					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];
						if (ShapeUtils.isClockWise(ahole)) {
							holes[h] = ahole.reverse();
						}
					}
				}
				const faces = ShapeUtils.triangulateShape(vertices, holes);
				/* Vertices */
				const contour = vertices; // vertices has all points but contour has only points of circumference
				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					vertices = vertices.concat(ahole);
				}

				function scalePt2(pt, vec, size) {
					if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
					return pt.clone().addScaledVector(vec, size);
				}
				const vlen = vertices.length,
					flen = faces.length;
				// Find directions for point movement
				function getBevelVec(inPt, inPrev, inNext) {
					// computes for inPt the corresponding point inPt' on a new contour
					//   shifted by 1 unit (length of normalized vector) to the left
					// if we walk along contour clockwise, this new contour is outside the old one
					//
					// inPt' is the intersection of the two lines parallel to the two
					//  adjacent edges of inPt at a distance of 1 unit on the left side.
					let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
					// good reading for geometry algorithms (here: line-line intersection)
					// http://geomalgorithms.com/a05-_intersect-1.html
					const v_prev_x = inPt.x - inPrev.x,
						v_prev_y = inPt.y - inPrev.y;
					const v_next_x = inNext.x - inPt.x,
						v_next_y = inNext.y - inPt.y;
					const v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
					// check for collinear edges
					const collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
					if (Math.abs(collinear0) > Number.EPSILON) {
						// not collinear
						// length of vectors for normalizing
						const v_prev_len = Math.sqrt(v_prev_lensq);
						const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
						// shift adjacent points by unit vectors to the left
						const ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
						const ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);
						const ptNextShift_x = (inNext.x - v_next_y / v_next_len);
						const ptNextShift_y = (inNext.y + v_next_x / v_next_len);
						// scaling factor for v_prev to intersection point
						const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -
								(ptNextShift_y - ptPrevShift_y) * v_next_x) /
							(v_prev_x * v_next_y - v_prev_y * v_next_x);
						// vector from inPt to intersection point
						v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
						v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);
						// Don't normalize!, otherwise sharp corners become ugly
						//  but prevent crazy spikes
						const v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
						if (v_trans_lensq <= 2) {
							return new Vector2(v_trans_x, v_trans_y);
						} else {
							shrink_by = Math.sqrt(v_trans_lensq / 2);
						}
					} else {
						// handle special case of collinear edges
						let direction_eq = false; // assumes: opposite
						if (v_prev_x > Number.EPSILON) {
							if (v_next_x > Number.EPSILON) {
								direction_eq = true;
							}
						} else {
							if (v_prev_x < -Number.EPSILON) {
								if (v_next_x < -Number.EPSILON) {
									direction_eq = true;
								}
							} else {
								if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
									direction_eq = true;
								}
							}
						}
						if (direction_eq) {
							// console.log("Warning: lines are a straight sequence");
							v_trans_x = -v_prev_y;
							v_trans_y = v_prev_x;
							shrink_by = Math.sqrt(v_prev_lensq);
						} else {
							// console.log("Warning: lines are a straight spike");
							v_trans_x = v_prev_x;
							v_trans_y = v_prev_y;
							shrink_by = Math.sqrt(v_prev_lensq / 2);
						}
					}
					return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
				}
				const contourMovements = [];
				for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
					if (j === il) j = 0;
					if (k === il) k = 0;
					//  (j)---(i)---(k)
					// console.log('i,j,k', i, j , k)
					contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
				}
				const holesMovements = [];
				let oneHoleMovements, verticesMovements = contourMovements.concat();
				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					oneHoleMovements = [];
					for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
						if (j === il) j = 0;
						if (k === il) k = 0;
						//  (j)---(i)---(k)
						oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
					}
					holesMovements.push(oneHoleMovements);
					verticesMovements = verticesMovements.concat(oneHoleMovements);
				}
				// Loop bevelSegments, 1 for the front, 1 for the back
				for (let b = 0; b < bevelSegments; b++) {
					//for ( b = bevelSegments; b > 0; b -- ) {
					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos(t * Math.PI / 2);
					const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
					// contract shape
					for (let i = 0, il = contour.length; i < il; i++) {
						const vert = scalePt2(contour[i], contourMovements[i], bs);
						v(vert.x, vert.y, -z);
					}
					// expand holes
					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];
						oneHoleMovements = holesMovements[h];
						for (let i = 0, il = ahole.length; i < il; i++) {
							const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
							v(vert.x, vert.y, -z);
						}
					}
				}
				const bs = bevelSize + bevelOffset;
				// Back facing vertices
				for (let i = 0; i < vlen; i++) {
					const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
					if (!extrudeByPath) {
						v(vert.x, vert.y, 0);
					} else {
						// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
						normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
						binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
						position2.copy(extrudePts[0]).add(normal).add(binormal);
						v(position2.x, position2.y, position2.z);
					}
				}
				// Add stepped vertices...
				// Including front facing vertices
				for (let s = 1; s <= steps; s++) {
					for (let i = 0; i < vlen; i++) {
						const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
						if (!extrudeByPath) {
							v(vert.x, vert.y, depth / steps * s);
						} else {
							// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
							normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
							binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
							position2.copy(extrudePts[s]).add(normal).add(binormal);
							v(position2.x, position2.y, position2.z);
						}
					}
				}
				// Add bevel segments planes
				//for ( b = 1; b <= bevelSegments; b ++ ) {
				for (let b = bevelSegments - 1; b >= 0; b--) {
					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos(t * Math.PI / 2);
					const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
					// contract shape
					for (let i = 0, il = contour.length; i < il; i++) {
						const vert = scalePt2(contour[i], contourMovements[i], bs);
						v(vert.x, vert.y, depth + z);
					}
					// expand holes
					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];
						oneHoleMovements = holesMovements[h];
						for (let i = 0, il = ahole.length; i < il; i++) {
							const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
							if (!extrudeByPath) {
								v(vert.x, vert.y, depth + z);
							} else {
								v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
							}
						}
					}
				}
				/* Faces */
				// Top and bottom faces
				buildLidFaces();
				// Sides faces
				buildSideFaces();
				/////  Internal functions
				function buildLidFaces() {
					const start = verticesArray.length / 3;
					if (bevelEnabled) {
						let layer = 0; // steps + 1
						let offset = vlen * layer;
						// Bottom faces
						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[2] + offset, face[1] + offset, face[0] + offset);
						}
						layer = steps + bevelSegments * 2;
						offset = vlen * layer;
						// Top faces
						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[0] + offset, face[1] + offset, face[2] + offset);
						}
					} else {
						// Bottom faces
						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[2], face[1], face[0]);
						}
						// Top faces
						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
						}
					}
					scope.addGroup(start, verticesArray.length / 3 - start, 0);
				}
				// Create faces for the z-sides of the shape
				function buildSideFaces() {
					const start = verticesArray.length / 3;
					let layeroffset = 0;
					sidewalls(contour, layeroffset);
					layeroffset += contour.length;
					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];
						sidewalls(ahole, layeroffset);
						//, true
						layeroffset += ahole.length;
					}
					scope.addGroup(start, verticesArray.length / 3 - start, 1);
				}

				function sidewalls(contour, layeroffset) {
					let i = contour.length;
					while (--i >= 0) {
						const j = i;
						let k = i - 1;
						if (k < 0) k = contour.length - 1;
						//console.log('b', i,j, i-1, k,vertices.length);
						for (let s = 0, sl = (steps + bevelSegments * 2); s < sl; s++) {
							const slen1 = vlen * s;
							const slen2 = vlen * (s + 1);
							const a = layeroffset + j + slen1,
								b = layeroffset + k + slen1,
								c = layeroffset + k + slen2,
								d = layeroffset + j + slen2;
							f4(a, b, c, d);
						}
					}
				}

				function v(x, y, z) {
					placeholder.push(x);
					placeholder.push(y);
					placeholder.push(z);
				}

				function f3(a, b, c) {
					addVertex(a);
					addVertex(b);
					addVertex(c);
					const nextIndex = verticesArray.length / 3;
					const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
					addUV(uvs[0]);
					addUV(uvs[1]);
					addUV(uvs[2]);
				}

				function f4(a, b, c, d) {
					addVertex(a);
					addVertex(b);
					addVertex(d);
					addVertex(b);
					addVertex(c);
					addVertex(d);
					const nextIndex = verticesArray.length / 3;
					const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
					addUV(uvs[0]);
					addUV(uvs[1]);
					addUV(uvs[3]);
					addUV(uvs[1]);
					addUV(uvs[2]);
					addUV(uvs[3]);
				}

				function addVertex(index) {
					verticesArray.push(placeholder[index * 3 + 0]);
					verticesArray.push(placeholder[index * 3 + 1]);
					verticesArray.push(placeholder[index * 3 + 2]);
				}

				function addUV(vector2) {
					uvArray.push(vector2.x);
					uvArray.push(vector2.y);
				}
			}
		}
		copy(source) {
			super.copy(source);
			this.parameters = Object.assign({}, source.parameters);
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			const shapes = this.parameters.shapes;
			const options = this.parameters.options;
			return toJSON$1(shapes, options, data);
		}
		static fromJSON(data, shapes) {
			const geometryShapes = [];
			for (let j = 0, jl = data.shapes.length; j < jl; j++) {
				const shape = shapes[data.shapes[j]];
				geometryShapes.push(shape);
			}
			const extrudePath = data.options.extrudePath;
			if (extrudePath !== undefined) {
				data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
			}
			return new ExtrudeGeometry(geometryShapes, data.options);
		}
	}
	const WorldUVGenerator = {
		generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
			const a_x = vertices[indexA * 3];
			const a_y = vertices[indexA * 3 + 1];
			const b_x = vertices[indexB * 3];
			const b_y = vertices[indexB * 3 + 1];
			const c_x = vertices[indexC * 3];
			const c_y = vertices[indexC * 3 + 1];
			return [
				new Vector2(a_x, a_y),
				new Vector2(b_x, b_y),
				new Vector2(c_x, c_y)
			];
		},
		generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
			const a_x = vertices[indexA * 3];
			const a_y = vertices[indexA * 3 + 1];
			const a_z = vertices[indexA * 3 + 2];
			const b_x = vertices[indexB * 3];
			const b_y = vertices[indexB * 3 + 1];
			const b_z = vertices[indexB * 3 + 2];
			const c_x = vertices[indexC * 3];
			const c_y = vertices[indexC * 3 + 1];
			const c_z = vertices[indexC * 3 + 2];
			const d_x = vertices[indexD * 3];
			const d_y = vertices[indexD * 3 + 1];
			const d_z = vertices[indexD * 3 + 2];
			if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
				return [
					new Vector2(a_x, 1 - a_z),
					new Vector2(b_x, 1 - b_z),
					new Vector2(c_x, 1 - c_z),
					new Vector2(d_x, 1 - d_z)
				];
			} else {
				return [
					new Vector2(a_y, 1 - a_z),
					new Vector2(b_y, 1 - b_z),
					new Vector2(c_y, 1 - c_z),
					new Vector2(d_y, 1 - d_z)
				];
			}
		}
	};

	function toJSON$1(shapes, options, data) {
		data.shapes = [];
		if (Array.isArray(shapes)) {
			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];
				data.shapes.push(shape.uuid);
			}
		} else {
			data.shapes.push(shapes.uuid);
		}
		data.options = Object.assign({}, options);
		if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
		return data;
	}
	class IcosahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const t = (1 + Math.sqrt(5)) / 2;
			const vertices = [
				-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0,
				0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t,
				t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1
			];
			const indices = [
				0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,
				1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
				3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
				4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
			];
			super(vertices, indices, radius, detail);
			this.type = 'IcosahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}
		static fromJSON(data) {
			return new IcosahedronGeometry(data.radius, data.detail);
		}
	}
	class OctahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const vertices = [
				1, 0, 0, -1, 0, 0, 0, 1, 0,
				0, -1, 0, 0, 0, 1, 0, 0, -1
			];
			const indices = [
				0, 2, 4, 0, 4, 3, 0, 3, 5,
				0, 5, 2, 1, 2, 5, 1, 5, 3,
				1, 3, 4, 1, 4, 2
			];
			super(vertices, indices, radius, detail);
			this.type = 'OctahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}
		static fromJSON(data) {
			return new OctahedronGeometry(data.radius, data.detail);
		}
	}
	class RingGeometry extends BufferGeometry {
		constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
			super();
			this.type = 'RingGeometry';
			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			thetaSegments = Math.max(3, thetaSegments);
			phiSegments = Math.max(1, phiSegments);
			// buffers
			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];
			// some helper variables
			let radius = innerRadius;
			const radiusStep = ((outerRadius - innerRadius) / phiSegments);
			const vertex = new Vector3();
			const uv = new Vector2();
			// generate vertices, normals and uvs
			for (let j = 0; j <= phiSegments; j++) {
				for (let i = 0; i <= thetaSegments; i++) {
					// values are generate from the inside of the ring to the outside
					const segment = thetaStart + i / thetaSegments * thetaLength;
					// vertex
					vertex.x = radius * Math.cos(segment);
					vertex.y = radius * Math.sin(segment);
					vertices.push(vertex.x, vertex.y, vertex.z);
					// normal
					normals.push(0, 0, 1);
					// uv
					uv.x = (vertex.x / outerRadius + 1) / 2;
					uv.y = (vertex.y / outerRadius + 1) / 2;
					uvs.push(uv.x, uv.y);
				}
				// increase the radius for next row of vertices
				radius += radiusStep;
			}
			// indices
			for (let j = 0; j < phiSegments; j++) {
				const thetaSegmentLevel = j * (thetaSegments + 1);
				for (let i = 0; i < thetaSegments; i++) {
					const segment = i + thetaSegmentLevel;
					const a = segment;
					const b = segment + thetaSegments + 1;
					const c = segment + thetaSegments + 2;
					const d = segment + 1;
					// faces
					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			}
			// build geometry
			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}
		copy(source) {
			super.copy(source);
			this.parameters = Object.assign({}, source.parameters);
			return this;
		}
		static fromJSON(data) {
			return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
		}
	}
	class ShapeGeometry extends BufferGeometry {
		constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
			super();
			this.type = 'ShapeGeometry';
			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			};
			// buffers
			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];
			// helper variables
			let groupStart = 0;
			let groupCount = 0;
			// allow single and array values for "shapes" parameter
			if (Array.isArray(shapes) === false) {
				addShape(shapes);
			} else {
				for (let i = 0; i < shapes.length; i++) {
					addShape(shapes[i]);
					this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support
					groupStart += groupCount;
					groupCount = 0;
				}
			}
			// build geometry
			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
			// helper functions
			function addShape(shape) {
				const indexOffset = vertices.length / 3;
				const points = shape.extractPoints(curveSegments);
				let shapeVertices = points.shape;
				const shapeHoles = points.holes;
				// check direction of vertices
				if (ShapeUtils.isClockWise(shapeVertices) === false) {
					shapeVertices = shapeVertices.reverse();
				}
				for (let i = 0, l = shapeHoles.length; i < l; i++) {
					const shapeHole = shapeHoles[i];
					if (ShapeUtils.isClockWise(shapeHole) === true) {
						shapeHoles[i] = shapeHole.reverse();
					}
				}
				const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
				// join vertices of inner and outer paths to a single array
				for (let i = 0, l = shapeHoles.length; i < l; i++) {
					const shapeHole = shapeHoles[i];
					shapeVertices = shapeVertices.concat(shapeHole);
				}
				// vertices, normals, uvs
				for (let i = 0, l = shapeVertices.length; i < l; i++) {
					const vertex = shapeVertices[i];
					vertices.push(vertex.x, vertex.y, 0);
					normals.push(0, 0, 1);
					uvs.push(vertex.x, vertex.y); // world uvs
				}
				// indices
				for (let i = 0, l = faces.length; i < l; i++) {
					const face = faces[i];
					const a = face[0] + indexOffset;
					const b = face[1] + indexOffset;
					const c = face[2] + indexOffset;
					indices.push(a, b, c);
					groupCount += 3;
				}
			}
		}
		copy(source) {
			super.copy(source);
			this.parameters = Object.assign({}, source.parameters);
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			const shapes = this.parameters.shapes;
			return toJSON(shapes, data);
		}
		static fromJSON(data, shapes) {
			const geometryShapes = [];
			for (let j = 0, jl = data.shapes.length; j < jl; j++) {
				const shape = shapes[data.shapes[j]];
				geometryShapes.push(shape);
			}
			return new ShapeGeometry(geometryShapes, data.curveSegments);
		}
	}

	function toJSON(shapes, data) {
		data.shapes = [];
		if (Array.isArray(shapes)) {
			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];
				data.shapes.push(shape.uuid);
			}
		} else {
			data.shapes.push(shapes.uuid);
		}
		return data;
	}
	class SphereGeometry extends BufferGeometry {
		constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
			super();
			this.type = 'SphereGeometry';
			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			widthSegments = Math.max(3, Math.floor(widthSegments));
			heightSegments = Math.max(2, Math.floor(heightSegments));
			const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
			let index = 0;
			const grid = [];
			const vertex = new Vector3();
			const normal = new Vector3();
			// buffers
			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];
			// generate vertices, normals and uvs
			for (let iy = 0; iy <= heightSegments; iy++) {
				const verticesRow = [];
				const v = iy / heightSegments;
				// special case for the poles
				let uOffset = 0;
				if (iy == 0 && thetaStart == 0) {
					uOffset = 0.5 / widthSegments;
				} else if (iy == heightSegments && thetaEnd == Math.PI) {
					uOffset = -0.5 / widthSegments;
				}
				for (let ix = 0; ix <= widthSegments; ix++) {
					const u = ix / widthSegments;
					// vertex
					vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
					vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
					vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
					vertices.push(vertex.x, vertex.y, vertex.z);
					// normal
					normal.copy(vertex).normalize();
					normals.push(normal.x, normal.y, normal.z);
					// uv
					uvs.push(u + uOffset, 1 - v);
					verticesRow.push(index++);
				}
				grid.push(verticesRow);
			}
			// indices
			for (let iy = 0; iy < heightSegments; iy++) {
				for (let ix = 0; ix < widthSegments; ix++) {
					const a = grid[iy][ix + 1];
					const b = grid[iy][ix];
					const c = grid[iy + 1][ix];
					const d = grid[iy + 1][ix + 1];
					if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
					if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
				}
			}
			// build geometry
			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}
		copy(source) {
			super.copy(source);
			this.parameters = Object.assign({}, source.parameters);
			return this;
		}
		static fromJSON(data) {
			return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
		}
	}
	class TetrahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const vertices = [
				1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1
			];
			const indices = [
				2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1
			];
			super(vertices, indices, radius, detail);
			this.type = 'TetrahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}
		static fromJSON(data) {
			return new TetrahedronGeometry(data.radius, data.detail);
		}
	}
	class TorusGeometry extends BufferGeometry {
		constructor(radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2) {
			super();
			this.type = 'TorusGeometry';
			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};
			radialSegments = Math.floor(radialSegments);
			tubularSegments = Math.floor(tubularSegments);
			// buffers
			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];
			// helper variables
			const center = new Vector3();
			const vertex = new Vector3();
			const normal = new Vector3();
			// generate vertices, normals and uvs
			for (let j = 0; j <= radialSegments; j++) {
				for (let i = 0; i <= tubularSegments; i++) {
					const u = i / tubularSegments * arc;
					const v = j / radialSegments * Math.PI * 2;
					// vertex
					vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
					vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
					vertex.z = tube * Math.sin(v);
					vertices.push(vertex.x, vertex.y, vertex.z);
					// normal
					center.x = radius * Math.cos(u);
					center.y = radius * Math.sin(u);
					normal.subVectors(vertex, center).normalize();
					normals.push(normal.x, normal.y, normal.z);
					// uv
					uvs.push(i / tubularSegments);
					uvs.push(j / radialSegments);
				}
			}
			// generate indices
			for (let j = 1; j <= radialSegments; j++) {
				for (let i = 1; i <= tubularSegments; i++) {
					// indices
					const a = (tubularSegments + 1) * j + i - 1;
					const b = (tubularSegments + 1) * (j - 1) + i - 1;
					const c = (tubularSegments + 1) * (j - 1) + i;
					const d = (tubularSegments + 1) * j + i;
					// faces
					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			}
			// build geometry
			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}
		copy(source) {
			super.copy(source);
			this.parameters = Object.assign({}, source.parameters);
			return this;
		}
		static fromJSON(data) {
			return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
		}
	}
	class TorusKnotGeometry extends BufferGeometry {
		constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
			super();
			this.type = 'TorusKnotGeometry';
			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};
			tubularSegments = Math.floor(tubularSegments);
			radialSegments = Math.floor(radialSegments);
			// buffers
			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];
			// helper variables
			const vertex = new Vector3();
			const normal = new Vector3();
			const P1 = new Vector3();
			const P2 = new Vector3();
			const B = new Vector3();
			const T = new Vector3();
			const N = new Vector3();
			// generate vertices, normals and uvs
			for (let i = 0; i <= tubularSegments; ++i) {
				// the radian "u" is used to calculate the position on the torus curve of the current tubular segment
				const u = i / tubularSegments * p * Math.PI * 2;
				// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
				calculatePositionOnCurve(u, p, q, radius, P1);
				calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
				// calculate orthonormal basis
				T.subVectors(P2, P1);
				N.addVectors(P2, P1);
				B.crossVectors(T, N);
				N.crossVectors(B, T);
				// normalize B, N. T can be ignored, we don't use it
				B.normalize();
				N.normalize();
				for (let j = 0; j <= radialSegments; ++j) {
					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
					const v = j / radialSegments * Math.PI * 2;
					const cx = -tube * Math.cos(v);
					const cy = tube * Math.sin(v);
					// now calculate the final vertex position.
					// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve
					vertex.x = P1.x + (cx * N.x + cy * B.x);
					vertex.y = P1.y + (cx * N.y + cy * B.y);
					vertex.z = P1.z + (cx * N.z + cy * B.z);
					vertices.push(vertex.x, vertex.y, vertex.z);
					// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
					normal.subVectors(vertex, P1).normalize();
					normals.push(normal.x, normal.y, normal.z);
					// uv
					uvs.push(i / tubularSegments);
					uvs.push(j / radialSegments);
				}
			}
			// generate indices
			for (let j = 1; j <= tubularSegments; j++) {
				for (let i = 1; i <= radialSegments; i++) {
					// indices
					const a = (radialSegments + 1) * (j - 1) + (i - 1);
					const b = (radialSegments + 1) * j + (i - 1);
					const c = (radialSegments + 1) * j + i;
					const d = (radialSegments + 1) * (j - 1) + i;
					// faces
					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			}
			// build geometry
			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
			// this function calculates the current position on the torus curve
			function calculatePositionOnCurve(u, p, q, radius, position) {
				const cu = Math.cos(u);
				const su = Math.sin(u);
				const quOverP = q / p * u;
				const cs = Math.cos(quOverP);
				position.x = radius * (2 + cs) * 0.5 * cu;
				position.y = radius * (2 + cs) * su * 0.5;
				position.z = radius * Math.sin(quOverP) * 0.5;
			}
		}
		copy(source) {
			super.copy(source);
			this.parameters = Object.assign({}, source.parameters);
			return this;
		}
		static fromJSON(data) {
			return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
		}
	}
	class TubeGeometry extends BufferGeometry {
		constructor(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
			super();
			this.type = 'TubeGeometry';
			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};
			const frames = path.computeFrenetFrames(tubularSegments, closed);
			// expose internals
			this.tangents = frames.tangents;
			this.normals = frames.normals;
			this.binormals = frames.binormals;
			// helper variables
			const vertex = new Vector3();
			const normal = new Vector3();
			const uv = new Vector2();
			let P = new Vector3();
			// buffer
			const vertices = [];
			const normals = [];
			const uvs = [];
			const indices = [];
			// create buffer data
			generateBufferData();
			// build geometry
			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
			// functions
			function generateBufferData() {
				for (let i = 0; i < tubularSegments; i++) {
					generateSegment(i);
				}
				// if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
				generateSegment((closed === false) ? tubularSegments : 0);
				// uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries
				generateUVs();
				// finally create faces
				generateIndices();
			}

			function generateSegment(i) {
				// we use getPointAt to sample evenly distributed points from the given path
				P = path.getPointAt(i / tubularSegments, P);
				// retrieve corresponding normal and binormal
				const N = frames.normals[i];
				const B = frames.binormals[i];
				// generate normals and vertices for the current segment
				for (let j = 0; j <= radialSegments; j++) {
					const v = j / radialSegments * Math.PI * 2;
					const sin = Math.sin(v);
					const cos = -Math.cos(v);
					// normal
					normal.x = (cos * N.x + sin * B.x);
					normal.y = (cos * N.y + sin * B.y);
					normal.z = (cos * N.z + sin * B.z);
					normal.normalize();
					normals.push(normal.x, normal.y, normal.z);
					// vertex
					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;
					vertices.push(vertex.x, vertex.y, vertex.z);
				}
			}

			function generateIndices() {
				for (let j = 1; j <= tubularSegments; j++) {
					for (let i = 1; i <= radialSegments; i++) {
						const a = (radialSegments + 1) * (j - 1) + (i - 1);
						const b = (radialSegments + 1) * j + (i - 1);
						const c = (radialSegments + 1) * j + i;
						const d = (radialSegments + 1) * (j - 1) + i;
						// faces
						indices.push(a, b, d);
						indices.push(b, c, d);
					}
				}
			}

			function generateUVs() {
				for (let i = 0; i <= tubularSegments; i++) {
					for (let j = 0; j <= radialSegments; j++) {
						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;
						uvs.push(uv.x, uv.y);
					}
				}
			}
		}
		copy(source) {
			super.copy(source);
			this.parameters = Object.assign({}, source.parameters);
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			data.path = this.parameters.path.toJSON();
			return data;
		}
		static fromJSON(data) {
			// This only works for built-in curves (e.g. CatmullRomCurve3).
			// User defined curves or instances of CurvePath will not be deserialized.
			return new TubeGeometry(
				new Curves[data.path.type]().fromJSON(data.path),
				data.tubularSegments,
				data.radius,
				data.radialSegments,
				data.closed
			);
		}
	}
	class WireframeGeometry extends BufferGeometry {
		constructor(geometry = null) {
			super();
			this.type = 'WireframeGeometry';
			this.parameters = {
				geometry: geometry
			};
			if (geometry !== null) {
				// buffer
				const vertices = [];
				const edges = new Set();
				// helper variables
				const start = new Vector3();
				const end = new Vector3();
				if (geometry.index !== null) {
					// indexed BufferGeometry
					const position = geometry.attributes.position;
					const indices = geometry.index;
					let groups = geometry.groups;
					if (groups.length === 0) {
						groups = [{
							start: 0,
							count: indices.count,
							materialIndex: 0
						}];
					}
					// create a data structure that contains all edges without duplicates
					for (let o = 0, ol = groups.length; o < ol; ++o) {
						const group = groups[o];
						const groupStart = group.start;
						const groupCount = group.count;
						for (let i = groupStart, l = (groupStart + groupCount); i < l; i += 3) {
							for (let j = 0; j < 3; j++) {
								const index1 = indices.getX(i + j);
								const index2 = indices.getX(i + (j + 1) % 3);
								start.fromBufferAttribute(position, index1);
								end.fromBufferAttribute(position, index2);
								if (isUniqueEdge(start, end, edges) === true) {
									vertices.push(start.x, start.y, start.z);
									vertices.push(end.x, end.y, end.z);
								}
							}
						}
					}
				} else {
					// non-indexed BufferGeometry
					const position = geometry.attributes.position;
					for (let i = 0, l = (position.count / 3); i < l; i++) {
						for (let j = 0; j < 3; j++) {
							// three edges per triangle, an edge is represented as (index1, index2)
							// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
							const index1 = 3 * i + j;
							const index2 = 3 * i + ((j + 1) % 3);
							start.fromBufferAttribute(position, index1);
							end.fromBufferAttribute(position, index2);
							if (isUniqueEdge(start, end, edges) === true) {
								vertices.push(start.x, start.y, start.z);
								vertices.push(end.x, end.y, end.z);
							}
						}
					}
				}
				// build geometry
				this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			}
		}
		copy(source) {
			super.copy(source);
			this.parameters = Object.assign({}, source.parameters);
			return this;
		}
	}

	function isUniqueEdge(start, end, edges) {
		const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
		const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge
		if (edges.has(hash1) === true || edges.has(hash2) === true) {
			return false;
		} else {
			edges.add(hash1);
			edges.add(hash2);
			return true;
		}
	}
	var Geometries = /*#__PURE__*/ Object.freeze({
		__proto__: null,
		BoxGeometry: BoxGeometry,
		CapsuleGeometry: CapsuleGeometry,
		CircleGeometry: CircleGeometry,
		ConeGeometry: ConeGeometry,
		CylinderGeometry: CylinderGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		EdgesGeometry: EdgesGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		LatheGeometry: LatheGeometry,
		OctahedronGeometry: OctahedronGeometry,
		PlaneGeometry: PlaneGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		RingGeometry: RingGeometry,
		ShapeGeometry: ShapeGeometry,
		SphereGeometry: SphereGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TorusGeometry: TorusGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TubeGeometry: TubeGeometry,
		WireframeGeometry: WireframeGeometry
	});
	class ShadowMaterial extends Material {
		constructor(parameters) {
			super();
			this.isShadowMaterial = true;
			this.type = 'ShadowMaterial';
			this.color = new Color(0x000000);
			this.transparent = true;
			this.fog = true;
			this.setValues(parameters);
		}
		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.fog = source.fog;
			return this;
		}
	}
	class RawShaderMaterial extends ShaderMaterial {
		constructor(parameters) {
			super(parameters);
			this.isRawShaderMaterial = true;
			this.type = 'RawShaderMaterial';
		}
	}
	class MeshStandardMaterial extends Material {
		constructor(parameters) {
			super();
			this.isMeshStandardMaterial = true;
			this.defines = {
				'STANDARD': ''
			};
			this.type = 'MeshStandardMaterial';
			this.color = new Color(0xffffff); // diffuse
			this.roughness = 1.0;
			this.metalness = 0.0;
			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.roughnessMap = null;
			this.metalnessMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.envMapIntensity = 1.0;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.flatShading = false;
			this.fog = true;
			this.setValues(parameters);
		}
		copy(source) {
			super.copy(source);
			this.defines = {
				'STANDARD': ''
			};
			this.color.copy(source.color);
			this.roughness = source.roughness;
			this.metalness = source.metalness;
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.roughnessMap = source.roughnessMap;
			this.metalnessMap = source.metalnessMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.flatShading = source.flatShading;
			this.fog = source.fog;
			return this;
		}
	}
	class MeshPhysicalMaterial extends MeshStandardMaterial {
		constructor(parameters) {
			super();
			this.isMeshPhysicalMaterial = true;
			this.defines = {
				'STANDARD': '',
				'PHYSICAL': ''
			};
			this.type = 'MeshPhysicalMaterial';
			this.clearcoatMap = null;
			this.clearcoatRoughness = 0.0;
			this.clearcoatRoughnessMap = null;
			this.clearcoatNormalScale = new Vector2(1, 1);
			this.clearcoatNormalMap = null;
			this.ior = 1.5;
			Object.defineProperty(this, 'reflectivity', {
				get: function() {
					return (clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1));
				},
				set: function(reflectivity) {
					this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
				}
			});
			this.iridescenceMap = null;
			this.iridescenceIOR = 1.3;
			this.iridescenceThicknessRange = [100, 400];
			this.iridescenceThicknessMap = null;
			this.sheenColor = new Color(0x000000);
			this.sheenColorMap = null;
			this.sheenRoughness = 1.0;
			this.sheenRoughnessMap = null;
			this.transmissionMap = null;
			this.thickness = 0;
			this.thicknessMap = null;
			this.attenuationDistance = Infinity;
			this.attenuationColor = new Color(1, 1, 1);
			this.specularIntensity = 1.0;
			this.specularIntensityMap = null;
			this.specularColor = new Color(1, 1, 1);
			this.specularColorMap = null;
			this._sheen = 0.0;
			this._clearcoat = 0;
			this._iridescence = 0;
			this._transmission = 0;
			this.setValues(parameters);
		}
		get sheen() {
			return this._sheen;
		}
		set sheen(value) {
			if (this._sheen > 0 !== value > 0) {
				this.version++;
			}
			this._sheen = value;
		}
		get clearcoat() {
			return this._clearcoat;
		}
		set clearcoat(value) {
			if (this._clearcoat > 0 !== value > 0) {
				this.version++;
			}
			this._clearcoat = value;
		}
		get iridescence() {
			return this._iridescence;
		}
		set iridescence(value) {
			if (this._iridescence > 0 !== value > 0) {
				this.version++;
			}
			this._iridescence = value;
		}
		get transmission() {
			return this._transmission;
		}
		set transmission(value) {
			if (this._transmission > 0 !== value > 0) {
				this.version++;
			}
			this._transmission = value;
		}
		copy(source) {
			super.copy(source);
			this.defines = {
				'STANDARD': '',
				'PHYSICAL': ''
			};
			this.clearcoat = source.clearcoat;
			this.clearcoatMap = source.clearcoatMap;
			this.clearcoatRoughness = source.clearcoatRoughness;
			this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
			this.clearcoatNormalMap = source.clearcoatNormalMap;
			this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
			this.ior = source.ior;
			this.iridescence = source.iridescence;
			this.iridescenceMap = source.iridescenceMap;
			this.iridescenceIOR = source.iridescenceIOR;
			this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
			this.iridescenceThicknessMap = source.iridescenceThicknessMap;
			this.sheen = source.sheen;
			this.sheenColor.copy(source.sheenColor);
			this.sheenColorMap = source.sheenColorMap;
			this.sheenRoughness = source.sheenRoughness;
			this.sheenRoughnessMap = source.sheenRoughnessMap;
			this.transmission = source.transmission;
			this.transmissionMap = source.transmissionMap;
			this.thickness = source.thickness;
			this.thicknessMap = source.thicknessMap;
			this.attenuationDistance = source.attenuationDistance;
			this.attenuationColor.copy(source.attenuationColor);
			this.specularIntensity = source.specularIntensity;
			this.specularIntensityMap = source.specularIntensityMap;
			this.specularColor.copy(source.specularColor);
			this.specularColorMap = source.specularColorMap;
			return this;
		}
	}
	class MeshPhongMaterial extends Material {
		constructor(parameters) {
			super();
			this.isMeshPhongMaterial = true;
			this.type = 'MeshPhongMaterial';
			this.color = new Color(0xffffff); // diffuse
			this.specular = new Color(0x111111);
			this.shininess = 30;
			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.specularMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.flatShading = false;
			this.fog = true;
			this.setValues(parameters);
		}
		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.specular.copy(source.specular);
			this.shininess = source.shininess;
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.flatShading = source.flatShading;
			this.fog = source.fog;
			return this;
		}
	}
	class MeshToonMaterial extends Material {
		constructor(parameters) {
			super();
			this.isMeshToonMaterial = true;
			this.defines = {
				'TOON': ''
			};
			this.type = 'MeshToonMaterial';
			this.color = new Color(0xffffff);
			this.map = null;
			this.gradientMap = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.alphaMap = null;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.fog = true;
			this.setValues(parameters);
		}
		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.gradientMap = source.gradientMap;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.alphaMap = source.alphaMap;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.fog = source.fog;
			return this;
		}
	}
	class MeshNormalMaterial extends Material {
		constructor(parameters) {
			super();
			this.isMeshNormalMaterial = true;
			this.type = 'MeshNormalMaterial';
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.flatShading = false;
			this.setValues(parameters);
		}
		copy(source) {
			super.copy(source);
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.flatShading = source.flatShading;
			return this;
		}
	}
	class MeshLambertMaterial extends Material {
		constructor(parameters) {
			super();
			this.isMeshLambertMaterial = true;
			this.type = 'MeshLambertMaterial';
			this.color = new Color(0xffffff); // diffuse
			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.specularMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.flatShading = false;
			this.fog = true;
			this.setValues(parameters);
		}
		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.flatShading = source.flatShading;
			this.fog = source.fog;
			return this;
		}
	}
	class MeshMatcapMaterial extends Material {
		constructor(parameters) {
			super();
			this.isMeshMatcapMaterial = true;
			this.defines = {
				'MATCAP': ''
			};
			this.type = 'MeshMatcapMaterial';
			this.color = new Color(0xffffff); // diffuse
			this.matcap = null;
			this.map = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.alphaMap = null;
			this.flatShading = false;
			this.fog = true;
			this.setValues(parameters);
		}
		copy(source) {
			super.copy(source);
			this.defines = {
				'MATCAP': ''
			};
			this.color.copy(source.color);
			this.matcap = source.matcap;
			this.map = source.map;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.alphaMap = source.alphaMap;
			this.flatShading = source.flatShading;
			this.fog = source.fog;
			return this;
		}
	}
	class LineDashedMaterial extends LineBasicMaterial {
		constructor(parameters) {
			super();
			this.isLineDashedMaterial = true;
			this.type = 'LineDashedMaterial';
			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;
			this.setValues(parameters);
		}
		copy(source) {
			super.copy(source);
			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;
			return this;
		}
	}
	// same as Array.prototype.slice, but also works on typed arrays
	function arraySlice(array, from, to) {
		if (isTypedArray(array)) {
			// in ios9 array.subarray(from, undefined) will return empty array
			// but array.subarray(from) or array.subarray(from, len) is correct
			return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
		}
		return array.slice(from, to);
	}
	// converts an array to a specific type
	function convertArray(array, type, forceClone) {
		if (!array || // let 'undefined' and 'null' pass
			!forceClone && array.constructor === type) return array;
		if (typeof type.BYTES_PER_ELEMENT === 'number') {
			return new type(array); // create typed array
		}
		return Array.prototype.slice.call(array); // create Array
	}

	function isTypedArray(object) {
		return ArrayBuffer.isView(object) &&
			!(object instanceof DataView);
	}
	// returns an array by which times and values can be sorted
	function getKeyframeOrder(times) {
		function compareTime(i, j) {
			return times[i] - times[j];
		}
		const n = times.length;
		const result = new Array(n);
		for (let i = 0; i !== n; ++i) result[i] = i;
		result.sort(compareTime);
		return result;
	}
	// uses the array previously returned by 'getKeyframeOrder' to sort data
	function sortedArray(values, stride, order) {
		const nValues = values.length;
		const result = new values.constructor(nValues);
		for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
			const srcOffset = order[i] * stride;
			for (let j = 0; j !== stride; ++j) {
				result[dstOffset++] = values[srcOffset + j];
			}
		}
		return result;
	}
	// function for parsing AOS keyframe formats
	function flattenJSON(jsonKeys, times, values, valuePropertyName) {
		let i = 1,
			key = jsonKeys[0];
		while (key !== undefined && key[valuePropertyName] === undefined) {
			key = jsonKeys[i++];
		}
		if (key === undefined) return; // no data
		let value = key[valuePropertyName];
		if (value === undefined) return; // no data
		if (Array.isArray(value)) {
			do {
				value = key[valuePropertyName];
				if (value !== undefined) {
					times.push(key.time);
					values.push.apply(values, value); // push all elements
				}
				key = jsonKeys[i++];
			} while (key !== undefined);
		} else if (value.toArray !== undefined) {
			// ...assume THREE.Math-ish
			do {
				value = key[valuePropertyName];
				if (value !== undefined) {
					times.push(key.time);
					value.toArray(values, values.length);
				}
				key = jsonKeys[i++];
			} while (key !== undefined);
		} else {
			// otherwise push as-is
			do {
				value = key[valuePropertyName];
				if (value !== undefined) {
					times.push(key.time);
					values.push(value);
				}
				key = jsonKeys[i++];
			} while (key !== undefined);
		}
	}

	function subclip(sourceClip, name, startFrame, endFrame, fps = 30) {
		const clip = sourceClip.clone();
		clip.name = name;
		const tracks = [];
		for (let i = 0; i < clip.tracks.length; ++i) {
			const track = clip.tracks[i];
			const valueSize = track.getValueSize();
			const times = [];
			const values = [];
			for (let j = 0; j < track.times.length; ++j) {
				const frame = track.times[j] * fps;
				if (frame < startFrame || frame >= endFrame) continue;
				times.push(track.times[j]);
				for (let k = 0; k < valueSize; ++k) {
					values.push(track.values[j * valueSize + k]);
				}
			}
			if (times.length === 0) continue;
			track.times = convertArray(times, track.times.constructor);
			track.values = convertArray(values, track.values.constructor);
			tracks.push(track);
		}
		clip.tracks = tracks;
		// find minimum .times value across all tracks in the trimmed clip
		let minStartTime = Infinity;
		for (let i = 0; i < clip.tracks.length; ++i) {
			if (minStartTime > clip.tracks[i].times[0]) {
				minStartTime = clip.tracks[i].times[0];
			}
		}
		// shift all tracks such that clip begins at t=0
		for (let i = 0; i < clip.tracks.length; ++i) {
			clip.tracks[i].shift(-1 * minStartTime);
		}
		clip.resetDuration();
		return clip;
	}

	function makeClipAdditive(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
		if (fps <= 0) fps = 30;
		const numTracks = referenceClip.tracks.length;
		const referenceTime = referenceFrame / fps;
		// Make each track's values relative to the values at the reference frame
		for (let i = 0; i < numTracks; ++i) {
			const referenceTrack = referenceClip.tracks[i];
			const referenceTrackType = referenceTrack.ValueTypeName;
			// Skip this track if it's non-numeric
			if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue;
			// Find the track in the target clip whose name and type matches the reference track
			const targetTrack = targetClip.tracks.find(function(track) {
				return track.name === referenceTrack.name &&
					track.ValueTypeName === referenceTrackType;
			});
			if (targetTrack === undefined) continue;
			let referenceOffset = 0;
			const referenceValueSize = referenceTrack.getValueSize();
			if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
				referenceOffset = referenceValueSize / 3;
			}
			let targetOffset = 0;
			const targetValueSize = targetTrack.getValueSize();
			if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
				targetOffset = targetValueSize / 3;
			}
			const lastIndex = referenceTrack.times.length - 1;
			let referenceValue;
			// Find the value to subtract out of the track
			if (referenceTime <= referenceTrack.times[0]) {
				// Reference frame is earlier than the first keyframe, so just use the first keyframe
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				referenceValue = arraySlice(referenceTrack.values, startIndex, endIndex);
			} else if (referenceTime >= referenceTrack.times[lastIndex]) {
				// Reference frame is after the last keyframe, so just use the last keyframe
				const startIndex = lastIndex * referenceValueSize + referenceOffset;
				const endIndex = startIndex + referenceValueSize - referenceOffset;
				referenceValue = arraySlice(referenceTrack.values, startIndex, endIndex);
			} else {
				// Interpolate to the reference value
				const interpolant = referenceTrack.createInterpolant();
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				interpolant.evaluate(referenceTime);
				referenceValue = arraySlice(interpolant.resultBuffer, startIndex, endIndex);
			}
			// Conjugate the quaternion
			if (referenceTrackType === 'quaternion') {
				const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
				referenceQuat.toArray(referenceValue);
			}
			// Subtract the reference value from all of the track values
			const numTimes = targetTrack.times.length;
			for (let j = 0; j < numTimes; ++j) {
				const valueStart = j * targetValueSize + targetOffset;
				if (referenceTrackType === 'quaternion') {
					// Multiply the conjugate for quaternion track types
					Quaternion.multiplyQuaternionsFlat(
						targetTrack.values,
						valueStart,
						referenceValue,
						0,
						targetTrack.values,
						valueStart
					);
				} else {
					const valueEnd = targetValueSize - targetOffset * 2;
					// Subtract each value for all other numeric track types
					for (let k = 0; k < valueEnd; ++k) {
						targetTrack.values[valueStart + k] -= referenceValue[k];
					}
				}
			}
		}
		targetClip.blendMode = AdditiveAnimationBlendMode;
		return targetClip;
	}
	const AnimationUtils = {
		arraySlice: arraySlice,
		convertArray: convertArray,
		isTypedArray: isTypedArray,
		getKeyframeOrder: getKeyframeOrder,
		sortedArray: sortedArray,
		flattenJSON: flattenJSON,
		subclip: subclip,
		makeClipAdditive: makeClipAdditive
	};
	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 */
	class Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			this.parameterPositions = parameterPositions;
			this._cachedIndex = 0;
			this.resultBuffer = resultBuffer !== undefined ?
				resultBuffer : new sampleValues.constructor(sampleSize);
			this.sampleValues = sampleValues;
			this.valueSize = sampleSize;
			this.settings = null;
			this.DefaultSettings_ = {};
		}
		evaluate(t) {
			const pp = this.parameterPositions;
			let i1 = this._cachedIndex,
				t1 = pp[i1],
				t0 = pp[i1 - 1];
			validate_interval: {
				seek: {
					let right;
					linear_scan: {
						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if (!(t < t1)) {
							for (let giveUpAt = i1 + 2;;) {
								if (t1 === undefined) {
									if (t < t0) break forward_scan;
									// after end
									i1 = pp.length;
									this._cachedIndex = i1;
									return this.copySampleValue_(i1 - 1);
								}
								if (i1 === giveUpAt) break; // this loop
								t0 = t1;
								t1 = pp[++i1];
								if (t < t1) {
									// we have arrived at the sought interval
									break seek;
								}
							}
							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;
						}
						//- slower code:
						//-					if ( t < t0 || t0 === undefined ) {
						if (!(t >= t0)) {
							// looping?
							const t1global = pp[1];
							if (t < t1global) {
								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;
							}
							// linear reverse scan
							for (let giveUpAt = i1 - 2;;) {
								if (t0 === undefined) {
									// before start
									this._cachedIndex = 0;
									return this.copySampleValue_(0);
								}
								if (i1 === giveUpAt) break; // this loop
								t1 = t0;
								t0 = pp[--i1 - 1];
								if (t >= t0) {
									// we have arrived at the sought interval
									break seek;
								}
							}
							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;
						}
						// the interval is valid
						break validate_interval;
					} // linear scan
					// binary search
					while (i1 < right) {
						const mid = (i1 + right) >>> 1;
						if (t < pp[mid]) {
							right = mid;
						} else {
							i1 = mid + 1;
						}
					}
					t1 = pp[i1];
					t0 = pp[i1 - 1];
					// check boundary cases, again
					if (t0 === undefined) {
						this._cachedIndex = 0;
						return this.copySampleValue_(0);
					}
					if (t1 === undefined) {
						i1 = pp.length;
						this._cachedIndex = i1;
						return this.copySampleValue_(i1 - 1);
					}
				} // seek
				this._cachedIndex = i1;
				this.intervalChanged_(i1, t0, t1);
			} // validate_interval
			return this.interpolate_(i1, t0, t, t1);
		}
		getSettings_() {
			return this.settings || this.DefaultSettings_;
		}
		copySampleValue_(index) {
			// copies a sample value to the result buffer
			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;
			for (let i = 0; i !== stride; ++i) {
				result[i] = values[offset + i];
			}
			return result;
		}
		// Template methods for derived classes:
		interpolate_( /* i1, t0, t, t1 */ ) {
			throw new Error('call to abstract method');
			// implementations shall return this.resultBuffer
		}
		intervalChanged_( /* i1, t0, t1 */ ) {
			// empty
		}
	}
	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 */
	class CubicInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
			this._weightPrev = -0;
			this._offsetPrev = -0;
			this._weightNext = -0;
			this._offsetNext = -0;
			this.DefaultSettings_ = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};
		}
		intervalChanged_(i1, t0, t1) {
			const pp = this.parameterPositions;
			let iPrev = i1 - 2,
				iNext = i1 + 1,
				tPrev = pp[iPrev],
				tNext = pp[iNext];
			if (tPrev === undefined) {
				switch (this.getSettings_().endingStart) {
					case ZeroSlopeEnding:
						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;
						break;
					case WrapAroundEnding:
						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
						break;
					default: // ZeroCurvatureEnding
						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;
				}
			}
			if (tNext === undefined) {
				switch (this.getSettings_().endingEnd) {
					case ZeroSlopeEnding:
						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;
						break;
					case WrapAroundEnding:
						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[1] - pp[0];
						break;
					default: // ZeroCurvatureEnding
						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;
				}
			}
			const halfDt = (t1 - t0) * 0.5,
				stride = this.valueSize;
			this._weightPrev = halfDt / (t0 - tPrev);
			this._weightNext = halfDt / (tNext - t1);
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;
		}
		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				o1 = i1 * stride,
				o0 = o1 - stride,
				oP = this._offsetPrev,
				oN = this._offsetNext,
				wP = this._weightPrev,
				wN = this._weightNext,
				p = (t - t0) / (t1 - t0),
				pp = p * p,
				ppp = pp * p;
			// evaluate polynomials
			const sP = -wP * ppp + 2 * wP * pp - wP * p;
			const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
			const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
			const sN = wN * ppp - wN * pp;
			// combine data linearly
			for (let i = 0; i !== stride; ++i) {
				result[i] =
					sP * values[oP + i] +
					s0 * values[o0 + i] +
					s1 * values[o1 + i] +
					sN * values[oN + i];
			}
			return result;
		}
	}
	class LinearInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		}
		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset1 = i1 * stride,
				offset0 = offset1 - stride,
				weight1 = (t - t0) / (t1 - t0),
				weight0 = 1 - weight1;
			for (let i = 0; i !== stride; ++i) {
				result[i] =
					values[offset0 + i] * weight0 +
					values[offset1 + i] * weight1;
			}
			return result;
		}
	}
	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceding
	 * the parameter.
	 */
	class DiscreteInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		}
		interpolate_(i1 /*, t0, t, t1 */ ) {
			return this.copySampleValue_(i1 - 1);
		}
	}
	class KeyframeTrack {
		constructor(name, times, values, interpolation) {
			if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
			if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
			this.name = name;
			this.times = convertArray(times, this.TimeBufferType);
			this.values = convertArray(values, this.ValueBufferType);
			this.setInterpolation(interpolation || this.DefaultInterpolation);
		}
		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):
		static toJSON(track) {
			const trackType = track.constructor;
			let json;
			// derived classes can define a static toJSON method
			if (trackType.toJSON !== this.toJSON) {
				json = trackType.toJSON(track);
			} else {
				// by default, we assume the data can be serialized as-is
				json = {
					'name': track.name,
					'times': convertArray(track.times, Array),
					'values': convertArray(track.values, Array)
				};
				const interpolation = track.getInterpolation();
				if (interpolation !== track.DefaultInterpolation) {
					json.interpolation = interpolation;
				}
			}
			json.type = track.ValueTypeName; // mandatory
			return json;
		}
		InterpolantFactoryMethodDiscrete(result) {
			return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
		}
		InterpolantFactoryMethodLinear(result) {
			return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
		}
		InterpolantFactoryMethodSmooth(result) {
			return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
		}
		setInterpolation(interpolation) {
			let factoryMethod;
			switch (interpolation) {
				case InterpolateDiscrete:
					factoryMethod = this.InterpolantFactoryMethodDiscrete;
					break;
				case InterpolateLinear:
					factoryMethod = this.InterpolantFactoryMethodLinear;
					break;
				case InterpolateSmooth:
					factoryMethod = this.InterpolantFactoryMethodSmooth;
					break;
			}
			if (factoryMethod === undefined) {
				const message = 'unsupported interpolation for ' +
					this.ValueTypeName + ' keyframe track named ' + this.name;
				if (this.createInterpolant === undefined) {
					// fall back to default, unless the default itself is messed up
					if (interpolation !== this.DefaultInterpolation) {
						this.setInterpolation(this.DefaultInterpolation);
					} else {
						throw new Error(message); // fatal, in this case
					}
				}
				console.warn('THREE.KeyframeTrack:', message);
				return this;
			}
			this.createInterpolant = factoryMethod;
			return this;
		}
		getInterpolation() {
			switch (this.createInterpolant) {
				case this.InterpolantFactoryMethodDiscrete:
					return InterpolateDiscrete;
				case this.InterpolantFactoryMethodLinear:
					return InterpolateLinear;
				case this.InterpolantFactoryMethodSmooth:
					return InterpolateSmooth;
			}
		}
		getValueSize() {
			return this.values.length / this.times.length;
		}
		// move all keyframes either forwards or backwards in time
		shift(timeOffset) {
			if (timeOffset !== 0.0) {
				const times = this.times;
				for (let i = 0, n = times.length; i !== n; ++i) {
					times[i] += timeOffset;
				}
			}
			return this;
		}
		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale(timeScale) {
			if (timeScale !== 1.0) {
				const times = this.times;
				for (let i = 0, n = times.length; i !== n; ++i) {
					times[i] *= timeScale;
				}
			}
			return this;
		}
		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim(startTime, endTime) {
			const times = this.times,
				nKeys = times.length;
			let from = 0,
				to = nKeys - 1;
			while (from !== nKeys && times[from] < startTime) {
				++from;
			}
			while (to !== -1 && times[to] > endTime) {
				--to;
			}
			++to; // inclusive -> exclusive bound
			if (from !== 0 || to !== nKeys) {
				// empty tracks are forbidden, so keep at least one keyframe
				if (from >= to) {
					to = Math.max(to, 1);
					from = to - 1;
				}
				const stride = this.getValueSize();
				this.times = arraySlice(times, from, to);
				this.values = arraySlice(this.values, from * stride, to * stride);
			}
			return this;
		}
		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate() {
			let valid = true;
			const valueSize = this.getValueSize();
			if (valueSize - Math.floor(valueSize) !== 0) {
				console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
				valid = false;
			}
			const times = this.times,
				values = this.values,
				nKeys = times.length;
			if (nKeys === 0) {
				console.error('THREE.KeyframeTrack: Track is empty.', this);
				valid = false;
			}
			let prevTime = null;
			for (let i = 0; i !== nKeys; i++) {
				const currTime = times[i];
				if (typeof currTime === 'number' && isNaN(currTime)) {
					console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
					valid = false;
					break;
				}
				if (prevTime !== null && prevTime > currTime) {
					console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
					valid = false;
					break;
				}
				prevTime = currTime;
			}
			if (values !== undefined) {
				if (isTypedArray(values)) {
					for (let i = 0, n = values.length; i !== n; ++i) {
						const value = values[i];
						if (isNaN(value)) {
							console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
							valid = false;
							break;
						}
					}
				}
			}
			return valid;
		}
		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize() {
			// times or values may be shared with other tracks, so overwriting is unsafe
			const times = arraySlice(this.times),
				values = arraySlice(this.values),
				stride = this.getValueSize(),
				smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
				lastIndex = times.length - 1;
			let writeIndex = 1;
			for (let i = 1; i < lastIndex; ++i) {
				let keep = false;
				const time = times[i];
				const timeNext = times[i + 1];
				// remove adjacent keyframes scheduled at the same time
				if (time !== timeNext && (i !== 1 || time !== times[0])) {
					if (!smoothInterpolation) {
						// remove unnecessary keyframes same as their neighbors
						const offset = i * stride,
							offsetP = offset - stride,
							offsetN = offset + stride;
						for (let j = 0; j !== stride; ++j) {
							const value = values[offset + j];
							if (value !== values[offsetP + j] ||
								value !== values[offsetN + j]) {
								keep = true;
								break;
							}
						}
					} else {
						keep = true;
					}
				}
				// in-place compaction
				if (keep) {
					if (i !== writeIndex) {
						times[writeIndex] = times[i];
						const readOffset = i * stride,
							writeOffset = writeIndex * stride;
						for (let j = 0; j !== stride; ++j) {
							values[writeOffset + j] = values[readOffset + j];
						}
					}
					++writeIndex;
				}
			}
			// flush last keyframe (compaction looks ahead)
			if (lastIndex > 0) {
				times[writeIndex] = times[lastIndex];
				for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
					values[writeOffset + j] = values[readOffset + j];
				}
				++writeIndex;
			}
			if (writeIndex !== times.length) {
				this.times = arraySlice(times, 0, writeIndex);
				this.values = arraySlice(values, 0, writeIndex * stride);
			} else {
				this.times = times;
				this.values = values;
			}
			return this;
		}
		clone() {
			const times = arraySlice(this.times, 0);
			const values = arraySlice(this.values, 0);
			const TypedKeyframeTrack = this.constructor;
			const track = new TypedKeyframeTrack(this.name, times, values);
			// Interpolant argument to constructor is not saved, so copy the factory method directly.
			track.createInterpolant = this.createInterpolant;
			return track;
		}
	}
	KeyframeTrack.prototype.TimeBufferType = Float32Array;
	KeyframeTrack.prototype.ValueBufferType = Float32Array;
	KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
	/**
	 * A Track of Boolean keyframe values.
	 */
	class BooleanKeyframeTrack extends KeyframeTrack {}
	BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
	BooleanKeyframeTrack.prototype.ValueBufferType = Array;
	BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
	/**
	 * A Track of keyframe values that represent color.
	 */
	class ColorKeyframeTrack extends KeyframeTrack {}
	ColorKeyframeTrack.prototype.ValueTypeName = 'color';
	/**
	 * A Track of numeric keyframe values.
	 */
	class NumberKeyframeTrack extends KeyframeTrack {}
	NumberKeyframeTrack.prototype.ValueTypeName = 'number';
	/**
	 * Spherical linear unit quaternion interpolant.
	 */
	class QuaternionLinearInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		}
		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				alpha = (t - t0) / (t1 - t0);
			let offset = i1 * stride;
			for (let end = offset + stride; offset !== end; offset += 4) {
				Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
			}
			return result;
		}
	}
	/**
	 * A Track of quaternion keyframe values.
	 */
	class QuaternionKeyframeTrack extends KeyframeTrack {
		InterpolantFactoryMethodLinear(result) {
			return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
		}
	}
	QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
	// ValueBufferType is inherited
	QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
	QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
	/**
	 * A Track that interpolates Strings
	 */
	class StringKeyframeTrack extends KeyframeTrack {}
	StringKeyframeTrack.prototype.ValueTypeName = 'string';
	StringKeyframeTrack.prototype.ValueBufferType = Array;
	StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
	/**
	 * A Track of vectored keyframe values.
	 */
	class VectorKeyframeTrack extends KeyframeTrack {}
	VectorKeyframeTrack.prototype.ValueTypeName = 'vector';
	class AnimationClip {
		constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
			this.name = name;
			this.tracks = tracks;
			this.duration = duration;
			this.blendMode = blendMode;
			this.uuid = generateUUID();
			// this means it should figure out its duration by scanning the tracks
			if (this.duration < 0) {
				this.resetDuration();
			}
		}
		static parse(json) {
			const tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / (json.fps || 1.0);
			for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
				tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
			}
			const clip = new this(json.name, json.duration, tracks, json.blendMode);
			clip.uuid = json.uuid;
			return clip;
		}
		static toJSON(clip) {
			const tracks = [],
				clipTracks = clip.tracks;
			const json = {
				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid,
				'blendMode': clip.blendMode
			};
			for (let i = 0, n = clipTracks.length; i !== n; ++i) {
				tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
			}
			return json;
		}
		static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
			const numMorphTargets = morphTargetSequence.length;
			const tracks = [];
			for (let i = 0; i < numMorphTargets; i++) {
				let times = [];
				let values = [];
				times.push(
					(i + numMorphTargets - 1) % numMorphTargets,
					i,
					(i + 1) % numMorphTargets);
				values.push(0, 1, 0);
				const order = getKeyframeOrder(times);
				times = sortedArray(times, 1, order);
				values = sortedArray(values, 1, order);
				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if (!noLoop && times[0] === 0) {
					times.push(numMorphTargets);
					values.push(values[0]);
				}
				tracks.push(
					new NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[i].name + ']',
						times, values
					).scale(1.0 / fps));
			}
			return new this(name, -1, tracks);
		}
		static findByName(objectOrClipArray, name) {
			let clipArray = objectOrClipArray;
			if (!Array.isArray(objectOrClipArray)) {
				const o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;
			}
			for (let i = 0; i < clipArray.length; i++) {
				if (clipArray[i].name === name) {
					return clipArray[i];
				}
			}
			return null;
		}
		static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
			const animationToMorphTargets = {};
			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			const pattern = /^([\w-]*?)([\d]+)$/;
			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for (let i = 0, il = morphTargets.length; i < il; i++) {
				const morphTarget = morphTargets[i];
				const parts = morphTarget.name.match(pattern);
				if (parts && parts.length > 1) {
					const name = parts[1];
					let animationMorphTargets = animationToMorphTargets[name];
					if (!animationMorphTargets) {
						animationToMorphTargets[name] = animationMorphTargets = [];
					}
					animationMorphTargets.push(morphTarget);
				}
			}
			const clips = [];
			for (const name in animationToMorphTargets) {
				clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
			}
			return clips;
		}
		// parse the animation.hierarchy format
		static parseAnimation(animation, bones) {
			if (!animation) {
				console.error('THREE.AnimationClip: No animation in JSONLoader data.');
				return null;
			}
			const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
				// only return track if there are actually keys.
				if (animationKeys.length !== 0) {
					const times = [];
					const values = [];
					flattenJSON(animationKeys, times, values, propertyName);
					// empty keys are filtered out, so check again
					if (times.length !== 0) {
						destTracks.push(new trackType(trackName, times, values));
					}
				}
			};
			const tracks = [];
			const clipName = animation.name || 'default';
			const fps = animation.fps || 30;
			const blendMode = animation.blendMode;
			// automatic length determination in AnimationClip.
			let duration = animation.length || -1;
			const hierarchyTracks = animation.hierarchy || [];
			for (let h = 0; h < hierarchyTracks.length; h++) {
				const animationKeys = hierarchyTracks[h].keys;
				// skip empty tracks
				if (!animationKeys || animationKeys.length === 0) continue;
				// process morph targets
				if (animationKeys[0].morphTargets) {
					// figure out all morph targets used in this track
					const morphTargetNames = {};
					let k;
					for (k = 0; k < animationKeys.length; k++) {
						if (animationKeys[k].morphTargets) {
							for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
								morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
							}
						}
					}
					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for (const morphTargetName in morphTargetNames) {
						const times = [];
						const values = [];
						for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
							const animationKey = animationKeys[k];
							times.push(animationKey.time);
							values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0);
						}
						tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
					}
					duration = morphTargetNames.length * fps;
				} else {
					// ...assume skeletal animation
					const boneName = '.bones[' + bones[h].name + ']';
					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks);
					addNonemptyTrack(
						QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks);
					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks);
				}
			}
			if (tracks.length === 0) {
				return null;
			}
			const clip = new this(clipName, duration, tracks, blendMode);
			return clip;
		}
		resetDuration() {
			const tracks = this.tracks;
			let duration = 0;
			for (let i = 0, n = tracks.length; i !== n; ++i) {
				const track = this.tracks[i];
				duration = Math.max(duration, track.times[track.times.length - 1]);
			}
			this.duration = duration;
			return this;
		}
		trim() {
			for (let i = 0; i < this.tracks.length; i++) {
				this.tracks[i].trim(0, this.duration);
			}
			return this;
		}
		validate() {
			let valid = true;
			for (let i = 0; i < this.tracks.length; i++) {
				valid = valid && this.tracks[i].validate();
			}
			return valid;
		}
		optimize() {
			for (let i = 0; i < this.tracks.length; i++) {
				this.tracks[i].optimize();
			}
			return this;
		}
		clone() {
			const tracks = [];
			for (let i = 0; i < this.tracks.length; i++) {
				tracks.push(this.tracks[i].clone());
			}
			return new this.constructor(this.name, this.duration, tracks, this.blendMode);
		}
		toJSON() {
			return this.constructor.toJSON(this);
		}
	}

	function getTrackTypeForValueTypeName(typeName) {
		switch (typeName.toLowerCase()) {
			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':
				return NumberKeyframeTrack;
			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':
				return VectorKeyframeTrack;
			case 'color':
				return ColorKeyframeTrack;
			case 'quaternion':
				return QuaternionKeyframeTrack;
			case 'bool':
			case 'boolean':
				return BooleanKeyframeTrack;
			case 'string':
				return StringKeyframeTrack;
		}
		throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
	}

	function parseKeyframeTrack(json) {
		if (json.type === undefined) {
			throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
		}
		const trackType = getTrackTypeForValueTypeName(json.type);
		if (json.times === undefined) {
			const times = [],
				values = [];
			flattenJSON(json.keys, times, values, 'value');
			json.times = times;
			json.values = values;
		}
		// derived classes can define a static parse method
		if (trackType.parse !== undefined) {
			return trackType.parse(json);
		} else {
			// by default, we assume a constructor compatible with the base
			return new trackType(json.name, json.times, json.values, json.interpolation);
		}
	}
	const Cache = {
		enabled: false,
		files: {},
		add: function(key, file) {
			if (this.enabled === false) return;
			// console.log( 'THREE.Cache', 'Adding key:', key );
			this.files[key] = file;
		},
		get: function(key) {
			if (this.enabled === false) return;
			// console.log( 'THREE.Cache', 'Checking key:', key );
			return this.files[key];
		},
		remove: function(key) {
			delete this.files[key];
		},
		clear: function() {
			this.files = {};
		}
	};
	class LoadingManager {
		constructor(onLoad, onProgress, onError) {
			const scope = this;
			let isLoading = false;
			let itemsLoaded = 0;
			let itemsTotal = 0;
			let urlModifier = undefined;
			const handlers = [];
			// Refer to #5689 for the reason why we don't set .onStart
			// in the constructor
			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;
			this.itemStart = function(url) {
				itemsTotal++;
				if (isLoading === false) {
					if (scope.onStart !== undefined) {
						scope.onStart(url, itemsLoaded, itemsTotal);
					}
				}
				isLoading = true;
			};
			this.itemEnd = function(url) {
				itemsLoaded++;
				if (scope.onProgress !== undefined) {
					scope.onProgress(url, itemsLoaded, itemsTotal);
				}
				if (itemsLoaded === itemsTotal) {
					isLoading = false;
					if (scope.onLoad !== undefined) {
						scope.onLoad();
					}
				}
			};
			this.itemError = function(url) {
				if (scope.onError !== undefined) {
					scope.onError(url);
				}
			};
			this.resolveURL = function(url) {
				if (urlModifier) {
					return urlModifier(url);
				}
				return url;
			};
			this.setURLModifier = function(transform) {
				urlModifier = transform;
				return this;
			};
			this.addHandler = function(regex, loader) {
				handlers.push(regex, loader);
				return this;
			};
			this.removeHandler = function(regex) {
				const index = handlers.indexOf(regex);
				if (index !== -1) {
					handlers.splice(index, 2);
				}
				return this;
			};
			this.getHandler = function(file) {
				for (let i = 0, l = handlers.length; i < l; i += 2) {
					const regex = handlers[i];
					const loader = handlers[i + 1];
					if (regex.global) regex.lastIndex = 0; // see #17920
					if (regex.test(file)) {
						return loader;
					}
				}
				return null;
			};
		}
	}
	const DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();
	class Loader {
		constructor(manager) {
			this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
			this.crossOrigin = 'anonymous';
			this.withCredentials = false;
			this.path = '';
			this.resourcePath = '';
			this.requestHeader = {};
		}
		load( /* url, onLoad, onProgress, onError */ ) {}
		loadAsync(url, onProgress) {
			const scope = this;
			return new Promise(function(resolve, reject) {
				scope.load(url, resolve, onProgress, reject);
			});
		}
		parse( /* data */ ) {}
		setCrossOrigin(crossOrigin) {
			this.crossOrigin = crossOrigin;
			return this;
		}
		setWithCredentials(value) {
			this.withCredentials = value;
			return this;
		}
		setPath(path) {
			this.path = path;
			return this;
		}
		setResourcePath(resourcePath) {
			this.resourcePath = resourcePath;
			return this;
		}
		setRequestHeader(requestHeader) {
			this.requestHeader = requestHeader;
			return this;
		}
	}
	const loading = {};
	class HttpError extends Error {
		constructor(message, response) {
			super(message);
			this.response = response;
		}
	}
	class FileLoader extends Loader {
		constructor(manager) {
			super(manager);
		}
		load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			const cached = Cache.get(url);
			if (cached !== undefined) {
				this.manager.itemStart(url);
				setTimeout(() => {
					if (onLoad) onLoad(cached);
					this.manager.itemEnd(url);
				}, 0);
				return cached;
			}
			// Check if request is duplicate
			if (loading[url] !== undefined) {
				loading[url].push({
					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError
				});
				return;
			}
			// Initialise array for duplicate requests
			loading[url] = [];
			loading[url].push({
				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError,
			});
			// create request
			const req = new Request(url, {
				headers: new Headers(this.requestHeader),
				credentials: this.withCredentials ? 'include' : 'same-origin',
				// An abort controller could be added within a future PR
			});
			// record states ( avoid data race )
			const mimeType = this.mimeType;
			const responseType = this.responseType;
			// start the fetch
			fetch(req)
				.then(response => {
					if (response.status === 200 || response.status === 0) {
						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.
						if (response.status === 0) {
							console.warn('THREE.FileLoader: HTTP Status 0 received.');
						}
						// Workaround: Checking if response.body === undefined for Alipay browser #23548
						if (typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined) {
							return response;
						}
						const callbacks = loading[url];
						const reader = response.body.getReader();
						// Nginx needs X-File-Size check
						// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content
						const contentLength = response.headers.get('Content-Length') || response.headers.get('X-File-Size');
						const total = contentLength ? parseInt(contentLength) : 0;
						const lengthComputable = total !== 0;
						let loaded = 0;
						// periodically read data into the new stream tracking while download progress
						const stream = new ReadableStream({
							start(controller) {
								readData();

								function readData() {
									reader.read().then(({
										done,
										value
									}) => {
										if (done) {
											controller.close();
										} else {
											loaded += value.byteLength;
											const event = new ProgressEvent('progress', {
												lengthComputable,
												loaded,
												total
											});
											for (let i = 0, il = callbacks.length; i < il; i++) {
												const callback = callbacks[i];
												if (callback.onProgress) callback.onProgress(event);
											}
											controller.enqueue(value);
											readData();
										}
									});
								}
							}
						});
						return new Response(stream);
					} else {
						throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);
					}
				})
				.then(response => {
					switch (responseType) {
						case 'arraybuffer':
							return response.arrayBuffer();
						case 'blob':
							return response.blob();
						case 'document':
							return response.text()
								.then(text => {
									const parser = new DOMParser();
									return parser.parseFromString(text, mimeType);
								});
						case 'json':
							return response.json();
						default:
							if (mimeType === undefined) {
								return response.text();
							} else {
								// sniff encoding
								const re = /charset="?([^;"\s]*)"?/i;
								const exec = re.exec(mimeType);
								const label = exec && exec[1] ? exec[1].toLowerCase() : undefined;
								const decoder = new TextDecoder(label);
								return response.arrayBuffer().then(ab => decoder.decode(ab));
							}
					}
				})
				.then(data => {
					// Add to cache only on HTTP success, so that we do not cache
					// error response bodies as proper responses to requests.
					Cache.add(url, data);
					const callbacks = loading[url];
					delete loading[url];
					for (let i = 0, il = callbacks.length; i < il; i++) {
						const callback = callbacks[i];
						if (callback.onLoad) callback.onLoad(data);
					}
				})
				.catch(err => {
					// Abort errors and other errors are handled the same
					const callbacks = loading[url];
					if (callbacks === undefined) {
						// When onLoad was called and url was deleted in `loading`
						this.manager.itemError(url);
						throw err;
					}
					delete loading[url];
					for (let i = 0, il = callbacks.length; i < il; i++) {
						const callback = callbacks[i];
						if (callback.onError) callback.onError(err);
					}
					this.manager.itemError(url);
				})
				.finally(() => {
					this.manager.itemEnd(url);
				});
			this.manager.itemStart(url);
		}
		setResponseType(value) {
			this.responseType = value;
			return this;
		}
		setMimeType(value) {
			this.mimeType = value;
			return this;
		}
	}
	class AnimationLoader extends Loader {
		constructor(manager) {
			super(manager);
		}
		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function(text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}
					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}
		parse(json) {
			const animations = [];
			for (let i = 0; i < json.length; i++) {
				const clip = AnimationClip.parse(json[i]);
				animations.push(clip);
			}
			return animations;
		}
	}
	/**
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */
	class CompressedTextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}
		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const images = [];
			const texture = new CompressedTexture();
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setResponseType('arraybuffer');
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			let loaded = 0;

			function loadTexture(i) {
				loader.load(url[i], function(buffer) {
					const texDatas = scope.parse(buffer, true);
					images[i] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};
					loaded += 1;
					if (loaded === 6) {
						if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
						texture.image = images;
						texture.format = texDatas.format;
						texture.needsUpdate = true;
						if (onLoad) onLoad(texture);
					}
				}, onProgress, onError);
			}
			if (Array.isArray(url)) {
				for (let i = 0, il = url.length; i < il; ++i) {
					loadTexture(i);
				}
			} else {
				// compressed cubemap texture stored in a single DDS file
				loader.load(url, function(buffer) {
					const texDatas = scope.parse(buffer, true);
					if (texDatas.isCubemap) {
						const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
						for (let f = 0; f < faces; f++) {
							images[f] = {
								mipmaps: []
							};
							for (let i = 0; i < texDatas.mipmapCount; i++) {
								images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
								images[f].format = texDatas.format;
								images[f].width = texDatas.width;
								images[f].height = texDatas.height;
							}
						}
						texture.image = images;
					} else {
						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;
					}
					if (texDatas.mipmapCount === 1) {
						texture.minFilter = LinearFilter;
					}
					texture.format = texDatas.format;
					texture.needsUpdate = true;
					if (onLoad) onLoad(texture);
				}, onProgress, onError);
			}
			return texture;
		}
	}
	class ImageLoader extends Loader {
		constructor(manager) {
			super(manager);
		}
		load(url, onLoad, onProgress, onError) {
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			const scope = this;
			const cached = Cache.get(url);
			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function() {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			}
			const image = createElementNS('img');

			function onImageLoad() {
				removeEventListeners();
				Cache.add(url, this);
				if (onLoad) onLoad(this);
				scope.manager.itemEnd(url);
			}

			function onImageError(event) {
				removeEventListeners();
				if (onError) onError(event);
				scope.manager.itemError(url);
				scope.manager.itemEnd(url);
			}

			function removeEventListeners() {
				image.removeEventListener('load', onImageLoad, false);
				image.removeEventListener('error', onImageError, false);
			}
			image.addEventListener('load', onImageLoad, false);
			image.addEventListener('error', onImageError, false);
			if (url.slice(0, 5) !== 'data:') {
				if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
			}
			scope.manager.itemStart(url);
			image.src = url;
			return image;
		}
	}
	class CubeTextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}
		load(urls, onLoad, onProgress, onError) {
			const texture = new CubeTexture();
			const loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);
			let loaded = 0;

			function loadTexture(i) {
				loader.load(urls[i], function(image) {
					texture.images[i] = image;
					loaded++;
					if (loaded === 6) {
						texture.needsUpdate = true;
						if (onLoad) onLoad(texture);
					}
				}, undefined, onError);
			}
			for (let i = 0; i < urls.length; ++i) {
				loadTexture(i);
			}
			return texture;
		}
	}
	/**
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */
	class DataTextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}
		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const texture = new DataTexture();
			const loader = new FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.setRequestHeader(this.requestHeader);
			loader.setPath(this.path);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function(buffer) {
				const texData = scope.parse(buffer);
				if (!texData) return;
				if (texData.image !== undefined) {
					texture.image = texData.image;
				} else if (texData.data !== undefined) {
					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;
				}
				texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
				texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
				texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
				texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
				if (texData.encoding !== undefined) {
					texture.encoding = texData.encoding;
				}
				if (texData.flipY !== undefined) {
					texture.flipY = texData.flipY;
				}
				if (texData.format !== undefined) {
					texture.format = texData.format;
				}
				if (texData.type !== undefined) {
					texture.type = texData.type;
				}
				if (texData.mipmaps !== undefined) {
					texture.mipmaps = texData.mipmaps;
					texture.minFilter = LinearMipmapLinearFilter; // presumably...
				}
				if (texData.mipmapCount === 1) {
					texture.minFilter = LinearFilter;
				}
				if (texData.generateMipmaps !== undefined) {
					texture.generateMipmaps = texData.generateMipmaps;
				}
				texture.needsUpdate = true;
				if (onLoad) onLoad(texture, texData);
			}, onProgress, onError);
			return texture;
		}
	}
	class TextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}
		load(url, onLoad, onProgress, onError) {
			const texture = new Texture();
			const loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);
			loader.load(url, function(image) {
				texture.image = image;
				texture.needsUpdate = true;
				if (onLoad !== undefined) {
					onLoad(texture);
				}
			}, onProgress, onError);
			return texture;
		}
	}
	class Light extends Object3D {
		constructor(color, intensity = 1) {
			super();
			this.isLight = true;
			this.type = 'Light';
			this.color = new Color(color);
			this.intensity = intensity;
		}
		dispose() {
			// Empty here in base class; some subclasses override.
		}
		copy(source, recursive) {
			super.copy(source, recursive);
			this.color.copy(source.color);
			this.intensity = source.intensity;
			return this;
		}
		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;
			if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
			if (this.distance !== undefined) data.object.distance = this.distance;
			if (this.angle !== undefined) data.object.angle = this.angle;
			if (this.decay !== undefined) data.object.decay = this.decay;
			if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
			if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
			return data;
		}
	}
	class HemisphereLight extends Light {
		constructor(skyColor, groundColor, intensity) {
			super(skyColor, intensity);
			this.isHemisphereLight = true;
			this.type = 'HemisphereLight';
			this.position.copy(Object3D.DEFAULT_UP);
			this.updateMatrix();
			this.groundColor = new Color(groundColor);
		}
		copy(source, recursive) {
			super.copy(source, recursive);
			this.groundColor.copy(source.groundColor);
			return this;
		}
	}
	const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
	const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
	const _lookTarget$1 = /*@__PURE__*/ new Vector3();
	class LightShadow {
		constructor(camera) {
			this.camera = camera;
			this.bias = 0;
			this.normalBias = 0;
			this.radius = 1;
			this.blurSamples = 8;
			this.mapSize = new Vector2(512, 512);
			this.map = null;
			this.mapPass = null;
			this.matrix = new Matrix4();
			this.autoUpdate = true;
			this.needsUpdate = false;
			this._frustum = new Frustum();
			this._frameExtents = new Vector2(1, 1);
			this._viewportCount = 1;
			this._viewports = [
				new Vector4(0, 0, 1, 1)
			];
		}
		getViewportCount() {
			return this._viewportCount;
		}
		getFrustum() {
			return this._frustum;
		}
		updateMatrices(light) {
			const shadowCamera = this.camera;
			const shadowMatrix = this.matrix;
			_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
			shadowCamera.position.copy(_lightPositionWorld$1);
			_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
			shadowCamera.lookAt(_lookTarget$1);
			shadowCamera.updateMatrixWorld();
			_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
			this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
			shadowMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 0.5, 0.5,
				0.0, 0.0, 0.0, 1.0
			);
			shadowMatrix.multiply(_projScreenMatrix$1);
		}
		getViewport(viewportIndex) {
			return this._viewports[viewportIndex];
		}
		getFrameExtents() {
			return this._frameExtents;
		}
		dispose() {
			if (this.map) {
				this.map.dispose();
			}
			if (this.mapPass) {
				this.mapPass.dispose();
			}
		}
		copy(source) {
			this.camera = source.camera.clone();
			this.bias = source.bias;
			this.radius = source.radius;
			this.mapSize.copy(source.mapSize);
			return this;
		}
		clone() {
			return new this.constructor().copy(this);
		}
		toJSON() {
			const object = {};
			if (this.bias !== 0) object.bias = this.bias;
			if (this.normalBias !== 0) object.normalBias = this.normalBias;
			if (this.radius !== 1) object.radius = this.radius;
			if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
			object.camera = this.camera.toJSON(false).object;
			delete object.camera.matrix;
			return object;
		}
	}
	class SpotLightShadow extends LightShadow {
		constructor() {
			super(new PerspectiveCamera(50, 1, 0.5, 500));
			this.isSpotLightShadow = true;
			this.focus = 1;
		}
		updateMatrices(light) {
			const camera = this.camera;
			const fov = RAD2DEG * 2 * light.angle * this.focus;
			const aspect = this.mapSize.width / this.mapSize.height;
			const far = light.distance || camera.far;
			if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();
			}
			super.updateMatrices(light);
		}
		copy(source) {
			super.copy(source);
			this.focus = source.focus;
			return this;
		}
	}
	class SpotLight extends Light {
		constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {
			super(color, intensity);
			this.isSpotLight = true;
			this.type = 'SpotLight';
			this.position.copy(Object3D.DEFAULT_UP);
			this.updateMatrix();
			this.target = new Object3D();
			this.distance = distance;
			this.angle = angle;
			this.penumbra = penumbra;
			this.decay = decay;
			this.map = null;
			this.shadow = new SpotLightShadow();
		}
		get power() {
			// compute the light's luminous power (in lumens) from its intensity (in candela)
			// by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)
			return this.intensity * Math.PI;
		}
		set power(power) {
			// set the light's intensity (in candela) from the desired luminous power (in lumens)
			this.intensity = power / Math.PI;
		}
		dispose() {
			this.shadow.dispose();
		}
		copy(source, recursive) {
			super.copy(source, recursive);
			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;
			this.target = source.target.clone();
			this.shadow = source.shadow.clone();
			return this;
		}
	}
	const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
	const _lightPositionWorld = /*@__PURE__*/ new Vector3();
	const _lookTarget = /*@__PURE__*/ new Vector3();
	class PointLightShadow extends LightShadow {
		constructor() {
			super(new PerspectiveCamera(90, 1, 0.5, 500));
			this.isPointLightShadow = true;
			this._frameExtents = new Vector2(4, 2);
			this._viewportCount = 6;
			this._viewports = [
				// These viewports map a cube-map onto a 2D texture with the
				// following orientation:
				//
				//  xzXZ
				//   y Y
				//
				// X - Positive x direction
				// x - Negative x direction
				// Y - Positive y direction
				// y - Negative y direction
				// Z - Positive z direction
				// z - Negative z direction
				// positive X
				new Vector4(2, 1, 1, 1),
				// negative X
				new Vector4(0, 1, 1, 1),
				// positive Z
				new Vector4(3, 1, 1, 1),
				// negative Z
				new Vector4(1, 1, 1, 1),
				// positive Y
				new Vector4(3, 0, 1, 1),
				// negative Y
				new Vector4(1, 0, 1, 1)
			];
			this._cubeDirections = [
				new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1),
				new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)
			];
			this._cubeUps = [
				new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0),
				new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)
			];
		}
		updateMatrices(light, viewportIndex = 0) {
			const camera = this.camera;
			const shadowMatrix = this.matrix;
			const far = light.distance || camera.far;
			if (far !== camera.far) {
				camera.far = far;
				camera.updateProjectionMatrix();
			}
			_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
			camera.position.copy(_lightPositionWorld);
			_lookTarget.copy(camera.position);
			_lookTarget.add(this._cubeDirections[viewportIndex]);
			camera.up.copy(this._cubeUps[viewportIndex]);
			camera.lookAt(_lookTarget);
			camera.updateMatrixWorld();
			shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
			this._frustum.setFromProjectionMatrix(_projScreenMatrix);
		}
	}
	class PointLight extends Light {
		constructor(color, intensity, distance = 0, decay = 2) {
			super(color, intensity);
			this.isPointLight = true;
			this.type = 'PointLight';
			this.distance = distance;
			this.decay = decay;
			this.shadow = new PointLightShadow();
		}
		get power() {
			// compute the light's luminous power (in lumens) from its intensity (in candela)
			// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
			return this.intensity * 4 * Math.PI;
		}
		set power(power) {
			// set the light's intensity (in candela) from the desired luminous power (in lumens)
			this.intensity = power / (4 * Math.PI);
		}
		dispose() {
			this.shadow.dispose();
		}
		copy(source, recursive) {
			super.copy(source, recursive);
			this.distance = source.distance;
			this.decay = source.decay;
			this.shadow = source.shadow.clone();
			return this;
		}
	}
	class DirectionalLightShadow extends LightShadow {
		constructor() {
			super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
			this.isDirectionalLightShadow = true;
		}
	}
	class DirectionalLight extends Light {
		constructor(color, intensity) {
			super(color, intensity);
			this.isDirectionalLight = true;
			this.type = 'DirectionalLight';
			this.position.copy(Object3D.DEFAULT_UP);
			this.updateMatrix();
			this.target = new Object3D();
			this.shadow = new DirectionalLightShadow();
		}
		dispose() {
			this.shadow.dispose();
		}
		copy(source) {
			super.copy(source);
			this.target = source.target.clone();
			this.shadow = source.shadow.clone();
			return this;
		}
	}
	class AmbientLight extends Light {
		constructor(color, intensity) {
			super(color, intensity);
			this.isAmbientLight = true;
			this.type = 'AmbientLight';
		}
	}
	class RectAreaLight extends Light {
		constructor(color, intensity, width = 10, height = 10) {
			super(color, intensity);
			this.isRectAreaLight = true;
			this.type = 'RectAreaLight';
			this.width = width;
			this.height = height;
		}
		get power() {
			// compute the light's luminous power (in lumens) from its intensity (in nits)
			return this.intensity * this.width * this.height * Math.PI;
		}
		set power(power) {
			// set the light's intensity (in nits) from the desired luminous power (in lumens)
			this.intensity = power / (this.width * this.height * Math.PI);
		}
		copy(source) {
			super.copy(source);
			this.width = source.width;
			this.height = source.height;
			return this;
		}
		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.width = this.width;
			data.object.height = this.height;
			return data;
		}
	}
	/**
	 * Primary reference:
	 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
	 *
	 * Secondary reference:
	 *   https://www.ppsloan.org/publications/StupidSH36.pdf
	 */
	// 3-band SH defined by 9 coefficients
	class SphericalHarmonics3 {
		constructor() {
			this.isSphericalHarmonics3 = true;
			this.coefficients = [];
			for (let i = 0; i < 9; i++) {
				this.coefficients.push(new Vector3());
			}
		}
		set(coefficients) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].copy(coefficients[i]);
			}
			return this;
		}
		zero() {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].set(0, 0, 0);
			}
			return this;
		}
		// get the radiance in the direction of the normal
		// target is a Vector3
		getAt(normal, target) {
			// normal is assumed to be unit length
			const x = normal.x,
				y = normal.y,
				z = normal.z;
			const coeff = this.coefficients;
			// band 0
			target.copy(coeff[0]).multiplyScalar(0.282095);
			// band 1
			target.addScaledVector(coeff[1], 0.488603 * y);
			target.addScaledVector(coeff[2], 0.488603 * z);
			target.addScaledVector(coeff[3], 0.488603 * x);
			// band 2
			target.addScaledVector(coeff[4], 1.092548 * (x * y));
			target.addScaledVector(coeff[5], 1.092548 * (y * z));
			target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
			target.addScaledVector(coeff[7], 1.092548 * (x * z));
			target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
			return target;
		}
		// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
		// target is a Vector3
		// https://graphics.stanford.edu/papers/envmap/envmap.pdf
		getIrradianceAt(normal, target) {
			// normal is assumed to be unit length
			const x = normal.x,
				y = normal.y,
				z = normal.z;
			const coeff = this.coefficients;
			// band 0
			target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095
			// band 1
			target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603
			target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
			target.addScaledVector(coeff[3], 2.0 * 0.511664 * x);
			// band 2
			target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548
			target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
			target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3
			target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
			target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274
			return target;
		}
		add(sh) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].add(sh.coefficients[i]);
			}
			return this;
		}
		addScaledSH(sh, s) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].addScaledVector(sh.coefficients[i], s);
			}
			return this;
		}
		scale(s) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].multiplyScalar(s);
			}
			return this;
		}
		lerp(sh, alpha) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].lerp(sh.coefficients[i], alpha);
			}
			return this;
		}
		equals(sh) {
			for (let i = 0; i < 9; i++) {
				if (!this.coefficients[i].equals(sh.coefficients[i])) {
					return false;
				}
			}
			return true;
		}
		copy(sh) {
			return this.set(sh.coefficients);
		}
		clone() {
			return new this.constructor().copy(this);
		}
		fromArray(array, offset = 0) {
			const coefficients = this.coefficients;
			for (let i = 0; i < 9; i++) {
				coefficients[i].fromArray(array, offset + (i * 3));
			}
			return this;
		}
		toArray(array = [], offset = 0) {
			const coefficients = this.coefficients;
			for (let i = 0; i < 9; i++) {
				coefficients[i].toArray(array, offset + (i * 3));
			}
			return array;
		}
		// evaluate the basis functions
		// shBasis is an Array[ 9 ]
		static getBasisAt(normal, shBasis) {
			// normal is assumed to be unit length
			const x = normal.x,
				y = normal.y,
				z = normal.z;
			// band 0
			shBasis[0] = 0.282095;
			// band 1
			shBasis[1] = 0.488603 * y;
			shBasis[2] = 0.488603 * z;
			shBasis[3] = 0.488603 * x;
			// band 2
			shBasis[4] = 1.092548 * x * y;
			shBasis[5] = 1.092548 * y * z;
			shBasis[6] = 0.315392 * (3 * z * z - 1);
			shBasis[7] = 1.092548 * x * z;
			shBasis[8] = 0.546274 * (x * x - y * y);
		}
	}
	class LightProbe extends Light {
		constructor(sh = new SphericalHarmonics3(), intensity = 1) {
			super(undefined, intensity);
			this.isLightProbe = true;
			this.sh = sh;
		}
		copy(source) {
			super.copy(source);
			this.sh.copy(source.sh);
			return this;
		}
		fromJSON(json) {
			this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
			this.sh.fromArray(json.sh);
			return this;
		}
		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.sh = this.sh.toArray();
			return data;
		}
	}
	class MaterialLoader extends Loader {
		constructor(manager) {
			super(manager);
			this.textures = {};
		}
		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.setRequestHeader(scope.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function(text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}
					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}
		parse(json) {
			const textures = this.textures;

			function getTexture(name) {
				if (textures[name] === undefined) {
					console.warn('THREE.MaterialLoader: Undefined texture', name);
				}
				return textures[name];
			}
			const material = MaterialLoader.createMaterialFromType(json.type);
			if (json.uuid !== undefined) material.uuid = json.uuid;
			if (json.name !== undefined) material.name = json.name;
			if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
			if (json.roughness !== undefined) material.roughness = json.roughness;
			if (json.metalness !== undefined) material.metalness = json.metalness;
			if (json.sheen !== undefined) material.sheen = json.sheen;
			if (json.sheenColor !== undefined) material.sheenColor = new Color().setHex(json.sheenColor);
			if (json.sheenRoughness !== undefined) material.sheenRoughness = json.sheenRoughness;
			if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
			if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
			if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity;
			if (json.specularColor !== undefined && material.specularColor !== undefined) material.specularColor.setHex(json.specularColor);
			if (json.shininess !== undefined) material.shininess = json.shininess;
			if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
			if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
			if (json.iridescence !== undefined) material.iridescence = json.iridescence;
			if (json.iridescenceIOR !== undefined) material.iridescenceIOR = json.iridescenceIOR;
			if (json.iridescenceThicknessRange !== undefined) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
			if (json.transmission !== undefined) material.transmission = json.transmission;
			if (json.thickness !== undefined) material.thickness = json.thickness;
			if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;
			if (json.attenuationColor !== undefined && material.attenuationColor !== undefined) material.attenuationColor.setHex(json.attenuationColor);
			if (json.fog !== undefined) material.fog = json.fog;
			if (json.flatShading !== undefined) material.flatShading = json.flatShading;
			if (json.blending !== undefined) material.blending = json.blending;
			if (json.combine !== undefined) material.combine = json.combine;
			if (json.side !== undefined) material.side = json.side;
			if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;
			if (json.opacity !== undefined) material.opacity = json.opacity;
			if (json.transparent !== undefined) material.transparent = json.transparent;
			if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
			if (json.depthTest !== undefined) material.depthTest = json.depthTest;
			if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
			if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
			if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
			if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
			if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
			if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
			if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
			if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
			if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
			if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
			if (json.wireframe !== undefined) material.wireframe = json.wireframe;
			if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
			if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
			if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
			if (json.rotation !== undefined) material.rotation = json.rotation;
			if (json.linewidth !== 1) material.linewidth = json.linewidth;
			if (json.dashSize !== undefined) material.dashSize = json.dashSize;
			if (json.gapSize !== undefined) material.gapSize = json.gapSize;
			if (json.scale !== undefined) material.scale = json.scale;
			if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
			if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
			if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
			if (json.dithering !== undefined) material.dithering = json.dithering;
			if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;
			if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;
			if (json.forceSinglePass !== undefined) material.forceSinglePass = json.forceSinglePass;
			if (json.visible !== undefined) material.visible = json.visible;
			if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
			if (json.userData !== undefined) material.userData = json.userData;
			if (json.vertexColors !== undefined) {
				if (typeof json.vertexColors === 'number') {
					material.vertexColors = (json.vertexColors > 0) ? true : false;
				} else {
					material.vertexColors = json.vertexColors;
				}
			}
			// Shader Material
			if (json.uniforms !== undefined) {
				for (const name in json.uniforms) {
					const uniform = json.uniforms[name];
					material.uniforms[name] = {};
					switch (uniform.type) {
						case 't':
							material.uniforms[name].value = getTexture(uniform.value);
							break;
						case 'c':
							material.uniforms[name].value = new Color().setHex(uniform.value);
							break;
						case 'v2':
							material.uniforms[name].value = new Vector2().fromArray(uniform.value);
							break;
						case 'v3':
							material.uniforms[name].value = new Vector3().fromArray(uniform.value);
							break;
						case 'v4':
							material.uniforms[name].value = new Vector4().fromArray(uniform.value);
							break;
						case 'm3':
							material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
							break;
						case 'm4':
							material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
							break;
						default:
							material.uniforms[name].value = uniform.value;
					}
				}
			}
			if (json.defines !== undefined) material.defines = json.defines;
			if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
			if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
			if (json.glslVersion !== undefined) material.glslVersion = json.glslVersion;
			if (json.extensions !== undefined) {
				for (const key in json.extensions) {
					material.extensions[key] = json.extensions[key];
				}
			}
			// for PointsMaterial
			if (json.size !== undefined) material.size = json.size;
			if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;
			// maps
			if (json.map !== undefined) material.map = getTexture(json.map);
			if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
			if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
			if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
			if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
			if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
			if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
			if (json.normalScale !== undefined) {
				let normalScale = json.normalScale;
				if (Array.isArray(normalScale) === false) {
					// Blender exporter used to export a scalar. See #7459
					normalScale = [normalScale, normalScale];
				}
				material.normalScale = new Vector2().fromArray(normalScale);
			}
			if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
			if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
			if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
			if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
			if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
			if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
			if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
			if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
			if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap);
			if (json.specularColorMap !== undefined) material.specularColorMap = getTexture(json.specularColorMap);
			if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
			if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
			if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
			if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
			if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
			if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
			if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
			if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
			if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
			if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
			if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
			if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
			if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
			if (json.iridescenceMap !== undefined) material.iridescenceMap = getTexture(json.iridescenceMap);
			if (json.iridescenceThicknessMap !== undefined) material.iridescenceThicknessMap = getTexture(json.iridescenceThicknessMap);
			if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
			if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);
			if (json.sheenColorMap !== undefined) material.sheenColorMap = getTexture(json.sheenColorMap);
			if (json.sheenRoughnessMap !== undefined) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
			return material;
		}
		setTextures(value) {
			this.textures = value;
			return this;
		}
		static createMaterialFromType(type) {
			const materialLib = {
				ShadowMaterial,
				SpriteMaterial,
				RawShaderMaterial,
				ShaderMaterial,
				PointsMaterial,
				MeshPhysicalMaterial,
				MeshStandardMaterial,
				MeshPhongMaterial,
				MeshToonMaterial,
				MeshNormalMaterial,
				MeshLambertMaterial,
				MeshDepthMaterial,
				MeshDistanceMaterial,
				MeshBasicMaterial,
				MeshMatcapMaterial,
				LineDashedMaterial,
				LineBasicMaterial,
				Material
			};
			return new materialLib[type]();
		}
	}
	class LoaderUtils {
		static decodeText(array) {
			if (typeof TextDecoder !== 'undefined') {
				return new TextDecoder().decode(array);
			}
			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.
			let s = '';
			for (let i = 0, il = array.length; i < il; i++) {
				// Implicitly assumes little-endian.
				s += String.fromCharCode(array[i]);
			}
			try {
				// merges multi-byte utf-8 characters.
				return decodeURIComponent(escape(s));
			} catch (e) { // see #16358
				return s;
			}
		}
		static extractUrlBase(url) {
			const index = url.lastIndexOf('/');
			if (index === -1) return './';
			return url.slice(0, index + 1);
		}
		static resolveURL(url, path) {
			// Invalid URL
			if (typeof url !== 'string' || url === '') return '';
			// Host Relative URL
			if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
				path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
			}
			// Absolute URL http://,https://,//
			if (/^(https?:)?\/\//i.test(url)) return url;
			// Data URI
			if (/^data:.*,.*$/i.test(url)) return url;
			// Blob URL
			if (/^blob:.*$/i.test(url)) return url;
			// Relative URL
			return path + url;
		}
	}
	class InstancedBufferGeometry extends BufferGeometry {
		constructor() {
			super();
			this.isInstancedBufferGeometry = true;
			this.type = 'InstancedBufferGeometry';
			this.instanceCount = Infinity;
		}
		copy(source) {
			super.copy(source);
			this.instanceCount = source.instanceCount;
			return this;
		}
		toJSON() {
			const data = super.toJSON();
			data.instanceCount = this.instanceCount;
			data.isInstancedBufferGeometry = true;
			return data;
		}
	}
	class BufferGeometryLoader extends Loader {
		constructor(manager) {
			super(manager);
		}
		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.setRequestHeader(scope.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function(text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}
					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}
		parse(json) {
			const interleavedBufferMap = {};
			const arrayBufferMap = {};

			function getInterleavedBuffer(json, uuid) {
				if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
				const interleavedBuffers = json.interleavedBuffers;
				const interleavedBuffer = interleavedBuffers[uuid];
				const buffer = getArrayBuffer(json, interleavedBuffer.buffer);
				const array = getTypedArray(interleavedBuffer.type, buffer);
				const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
				ib.uuid = interleavedBuffer.uuid;
				interleavedBufferMap[uuid] = ib;
				return ib;
			}

			function getArrayBuffer(json, uuid) {
				if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
				const arrayBuffers = json.arrayBuffers;
				const arrayBuffer = arrayBuffers[uuid];
				const ab = new Uint32Array(arrayBuffer).buffer;
				arrayBufferMap[uuid] = ab;
				return ab;
			}
			const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
			const index = json.data.index;
			if (index !== undefined) {
				const typedArray = getTypedArray(index.type, index.array);
				geometry.setIndex(new BufferAttribute(typedArray, 1));
			}
			const attributes = json.data.attributes;
			for (const key in attributes) {
				const attribute = attributes[key];
				let bufferAttribute;
				if (attribute.isInterleavedBufferAttribute) {
					const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
					bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
				} else {
					const typedArray = getTypedArray(attribute.type, attribute.array);
					const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
					bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
				}
				if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
				if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);
				if (attribute.updateRange !== undefined) {
					bufferAttribute.updateRange.offset = attribute.updateRange.offset;
					bufferAttribute.updateRange.count = attribute.updateRange.count;
				}
				geometry.setAttribute(key, bufferAttribute);
			}
			const morphAttributes = json.data.morphAttributes;
			if (morphAttributes) {
				for (const key in morphAttributes) {
					const attributeArray = morphAttributes[key];
					const array = [];
					for (let i = 0, il = attributeArray.length; i < il; i++) {
						const attribute = attributeArray[i];
						let bufferAttribute;
						if (attribute.isInterleavedBufferAttribute) {
							const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
							bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
						} else {
							const typedArray = getTypedArray(attribute.type, attribute.array);
							bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
						}
						if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
						array.push(bufferAttribute);
					}
					geometry.morphAttributes[key] = array;
				}
			}
			const morphTargetsRelative = json.data.morphTargetsRelative;
			if (morphTargetsRelative) {
				geometry.morphTargetsRelative = true;
			}
			const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
			if (groups !== undefined) {
				for (let i = 0, n = groups.length; i !== n; ++i) {
					const group = groups[i];
					geometry.addGroup(group.start, group.count, group.materialIndex);
				}
			}
			const boundingSphere = json.data.boundingSphere;
			if (boundingSphere !== undefined) {
				const center = new Vector3();
				if (boundingSphere.center !== undefined) {
					center.fromArray(boundingSphere.center);
				}
				geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
			}
			if (json.name) geometry.name = json.name;
			if (json.userData) geometry.userData = json.userData;
			return geometry;
		}
	}
	class ObjectLoader extends Loader {
		constructor(manager) {
			super(manager);
		}
		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const path = (this.path === '') ? LoaderUtils.extractUrlBase(url) : this.path;
			this.resourcePath = this.resourcePath || path;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function(text) {
				let json = null;
				try {
					json = JSON.parse(text);
				} catch (error) {
					if (onError !== undefined) onError(error);
					console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
					return;
				}
				const metadata = json.metadata;
				if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
					if (onError !== undefined) onError(new Error('THREE.ObjectLoader: Can\'t load ' + url));
					console.error('THREE.ObjectLoader: Can\'t load ' + url);
					return;
				}
				scope.parse(json, onLoad);
			}, onProgress, onError);
		}
		async loadAsync(url, onProgress) {
			const scope = this;
			const path = (this.path === '') ? LoaderUtils.extractUrlBase(url) : this.path;
			this.resourcePath = this.resourcePath || path;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			const text = await loader.loadAsync(url, onProgress);
			const json = JSON.parse(text);
			const metadata = json.metadata;
			if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
				throw new Error('THREE.ObjectLoader: Can\'t load ' + url);
			}
			return await scope.parseAsync(json);
		}
		parse(json, onLoad) {
			const animations = this.parseAnimations(json.animations);
			const shapes = this.parseShapes(json.shapes);
			const geometries = this.parseGeometries(json.geometries, shapes);
			const images = this.parseImages(json.images, function() {
				if (onLoad !== undefined) onLoad(object);
			});
			const textures = this.parseTextures(json.textures, images);
			const materials = this.parseMaterials(json.materials, textures);
			const object = this.parseObject(json.object, geometries, materials, textures, animations);
			const skeletons = this.parseSkeletons(json.skeletons, object);
			this.bindSkeletons(object, skeletons);
			//
			if (onLoad !== undefined) {
				let hasImages = false;
				for (const uuid in images) {
					if (images[uuid].data instanceof HTMLImageElement) {
						hasImages = true;
						break;
					}
				}
				if (hasImages === false) onLoad(object);
			}
			return object;
		}
		async parseAsync(json) {
			const animations = this.parseAnimations(json.animations);
			const shapes = this.parseShapes(json.shapes);
			const geometries = this.parseGeometries(json.geometries, shapes);
			const images = await this.parseImagesAsync(json.images);
			const textures = this.parseTextures(json.textures, images);
			const materials = this.parseMaterials(json.materials, textures);
			const object = this.parseObject(json.object, geometries, materials, textures, animations);
			const skeletons = this.parseSkeletons(json.skeletons, object);
			this.bindSkeletons(object, skeletons);
			return object;
		}
		parseShapes(json) {
			const shapes = {};
			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const shape = new Shape().fromJSON(json[i]);
					shapes[shape.uuid] = shape;
				}
			}
			return shapes;
		}
		parseSkeletons(json, object) {
			const skeletons = {};
			const bones = {};
			// generate bone lookup table
			object.traverse(function(child) {
				if (child.isBone) bones[child.uuid] = child;
			});
			// create skeletons
			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const skeleton = new Skeleton().fromJSON(json[i], bones);
					skeletons[skeleton.uuid] = skeleton;
				}
			}
			return skeletons;
		}
		parseGeometries(json, shapes) {
			const geometries = {};
			if (json !== undefined) {
				const bufferGeometryLoader = new BufferGeometryLoader();
				for (let i = 0, l = json.length; i < l; i++) {
					let geometry;
					const data = json[i];
					switch (data.type) {
						case 'BufferGeometry':
						case 'InstancedBufferGeometry':
							geometry = bufferGeometryLoader.parse(data);
							break;
						default:
							if (data.type in Geometries) {
								geometry = Geometries[data.type].fromJSON(data, shapes);
							} else {
								console.warn(`THREE.ObjectLoader: Unsupported geometry type "${ data.type }"`);
							}
					}
					geometry.uuid = data.uuid;
					if (data.name !== undefined) geometry.name = data.name;
					if (data.userData !== undefined) geometry.userData = data.userData;
					geometries[data.uuid] = geometry;
				}
			}
			return geometries;
		}
		parseMaterials(json, textures) {
			const cache = {}; // MultiMaterial
			const materials = {};
			if (json !== undefined) {
				const loader = new MaterialLoader();
				loader.setTextures(textures);
				for (let i = 0, l = json.length; i < l; i++) {
					const data = json[i];
					if (cache[data.uuid] === undefined) {
						cache[data.uuid] = loader.parse(data);
					}
					materials[data.uuid] = cache[data.uuid];
				}
			}
			return materials;
		}
		parseAnimations(json) {
			const animations = {};
			if (json !== undefined) {
				for (let i = 0; i < json.length; i++) {
					const data = json[i];
					const clip = AnimationClip.parse(data);
					animations[clip.uuid] = clip;
				}
			}
			return animations;
		}
		parseImages(json, onLoad) {
			const scope = this;
			const images = {};
			let loader;

			function loadImage(url) {
				scope.manager.itemStart(url);
				return loader.load(url, function() {
					scope.manager.itemEnd(url);
				}, undefined, function() {
					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				});
			}

			function deserializeImage(image) {
				if (typeof image === 'string') {
					const url = image;
					const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
					return loadImage(path);
				} else {
					if (image.data) {
						return {
							data: getTypedArray(image.type, image.data),
							width: image.width,
							height: image.height
						};
					} else {
						return null;
					}
				}
			}
			if (json !== undefined && json.length > 0) {
				const manager = new LoadingManager(onLoad);
				loader = new ImageLoader(manager);
				loader.setCrossOrigin(this.crossOrigin);
				for (let i = 0, il = json.length; i < il; i++) {
					const image = json[i];
					const url = image.url;
					if (Array.isArray(url)) {
						// load array of images e.g CubeTexture
						const imageArray = [];
						for (let j = 0, jl = url.length; j < jl; j++) {
							const currentUrl = url[j];
							const deserializedImage = deserializeImage(currentUrl);
							if (deserializedImage !== null) {
								if (deserializedImage instanceof HTMLImageElement) {
									imageArray.push(deserializedImage);
								} else {
									// special case: handle array of data textures for cube textures
									imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
								}
							}
						}
						images[image.uuid] = new Source(imageArray);
					} else {
						// load single image
						const deserializedImage = deserializeImage(image.url);
						images[image.uuid] = new Source(deserializedImage);
					}
				}
			}
			return images;
		}
		async parseImagesAsync(json) {
			const scope = this;
			const images = {};
			let loader;
			async function deserializeImage(image) {
				if (typeof image === 'string') {
					const url = image;
					const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
					return await loader.loadAsync(path);
				} else {
					if (image.data) {
						return {
							data: getTypedArray(image.type, image.data),
							width: image.width,
							height: image.height
						};
					} else {
						return null;
					}
				}
			}
			if (json !== undefined && json.length > 0) {
				loader = new ImageLoader(this.manager);
				loader.setCrossOrigin(this.crossOrigin);
				for (let i = 0, il = json.length; i < il; i++) {
					const image = json[i];
					const url = image.url;
					if (Array.isArray(url)) {
						// load array of images e.g CubeTexture
						const imageArray = [];
						for (let j = 0, jl = url.length; j < jl; j++) {
							const currentUrl = url[j];
							const deserializedImage = await deserializeImage(currentUrl);
							if (deserializedImage !== null) {
								if (deserializedImage instanceof HTMLImageElement) {
									imageArray.push(deserializedImage);
								} else {
									// special case: handle array of data textures for cube textures
									imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
								}
							}
						}
						images[image.uuid] = new Source(imageArray);
					} else {
						// load single image
						const deserializedImage = await deserializeImage(image.url);
						images[image.uuid] = new Source(deserializedImage);
					}
				}
			}
			return images;
		}
		parseTextures(json, images) {
			function parseConstant(value, type) {
				if (typeof value === 'number') return value;
				console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
				return type[value];
			}
			const textures = {};
			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const data = json[i];
					if (data.image === undefined) {
						console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
					}
					if (images[data.image] === undefined) {
						console.warn('THREE.ObjectLoader: Undefined image', data.image);
					}
					const source = images[data.image];
					const image = source.data;
					let texture;
					if (Array.isArray(image)) {
						texture = new CubeTexture();
						if (image.length === 6) texture.needsUpdate = true;
					} else {
						if (image && image.data) {
							texture = new DataTexture();
						} else {
							texture = new Texture();
						}
						if (image) texture.needsUpdate = true; // textures can have undefined image data
					}
					texture.source = source;
					texture.uuid = data.uuid;
					if (data.name !== undefined) texture.name = data.name;
					if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
					if (data.offset !== undefined) texture.offset.fromArray(data.offset);
					if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
					if (data.center !== undefined) texture.center.fromArray(data.center);
					if (data.rotation !== undefined) texture.rotation = data.rotation;
					if (data.wrap !== undefined) {
						texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
						texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
					}
					if (data.format !== undefined) texture.format = data.format;
					if (data.internalFormat !== undefined) texture.internalFormat = data.internalFormat;
					if (data.type !== undefined) texture.type = data.type;
					if (data.encoding !== undefined) texture.encoding = data.encoding;
					if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
					if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
					if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
					if (data.flipY !== undefined) texture.flipY = data.flipY;
					if (data.generateMipmaps !== undefined) texture.generateMipmaps = data.generateMipmaps;
					if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
					if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
					if (data.userData !== undefined) texture.userData = data.userData;
					textures[data.uuid] = texture;
				}
			}
			return textures;
		}
		parseObject(data, geometries, materials, textures, animations) {
			let object;

			function getGeometry(name) {
				if (geometries[name] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined geometry', name);
				}
				return geometries[name];
			}

			function getMaterial(name) {
				if (name === undefined) return undefined;
				if (Array.isArray(name)) {
					const array = [];
					for (let i = 0, l = name.length; i < l; i++) {
						const uuid = name[i];
						if (materials[uuid] === undefined) {
							console.warn('THREE.ObjectLoader: Undefined material', uuid);
						}
						array.push(materials[uuid]);
					}
					return array;
				}
				if (materials[name] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined material', name);
				}
				return materials[name];
			}

			function getTexture(uuid) {
				if (textures[uuid] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined texture', uuid);
				}
				return textures[uuid];
			}
			let geometry, material;
			switch (data.type) {
				case 'Scene':
					object = new Scene();
					if (data.background !== undefined) {
						if (Number.isInteger(data.background)) {
							object.background = new Color(data.background);
						} else {
							object.background = getTexture(data.background);
						}
					}
					if (data.environment !== undefined) {
						object.environment = getTexture(data.environment);
					}
					if (data.fog !== undefined) {
						if (data.fog.type === 'Fog') {
							object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
						} else if (data.fog.type === 'FogExp2') {
							object.fog = new FogExp2(data.fog.color, data.fog.density);
						}
					}
					if (data.backgroundBlurriness !== undefined) object.backgroundBlurriness = data.backgroundBlurriness;
					if (data.backgroundIntensity !== undefined) object.backgroundIntensity = data.backgroundIntensity;
					break;
				case 'PerspectiveCamera':
					object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
					if (data.focus !== undefined) object.focus = data.focus;
					if (data.zoom !== undefined) object.zoom = data.zoom;
					if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
					if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
					if (data.view !== undefined) object.view = Object.assign({}, data.view);
					break;
				case 'OrthographicCamera':
					object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
					if (data.zoom !== undefined) object.zoom = data.zoom;
					if (data.view !== undefined) object.view = Object.assign({}, data.view);
					break;
				case 'AmbientLight':
					object = new AmbientLight(data.color, data.intensity);
					break;
				case 'DirectionalLight':
					object = new DirectionalLight(data.color, data.intensity);
					break;
				case 'PointLight':
					object = new PointLight(data.color, data.intensity, data.distance, data.decay);
					break;
				case 'RectAreaLight':
					object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
					break;
				case 'SpotLight':
					object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
					break;
				case 'HemisphereLight':
					object = new HemisphereLight(data.color, data.groundColor, data.intensity);
					break;
				case 'LightProbe':
					object = new LightProbe().fromJSON(data);
					break;
				case 'SkinnedMesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					object = new SkinnedMesh(geometry, material);
					if (data.bindMode !== undefined) object.bindMode = data.bindMode;
					if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
					if (data.skeleton !== undefined) object.skeleton = data.skeleton;
					break;
				case 'Mesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					object = new Mesh(geometry, material);
					break;
				case 'InstancedMesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					const count = data.count;
					const instanceMatrix = data.instanceMatrix;
					const instanceColor = data.instanceColor;
					object = new InstancedMesh(geometry, material, count);
					object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
					if (instanceColor !== undefined) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
					break;
				case 'LOD':
					object = new LOD();
					break;
				case 'Line':
					object = new Line(getGeometry(data.geometry), getMaterial(data.material));
					break;
				case 'LineLoop':
					object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
					break;
				case 'LineSegments':
					object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
					break;
				case 'PointCloud':
				case 'Points':
					object = new Points(getGeometry(data.geometry), getMaterial(data.material));
					break;
				case 'Sprite':
					object = new Sprite(getMaterial(data.material));
					break;
				case 'Group':
					object = new Group();
					break;
				case 'Bone':
					object = new Bone();
					break;
				default:
					object = new Object3D();
			}
			object.uuid = data.uuid;
			if (data.name !== undefined) object.name = data.name;
			if (data.matrix !== undefined) {
				object.matrix.fromArray(data.matrix);
				if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
				if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
			} else {
				if (data.position !== undefined) object.position.fromArray(data.position);
				if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
				if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
				if (data.scale !== undefined) object.scale.fromArray(data.scale);
			}
			if (data.castShadow !== undefined) object.castShadow = data.castShadow;
			if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
			if (data.shadow) {
				if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
				if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
				if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
				if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
				if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
			}
			if (data.visible !== undefined) object.visible = data.visible;
			if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
			if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
			if (data.userData !== undefined) object.userData = data.userData;
			if (data.layers !== undefined) object.layers.mask = data.layers;
			if (data.children !== undefined) {
				const children = data.children;
				for (let i = 0; i < children.length; i++) {
					object.add(this.parseObject(children[i], geometries, materials, textures, animations));
				}
			}
			if (data.animations !== undefined) {
				const objectAnimations = data.animations;
				for (let i = 0; i < objectAnimations.length; i++) {
					const uuid = objectAnimations[i];
					object.animations.push(animations[uuid]);
				}
			}
			if (data.type === 'LOD') {
				if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
				const levels = data.levels;
				for (let l = 0; l < levels.length; l++) {
					const level = levels[l];
					const child = object.getObjectByProperty('uuid', level.object);
					if (child !== undefined) {
						object.addLevel(child, level.distance, level.hysteresis);
					}
				}
			}
			return object;
		}
		bindSkeletons(object, skeletons) {
			if (Object.keys(skeletons).length === 0) return;
			object.traverse(function(child) {
				if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
					const skeleton = skeletons[child.skeleton];
					if (skeleton === undefined) {
						console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
					} else {
						child.bind(skeleton, child.bindMatrix);
					}
				}
			});
		}
	}
	const TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping
	};
	const TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};
	const TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipmapNearestFilter: NearestMipmapNearestFilter,
		NearestMipmapLinearFilter: NearestMipmapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipmapNearestFilter: LinearMipmapNearestFilter,
		LinearMipmapLinearFilter: LinearMipmapLinearFilter
	};
	class ImageBitmapLoader extends Loader {
		constructor(manager) {
			super(manager);
			this.isImageBitmapLoader = true;
			if (typeof createImageBitmap === 'undefined') {
				console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
			}
			if (typeof fetch === 'undefined') {
				console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
			}
			this.options = {
				premultiplyAlpha: 'none'
			};
		}
		setOptions(options) {
			this.options = options;
			return this;
		}
		load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			const scope = this;
			const cached = Cache.get(url);
			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function() {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			}
			const fetchOptions = {};
			fetchOptions.credentials = (this.crossOrigin === 'anonymous') ? 'same-origin' : 'include';
			fetchOptions.headers = this.requestHeader;
			fetch(url, fetchOptions).then(function(res) {
				return res.blob();
			}).then(function(blob) {
				return createImageBitmap(blob, Object.assign(scope.options, {
					colorSpaceConversion: 'none'
				}));
			}).then(function(imageBitmap) {
				Cache.add(url, imageBitmap);
				if (onLoad) onLoad(imageBitmap);
				scope.manager.itemEnd(url);
			}).catch(function(e) {
				if (onError) onError(e);
				scope.manager.itemError(url);
				scope.manager.itemEnd(url);
			});
			scope.manager.itemStart(url);
		}
	}
	let _context;
	class AudioContext {
		static getContext() {
			if (_context === undefined) {
				_context = new(window.AudioContext || window.webkitAudioContext)();
			}
			return _context;
		}
		static setContext(value) {
			_context = value;
		}
	}
	class AudioLoader extends Loader {
		constructor(manager) {
			super(manager);
		}
		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function(buffer) {
				try {
					// Create a copy of the buffer. The `decodeAudioData` method
					// detaches the buffer when complete, preventing reuse.
					const bufferCopy = buffer.slice(0);
					const context = AudioContext.getContext();
					context.decodeAudioData(bufferCopy, function(audioBuffer) {
						onLoad(audioBuffer);
					});
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}
					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}
	}
	class HemisphereLightProbe extends LightProbe {
		constructor(skyColor, groundColor, intensity = 1) {
			super(undefined, intensity);
			this.isHemisphereLightProbe = true;
			const color1 = new Color().set(skyColor);
			const color2 = new Color().set(groundColor);
			const sky = new Vector3(color1.r, color1.g, color1.b);
			const ground = new Vector3(color2.r, color2.g, color2.b);
			// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
			const c0 = Math.sqrt(Math.PI);
			const c1 = c0 * Math.sqrt(0.75);
			this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
			this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
		}
	}
	class AmbientLightProbe extends LightProbe {
		constructor(color, intensity = 1) {
			super(undefined, intensity);
			this.isAmbientLightProbe = true;
			const color1 = new Color().set(color);
			// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
			this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
		}
	}
	const _eyeRight = /*@__PURE__*/ new Matrix4();
	const _eyeLeft = /*@__PURE__*/ new Matrix4();
	const _projectionMatrix = /*@__PURE__*/ new Matrix4();
	class StereoCamera {
		constructor() {
			this.type = 'StereoCamera';
			this.aspect = 1;
			this.eyeSep = 0.064;
			this.cameraL = new PerspectiveCamera();
			this.cameraL.layers.enable(1);
			this.cameraL.matrixAutoUpdate = false;
			this.cameraR = new PerspectiveCamera();
			this.cameraR.layers.enable(2);
			this.cameraR.matrixAutoUpdate = false;
			this._cache = {
				focus: null,
				fov: null,
				aspect: null,
				near: null,
				far: null,
				zoom: null,
				eyeSep: null
			};
		}
		update(camera) {
			const cache = this._cache;
			const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
				cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
				cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
			if (needsUpdate) {
				cache.focus = camera.focus;
				cache.fov = camera.fov;
				cache.aspect = camera.aspect * this.aspect;
				cache.near = camera.near;
				cache.far = camera.far;
				cache.zoom = camera.zoom;
				cache.eyeSep = this.eyeSep;
				// Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/
				_projectionMatrix.copy(camera.projectionMatrix);
				const eyeSepHalf = cache.eyeSep / 2;
				const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
				const ymax = (cache.near * Math.tan(DEG2RAD * cache.fov * 0.5)) / cache.zoom;
				let xmin, xmax;
				// translate xOffset
				_eyeLeft.elements[12] = -eyeSepHalf;
				_eyeRight.elements[12] = eyeSepHalf;
				// for left eye
				xmin = -ymax * cache.aspect + eyeSepOnProjection;
				xmax = ymax * cache.aspect + eyeSepOnProjection;
				_projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
				_projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
				this.cameraL.projectionMatrix.copy(_projectionMatrix);
				// for right eye
				xmin = -ymax * cache.aspect - eyeSepOnProjection;
				xmax = ymax * cache.aspect - eyeSepOnProjection;
				_projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
				_projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
				this.cameraR.projectionMatrix.copy(_projectionMatrix);
			}
			this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
			this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
		}
	}
	class Clock {
		constructor(autoStart = true) {
			this.autoStart = autoStart;
			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;
			this.running = false;
		}
		start() {
			this.startTime = now();
			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;
		}
		stop() {
			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;
		}
		getElapsedTime() {
			this.getDelta();
			return this.elapsedTime;
		}
		getDelta() {
			let diff = 0;
			if (this.autoStart && !this.running) {
				this.start();
				return 0;
			}
			if (this.running) {
				const newTime = now();
				diff = (newTime - this.oldTime) / 1000;
				this.oldTime = newTime;
				this.elapsedTime += diff;
			}
			return diff;
		}
	}

	function now() {
		return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
	}
	const _position$1 = /*@__PURE__*/ new Vector3();
	const _quaternion$1 = /*@__PURE__*/ new Quaternion();
	const _scale$1 = /*@__PURE__*/ new Vector3();
	const _orientation$1 = /*@__PURE__*/ new Vector3();
	class AudioListener extends Object3D {
		constructor() {
			super();
			this.type = 'AudioListener';
			this.context = AudioContext.getContext();
			this.gain = this.context.createGain();
			this.gain.connect(this.context.destination);
			this.filter = null;
			this.timeDelta = 0;
			// private
			this._clock = new Clock();
		}
		getInput() {
			return this.gain;
		}
		removeFilter() {
			if (this.filter !== null) {
				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
				this.gain.connect(this.context.destination);
				this.filter = null;
			}
			return this;
		}
		getFilter() {
			return this.filter;
		}
		setFilter(value) {
			if (this.filter !== null) {
				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
			} else {
				this.gain.disconnect(this.context.destination);
			}
			this.filter = value;
			this.gain.connect(this.filter);
			this.filter.connect(this.context.destination);
			return this;
		}
		getMasterVolume() {
			return this.gain.gain.value;
		}
		setMasterVolume(value) {
			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
			return this;
		}
		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);
			const listener = this.context.listener;
			const up = this.up;
			this.timeDelta = this._clock.getDelta();
			this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
			_orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
			if (listener.positionX) {
				// code path for Chrome (see #14393)
				const endTime = this.context.currentTime + this.timeDelta;
				listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
				listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
				listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
				listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
				listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
				listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
				listener.upX.linearRampToValueAtTime(up.x, endTime);
				listener.upY.linearRampToValueAtTime(up.y, endTime);
				listener.upZ.linearRampToValueAtTime(up.z, endTime);
			} else {
				listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
				listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
			}
		}
	}
	class Audio extends Object3D {
		constructor(listener) {
			super();
			this.type = 'Audio';
			this.listener = listener;
			this.context = listener.context;
			this.gain = this.context.createGain();
			this.gain.connect(listener.getInput());
			this.autoplay = false;
			this.buffer = null;
			this.detune = 0;
			this.loop = false;
			this.loopStart = 0;
			this.loopEnd = 0;
			this.offset = 0;
			this.duration = undefined;
			this.playbackRate = 1;
			this.isPlaying = false;
			this.hasPlaybackControl = true;
			this.source = null;
			this.sourceType = 'empty';
			this._startedAt = 0;
			this._progress = 0;
			this._connected = false;
			this.filters = [];
		}
		getOutput() {
			return this.gain;
		}
		setNodeSource(audioNode) {
			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();
			return this;
		}
		setMediaElementSource(mediaElement) {
			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource(mediaElement);
			this.connect();
			return this;
		}
		setMediaStreamSource(mediaStream) {
			this.hasPlaybackControl = false;
			this.sourceType = 'mediaStreamNode';
			this.source = this.context.createMediaStreamSource(mediaStream);
			this.connect();
			return this;
		}
		setBuffer(audioBuffer) {
			this.buffer = audioBuffer;
			this.sourceType = 'buffer';
			if (this.autoplay) this.play();
			return this;
		}
		play(delay = 0) {
			if (this.isPlaying === true) {
				console.warn('THREE.Audio: Audio is already playing.');
				return;
			}
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}
			this._startedAt = this.context.currentTime + delay;
			const source = this.context.createBufferSource();
			source.buffer = this.buffer;
			source.loop = this.loop;
			source.loopStart = this.loopStart;
			source.loopEnd = this.loopEnd;
			source.onended = this.onEnded.bind(this);
			source.start(this._startedAt, this._progress + this.offset, this.duration);
			this.isPlaying = true;
			this.source = source;
			this.setDetune(this.detune);
			this.setPlaybackRate(this.playbackRate);
			return this.connect();
		}
		pause() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}
			if (this.isPlaying === true) {
				// update current progress
				this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
				if (this.loop === true) {
					// ensure _progress does not exceed duration with looped audios
					this._progress = this._progress % (this.duration || this.buffer.duration);
				}
				this.source.stop();
				this.source.onended = null;
				this.isPlaying = false;
			}
			return this;
		}
		stop() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}
			this._progress = 0;
			if (this.source !== null) {
				this.source.stop();
				this.source.onended = null;
			}
			this.isPlaying = false;
			return this;
		}
		connect() {
			if (this.filters.length > 0) {
				this.source.connect(this.filters[0]);
				for (let i = 1, l = this.filters.length; i < l; i++) {
					this.filters[i - 1].connect(this.filters[i]);
				}
				this.filters[this.filters.length - 1].connect(this.getOutput());
			} else {
				this.source.connect(this.getOutput());
			}
			this._connected = true;
			return this;
		}
		disconnect() {
			if (this.filters.length > 0) {
				this.source.disconnect(this.filters[0]);
				for (let i = 1, l = this.filters.length; i < l; i++) {
					this.filters[i - 1].disconnect(this.filters[i]);
				}
				this.filters[this.filters.length - 1].disconnect(this.getOutput());
			} else {
				this.source.disconnect(this.getOutput());
			}
			this._connected = false;
			return this;
		}
		getFilters() {
			return this.filters;
		}
		setFilters(value) {
			if (!value) value = [];
			if (this._connected === true) {
				this.disconnect();
				this.filters = value.slice();
				this.connect();
			} else {
				this.filters = value.slice();
			}
			return this;
		}
		setDetune(value) {
			this.detune = value;
			if (this.source.detune === undefined) return; // only set detune when available
			if (this.isPlaying === true) {
				this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
			}
			return this;
		}
		getDetune() {
			return this.detune;
		}
		getFilter() {
			return this.getFilters()[0];
		}
		setFilter(filter) {
			return this.setFilters(filter ? [filter] : []);
		}
		setPlaybackRate(value) {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}
			this.playbackRate = value;
			if (this.isPlaying === true) {
				this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
			}
			return this;
		}
		getPlaybackRate() {
			return this.playbackRate;
		}
		onEnded() {
			this.isPlaying = false;
		}
		getLoop() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return false;
			}
			return this.loop;
		}
		setLoop(value) {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}
			this.loop = value;
			if (this.isPlaying === true) {
				this.source.loop = this.loop;
			}
			return this;
		}
		setLoopStart(value) {
			this.loopStart = value;
			return this;
		}
		setLoopEnd(value) {
			this.loopEnd = value;
			return this;
		}
		getVolume() {
			return this.gain.gain.value;
		}
		setVolume(value) {
			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
			return this;
		}
	}
	const _position = /*@__PURE__*/ new Vector3();
	const _quaternion = /*@__PURE__*/ new Quaternion();
	const _scale = /*@__PURE__*/ new Vector3();
	const _orientation = /*@__PURE__*/ new Vector3();
	class PositionalAudio extends Audio {
		constructor(listener) {
			super(listener);
			this.panner = this.context.createPanner();
			this.panner.panningModel = 'HRTF';
			this.panner.connect(this.gain);
		}
		disconnect() {
			super.disconnect();
			this.panner.disconnect(this.gain);
		}
		getOutput() {
			return this.panner;
		}
		getRefDistance() {
			return this.panner.refDistance;
		}
		setRefDistance(value) {
			this.panner.refDistance = value;
			return this;
		}
		getRolloffFactor() {
			return this.panner.rolloffFactor;
		}
		setRolloffFactor(value) {
			this.panner.rolloffFactor = value;
			return this;
		}
		getDistanceModel() {
			return this.panner.distanceModel;
		}
		setDistanceModel(value) {
			this.panner.distanceModel = value;
			return this;
		}
		getMaxDistance() {
			return this.panner.maxDistance;
		}
		setMaxDistance(value) {
			this.panner.maxDistance = value;
			return this;
		}
		setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
			this.panner.coneInnerAngle = coneInnerAngle;
			this.panner.coneOuterAngle = coneOuterAngle;
			this.panner.coneOuterGain = coneOuterGain;
			return this;
		}
		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);
			if (this.hasPlaybackControl === true && this.isPlaying === false) return;
			this.matrixWorld.decompose(_position, _quaternion, _scale);
			_orientation.set(0, 0, 1).applyQuaternion(_quaternion);
			const panner = this.panner;
			if (panner.positionX) {
				// code path for Chrome and Firefox (see #14393)
				const endTime = this.context.currentTime + this.listener.timeDelta;
				panner.positionX.linearRampToValueAtTime(_position.x, endTime);
				panner.positionY.linearRampToValueAtTime(_position.y, endTime);
				panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
				panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
				panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
				panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
			} else {
				panner.setPosition(_position.x, _position.y, _position.z);
				panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
			}
		}
	}
	class AudioAnalyser {
		constructor(audio, fftSize = 2048) {
			this.analyser = audio.context.createAnalyser();
			this.analyser.fftSize = fftSize;
			this.data = new Uint8Array(this.analyser.frequencyBinCount);
			audio.getOutput().connect(this.analyser);
		}
		getFrequencyData() {
			this.analyser.getByteFrequencyData(this.data);
			return this.data;
		}
		getAverageFrequency() {
			let value = 0;
			const data = this.getFrequencyData();
			for (let i = 0; i < data.length; i++) {
				value += data[i];
			}
			return value / data.length;
		}
	}
	class PropertyMixer {
		constructor(binding, typeName, valueSize) {
			this.binding = binding;
			this.valueSize = valueSize;
			let mixFunction,
				mixFunctionAdditive,
				setIdentity;
			// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property
			//
			// 'add' is used for additive cumulative results
			//
			// 'work' is optional and is only present for quaternion types. It is used
			// to store intermediate quaternion multiplication results
			switch (typeName) {
				case 'quaternion':
					mixFunction = this._slerp;
					mixFunctionAdditive = this._slerpAdditive;
					setIdentity = this._setAdditiveIdentityQuaternion;
					this.buffer = new Float64Array(valueSize * 6);
					this._workIndex = 5;
					break;
				case 'string':
				case 'bool':
					mixFunction = this._select;
					// Use the regular mix function and for additive on these types,
					// additive is not relevant for non-numeric types
					mixFunctionAdditive = this._select;
					setIdentity = this._setAdditiveIdentityOther;
					this.buffer = new Array(valueSize * 5);
					break;
				default:
					mixFunction = this._lerp;
					mixFunctionAdditive = this._lerpAdditive;
					setIdentity = this._setAdditiveIdentityNumeric;
					this.buffer = new Float64Array(valueSize * 5);
			}
			this._mixBufferRegion = mixFunction;
			this._mixBufferRegionAdditive = mixFunctionAdditive;
			this._setIdentity = setIdentity;
			this._origIndex = 3;
			this._addIndex = 4;
			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;
			this.useCount = 0;
			this.referenceCount = 0;
		}
		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate(accuIndex, weight) {
			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place
			const buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride;
			let currentWeight = this.cumulativeWeight;
			if (currentWeight === 0) {
				// accuN := incoming * weight
				for (let i = 0; i !== stride; ++i) {
					buffer[offset + i] = buffer[i];
				}
				currentWeight = weight;
			} else {
				// accuN := accuN + incoming * weight
				currentWeight += weight;
				const mix = weight / currentWeight;
				this._mixBufferRegion(buffer, offset, 0, mix, stride);
			}
			this.cumulativeWeight = currentWeight;
		}
		// accumulate data in the 'incoming' region into 'add'
		accumulateAdditive(weight) {
			const buffer = this.buffer,
				stride = this.valueSize,
				offset = stride * this._addIndex;
			if (this.cumulativeWeightAdditive === 0) {
				// add = identity
				this._setIdentity();
			}
			// add := add + incoming * weight
			this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
			this.cumulativeWeightAdditive += weight;
		}
		// apply the state of 'accu<i>' to the binding when accus differ
		apply(accuIndex) {
			const stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,
				weight = this.cumulativeWeight,
				weightAdditive = this.cumulativeWeightAdditive,
				binding = this.binding;
			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;
			if (weight < 1) {
				// accuN := accuN + original * ( 1 - cumulativeWeight )
				const originalValueOffset = stride * this._origIndex;
				this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride);
			}
			if (weightAdditive > 0) {
				// accuN := accuN + additive accuN
				this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
			}
			for (let i = stride, e = stride + stride; i !== e; ++i) {
				if (buffer[i] !== buffer[i + stride]) {
					// value has changed -> update scene graph
					binding.setValue(buffer, offset);
					break;
				}
			}
		}
		// remember the state of the bound property and copy it to both accus
		saveOriginalState() {
			const binding = this.binding;
			const buffer = this.buffer,
				stride = this.valueSize,
				originalValueOffset = stride * this._origIndex;
			binding.getValue(buffer, originalValueOffset);
			// accu[0..1] := orig -- initially detect changes against the original
			for (let i = stride, e = originalValueOffset; i !== e; ++i) {
				buffer[i] = buffer[originalValueOffset + (i % stride)];
			}
			// Add to identity for additive
			this._setIdentity();
			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;
		}
		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState() {
			const originalValueOffset = this.valueSize * 3;
			this.binding.setValue(this.buffer, originalValueOffset);
		}
		_setAdditiveIdentityNumeric() {
			const startIndex = this._addIndex * this.valueSize;
			const endIndex = startIndex + this.valueSize;
			for (let i = startIndex; i < endIndex; i++) {
				this.buffer[i] = 0;
			}
		}
		_setAdditiveIdentityQuaternion() {
			this._setAdditiveIdentityNumeric();
			this.buffer[this._addIndex * this.valueSize + 3] = 1;
		}
		_setAdditiveIdentityOther() {
			const startIndex = this._origIndex * this.valueSize;
			const targetIndex = this._addIndex * this.valueSize;
			for (let i = 0; i < this.valueSize; i++) {
				this.buffer[targetIndex + i] = this.buffer[startIndex + i];
			}
		}
		// mix functions
		_select(buffer, dstOffset, srcOffset, t, stride) {
			if (t >= 0.5) {
				for (let i = 0; i !== stride; ++i) {
					buffer[dstOffset + i] = buffer[srcOffset + i];
				}
			}
		}
		_slerp(buffer, dstOffset, srcOffset, t) {
			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
		}
		_slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
			const workOffset = this._workIndex * stride;
			// Store result in intermediate buffer offset
			Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
			// Slerp to the intermediate result
			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
		}
		_lerp(buffer, dstOffset, srcOffset, t, stride) {
			const s = 1 - t;
			for (let i = 0; i !== stride; ++i) {
				const j = dstOffset + i;
				buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
			}
		}
		_lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
			for (let i = 0; i !== stride; ++i) {
				const j = dstOffset + i;
				buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
			}
		}
	}
	// Characters [].:/ are reserved for track binding syntax.
	const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
	const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');
	// Attempts to allow node names from any language. ES5's `\w` regexp matches
	// only latin characters, and the unicode \p{L} is not yet supported. So
	// instead, we exclude reserved characters and match everything else.
	const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
	const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';
	// Parent directories, delimited by '/' or ':'. Currently unused, but must
	// be matched to parse the rest of the track name.
	const _directoryRe = /*@__PURE__*/ /((?:WC+[\/:])*)/.source.replace('WC', _wordChar);
	// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
	const _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);
	// Object on target node, and accessor. May not contain reserved
	// characters. Accessor may contain any character except closing bracket.
	const _objectRe = /*@__PURE__*/ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);
	// Property and accessor. May not contain reserved characters. Accessor may
	// contain any non-bracket characters.
	const _propertyRe = /*@__PURE__*/ /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);
	const _trackRe = new RegExp('' +
		'^' +
		_directoryRe +
		_nodeRe +
		_objectRe +
		_propertyRe +
		'$'
	);
	const _supportedObjectNames = ['material', 'materials', 'bones', 'map'];
	class Composite {
		constructor(targetGroup, path, optionalParsedPath) {
			const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_(path, parsedPath);
		}
		getValue(array, offset) {
			this.bind(); // bind all binding
			const firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[firstValidIndex];
			// and only call .getValue on the first
			if (binding !== undefined) binding.getValue(array, offset);
		}
		setValue(array, offset) {
			const bindings = this._bindings;
			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].setValue(array, offset);
			}
		}
		bind() {
			const bindings = this._bindings;
			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].bind();
			}
		}
		unbind() {
			const bindings = this._bindings;
			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].unbind();
			}
		}
	}
	// Note: This class uses a State pattern on a per-method basis:
	// 'bind' sets 'this.getValue' / 'setValue' and shadows the
	// prototype version of these methods with one that represents
	// the bound state. When the property is not found, the methods
	// become no-ops.
	class PropertyBinding {
		constructor(rootNode, path, parsedPath) {
			this.path = path;
			this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
			this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
			this.rootNode = rootNode;
			// initial state of these methods that calls 'bind'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
		}
		static create(root, path, parsedPath) {
			if (!(root && root.isAnimationObjectGroup)) {
				return new PropertyBinding(root, path, parsedPath);
			} else {
				return new PropertyBinding.Composite(root, path, parsedPath);
			}
		}
		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param {string} name Node name to be sanitized.
		 * @return {string}
		 */
		static sanitizeNodeName(name) {
			return name.replace(/\s/g, '_').replace(_reservedRe, '');
		}
		static parseTrackName(trackName) {
			const matches = _trackRe.exec(trackName);
			if (matches === null) {
				throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
			}
			const results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[2],
				objectName: matches[3],
				objectIndex: matches[4],
				propertyName: matches[5], // required
				propertyIndex: matches[6]
			};
			const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
			if (lastDot !== undefined && lastDot !== -1) {
				const objectName = results.nodeName.substring(lastDot + 1);
				// Object names must be checked against an allowlist. Otherwise, there
				// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
				// 'bar' could be the objectName, or part of a nodeName (which can
				// include '.' characters).
				if (_supportedObjectNames.indexOf(objectName) !== -1) {
					results.nodeName = results.nodeName.substring(0, lastDot);
					results.objectName = objectName;
				}
			}
			if (results.propertyName === null || results.propertyName.length === 0) {
				throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
			}
			return results;
		}
		static findNode(root, nodeName) {
			if (nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
				return root;
			}
			// search into skeleton bones.
			if (root.skeleton) {
				const bone = root.skeleton.getBoneByName(nodeName);
				if (bone !== undefined) {
					return bone;
				}
			}
			// search into node subtree.
			if (root.children) {
				const searchNodeSubtree = function(children) {
					for (let i = 0; i < children.length; i++) {
						const childNode = children[i];
						if (childNode.name === nodeName || childNode.uuid === nodeName) {
							return childNode;
						}
						const result = searchNodeSubtree(childNode.children);
						if (result) return result;
					}
					return null;
				};
				const subTreeNode = searchNodeSubtree(root.children);
				if (subTreeNode) {
					return subTreeNode;
				}
			}
			return null;
		}
		// these are used to "bind" a nonexistent property
		_getValue_unavailable() {}
		_setValue_unavailable() {}
		// Getters
		_getValue_direct(buffer, offset) {
			buffer[offset] = this.targetObject[this.propertyName];
		}
		_getValue_array(buffer, offset) {
			const source = this.resolvedProperty;
			for (let i = 0, n = source.length; i !== n; ++i) {
				buffer[offset++] = source[i];
			}
		}
		_getValue_arrayElement(buffer, offset) {
			buffer[offset] = this.resolvedProperty[this.propertyIndex];
		}
		_getValue_toArray(buffer, offset) {
			this.resolvedProperty.toArray(buffer, offset);
		}
		// Direct
		_setValue_direct(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
		}
		_setValue_direct_setNeedsUpdate(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
			this.targetObject.needsUpdate = true;
		}
		_setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
			this.targetObject.matrixWorldNeedsUpdate = true;
		}
		// EntireArray
		_setValue_array(buffer, offset) {
			const dest = this.resolvedProperty;
			for (let i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}
		}
		_setValue_array_setNeedsUpdate(buffer, offset) {
			const dest = this.resolvedProperty;
			for (let i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}
			this.targetObject.needsUpdate = true;
		}
		_setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
			const dest = this.resolvedProperty;
			for (let i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}
			this.targetObject.matrixWorldNeedsUpdate = true;
		}
		// ArrayElement
		_setValue_arrayElement(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
		}
		_setValue_arrayElement_setNeedsUpdate(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
			this.targetObject.needsUpdate = true;
		}
		_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
			this.targetObject.matrixWorldNeedsUpdate = true;
		}
		// HasToFromArray
		_setValue_fromArray(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
		}
		_setValue_fromArray_setNeedsUpdate(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
			this.targetObject.needsUpdate = true;
		}
		_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
			this.targetObject.matrixWorldNeedsUpdate = true;
		}
		_getValue_unbound(targetArray, offset) {
			this.bind();
			this.getValue(targetArray, offset);
		}
		_setValue_unbound(sourceArray, offset) {
			this.bind();
			this.setValue(sourceArray, offset);
		}
		// create getter / setter pair for a property in the scene graph
		bind() {
			let targetObject = this.node;
			const parsedPath = this.parsedPath;
			const objectName = parsedPath.objectName;
			const propertyName = parsedPath.propertyName;
			let propertyIndex = parsedPath.propertyIndex;
			if (!targetObject) {
				targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
				this.node = targetObject;
			}
			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;
			// ensure there is a value node
			if (!targetObject) {
				console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
				return;
			}
			if (objectName) {
				let objectIndex = parsedPath.objectIndex;
				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch (objectName) {
					case 'materials':
						if (!targetObject.material) {
							console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
							return;
						}
						if (!targetObject.material.materials) {
							console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
							return;
						}
						targetObject = targetObject.material.materials;
						break;
					case 'bones':
						if (!targetObject.skeleton) {
							console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
							return;
						}
						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.
						targetObject = targetObject.skeleton.bones;
						// support resolving morphTarget names into indices.
						for (let i = 0; i < targetObject.length; i++) {
							if (targetObject[i].name === objectIndex) {
								objectIndex = i;
								break;
							}
						}
						break;
					case 'map':
						if ('map' in targetObject) {
							targetObject = targetObject.map;
							break;
						}
						if (!targetObject.material) {
							console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
							return;
						}
						if (!targetObject.material.map) {
							console.error('THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this);
							return;
						}
						targetObject = targetObject.material.map;
						break;
					default:
						if (targetObject[objectName] === undefined) {
							console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
							return;
						}
						targetObject = targetObject[objectName];
				}
				if (objectIndex !== undefined) {
					if (targetObject[objectIndex] === undefined) {
						console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
						return;
					}
					targetObject = targetObject[objectIndex];
				}
			}
			// resolve property
			const nodeProperty = targetObject[propertyName];
			if (nodeProperty === undefined) {
				const nodeName = parsedPath.nodeName;
				console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
					'.' + propertyName + ' but it wasn\'t found.', targetObject);
				return;
			}
			// determine versioning scheme
			let versioning = this.Versioning.None;
			this.targetObject = targetObject;
			if (targetObject.needsUpdate !== undefined) { // material
				versioning = this.Versioning.NeedsUpdate;
			} else if (targetObject.matrixWorldNeedsUpdate !== undefined) { // node transform
				versioning = this.Versioning.MatrixWorldNeedsUpdate;
			}
			// determine how the property gets bound
			let bindingType = this.BindingType.Direct;
			if (propertyIndex !== undefined) {
				// access a sub element of the property array (only primitives are supported right now)
				if (propertyName === 'morphTargetInfluences') {
					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
					// support resolving morphTarget names into indices.
					if (!targetObject.geometry) {
						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
						return;
					}
					if (!targetObject.geometry.morphAttributes) {
						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
						return;
					}
					if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
						propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
					}
				}
				bindingType = this.BindingType.ArrayElement;
				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;
			} else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
				// must use copy for Object3D.Euler/Quaternion
				bindingType = this.BindingType.HasFromToArray;
				this.resolvedProperty = nodeProperty;
			} else if (Array.isArray(nodeProperty)) {
				bindingType = this.BindingType.EntireArray;
				this.resolvedProperty = nodeProperty;
			} else {
				this.propertyName = propertyName;
			}
			// select getter / setter
			this.getValue = this.GetterByBindingType[bindingType];
			this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
		}
		unbind() {
			this.node = null;
			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
		}
	}
	PropertyBinding.Composite = Composite;
	PropertyBinding.prototype.BindingType = {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	};
	PropertyBinding.prototype.Versioning = {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	};
	PropertyBinding.prototype.GetterByBindingType = [
		PropertyBinding.prototype._getValue_direct,
		PropertyBinding.prototype._getValue_array,
		PropertyBinding.prototype._getValue_arrayElement,
		PropertyBinding.prototype._getValue_toArray,
	];
	PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
		[
			// Direct
			PropertyBinding.prototype._setValue_direct,
			PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
			PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
		],
		[
			// EntireArray
			PropertyBinding.prototype._setValue_array,
			PropertyBinding.prototype._setValue_array_setNeedsUpdate,
			PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,
		],
		[
			// ArrayElement
			PropertyBinding.prototype._setValue_arrayElement,
			PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
			PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
		],
		[
			// HasToFromArray
			PropertyBinding.prototype._setValue_fromArray,
			PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
			PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
		]
	];
	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 *  - Add objects you would otherwise pass as 'root' to the
	 *    constructor or the .clipAction method of AnimationMixer.
	 *
	 *  - Instead pass this object as 'root'.
	 *
	 *  - You can also add and remove objects later when the mixer
	 *    is running.
	 *
	 * Note:
	 *
	 *    Objects of this class appear as one object to the mixer,
	 *    so cache control of the individual objects must be done
	 *    on the group.
	 *
	 * Limitation:
	 *
	 *  - The animated properties must be compatible among the
	 *    all objects in the group.
	 *
	 *  - A single property can either be controlled through a
	 *    target group or directly, but not both.
	 */
	class AnimationObjectGroup {
		constructor() {
			this.isAnimationObjectGroup = true;
			this.uuid = generateUUID();
			// cached objects followed by the active ones
			this._objects = Array.prototype.slice.call(arguments);
			this.nCachedObjects_ = 0; // threshold
			// note: read by PropertyBinding.Composite
			const indices = {};
			this._indicesByUUID = indices; // for bookkeeping
			for (let i = 0, n = arguments.length; i !== n; ++i) {
				indices[arguments[i].uuid] = i;
			}
			this._paths = []; // inside: string
			this._parsedPaths = []; // inside: { we don't care, here }
			this._bindings = []; // inside: Array< PropertyBinding >
			this._bindingsIndicesByPath = {}; // inside: indices in these arrays
			const scope = this;
			this.stats = {
				objects: {
					get total() {
						return scope._objects.length;
					},
					get inUse() {
						return this.total - scope.nCachedObjects_;
					}
				},
				get bindingsPerObject() {
					return scope._bindings.length;
				}
			};
		}
		add() {
			const objects = this._objects,
				indicesByUUID = this._indicesByUUID,
				paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				nBindings = bindings.length;
			let knownObject = undefined,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_;
			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i],
					uuid = object.uuid;
				let index = indicesByUUID[uuid];
				if (index === undefined) {
					// unknown object -> add it to the ACTIVE region
					index = nObjects++;
					indicesByUUID[uuid] = index;
					objects.push(object);
					// accounting is done, now do the same for all bindings
					for (let j = 0, m = nBindings; j !== m; ++j) {
						bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
					}
				} else if (index < nCachedObjects) {
					knownObject = objects[index];
					// move existing object to the ACTIVE region
					const firstActiveIndex = --nCachedObjects,
						lastCachedObject = objects[firstActiveIndex];
					indicesByUUID[lastCachedObject.uuid] = index;
					objects[index] = lastCachedObject;
					indicesByUUID[uuid] = firstActiveIndex;
					objects[firstActiveIndex] = object;
					// accounting is done, now do the same for all bindings
					for (let j = 0, m = nBindings; j !== m; ++j) {
						const bindingsForPath = bindings[j],
							lastCached = bindingsForPath[firstActiveIndex];
						let binding = bindingsForPath[index];
						bindingsForPath[index] = lastCached;
						if (binding === undefined) {
							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist
							binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
						}
						bindingsForPath[firstActiveIndex] = binding;
					}
				} else if (objects[index] !== knownObject) {
					console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' +
						'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
				} // else the object is already where we want it to be
			} // for arguments
			this.nCachedObjects_ = nCachedObjects;
		}
		remove() {
			const objects = this._objects,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;
			let nCachedObjects = this.nCachedObjects_;
			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i],
					uuid = object.uuid,
					index = indicesByUUID[uuid];
				if (index !== undefined && index >= nCachedObjects) {
					// move existing object into the CACHED region
					const lastCachedIndex = nCachedObjects++,
						firstActiveObject = objects[lastCachedIndex];
					indicesByUUID[firstActiveObject.uuid] = index;
					objects[index] = firstActiveObject;
					indicesByUUID[uuid] = lastCachedIndex;
					objects[lastCachedIndex] = object;
					// accounting is done, now do the same for all bindings
					for (let j = 0, m = nBindings; j !== m; ++j) {
						const bindingsForPath = bindings[j],
							firstActive = bindingsForPath[lastCachedIndex],
							binding = bindingsForPath[index];
						bindingsForPath[index] = firstActive;
						bindingsForPath[lastCachedIndex] = binding;
					}
				}
			} // for arguments
			this.nCachedObjects_ = nCachedObjects;
		}
		// remove & forget
		uncache() {
			const objects = this._objects,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;
			let nCachedObjects = this.nCachedObjects_,
				nObjects = objects.length;
			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i],
					uuid = object.uuid,
					index = indicesByUUID[uuid];
				if (index !== undefined) {
					delete indicesByUUID[uuid];
					if (index < nCachedObjects) {
						// object is cached, shrink the CACHED region
						const firstActiveIndex = --nCachedObjects,
							lastCachedObject = objects[firstActiveIndex],
							lastIndex = --nObjects,
							lastObject = objects[lastIndex];
						// last cached object takes this object's place
						indicesByUUID[lastCachedObject.uuid] = index;
						objects[index] = lastCachedObject;
						// last object goes to the activated slot and pop
						indicesByUUID[lastObject.uuid] = firstActiveIndex;
						objects[firstActiveIndex] = lastObject;
						objects.pop();
						// accounting is done, now do the same for all bindings
						for (let j = 0, m = nBindings; j !== m; ++j) {
							const bindingsForPath = bindings[j],
								lastCached = bindingsForPath[firstActiveIndex],
								last = bindingsForPath[lastIndex];
							bindingsForPath[index] = lastCached;
							bindingsForPath[firstActiveIndex] = last;
							bindingsForPath.pop();
						}
					} else {
						// object is active, just swap with the last and pop
						const lastIndex = --nObjects,
							lastObject = objects[lastIndex];
						if (lastIndex > 0) {
							indicesByUUID[lastObject.uuid] = index;
						}
						objects[index] = lastObject;
						objects.pop();
						// accounting is done, now do the same for all bindings
						for (let j = 0, m = nBindings; j !== m; ++j) {
							const bindingsForPath = bindings[j];
							bindingsForPath[index] = bindingsForPath[lastIndex];
							bindingsForPath.pop();
						}
					} // cached or active
				} // if object is known
			} // for arguments
			this.nCachedObjects_ = nCachedObjects;
		}
		// Internal interface used by befriended PropertyBinding.Composite:
		subscribe_(path, parsedPath) {
			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group
			const indicesByPath = this._bindingsIndicesByPath;
			let index = indicesByPath[path];
			const bindings = this._bindings;
			if (index !== undefined) return bindings[index];
			const paths = this._paths,
				parsedPaths = this._parsedPaths,
				objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				bindingsForPath = new Array(nObjects);
			index = bindings.length;
			indicesByPath[path] = index;
			paths.push(path);
			parsedPaths.push(parsedPath);
			bindings.push(bindingsForPath);
			for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
				const object = objects[i];
				bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
			}
			return bindingsForPath;
		}
		unsubscribe_(path) {
			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'
			const indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[path];
			if (index !== undefined) {
				const paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					lastBindingsIndex = bindings.length - 1,
					lastBindings = bindings[lastBindingsIndex],
					lastBindingsPath = path[lastBindingsIndex];
				indicesByPath[lastBindingsPath] = index;
				bindings[index] = lastBindings;
				bindings.pop();
				parsedPaths[index] = parsedPaths[lastBindingsIndex];
				parsedPaths.pop();
				paths[index] = paths[lastBindingsIndex];
				paths.pop();
			}
		}
	}
	class AnimationAction {
		constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot;
			this.blendMode = blendMode;
			const tracks = clip.tracks,
				nTracks = tracks.length,
				interpolants = new Array(nTracks);
			const interpolantSettings = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};
			for (let i = 0; i !== nTracks; ++i) {
				const interpolant = tracks[i].createInterpolant(null);
				interpolants[i] = interpolant;
				interpolant.settings = interpolantSettings;
			}
			this._interpolantSettings = interpolantSettings;
			this._interpolants = interpolants; // bound by the mixer
			// inside: PropertyMixer (managed by the mixer)
			this._propertyBindings = new Array(nTracks);
			this._cacheIndex = null; // for the memory manager
			this._byClipCacheIndex = null; // for the memory manager
			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;
			this.loop = LoopRepeat;
			this._loopCount = -1;
			// global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action
			this._startTime = null;
			// scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop
			this.time = 0;
			this.timeScale = 1;
			this._effectiveTimeScale = 1;
			this.weight = 1;
			this._effectiveWeight = 1;
			this.repetitions = Infinity; // no. of repetitions when looping
			this.paused = false; // true -> zero effective time scale
			this.enabled = true; // false -> zero effective weight
			this.clampWhenFinished = false; // keep feeding the last frame?
			this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
			this.zeroSlopeAtEnd = true; // clips for start, loop and end
		}
		// State & Scheduling
		play() {
			this._mixer._activateAction(this);
			return this;
		}
		stop() {
			this._mixer._deactivateAction(this);
			return this.reset();
		}
		reset() {
			this.paused = false;
			this.enabled = true;
			this.time = 0; // restart clip
			this._loopCount = -1; // forget previous loops
			this._startTime = null; // forget scheduling
			return this.stopFading().stopWarping();
		}
		isRunning() {
			return this.enabled && !this.paused && this.timeScale !== 0 &&
				this._startTime === null && this._mixer._isActiveAction(this);
		}
		// return true when play has been called
		isScheduled() {
			return this._mixer._isActiveAction(this);
		}
		startAt(time) {
			this._startTime = time;
			return this;
		}
		setLoop(mode, repetitions) {
			this.loop = mode;
			this.repetitions = repetitions;
			return this;
		}
		// Weight
		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight(weight) {
			this.weight = weight;
			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;
			return this.stopFading();
		}
		// return the weight considering fading and .enabled
		getEffectiveWeight() {
			return this._effectiveWeight;
		}
		fadeIn(duration) {
			return this._scheduleFading(duration, 0, 1);
		}
		fadeOut(duration) {
			return this._scheduleFading(duration, 1, 0);
		}
		crossFadeFrom(fadeOutAction, duration, warp) {
			fadeOutAction.fadeOut(duration);
			this.fadeIn(duration);
			if (warp) {
				const fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,
					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration;
				fadeOutAction.warp(1.0, startEndRatio, duration);
				this.warp(endStartRatio, 1.0, duration);
			}
			return this;
		}
		crossFadeTo(fadeInAction, duration, warp) {
			return fadeInAction.crossFadeFrom(this, duration, warp);
		}
		stopFading() {
			const weightInterpolant = this._weightInterpolant;
			if (weightInterpolant !== null) {
				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant(weightInterpolant);
			}
			return this;
		}
		// Time Scale Control
		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale(timeScale) {
			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;
			return this.stopWarping();
		}
		// return the time scale considering warping and .paused
		getEffectiveTimeScale() {
			return this._effectiveTimeScale;
		}
		setDuration(duration) {
			this.timeScale = this._clip.duration / duration;
			return this.stopWarping();
		}
		syncWith(action) {
			this.time = action.time;
			this.timeScale = action.timeScale;
			return this.stopWarping();
		}
		halt(duration) {
			return this.warp(this._effectiveTimeScale, 0, duration);
		}
		warp(startTimeScale, endTimeScale, duration) {
			const mixer = this._mixer,
				now = mixer.time,
				timeScale = this.timeScale;
			let interpolant = this._timeScaleInterpolant;
			if (interpolant === null) {
				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;
			}
			const times = interpolant.parameterPositions,
				values = interpolant.sampleValues;
			times[0] = now;
			times[1] = now + duration;
			values[0] = startTimeScale / timeScale;
			values[1] = endTimeScale / timeScale;
			return this;
		}
		stopWarping() {
			const timeScaleInterpolant = this._timeScaleInterpolant;
			if (timeScaleInterpolant !== null) {
				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
			}
			return this;
		}
		// Object Accessors
		getMixer() {
			return this._mixer;
		}
		getClip() {
			return this._clip;
		}
		getRoot() {
			return this._localRoot || this._mixer._root;
		}
		// Interna
		_update(time, deltaTime, timeDirection, accuIndex) {
			// called by the mixer
			if (!this.enabled) {
				// call ._updateWeight() to update ._effectiveWeight
				this._updateWeight(time);
				return;
			}
			const startTime = this._startTime;
			if (startTime !== null) {
				// check for scheduled start of action
				const timeRunning = (time - startTime) * timeDirection;
				if (timeRunning < 0 || timeDirection === 0) {
					deltaTime = 0;
				} else {
					this._startTime = null; // unschedule
					deltaTime = timeDirection * timeRunning;
				}
			}
			// apply time scale and advance time
			deltaTime *= this._updateTimeScale(time);
			const clipTime = this._updateTime(deltaTime);
			// note: _updateTime may disable the action resulting in
			// an effective weight of 0
			const weight = this._updateWeight(time);
			if (weight > 0) {
				const interpolants = this._interpolants;
				const propertyMixers = this._propertyBindings;
				switch (this.blendMode) {
					case AdditiveAnimationBlendMode:
						for (let j = 0, m = interpolants.length; j !== m; ++j) {
							interpolants[j].evaluate(clipTime);
							propertyMixers[j].accumulateAdditive(weight);
						}
						break;
					case NormalAnimationBlendMode:
					default:
						for (let j = 0, m = interpolants.length; j !== m; ++j) {
							interpolants[j].evaluate(clipTime);
							propertyMixers[j].accumulate(accuIndex, weight);
						}
				}
			}
		}
		_updateWeight(time) {
			let weight = 0;
			if (this.enabled) {
				weight = this.weight;
				const interpolant = this._weightInterpolant;
				if (interpolant !== null) {
					const interpolantValue = interpolant.evaluate(time)[0];
					weight *= interpolantValue;
					if (time > interpolant.parameterPositions[1]) {
						this.stopFading();
						if (interpolantValue === 0) {
							// faded out, disable
							this.enabled = false;
						}
					}
				}
			}
			this._effectiveWeight = weight;
			return weight;
		}
		_updateTimeScale(time) {
			let timeScale = 0;
			if (!this.paused) {
				timeScale = this.timeScale;
				const interpolant = this._timeScaleInterpolant;
				if (interpolant !== null) {
					const interpolantValue = interpolant.evaluate(time)[0];
					timeScale *= interpolantValue;
					if (time > interpolant.parameterPositions[1]) {
						this.stopWarping();
						if (timeScale === 0) {
							// motion has halted, pause
							this.paused = true;
						} else {
							// warp done - apply final time scale
							this.timeScale = timeScale;
						}
					}
				}
			}
			this._effectiveTimeScale = timeScale;
			return timeScale;
		}
		_updateTime(deltaTime) {
			const duration = this._clip.duration;
			const loop = this.loop;
			let time = this.time + deltaTime;
			let loopCount = this._loopCount;
			const pingPong = (loop === LoopPingPong);
			if (deltaTime === 0) {
				if (loopCount === -1) return time;
				return (pingPong && (loopCount & 1) === 1) ? duration - time : time;
			}
			if (loop === LoopOnce) {
				if (loopCount === -1) {
					// just started
					this._loopCount = 0;
					this._setEndings(true, true, false);
				}
				handle_stop: {
					if (time >= duration) {
						time = duration;
					} else if (time < 0) {
						time = 0;
					} else {
						this.time = time;
						break handle_stop;
					}
					if (this.clampWhenFinished) this.paused = true;
					else this.enabled = false;
					this.time = time;
					this._mixer.dispatchEvent({
						type: 'finished',
						action: this,
						direction: deltaTime < 0 ? -1 : 1
					});
				}
			} else { // repetitive Repeat or PingPong
				if (loopCount === -1) {
					// just started
					if (deltaTime >= 0) {
						loopCount = 0;
						this._setEndings(true, this.repetitions === 0, pingPong);
					} else {
						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1
						this._setEndings(this.repetitions === 0, true, pingPong);
					}
				}
				if (time >= duration || time < 0) {
					// wrap around
					const loopDelta = Math.floor(time / duration); // signed
					time -= duration * loopDelta;
					loopCount += Math.abs(loopDelta);
					const pending = this.repetitions - loopCount;
					if (pending <= 0) {
						// have to stop (switch state, clamp time, fire event)
						if (this.clampWhenFinished) this.paused = true;
						else this.enabled = false;
						time = deltaTime > 0 ? duration : 0;
						this.time = time;
						this._mixer.dispatchEvent({
							type: 'finished',
							action: this,
							direction: deltaTime > 0 ? 1 : -1
						});
					} else {
						// keep running
						if (pending === 1) {
							// entering the last round
							const atStart = deltaTime < 0;
							this._setEndings(atStart, !atStart, pingPong);
						} else {
							this._setEndings(false, false, pingPong);
						}
						this._loopCount = loopCount;
						this.time = time;
						this._mixer.dispatchEvent({
							type: 'loop',
							action: this,
							loopDelta: loopDelta
						});
					}
				} else {
					this.time = time;
				}
				if (pingPong && (loopCount & 1) === 1) {
					// invert time for the "pong round"
					return duration - time;
				}
			}
			return time;
		}
		_setEndings(atStart, atEnd, pingPong) {
			const settings = this._interpolantSettings;
			if (pingPong) {
				settings.endingStart = ZeroSlopeEnding;
				settings.endingEnd = ZeroSlopeEnding;
			} else {
				// assuming for LoopOnce atStart == atEnd == true
				if (atStart) {
					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
				} else {
					settings.endingStart = WrapAroundEnding;
				}
				if (atEnd) {
					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
				} else {
					settings.endingEnd = WrapAroundEnding;
				}
			}
		}
		_scheduleFading(duration, weightNow, weightThen) {
			const mixer = this._mixer,
				now = mixer.time;
			let interpolant = this._weightInterpolant;
			if (interpolant === null) {
				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;
			}
			const times = interpolant.parameterPositions,
				values = interpolant.sampleValues;
			times[0] = now;
			values[0] = weightNow;
			times[1] = now + duration;
			values[1] = weightThen;
			return this;
		}
	}
	const _controlInterpolantsResultBuffer = new Float32Array(1);
	class AnimationMixer extends EventDispatcher {
		constructor(root) {
			super();
			this._root = root;
			this._initMemoryManager();
			this._accuIndex = 0;
			this.time = 0;
			this.timeScale = 1.0;
		}
		_bindAction(action, prototypeAction) {
			const root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName;
			let bindingsByName = bindingsByRoot[rootUuid];
			if (bindingsByName === undefined) {
				bindingsByName = {};
				bindingsByRoot[rootUuid] = bindingsByName;
			}
			for (let i = 0; i !== nTracks; ++i) {
				const track = tracks[i],
					trackName = track.name;
				let binding = bindingsByName[trackName];
				if (binding !== undefined) {
					++binding.referenceCount;
					bindings[i] = binding;
				} else {
					binding = bindings[i];
					if (binding !== undefined) {
						// existing binding, make sure the cache knows
						if (binding._cacheIndex === null) {
							++binding.referenceCount;
							this._addInactiveBinding(binding, rootUuid, trackName);
						}
						continue;
					}
					const path = prototypeAction && prototypeAction.
					_propertyBindings[i].binding.parsedPath;
					binding = new PropertyMixer(
						PropertyBinding.create(root, trackName, path),
						track.ValueTypeName, track.getValueSize());
					++binding.referenceCount;
					this._addInactiveBinding(binding, rootUuid, trackName);
					bindings[i] = binding;
				}
				interpolants[i].resultBuffer = binding.buffer;
			}
		}
		_activateAction(action) {
			if (!this._isActiveAction(action)) {
				if (action._cacheIndex === null) {
					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind
					const rootUuid = (action._localRoot || this._root).uuid,
						clipUuid = action._clip.uuid,
						actionsForClip = this._actionsByClip[clipUuid];
					this._bindAction(action,
						actionsForClip && actionsForClip.knownActions[0]);
					this._addInactiveAction(action, clipUuid, rootUuid);
				}
				const bindings = action._propertyBindings;
				// increment reference counts / sort out state
				for (let i = 0, n = bindings.length; i !== n; ++i) {
					const binding = bindings[i];
					if (binding.useCount++ === 0) {
						this._lendBinding(binding);
						binding.saveOriginalState();
					}
				}
				this._lendAction(action);
			}
		}
		_deactivateAction(action) {
			if (this._isActiveAction(action)) {
				const bindings = action._propertyBindings;
				// decrement reference counts / sort out state
				for (let i = 0, n = bindings.length; i !== n; ++i) {
					const binding = bindings[i];
					if (--binding.useCount === 0) {
						binding.restoreOriginalState();
						this._takeBackBinding(binding);
					}
				}
				this._takeBackAction(action);
			}
		}
		// Memory manager
		_initMemoryManager() {
			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;
			this._actionsByClip = {};
			// inside:
			// {
			// 	knownActions: Array< AnimationAction > - used as prototypes
			// 	actionByRoot: AnimationAction - lookup
			// }
			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;
			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;
			const scope = this;
			this.stats = {
				actions: {
					get total() {
						return scope._actions.length;
					},
					get inUse() {
						return scope._nActiveActions;
					}
				},
				bindings: {
					get total() {
						return scope._bindings.length;
					},
					get inUse() {
						return scope._nActiveBindings;
					}
				},
				controlInterpolants: {
					get total() {
						return scope._controlInterpolants.length;
					},
					get inUse() {
						return scope._nActiveControlInterpolants;
					}
				}
			};
		}
		// Memory management for AnimationAction objects
		_isActiveAction(action) {
			const index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;
		}
		_addInactiveAction(action, clipUuid, rootUuid) {
			const actions = this._actions,
				actionsByClip = this._actionsByClip;
			let actionsForClip = actionsByClip[clipUuid];
			if (actionsForClip === undefined) {
				actionsForClip = {
					knownActions: [action],
					actionByRoot: {}
				};
				action._byClipCacheIndex = 0;
				actionsByClip[clipUuid] = actionsForClip;
			} else {
				const knownActions = actionsForClip.knownActions;
				action._byClipCacheIndex = knownActions.length;
				knownActions.push(action);
			}
			action._cacheIndex = actions.length;
			actions.push(action);
			actionsForClip.actionByRoot[rootUuid] = action;
		}
		_removeInactiveAction(action) {
			const actions = this._actions,
				lastInactiveAction = actions[actions.length - 1],
				cacheIndex = action._cacheIndex;
			lastInactiveAction._cacheIndex = cacheIndex;
			actions[cacheIndex] = lastInactiveAction;
			actions.pop();
			action._cacheIndex = null;
			const clipUuid = action._clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[clipUuid],
				knownActionsForClip = actionsForClip.knownActions,
				lastKnownAction =
				knownActionsForClip[knownActionsForClip.length - 1],
				byClipCacheIndex = action._byClipCacheIndex;
			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[byClipCacheIndex] = lastKnownAction;
			knownActionsForClip.pop();
			action._byClipCacheIndex = null;
			const actionByRoot = actionsForClip.actionByRoot,
				rootUuid = (action._localRoot || this._root).uuid;
			delete actionByRoot[rootUuid];
			if (knownActionsForClip.length === 0) {
				delete actionsByClip[clipUuid];
			}
			this._removeInactiveBindingsForAction(action);
		}
		_removeInactiveBindingsForAction(action) {
			const bindings = action._propertyBindings;
			for (let i = 0, n = bindings.length; i !== n; ++i) {
				const binding = bindings[i];
				if (--binding.referenceCount === 0) {
					this._removeInactiveBinding(binding);
				}
			}
		}
		_lendAction(action) {
			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s
			const actions = this._actions,
				prevIndex = action._cacheIndex,
				lastActiveIndex = this._nActiveActions++,
				firstInactiveAction = actions[lastActiveIndex];
			action._cacheIndex = lastActiveIndex;
			actions[lastActiveIndex] = action;
			firstInactiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = firstInactiveAction;
		}
		_takeBackAction(action) {
			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a
			const actions = this._actions,
				prevIndex = action._cacheIndex,
				firstInactiveIndex = --this._nActiveActions,
				lastActiveAction = actions[firstInactiveIndex];
			action._cacheIndex = firstInactiveIndex;
			actions[firstInactiveIndex] = action;
			lastActiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = lastActiveAction;
		}
		// Memory management for PropertyMixer objects
		_addInactiveBinding(binding, rootUuid, trackName) {
			const bindingsByRoot = this._bindingsByRootAndName,
				bindings = this._bindings;
			let bindingByName = bindingsByRoot[rootUuid];
			if (bindingByName === undefined) {
				bindingByName = {};
				bindingsByRoot[rootUuid] = bindingByName;
			}
			bindingByName[trackName] = binding;
			binding._cacheIndex = bindings.length;
			bindings.push(binding);
		}
		_removeInactiveBinding(binding) {
			const bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[rootUuid],
				lastInactiveBinding = bindings[bindings.length - 1],
				cacheIndex = binding._cacheIndex;
			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[cacheIndex] = lastInactiveBinding;
			bindings.pop();
			delete bindingByName[trackName];
			if (Object.keys(bindingByName).length === 0) {
				delete bindingsByRoot[rootUuid];
			}
		}
		_lendBinding(binding) {
			const bindings = this._bindings,
				prevIndex = binding._cacheIndex,
				lastActiveIndex = this._nActiveBindings++,
				firstInactiveBinding = bindings[lastActiveIndex];
			binding._cacheIndex = lastActiveIndex;
			bindings[lastActiveIndex] = binding;
			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = firstInactiveBinding;
		}
		_takeBackBinding(binding) {
			const bindings = this._bindings,
				prevIndex = binding._cacheIndex,
				firstInactiveIndex = --this._nActiveBindings,
				lastActiveBinding = bindings[firstInactiveIndex];
			binding._cacheIndex = firstInactiveIndex;
			bindings[firstInactiveIndex] = binding;
			lastActiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = lastActiveBinding;
		}
		// Memory management of Interpolants for weight and time scale
		_lendControlInterpolant() {
			const interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants++;
			let interpolant = interpolants[lastActiveIndex];
			if (interpolant === undefined) {
				interpolant = new LinearInterpolant(
					new Float32Array(2), new Float32Array(2),
					1, _controlInterpolantsResultBuffer);
				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[lastActiveIndex] = interpolant;
			}
			return interpolant;
		}
		_takeBackControlInterpolant(interpolant) {
			const interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,
				firstInactiveIndex = --this._nActiveControlInterpolants,
				lastActiveInterpolant = interpolants[firstInactiveIndex];
			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[firstInactiveIndex] = interpolant;
			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[prevIndex] = lastActiveInterpolant;
		}
		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction(clip, optionalRoot, blendMode) {
			const root = optionalRoot || this._root,
				rootUuid = root.uuid;
			let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
			const clipUuid = clipObject !== null ? clipObject.uuid : clip;
			const actionsForClip = this._actionsByClip[clipUuid];
			let prototypeAction = null;
			if (blendMode === undefined) {
				if (clipObject !== null) {
					blendMode = clipObject.blendMode;
				} else {
					blendMode = NormalAnimationBlendMode;
				}
			}
			if (actionsForClip !== undefined) {
				const existingAction = actionsForClip.actionByRoot[rootUuid];
				if (existingAction !== undefined && existingAction.blendMode === blendMode) {
					return existingAction;
				}
				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[0];
				// also, take the clip from the prototype action
				if (clipObject === null)
					clipObject = prototypeAction._clip;
			}
			// clip must be known when specified via string
			if (clipObject === null) return null;
			// allocate all resources required to run it
			const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
			this._bindAction(newAction, prototypeAction);
			// and make the action known to the memory manager
			this._addInactiveAction(newAction, clipUuid, rootUuid);
			return newAction;
		}
		// get an existing action
		existingAction(clip, optionalRoot) {
			const root = optionalRoot || this._root,
				rootUuid = root.uuid,
				clipObject = typeof clip === 'string' ?
				AnimationClip.findByName(root, clip) : clip,
				clipUuid = clipObject ? clipObject.uuid : clip,
				actionsForClip = this._actionsByClip[clipUuid];
			if (actionsForClip !== undefined) {
				return actionsForClip.actionByRoot[rootUuid] || null;
			}
			return null;
		}
		// deactivates all previously scheduled actions
		stopAllAction() {
			const actions = this._actions,
				nActions = this._nActiveActions;
			for (let i = nActions - 1; i >= 0; --i) {
				actions[i].stop();
			}
			return this;
		}
		// advance the time and update apply the animation
		update(deltaTime) {
			deltaTime *= this.timeScale;
			const actions = this._actions,
				nActions = this._nActiveActions,
				time = this.time += deltaTime,
				timeDirection = Math.sign(deltaTime),
				accuIndex = this._accuIndex ^= 1;
			// run active actions
			for (let i = 0; i !== nActions; ++i) {
				const action = actions[i];
				action._update(time, deltaTime, timeDirection, accuIndex);
			}
			// update scene graph
			const bindings = this._bindings,
				nBindings = this._nActiveBindings;
			for (let i = 0; i !== nBindings; ++i) {
				bindings[i].apply(accuIndex);
			}
			return this;
		}
		// Allows you to seek to a specific time in an animation.
		setTime(timeInSeconds) {
			this.time = 0; // Zero out time attribute for AnimationMixer object;
			for (let i = 0; i < this._actions.length; i++) {
				this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
			}
			return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
		}
		// return this mixer's root target object
		getRoot() {
			return this._root;
		}
		// free all resources specific to a particular clip
		uncacheClip(clip) {
			const actions = this._actions,
				clipUuid = clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[clipUuid];
			if (actionsForClip !== undefined) {
				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away
				const actionsToRemove = actionsForClip.knownActions;
				for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
					const action = actionsToRemove[i];
					this._deactivateAction(action);
					const cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[actions.length - 1];
					action._cacheIndex = null;
					action._byClipCacheIndex = null;
					lastInactiveAction._cacheIndex = cacheIndex;
					actions[cacheIndex] = lastInactiveAction;
					actions.pop();
					this._removeInactiveBindingsForAction(action);
				}
				delete actionsByClip[clipUuid];
			}
		}
		// free all resources specific to a particular root target object
		uncacheRoot(root) {
			const rootUuid = root.uuid,
				actionsByClip = this._actionsByClip;
			for (const clipUuid in actionsByClip) {
				const actionByRoot = actionsByClip[clipUuid].actionByRoot,
					action = actionByRoot[rootUuid];
				if (action !== undefined) {
					this._deactivateAction(action);
					this._removeInactiveAction(action);
				}
			}
			const bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[rootUuid];
			if (bindingByName !== undefined) {
				for (const trackName in bindingByName) {
					const binding = bindingByName[trackName];
					binding.restoreOriginalState();
					this._removeInactiveBinding(binding);
				}
			}
		}
		// remove a targeted clip from the cache
		uncacheAction(clip, optionalRoot) {
			const action = this.existingAction(clip, optionalRoot);
			if (action !== null) {
				this._deactivateAction(action);
				this._removeInactiveAction(action);
			}
		}
	}
	class Uniform {
		constructor(value) {
			this.value = value;
		}
		clone() {
			return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
		}
	}
	let id = 0;
	class UniformsGroup extends EventDispatcher {
		constructor() {
			super();
			this.isUniformsGroup = true;
			Object.defineProperty(this, 'id', {
				value: id++
			});
			this.name = '';
			this.usage = StaticDrawUsage;
			this.uniforms = [];
		}
		add(uniform) {
			this.uniforms.push(uniform);
			return this;
		}
		remove(uniform) {
			const index = this.uniforms.indexOf(uniform);
			if (index !== -1) this.uniforms.splice(index, 1);
			return this;
		}
		setName(name) {
			this.name = name;
			return this;
		}
		setUsage(value) {
			this.usage = value;
			return this;
		}
		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
			return this;
		}
		copy(source) {
			this.name = source.name;
			this.usage = source.usage;
			const uniformsSource = source.uniforms;
			this.uniforms.length = 0;
			for (let i = 0, l = uniformsSource.length; i < l; i++) {
				this.uniforms.push(uniformsSource[i].clone());
			}
			return this;
		}
		clone() {
			return new this.constructor().copy(this);
		}
	}
	class InstancedInterleavedBuffer extends InterleavedBuffer {
		constructor(array, stride, meshPerAttribute = 1) {
			super(array, stride);
			this.isInstancedInterleavedBuffer = true;
			this.meshPerAttribute = meshPerAttribute;
		}
		copy(source) {
			super.copy(source);
			this.meshPerAttribute = source.meshPerAttribute;
			return this;
		}
		clone(data) {
			const ib = super.clone(data);
			ib.meshPerAttribute = this.meshPerAttribute;
			return ib;
		}
		toJSON(data) {
			const json = super.toJSON(data);
			json.isInstancedInterleavedBuffer = true;
			json.meshPerAttribute = this.meshPerAttribute;
			return json;
		}
	}
	class GLBufferAttribute {
		constructor(buffer, type, itemSize, elementSize, count) {
			this.isGLBufferAttribute = true;
			this.name = '';
			this.buffer = buffer;
			this.type = type;
			this.itemSize = itemSize;
			this.elementSize = elementSize;
			this.count = count;
			this.version = 0;
		}
		set needsUpdate(value) {
			if (value === true) this.version++;
		}
		setBuffer(buffer) {
			this.buffer = buffer;
			return this;
		}
		setType(type, elementSize) {
			this.type = type;
			this.elementSize = elementSize;
			return this;
		}
		setItemSize(itemSize) {
			this.itemSize = itemSize;
			return this;
		}
		setCount(count) {
			this.count = count;
			return this;
		}
	}
	class Raycaster {
		constructor(origin, direction, near = 0, far = Infinity) {
			this.ray = new Ray(origin, direction);
			// direction is assumed to be normalized (for accurate distance calculations)
			this.near = near;
			this.far = far;
			this.camera = null;
			this.layers = new Layers();
			this.params = {
				Mesh: {},
				Line: {
					threshold: 1
				},
				LOD: {},
				Points: {
					threshold: 1
				},
				Sprite: {}
			};
		}
		set(origin, direction) {
			// direction is assumed to be normalized (for accurate distance calculations)
			this.ray.set(origin, direction);
		}
		setFromCamera(coords, camera) {
			if (camera.isPerspectiveCamera) {
				this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
				this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
				this.camera = camera;
			} else if (camera.isOrthographicCamera) {
				this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
				this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
				this.camera = camera;
			} else {
				console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
			}
		}
		intersectObject(object, recursive = true, intersects = []) {
			intersectObject(object, this, intersects, recursive);
			intersects.sort(ascSort);
			return intersects;
		}
		intersectObjects(objects, recursive = true, intersects = []) {
			for (let i = 0, l = objects.length; i < l; i++) {
				intersectObject(objects[i], this, intersects, recursive);
			}
			intersects.sort(ascSort);
			return intersects;
		}
	}

	function ascSort(a, b) {
		return a.distance - b.distance;
	}

	function intersectObject(object, raycaster, intersects, recursive) {
		if (object.layers.test(raycaster.layers)) {
			object.raycast(raycaster, intersects);
		}
		if (recursive === true) {
			const children = object.children;
			for (let i = 0, l = children.length; i < l; i++) {
				intersectObject(children[i], raycaster, intersects, true);
			}
		}
	}
	/**
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axis.
	 */
	class Spherical {
		constructor(radius = 1, phi = 0, theta = 0) {
			this.radius = radius;
			this.phi = phi; // polar angle
			this.theta = theta; // azimuthal angle
			return this;
		}
		set(radius, phi, theta) {
			this.radius = radius;
			this.phi = phi;
			this.theta = theta;
			return this;
		}
		copy(other) {
			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;
			return this;
		}
		// restrict phi to be between EPS and PI-EPS
		makeSafe() {
			const EPS = 0.000001;
			this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
			return this;
		}
		setFromVector3(v) {
			return this.setFromCartesianCoords(v.x, v.y, v.z);
		}
		setFromCartesianCoords(x, y, z) {
			this.radius = Math.sqrt(x * x + y * y + z * z);
			if (this.radius === 0) {
				this.theta = 0;
				this.phi = 0;
			} else {
				this.theta = Math.atan2(x, z);
				this.phi = Math.acos(clamp(y / this.radius, -1, 1));
			}
			return this;
		}
		clone() {
			return new this.constructor().copy(this);
		}
	}
	/**
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 */
	class Cylindrical {
		constructor(radius = 1, theta = 0, y = 0) {
			this.radius = radius; // distance from the origin to a point in the x-z plane
			this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
			this.y = y; // height above the x-z plane
			return this;
		}
		set(radius, theta, y) {
			this.radius = radius;
			this.theta = theta;
			this.y = y;
			return this;
		}
		copy(other) {
			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;
			return this;
		}
		setFromVector3(v) {
			return this.setFromCartesianCoords(v.x, v.y, v.z);
		}
		setFromCartesianCoords(x, y, z) {
			this.radius = Math.sqrt(x * x + z * z);
			this.theta = Math.atan2(x, z);
			this.y = y;
			return this;
		}
		clone() {
			return new this.constructor().copy(this);
		}
	}
	const _vector$4 = /*@__PURE__*/ new Vector2();
	class Box2 {
		constructor(min = new Vector2(+Infinity, +Infinity), max = new Vector2(-Infinity, -Infinity)) {
			this.isBox2 = true;
			this.min = min;
			this.max = max;
		}
		set(min, max) {
			this.min.copy(min);
			this.max.copy(max);
			return this;
		}
		setFromPoints(points) {
			this.makeEmpty();
			for (let i = 0, il = points.length; i < il; i++) {
				this.expandByPoint(points[i]);
			}
			return this;
		}
		setFromCenterAndSize(center, size) {
			const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
			this.min.copy(center).sub(halfSize);
			this.max.copy(center).add(halfSize);
			return this;
		}
		clone() {
			return new this.constructor().copy(this);
		}
		copy(box) {
			this.min.copy(box.min);
			this.max.copy(box.max);
			return this;
		}
		makeEmpty() {
			this.min.x = this.min.y = +Infinity;
			this.max.x = this.max.y = -Infinity;
			return this;
		}
		isEmpty() {
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
			return (this.max.x < this.min.x) || (this.max.y < this.min.y);
		}
		getCenter(target) {
			return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		}
		getSize(target) {
			return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
		}
		expandByPoint(point) {
			this.min.min(point);
			this.max.max(point);
			return this;
		}
		expandByVector(vector) {
			this.min.sub(vector);
			this.max.add(vector);
			return this;
		}
		expandByScalar(scalar) {
			this.min.addScalar(-scalar);
			this.max.addScalar(scalar);
			return this;
		}
		containsPoint(point) {
			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ? false : true;
		}
		containsBox(box) {
			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y;
		}
		getParameter(point, target) {
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
			return target.set(
				(point.x - this.min.x) / (this.max.x - this.min.x),
				(point.y - this.min.y) / (this.max.y - this.min.y)
			);
		}
		intersectsBox(box) {
			// using 4 splitting planes to rule out intersections
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
		}
		clampPoint(point, target) {
			return target.copy(point).clamp(this.min, this.max);
		}
		distanceToPoint(point) {
			return this.clampPoint(point, _vector$4).distanceTo(point);
		}
		intersect(box) {
			this.min.max(box.min);
			this.max.min(box.max);
			if (this.isEmpty()) this.makeEmpty();
			return this;
		}
		union(box) {
			this.min.min(box.min);
			this.max.max(box.max);
			return this;
		}
		translate(offset) {
			this.min.add(offset);
			this.max.add(offset);
			return this;
		}
		equals(box) {
			return box.min.equals(this.min) && box.max.equals(this.max);
		}
	}
	const _startP = /*@__PURE__*/ new Vector3();
	const _startEnd = /*@__PURE__*/ new Vector3();
	class Line3 {
		constructor(start = new Vector3(), end = new Vector3()) {
			this.start = start;
			this.end = end;
		}
		set(start, end) {
			this.start.copy(start);
			this.end.copy(end);
			return this;
		}
		copy(line) {
			this.start.copy(line.start);
			this.end.copy(line.end);
			return this;
		}
		getCenter(target) {
			return target.addVectors(this.start, this.end).multiplyScalar(0.5);
		}
		delta(target) {
			return target.subVectors(this.end, this.start);
		}
		distanceSq() {
			return this.start.distanceToSquared(this.end);
		}
		distance() {
			return this.start.distanceTo(this.end);
		}
		at(t, target) {
			return this.delta(target).multiplyScalar(t).add(this.start);
		}
		closestPointToPointParameter(point, clampToLine) {
			_startP.subVectors(point, this.start);
			_startEnd.subVectors(this.end, this.start);
			const startEnd2 = _startEnd.dot(_startEnd);
			const startEnd_startP = _startEnd.dot(_startP);
			let t = startEnd_startP / startEnd2;
			if (clampToLine) {
				t = clamp(t, 0, 1);
			}
			return t;
		}
		closestPointToPoint(point, clampToLine, target) {
			const t = this.closestPointToPointParameter(point, clampToLine);
			return this.delta(target).multiplyScalar(t).add(this.start);
		}
		applyMatrix4(matrix) {
			this.start.applyMatrix4(matrix);
			this.end.applyMatrix4(matrix);
			return this;
		}
		equals(line) {
			return line.start.equals(this.start) && line.end.equals(this.end);
		}
		clone() {
			return new this.constructor().copy(this);
		}
	}
	const _vector$3 = /*@__PURE__*/ new Vector3();
	class SpotLightHelper extends Object3D {
		constructor(light, color) {
			super();
			this.light = light;
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.color = color;
			this.type = 'SpotLightHelper';
			const geometry = new BufferGeometry();
			const positions = [
				0, 0, 0, 0, 0, 1,
				0, 0, 0, 1, 0, 1,
				0, 0, 0, -1, 0, 1,
				0, 0, 0, 0, 1, 1,
				0, 0, 0, 0, -1, 1
			];
			for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
				const p1 = (i / l) * Math.PI * 2;
				const p2 = (j / l) * Math.PI * 2;
				positions.push(
					Math.cos(p1), Math.sin(p1), 1,
					Math.cos(p2), Math.sin(p2), 1
				);
			}
			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			const material = new LineBasicMaterial({
				fog: false,
				toneMapped: false
			});
			this.cone = new LineSegments(geometry, material);
			this.add(this.cone);
			this.update();
		}
		dispose() {
			this.cone.geometry.dispose();
			this.cone.material.dispose();
		}
		update() {
			this.light.updateWorldMatrix(true, false);
			this.light.target.updateWorldMatrix(true, false);
			const coneLength = this.light.distance ? this.light.distance : 1000;
			const coneWidth = coneLength * Math.tan(this.light.angle);
			this.cone.scale.set(coneWidth, coneWidth, coneLength);
			_vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
			this.cone.lookAt(_vector$3);
			if (this.color !== undefined) {
				this.cone.material.color.set(this.color);
			} else {
				this.cone.material.color.copy(this.light.color);
			}
		}
	}
	const _vector$2 = /*@__PURE__*/ new Vector3();
	const _boneMatrix = /*@__PURE__*/ new Matrix4();
	const _matrixWorldInv = /*@__PURE__*/ new Matrix4();
	class SkeletonHelper extends LineSegments {
		constructor(object) {
			const bones = getBoneList(object);
			const geometry = new BufferGeometry();
			const vertices = [];
			const colors = [];
			const color1 = new Color(0, 0, 1);
			const color2 = new Color(0, 1, 0);
			for (let i = 0; i < bones.length; i++) {
				const bone = bones[i];
				if (bone.parent && bone.parent.isBone) {
					vertices.push(0, 0, 0);
					vertices.push(0, 0, 0);
					colors.push(color1.r, color1.g, color1.b);
					colors.push(color2.r, color2.g, color2.b);
				}
			}
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				depthTest: false,
				depthWrite: false,
				toneMapped: false,
				transparent: true
			});
			super(geometry, material);
			this.isSkeletonHelper = true;
			this.type = 'SkeletonHelper';
			this.root = object;
			this.bones = bones;
			this.matrix = object.matrixWorld;
			this.matrixAutoUpdate = false;
		}
		updateMatrixWorld(force) {
			const bones = this.bones;
			const geometry = this.geometry;
			const position = geometry.getAttribute('position');
			_matrixWorldInv.copy(this.root.matrixWorld).invert();
			for (let i = 0, j = 0; i < bones.length; i++) {
				const bone = bones[i];
				if (bone.parent && bone.parent.isBone) {
					_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
					_vector$2.setFromMatrixPosition(_boneMatrix);
					position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
					_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
					_vector$2.setFromMatrixPosition(_boneMatrix);
					position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
					j += 2;
				}
			}
			geometry.getAttribute('position').needsUpdate = true;
			super.updateMatrixWorld(force);
		}
		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}
	}

	function getBoneList(object) {
		const boneList = [];
		if (object.isBone === true) {
			boneList.push(object);
		}
		for (let i = 0; i < object.children.length; i++) {
			boneList.push.apply(boneList, getBoneList(object.children[i]));
		}
		return boneList;
	}
	class PointLightHelper extends Mesh {
		constructor(light, sphereSize, color) {
			const geometry = new SphereGeometry(sphereSize, 4, 2);
			const material = new MeshBasicMaterial({
				wireframe: true,
				fog: false,
				toneMapped: false
			});
			super(geometry, material);
			this.light = light;
			this.color = color;
			this.type = 'PointLightHelper';
			this.matrix = this.light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.update();
			/*
		// TODO: delete this comment?
		const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		const d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/
		}
		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}
		update() {
			this.light.updateWorldMatrix(true, false);
			if (this.color !== undefined) {
				this.material.color.set(this.color);
			} else {
				this.material.color.copy(this.light.color);
			}
			/*
			const d = this.light.distance;

			if ( d === 0.0 ) {

				this.lightDistance.visible = false;

			} else {

				this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );

			}
			*/
		}
	}
	const _vector$1 = /*@__PURE__*/ new Vector3();
	const _color1 = /*@__PURE__*/ new Color();
	const _color2 = /*@__PURE__*/ new Color();
	class HemisphereLightHelper extends Object3D {
		constructor(light, size, color) {
			super();
			this.light = light;
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.color = color;
			this.type = 'HemisphereLightHelper';
			const geometry = new OctahedronGeometry(size);
			geometry.rotateY(Math.PI * 0.5);
			this.material = new MeshBasicMaterial({
				wireframe: true,
				fog: false,
				toneMapped: false
			});
			if (this.color === undefined) this.material.vertexColors = true;
			const position = geometry.getAttribute('position');
			const colors = new Float32Array(position.count * 3);
			geometry.setAttribute('color', new BufferAttribute(colors, 3));
			this.add(new Mesh(geometry, this.material));
			this.update();
		}
		dispose() {
			this.children[0].geometry.dispose();
			this.children[0].material.dispose();
		}
		update() {
			const mesh = this.children[0];
			if (this.color !== undefined) {
				this.material.color.set(this.color);
			} else {
				const colors = mesh.geometry.getAttribute('color');
				_color1.copy(this.light.color);
				_color2.copy(this.light.groundColor);
				for (let i = 0, l = colors.count; i < l; i++) {
					const color = (i < (l / 2)) ? _color1 : _color2;
					colors.setXYZ(i, color.r, color.g, color.b);
				}
				colors.needsUpdate = true;
			}
			this.light.updateWorldMatrix(true, false);
			mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
		}
	}
	class GridHelper extends LineSegments {
		constructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {
			color1 = new Color(color1);
			color2 = new Color(color2);
			const center = divisions / 2;
			const step = size / divisions;
			const halfSize = size / 2;
			const vertices = [],
				colors = [];
			for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
				vertices.push(-halfSize, 0, k, halfSize, 0, k);
				vertices.push(k, 0, -halfSize, k, 0, halfSize);
				const color = i === center ? color1 : color2;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
			}
			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			super(geometry, material);
			this.type = 'GridHelper';
		}
		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}
	}
	class PolarGridHelper extends LineSegments {
		constructor(radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888) {
			color1 = new Color(color1);
			color2 = new Color(color2);
			const vertices = [];
			const colors = [];
			// create the sectors
			if (sectors > 1) {
				for (let i = 0; i < sectors; i++) {
					const v = (i / sectors) * (Math.PI * 2);
					const x = Math.sin(v) * radius;
					const z = Math.cos(v) * radius;
					vertices.push(0, 0, 0);
					vertices.push(x, 0, z);
					const color = (i & 1) ? color1 : color2;
					colors.push(color.r, color.g, color.b);
					colors.push(color.r, color.g, color.b);
				}
			}
			// create the rings
			for (let i = 0; i < rings; i++) {
				const color = (i & 1) ? color1 : color2;
				const r = radius - (radius / rings * i);
				for (let j = 0; j < divisions; j++) {
					// first vertex
					let v = (j / divisions) * (Math.PI * 2);
					let x = Math.sin(v) * r;
					let z = Math.cos(v) * r;
					vertices.push(x, 0, z);
					colors.push(color.r, color.g, color.b);
					// second vertex
					v = ((j + 1) / divisions) * (Math.PI * 2);
					x = Math.sin(v) * r;
					z = Math.cos(v) * r;
					vertices.push(x, 0, z);
					colors.push(color.r, color.g, color.b);
				}
			}
			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			super(geometry, material);
			this.type = 'PolarGridHelper';
		}
		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}
	}
	const _v1 = /*@__PURE__*/ new Vector3();
	const _v2 = /*@__PURE__*/ new Vector3();
	const _v3 = /*@__PURE__*/ new Vector3();
	class DirectionalLightHelper extends Object3D {
		constructor(light, size, color) {
			super();
			this.light = light;
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.color = color;
			this.type = 'DirectionalLightHelper';
			if (size === undefined) size = 1;
			let geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute([
				-size, size, 0,
				size, size, 0,
				size, -size, 0,
				-size, -size, 0,
				-size, size, 0
			], 3));
			const material = new LineBasicMaterial({
				fog: false,
				toneMapped: false
			});
			this.lightPlane = new Line(geometry, material);
			this.add(this.lightPlane);
			geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
			this.targetLine = new Line(geometry, material);
			this.add(this.targetLine);
			this.update();
		}
		dispose() {
			this.lightPlane.geometry.dispose();
			this.lightPlane.material.dispose();
			this.targetLine.geometry.dispose();
			this.targetLine.material.dispose();
		}
		update() {
			this.light.updateWorldMatrix(true, false);
			this.light.target.updateWorldMatrix(true, false);
			_v1.setFromMatrixPosition(this.light.matrixWorld);
			_v2.setFromMatrixPosition(this.light.target.matrixWorld);
			_v3.subVectors(_v2, _v1);
			this.lightPlane.lookAt(_v2);
			if (this.color !== undefined) {
				this.lightPlane.material.color.set(this.color);
				this.targetLine.material.color.set(this.color);
			} else {
				this.lightPlane.material.color.copy(this.light.color);
				this.targetLine.material.color.copy(this.light.color);
			}
			this.targetLine.lookAt(_v2);
			this.targetLine.scale.z = _v3.length();
		}
	}
	const _vector = /*@__PURE__*/ new Vector3();
	const _camera = /*@__PURE__*/ new Camera();
	/**
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html
	 */
	class CameraHelper extends LineSegments {
		constructor(camera) {
			const geometry = new BufferGeometry();
			const material = new LineBasicMaterial({
				color: 0xffffff,
				vertexColors: true,
				toneMapped: false
			});
			const vertices = [];
			const colors = [];
			const pointMap = {};
			// near
			addLine('n1', 'n2');
			addLine('n2', 'n4');
			addLine('n4', 'n3');
			addLine('n3', 'n1');
			// far
			addLine('f1', 'f2');
			addLine('f2', 'f4');
			addLine('f4', 'f3');
			addLine('f3', 'f1');
			// sides
			addLine('n1', 'f1');
			addLine('n2', 'f2');
			addLine('n3', 'f3');
			addLine('n4', 'f4');
			// cone
			addLine('p', 'n1');
			addLine('p', 'n2');
			addLine('p', 'n3');
			addLine('p', 'n4');
			// up
			addLine('u1', 'u2');
			addLine('u2', 'u3');
			addLine('u3', 'u1');
			// target
			addLine('c', 't');
			addLine('p', 'c');
			// cross
			addLine('cn1', 'cn2');
			addLine('cn3', 'cn4');
			addLine('cf1', 'cf2');
			addLine('cf3', 'cf4');

			function addLine(a, b) {
				addPoint(a);
				addPoint(b);
			}

			function addPoint(id) {
				vertices.push(0, 0, 0);
				colors.push(0, 0, 0);
				if (pointMap[id] === undefined) {
					pointMap[id] = [];
				}
				pointMap[id].push((vertices.length / 3) - 1);
			}
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			super(geometry, material);
			this.type = 'CameraHelper';
			this.camera = camera;
			if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
			this.matrix = camera.matrixWorld;
			this.matrixAutoUpdate = false;
			this.pointMap = pointMap;
			this.update();
			// colors
			const colorFrustum = new Color(0xffaa00);
			const colorCone = new Color(0xff0000);
			const colorUp = new Color(0x00aaff);
			const colorTarget = new Color(0xffffff);
			const colorCross = new Color(0x333333);
			this.setColors(colorFrustum, colorCone, colorUp, colorTarget, colorCross);
		}
		setColors(frustum, cone, up, target, cross) {
			const geometry = this.geometry;
			const colorAttribute = geometry.getAttribute('color');
			// near
			colorAttribute.setXYZ(0, frustum.r, frustum.g, frustum.b);
			colorAttribute.setXYZ(1, frustum.r, frustum.g, frustum.b); // n1, n2
			colorAttribute.setXYZ(2, frustum.r, frustum.g, frustum.b);
			colorAttribute.setXYZ(3, frustum.r, frustum.g, frustum.b); // n2, n4
			colorAttribute.setXYZ(4, frustum.r, frustum.g, frustum.b);
			colorAttribute.setXYZ(5, frustum.r, frustum.g, frustum.b); // n4, n3
			colorAttribute.setXYZ(6, frustum.r, frustum.g, frustum.b);
			colorAttribute.setXYZ(7, frustum.r, frustum.g, frustum.b); // n3, n1
			// far
			colorAttribute.setXYZ(8, frustum.r, frustum.g, frustum.b);
			colorAttribute.setXYZ(9, frustum.r, frustum.g, frustum.b); // f1, f2
			colorAttribute.setXYZ(10, frustum.r, frustum.g, frustum.b);
			colorAttribute.setXYZ(11, frustum.r, frustum.g, frustum.b); // f2, f4
			colorAttribute.setXYZ(12, frustum.r, frustum.g, frustum.b);
			colorAttribute.setXYZ(13, frustum.r, frustum.g, frustum.b); // f4, f3
			colorAttribute.setXYZ(14, frustum.r, frustum.g, frustum.b);
			colorAttribute.setXYZ(15, frustum.r, frustum.g, frustum.b); // f3, f1
			// sides
			colorAttribute.setXYZ(16, frustum.r, frustum.g, frustum.b);
			colorAttribute.setXYZ(17, frustum.r, frustum.g, frustum.b); // n1, f1
			colorAttribute.setXYZ(18, frustum.r, frustum.g, frustum.b);
			colorAttribute.setXYZ(19, frustum.r, frustum.g, frustum.b); // n2, f2
			colorAttribute.setXYZ(20, frustum.r, frustum.g, frustum.b);
			colorAttribute.setXYZ(21, frustum.r, frustum.g, frustum.b); // n3, f3
			colorAttribute.setXYZ(22, frustum.r, frustum.g, frustum.b);
			colorAttribute.setXYZ(23, frustum.r, frustum.g, frustum.b); // n4, f4
			// cone
			colorAttribute.setXYZ(24, cone.r, cone.g, cone.b);
			colorAttribute.setXYZ(25, cone.r, cone.g, cone.b); // p, n1
			colorAttribute.setXYZ(26, cone.r, cone.g, cone.b);
			colorAttribute.setXYZ(27, cone.r, cone.g, cone.b); // p, n2
			colorAttribute.setXYZ(28, cone.r, cone.g, cone.b);
			colorAttribute.setXYZ(29, cone.r, cone.g, cone.b); // p, n3
			colorAttribute.setXYZ(30, cone.r, cone.g, cone.b);
			colorAttribute.setXYZ(31, cone.r, cone.g, cone.b); // p, n4
			// up
			colorAttribute.setXYZ(32, up.r, up.g, up.b);
			colorAttribute.setXYZ(33, up.r, up.g, up.b); // u1, u2
			colorAttribute.setXYZ(34, up.r, up.g, up.b);
			colorAttribute.setXYZ(35, up.r, up.g, up.b); // u2, u3
			colorAttribute.setXYZ(36, up.r, up.g, up.b);
			colorAttribute.setXYZ(37, up.r, up.g, up.b); // u3, u1
			// target
			colorAttribute.setXYZ(38, target.r, target.g, target.b);
			colorAttribute.setXYZ(39, target.r, target.g, target.b); // c, t
			colorAttribute.setXYZ(40, cross.r, cross.g, cross.b);
			colorAttribute.setXYZ(41, cross.r, cross.g, cross.b); // p, c
			// cross
			colorAttribute.setXYZ(42, cross.r, cross.g, cross.b);
			colorAttribute.setXYZ(43, cross.r, cross.g, cross.b); // cn1, cn2
			colorAttribute.setXYZ(44, cross.r, cross.g, cross.b);
			colorAttribute.setXYZ(45, cross.r, cross.g, cross.b); // cn3, cn4
			colorAttribute.setXYZ(46, cross.r, cross.g, cross.b);
			colorAttribute.setXYZ(47, cross.r, cross.g, cross.b); // cf1, cf2
			colorAttribute.setXYZ(48, cross.r, cross.g, cross.b);
			colorAttribute.setXYZ(49, cross.r, cross.g, cross.b); // cf3, cf4
			colorAttribute.needsUpdate = true;
		}
		update() {
			const geometry = this.geometry;
			const pointMap = this.pointMap;
			const w = 1,
				h = 1;
			// we need just camera projection matrix inverse
			// world matrix must be identity
			_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
			// center / target
			setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
			setPoint('t', pointMap, geometry, _camera, 0, 0, 1);
			// near
			setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
			setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
			setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
			setPoint('n4', pointMap, geometry, _camera, w, h, -1);
			// far
			setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
			setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
			setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
			setPoint('f4', pointMap, geometry, _camera, w, h, 1);
			// up
			setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
			setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
			setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1);
			// cross
			setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
			setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
			setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
			setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
			setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
			setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
			setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
			setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
			geometry.getAttribute('position').needsUpdate = true;
		}
		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}
	}

	function setPoint(point, pointMap, geometry, camera, x, y, z) {
		_vector.set(x, y, z).unproject(camera);
		const points = pointMap[point];
		if (points !== undefined) {
			const position = geometry.getAttribute('position');
			for (let i = 0, l = points.length; i < l; i++) {
				position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
			}
		}
	}
	const _box = /*@__PURE__*/ new Box3();
	class BoxHelper extends LineSegments {
		constructor(object, color = 0xffff00) {
			const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
			const positions = new Float32Array(8 * 3);
			const geometry = new BufferGeometry();
			geometry.setIndex(new BufferAttribute(indices, 1));
			geometry.setAttribute('position', new BufferAttribute(positions, 3));
			super(geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.object = object;
			this.type = 'BoxHelper';
			this.matrixAutoUpdate = false;
			this.update();
		}
		update(object) {
			if (object !== undefined) {
				console.warn('THREE.BoxHelper: .update() has no longer arguments.');
			}
			if (this.object !== undefined) {
				_box.setFromObject(this.object);
			}
			if (_box.isEmpty()) return;
			const min = _box.min;
			const max = _box.max;
			/*
				5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/
			const position = this.geometry.attributes.position;
			const array = position.array;
			array[0] = max.x;
			array[1] = max.y;
			array[2] = max.z;
			array[3] = min.x;
			array[4] = max.y;
			array[5] = max.z;
			array[6] = min.x;
			array[7] = min.y;
			array[8] = max.z;
			array[9] = max.x;
			array[10] = min.y;
			array[11] = max.z;
			array[12] = max.x;
			array[13] = max.y;
			array[14] = min.z;
			array[15] = min.x;
			array[16] = max.y;
			array[17] = min.z;
			array[18] = min.x;
			array[19] = min.y;
			array[20] = min.z;
			array[21] = max.x;
			array[22] = min.y;
			array[23] = min.z;
			position.needsUpdate = true;
			this.geometry.computeBoundingSphere();
		}
		setFromObject(object) {
			this.object = object;
			this.update();
			return this;
		}
		copy(source, recursive) {
			super.copy(source, recursive);
			this.object = source.object;
			return this;
		}
		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}
	}
	class Box3Helper extends LineSegments {
		constructor(box, color = 0xffff00) {
			const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
			const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
			const geometry = new BufferGeometry();
			geometry.setIndex(new BufferAttribute(indices, 1));
			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			super(geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.box = box;
			this.type = 'Box3Helper';
			this.geometry.computeBoundingSphere();
		}
		updateMatrixWorld(force) {
			const box = this.box;
			if (box.isEmpty()) return;
			box.getCenter(this.position);
			box.getSize(this.scale);
			this.scale.multiplyScalar(0.5);
			super.updateMatrixWorld(force);
		}
		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}
	}
	class PlaneHelper extends Line {
		constructor(plane, size = 1, hex = 0xffff00) {
			const color = hex;
			const positions = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			geometry.computeBoundingSphere();
			super(geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.type = 'PlaneHelper';
			this.plane = plane;
			this.size = size;
			const positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
			const geometry2 = new BufferGeometry();
			geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
			geometry2.computeBoundingSphere();
			this.add(new Mesh(geometry2, new MeshBasicMaterial({
				color: color,
				opacity: 0.2,
				transparent: true,
				depthWrite: false,
				toneMapped: false
			})));
		}
		updateMatrixWorld(force) {
			this.position.set(0, 0, 0);
			this.scale.set(0.5 * this.size, 0.5 * this.size, 1);
			this.lookAt(this.plane.normal);
			this.translateZ(-this.plane.constant);
			super.updateMatrixWorld(force);
		}
		dispose() {
			this.geometry.dispose();
			this.material.dispose();
			this.children[0].geometry.dispose();
			this.children[0].material.dispose();
		}
	}
	const _axis = /*@__PURE__*/ new Vector3();
	let _lineGeometry, _coneGeometry;
	class ArrowHelper extends Object3D {
		// dir is assumed to be normalized
		constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2) {
			super();
			this.type = 'ArrowHelper';
			if (_lineGeometry === undefined) {
				_lineGeometry = new BufferGeometry();
				_lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
				_coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
				_coneGeometry.translate(0, -0.5, 0);
			}
			this.position.copy(origin);
			this.line = new Line(_lineGeometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.line.matrixAutoUpdate = false;
			this.add(this.line);
			this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.cone.matrixAutoUpdate = false;
			this.add(this.cone);
			this.setDirection(dir);
			this.setLength(length, headLength, headWidth);
		}
		setDirection(dir) {
			// dir is assumed to be normalized
			if (dir.y > 0.99999) {
				this.quaternion.set(0, 0, 0, 1);
			} else if (dir.y < -0.99999) {
				this.quaternion.set(1, 0, 0, 0);
			} else {
				_axis.set(dir.z, 0, -dir.x).normalize();
				const radians = Math.acos(dir.y);
				this.quaternion.setFromAxisAngle(_axis, radians);
			}
		}
		setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
			this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
			this.line.updateMatrix();
			this.cone.scale.set(headWidth, headLength, headWidth);
			this.cone.position.y = length;
			this.cone.updateMatrix();
		}
		setColor(color) {
			this.line.material.color.set(color);
			this.cone.material.color.set(color);
		}
		copy(source) {
			super.copy(source, false);
			this.line.copy(source.line);
			this.cone.copy(source.cone);
			return this;
		}
		dispose() {
			this.line.geometry.dispose();
			this.line.material.dispose();
			this.cone.geometry.dispose();
			this.cone.material.dispose();
		}
	}
	class AxesHelper extends LineSegments {
		constructor(size = 1) {
			const vertices = [
				0, 0, 0, size, 0, 0,
				0, 0, 0, 0, size, 0,
				0, 0, 0, 0, 0, size
			];
			const colors = [
				1, 0, 0, 1, 0.6, 0,
				0, 1, 0, 0.6, 1, 0,
				0, 0, 1, 0, 0.6, 1
			];
			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			super(geometry, material);
			this.type = 'AxesHelper';
		}
		setColors(xAxisColor, yAxisColor, zAxisColor) {
			const color = new Color();
			const array = this.geometry.attributes.color.array;
			color.set(xAxisColor);
			color.toArray(array, 0);
			color.toArray(array, 3);
			color.set(yAxisColor);
			color.toArray(array, 6);
			color.toArray(array, 9);
			color.set(zAxisColor);
			color.toArray(array, 12);
			color.toArray(array, 15);
			this.geometry.attributes.color.needsUpdate = true;
			return this;
		}
		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}
	}
	class ShapePath {
		constructor() {
			this.type = 'ShapePath';
			this.color = new Color();
			this.subPaths = [];
			this.currentPath = null;
		}
		moveTo(x, y) {
			this.currentPath = new Path();
			this.subPaths.push(this.currentPath);
			this.currentPath.moveTo(x, y);
			return this;
		}
		lineTo(x, y) {
			this.currentPath.lineTo(x, y);
			return this;
		}
		quadraticCurveTo(aCPx, aCPy, aX, aY) {
			this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
			return this;
		}
		bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
			return this;
		}
		splineThru(pts) {
			this.currentPath.splineThru(pts);
			return this;
		}
		toShapes(isCCW) {
			function toShapesNoHoles(inSubpaths) {
				const shapes = [];
				for (let i = 0, l = inSubpaths.length; i < l; i++) {
					const tmpPath = inSubpaths[i];
					const tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;
					shapes.push(tmpShape);
				}
				return shapes;
			}

			function isPointInsidePolygon(inPt, inPolygon) {
				const polyLen = inPolygon.length;
				// inPt on polygon contour => immediate success    or
				// toggling of inside/outside at every single! intersection point of an edge
				//  with the horizontal line through inPt, left of inPt
				//  not counting lowerY endpoints of edges and whole edges on that line
				let inside = false;
				for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
					let edgeLowPt = inPolygon[p];
					let edgeHighPt = inPolygon[q];
					let edgeDx = edgeHighPt.x - edgeLowPt.x;
					let edgeDy = edgeHighPt.y - edgeLowPt.y;
					if (Math.abs(edgeDy) > Number.EPSILON) {
						// not parallel
						if (edgeDy < 0) {
							edgeLowPt = inPolygon[q];
							edgeDx = -edgeDx;
							edgeHighPt = inPolygon[p];
							edgeDy = -edgeDy;
						}
						if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y)) continue;
						if (inPt.y === edgeLowPt.y) {
							if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!
						} else {
							const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
							if (perpEdge === 0) return true; // inPt is on contour ?
							if (perpEdge < 0) continue;
							inside = !inside; // true intersection left of inPt
						}
					} else {
						// parallel or collinear
						if (inPt.y !== edgeLowPt.y) continue; // parallel
						// edge lies on the same horizontal line as inPt
						if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) ||
							((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x))) return true; // inPt: Point on contour !
						// continue;
					}
				}
				return inside;
			}
			const isClockWise = ShapeUtils.isClockWise;
			const subPaths = this.subPaths;
			if (subPaths.length === 0) return [];
			let solid, tmpPath, tmpShape;
			const shapes = [];
			if (subPaths.length === 1) {
				tmpPath = subPaths[0];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push(tmpShape);
				return shapes;
			}
			let holesFirst = !isClockWise(subPaths[0].getPoints());
			holesFirst = isCCW ? !holesFirst : holesFirst;
			// console.log("Holes first", holesFirst);
			const betterShapeHoles = [];
			const newShapes = [];
			let newShapeHoles = [];
			let mainIdx = 0;
			let tmpPoints;
			newShapes[mainIdx] = undefined;
			newShapeHoles[mainIdx] = [];
			for (let i = 0, l = subPaths.length; i < l; i++) {
				tmpPath = subPaths[i];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise(tmpPoints);
				solid = isCCW ? !solid : solid;
				if (solid) {
					if ((!holesFirst) && (newShapes[mainIdx])) mainIdx++;
					newShapes[mainIdx] = {
						s: new Shape(),
						p: tmpPoints
					};
					newShapes[mainIdx].s.curves = tmpPath.curves;
					if (holesFirst) mainIdx++;
					newShapeHoles[mainIdx] = [];
					//console.log('cw', i);
				} else {
					newShapeHoles[mainIdx].push({
						h: tmpPath,
						p: tmpPoints[0]
					});
					//console.log('ccw', i);
				}
			}
			// only Holes? -> probably all Shapes with wrong orientation
			if (!newShapes[0]) return toShapesNoHoles(subPaths);
			if (newShapes.length > 1) {
				let ambiguous = false;
				let toChange = 0;
				for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
					betterShapeHoles[sIdx] = [];
				}
				for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
					const sho = newShapeHoles[sIdx];
					for (let hIdx = 0; hIdx < sho.length; hIdx++) {
						const ho = sho[hIdx];
						let hole_unassigned = true;
						for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
							if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
								if (sIdx !== s2Idx) toChange++;
								if (hole_unassigned) {
									hole_unassigned = false;
									betterShapeHoles[s2Idx].push(ho);
								} else {
									ambiguous = true;
								}
							}
						}
						if (hole_unassigned) {
							betterShapeHoles[sIdx].push(ho);
						}
					}
				}
				if (toChange > 0 && ambiguous === false) {
					newShapeHoles = betterShapeHoles;
				}
			}
			let tmpHoles;
			for (let i = 0, il = newShapes.length; i < il; i++) {
				tmpShape = newShapes[i].s;
				shapes.push(tmpShape);
				tmpHoles = newShapeHoles[i];
				for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
					tmpShape.holes.push(tmpHoles[j].h);
				}
			}
			//console.log("shape", shapes);
			return shapes;
		}
	}
	// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
	const _tables = /*@__PURE__*/ _generateTables();

	function _generateTables() {
		// float32 to float16 helpers
		const buffer = new ArrayBuffer(4);
		const floatView = new Float32Array(buffer);
		const uint32View = new Uint32Array(buffer);
		const baseTable = new Uint32Array(512);
		const shiftTable = new Uint32Array(512);
		for (let i = 0; i < 256; ++i) {
			const e = i - 127;
			// very small number (0, -0)
			if (e < -27) {
				baseTable[i] = 0x0000;
				baseTable[i | 0x100] = 0x8000;
				shiftTable[i] = 24;
				shiftTable[i | 0x100] = 24;
				// small number (denorm)
			} else if (e < -14) {
				baseTable[i] = 0x0400 >> (-e - 14);
				baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;
				shiftTable[i] = -e - 1;
				shiftTable[i | 0x100] = -e - 1;
				// normal number
			} else if (e <= 15) {
				baseTable[i] = (e + 15) << 10;
				baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;
				shiftTable[i] = 13;
				shiftTable[i | 0x100] = 13;
				// large number (Infinity, -Infinity)
			} else if (e < 128) {
				baseTable[i] = 0x7c00;
				baseTable[i | 0x100] = 0xfc00;
				shiftTable[i] = 24;
				shiftTable[i | 0x100] = 24;
				// stay (NaN, Infinity, -Infinity)
			} else {
				baseTable[i] = 0x7c00;
				baseTable[i | 0x100] = 0xfc00;
				shiftTable[i] = 13;
				shiftTable[i | 0x100] = 13;
			}
		}
		// float16 to float32 helpers
		const mantissaTable = new Uint32Array(2048);
		const exponentTable = new Uint32Array(64);
		const offsetTable = new Uint32Array(64);
		for (let i = 1; i < 1024; ++i) {
			let m = i << 13; // zero pad mantissa bits
			let e = 0; // zero exponent
			// normalized
			while ((m & 0x00800000) === 0) {
				m <<= 1;
				e -= 0x00800000; // decrement exponent
			}
			m &= ~0x00800000; // clear leading 1 bit
			e += 0x38800000; // adjust bias
			mantissaTable[i] = m | e;
		}
		for (let i = 1024; i < 2048; ++i) {
			mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);
		}
		for (let i = 1; i < 31; ++i) {
			exponentTable[i] = i << 23;
		}
		exponentTable[31] = 0x47800000;
		exponentTable[32] = 0x80000000;
		for (let i = 33; i < 63; ++i) {
			exponentTable[i] = 0x80000000 + ((i - 32) << 23);
		}
		exponentTable[63] = 0xc7800000;
		for (let i = 1; i < 64; ++i) {
			if (i !== 32) {
				offsetTable[i] = 1024;
			}
		}
		return {
			floatView: floatView,
			uint32View: uint32View,
			baseTable: baseTable,
			shiftTable: shiftTable,
			mantissaTable: mantissaTable,
			exponentTable: exponentTable,
			offsetTable: offsetTable
		};
	}
	// float32 to float16
	function toHalfFloat(val) {
		if (Math.abs(val) > 65504) console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.');
		val = clamp(val, -65504, 65504);
		_tables.floatView[0] = val;
		const f = _tables.uint32View[0];
		const e = (f >> 23) & 0x1ff;
		return _tables.baseTable[e] + ((f & 0x007fffff) >> _tables.shiftTable[e]);
	}
	// float16 to float32
	function fromHalfFloat(val) {
		const m = val >> 10;
		_tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 0x3ff)] + _tables.exponentTable[m];
		return _tables.floatView[0];
	}
	const DataUtils = {
		toHalfFloat: toHalfFloat,
		fromHalfFloat: fromHalfFloat,
	};
	// r144
	class BoxBufferGeometry extends BoxGeometry {
		constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
			console.warn('THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry.');
			super(width, height, depth, widthSegments, heightSegments, depthSegments);
		}
	}
	// r144
	class CapsuleBufferGeometry extends CapsuleGeometry {
		constructor(radius, length, capSegments, radialSegments) {
			console.warn('THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry.');
			super(radius, length, capSegments, radialSegments);
		}
	}
	// r144
	class CircleBufferGeometry extends CircleGeometry {
		constructor(radius, segments, thetaStart, thetaLength) {
			console.warn('THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry.');
			super(radius, segments, thetaStart, thetaLength);
		}
	}
	// r144
	class ConeBufferGeometry extends ConeGeometry {
		constructor(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
			console.warn('THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry.');
			super(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
		}
	}
	// r144
	class CylinderBufferGeometry extends CylinderGeometry {
		constructor(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
			console.warn('THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry.');
			super(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
		}
	}
	// r144
	class DodecahedronBufferGeometry extends DodecahedronGeometry {
		constructor(radius, detail) {
			console.warn('THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry.');
			super(radius, detail);
		}
	}
	// r144
	class ExtrudeBufferGeometry extends ExtrudeGeometry {
		constructor(shapes, options) {
			console.warn('THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry.');
			super(shapes, options);
		}
	}
	// r144
	class IcosahedronBufferGeometry extends IcosahedronGeometry {
		constructor(radius, detail) {
			console.warn('THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry.');
			super(radius, detail);
		}
	}
	// r144
	class LatheBufferGeometry extends LatheGeometry {
		constructor(points, segments, phiStart, phiLength) {
			console.warn('THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry.');
			super(points, segments, phiStart, phiLength);
		}
	}
	// r144
	class OctahedronBufferGeometry extends OctahedronGeometry {
		constructor(radius, detail) {
			console.warn('THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry.');
			super(radius, detail);
		}
	}
	// r144
	class PlaneBufferGeometry extends PlaneGeometry {
		constructor(width, height, widthSegments, heightSegments) {
			console.warn('THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry.');
			super(width, height, widthSegments, heightSegments);
		}
	}
	// r144
	class PolyhedronBufferGeometry extends PolyhedronGeometry {
		constructor(vertices, indices, radius, detail) {
			console.warn('THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry.');
			super(vertices, indices, radius, detail);
		}
	}
	// r144
	class RingBufferGeometry extends RingGeometry {
		constructor(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
			console.warn('THREE.RingBufferGeometry has been renamed to THREE.RingGeometry.');
			super(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength);
		}
	}
	// r144
	class ShapeBufferGeometry extends ShapeGeometry {
		constructor(shapes, curveSegments) {
			console.warn('THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry.');
			super(shapes, curveSegments);
		}
	}
	// r144
	class SphereBufferGeometry extends SphereGeometry {
		constructor(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
			console.warn('THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry.');
			super(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);
		}
	}
	// r144
	class TetrahedronBufferGeometry extends TetrahedronGeometry {
		constructor(radius, detail) {
			console.warn('THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry.');
			super(radius, detail);
		}
	}
	// r144
	class TorusBufferGeometry extends TorusGeometry {
		constructor(radius, tube, radialSegments, tubularSegments, arc) {
			console.warn('THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry.');
			super(radius, tube, radialSegments, tubularSegments, arc);
		}
	}
	// r144
	class TorusKnotBufferGeometry extends TorusKnotGeometry {
		constructor(radius, tube, tubularSegments, radialSegments, p, q) {
			console.warn('THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry.');
			super(radius, tube, tubularSegments, radialSegments, p, q);
		}
	}
	// r144
	class TubeBufferGeometry extends TubeGeometry {
		constructor(path, tubularSegments, radius, radialSegments, closed) {
			console.warn('THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry.');
			super(path, tubularSegments, radius, radialSegments, closed);
		}
	}
	if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
		__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
			detail: {
				revision: REVISION,
			}
		}));
	}
	if (typeof window !== 'undefined') {
		if (window.__THREE__) {
			console.warn('WARNING: Multiple instances of Three.js being imported.');
		} else {
			window.__THREE__ = REVISION;
		}
	}
	exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
	exports.AddEquation = AddEquation;
	exports.AddOperation = AddOperation;
	exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
	exports.AdditiveBlending = AdditiveBlending;
	exports.AlphaFormat = AlphaFormat;
	exports.AlwaysDepth = AlwaysDepth;
	exports.AlwaysStencilFunc = AlwaysStencilFunc;
	exports.AmbientLight = AmbientLight;
	exports.AmbientLightProbe = AmbientLightProbe;
	exports.AnimationClip = AnimationClip;
	exports.AnimationLoader = AnimationLoader;
	exports.AnimationMixer = AnimationMixer;
	exports.AnimationObjectGroup = AnimationObjectGroup;
	exports.AnimationUtils = AnimationUtils;
	exports.ArcCurve = ArcCurve;
	exports.ArrayCamera = ArrayCamera;
	exports.ArrowHelper = ArrowHelper;
	exports.Audio = Audio;
	exports.AudioAnalyser = AudioAnalyser;
	exports.AudioContext = AudioContext;
	exports.AudioListener = AudioListener;
	exports.AudioLoader = AudioLoader;
	exports.AxesHelper = AxesHelper;
	exports.BackSide = BackSide;
	exports.BasicDepthPacking = BasicDepthPacking;
	exports.BasicShadowMap = BasicShadowMap;
	exports.Bone = Bone;
	exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
	exports.Box2 = Box2;
	exports.Box3 = Box3;
	exports.Box3Helper = Box3Helper;
	exports.BoxBufferGeometry = BoxBufferGeometry;
	exports.BoxGeometry = BoxGeometry;
	exports.BoxHelper = BoxHelper;
	exports.BufferAttribute = BufferAttribute;
	exports.BufferGeometry = BufferGeometry;
	exports.BufferGeometryLoader = BufferGeometryLoader;
	exports.ByteType = ByteType;
	exports.Cache = Cache;
	exports.Camera = Camera;
	exports.CameraHelper = CameraHelper;
	exports.CanvasTexture = CanvasTexture;
	exports.CapsuleBufferGeometry = CapsuleBufferGeometry;
	exports.CapsuleGeometry = CapsuleGeometry;
	exports.CatmullRomCurve3 = CatmullRomCurve3;
	exports.CineonToneMapping = CineonToneMapping;
	exports.CircleBufferGeometry = CircleBufferGeometry;
	exports.CircleGeometry = CircleGeometry;
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.Clock = Clock;
	exports.Color = Color;
	exports.ColorKeyframeTrack = ColorKeyframeTrack;
	exports.ColorManagement = ColorManagement;
	exports.CompressedArrayTexture = CompressedArrayTexture;
	exports.CompressedTexture = CompressedTexture;
	exports.CompressedTextureLoader = CompressedTextureLoader;
	exports.ConeBufferGeometry = ConeBufferGeometry;
	exports.ConeGeometry = ConeGeometry;
	exports.CubeCamera = CubeCamera;
	exports.CubeReflectionMapping = CubeReflectionMapping;
	exports.CubeRefractionMapping = CubeRefractionMapping;
	exports.CubeTexture = CubeTexture;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
	exports.CubicBezierCurve = CubicBezierCurve;
	exports.CubicBezierCurve3 = CubicBezierCurve3;
	exports.CubicInterpolant = CubicInterpolant;
	exports.CullFaceBack = CullFaceBack;
	exports.CullFaceFront = CullFaceFront;
	exports.CullFaceFrontBack = CullFaceFrontBack;
	exports.CullFaceNone = CullFaceNone;
	exports.Curve = Curve;
	exports.CurvePath = CurvePath;
	exports.CustomBlending = CustomBlending;
	exports.CustomToneMapping = CustomToneMapping;
	exports.CylinderBufferGeometry = CylinderBufferGeometry;
	exports.CylinderGeometry = CylinderGeometry;
	exports.Cylindrical = Cylindrical;
	exports.Data3DTexture = Data3DTexture;
	exports.DataArrayTexture = DataArrayTexture;
	exports.DataTexture = DataTexture;
	exports.DataTextureLoader = DataTextureLoader;
	exports.DataUtils = DataUtils;
	exports.DecrementStencilOp = DecrementStencilOp;
	exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
	exports.DefaultLoadingManager = DefaultLoadingManager;
	exports.DepthFormat = DepthFormat;
	exports.DepthStencilFormat = DepthStencilFormat;
	exports.DepthTexture = DepthTexture;
	exports.DirectionalLight = DirectionalLight;
	exports.DirectionalLightHelper = DirectionalLightHelper;
	exports.DiscreteInterpolant = DiscreteInterpolant;
	exports.DisplayP3ColorSpace = DisplayP3ColorSpace;
	exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
	exports.DodecahedronGeometry = DodecahedronGeometry;
	exports.DoubleSide = DoubleSide;
	exports.DstAlphaFactor = DstAlphaFactor;
	exports.DstColorFactor = DstColorFactor;
	exports.DynamicCopyUsage = DynamicCopyUsage;
	exports.DynamicDrawUsage = DynamicDrawUsage;
	exports.DynamicReadUsage = DynamicReadUsage;
	exports.EdgesGeometry = EdgesGeometry;
	exports.EllipseCurve = EllipseCurve;
	exports.EqualDepth = EqualDepth;
	exports.EqualStencilFunc = EqualStencilFunc;
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
	exports.Euler = Euler;
	exports.EventDispatcher = EventDispatcher;
	exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
	exports.ExtrudeGeometry = ExtrudeGeometry;
	exports.FileLoader = FileLoader;
	exports.Float16BufferAttribute = Float16BufferAttribute;
	exports.Float32BufferAttribute = Float32BufferAttribute;
	exports.Float64BufferAttribute = Float64BufferAttribute;
	exports.FloatType = FloatType;
	exports.Fog = Fog;
	exports.FogExp2 = FogExp2;
	exports.FramebufferTexture = FramebufferTexture;
	exports.FrontSide = FrontSide;
	exports.Frustum = Frustum;
	exports.GLBufferAttribute = GLBufferAttribute;
	exports.GLSL1 = GLSL1;
	exports.GLSL3 = GLSL3;
	exports.GreaterDepth = GreaterDepth;
	exports.GreaterEqualDepth = GreaterEqualDepth;
	exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
	exports.GreaterStencilFunc = GreaterStencilFunc;
	exports.GridHelper = GridHelper;
	exports.Group = Group;
	exports.HalfFloatType = HalfFloatType;
	exports.HemisphereLight = HemisphereLight;
	exports.HemisphereLightHelper = HemisphereLightHelper;
	exports.HemisphereLightProbe = HemisphereLightProbe;
	exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
	exports.IcosahedronGeometry = IcosahedronGeometry;
	exports.ImageBitmapLoader = ImageBitmapLoader;
	exports.ImageLoader = ImageLoader;
	exports.ImageUtils = ImageUtils;
	exports.IncrementStencilOp = IncrementStencilOp;
	exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
	exports.InstancedBufferAttribute = InstancedBufferAttribute;
	exports.InstancedBufferGeometry = InstancedBufferGeometry;
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
	exports.InstancedMesh = InstancedMesh;
	exports.Int16BufferAttribute = Int16BufferAttribute;
	exports.Int32BufferAttribute = Int32BufferAttribute;
	exports.Int8BufferAttribute = Int8BufferAttribute;
	exports.IntType = IntType;
	exports.InterleavedBuffer = InterleavedBuffer;
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
	exports.Interpolant = Interpolant;
	exports.InterpolateDiscrete = InterpolateDiscrete;
	exports.InterpolateLinear = InterpolateLinear;
	exports.InterpolateSmooth = InterpolateSmooth;
	exports.InvertStencilOp = InvertStencilOp;
	exports.KeepStencilOp = KeepStencilOp;
	exports.KeyframeTrack = KeyframeTrack;
	exports.LOD = LOD;
	exports.LatheBufferGeometry = LatheBufferGeometry;
	exports.LatheGeometry = LatheGeometry;
	exports.Layers = Layers;
	exports.LessDepth = LessDepth;
	exports.LessEqualDepth = LessEqualDepth;
	exports.LessEqualStencilFunc = LessEqualStencilFunc;
	exports.LessStencilFunc = LessStencilFunc;
	exports.Light = Light;
	exports.LightProbe = LightProbe;
	exports.Line = Line;
	exports.Line3 = Line3;
	exports.LineBasicMaterial = LineBasicMaterial;
	exports.LineCurve = LineCurve;
	exports.LineCurve3 = LineCurve3;
	exports.LineDashedMaterial = LineDashedMaterial;
	exports.LineLoop = LineLoop;
	exports.LineSegments = LineSegments;
	exports.LinearEncoding = LinearEncoding;
	exports.LinearFilter = LinearFilter;
	exports.LinearInterpolant = LinearInterpolant;
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
	exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
	exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
	exports.LinearSRGBColorSpace = LinearSRGBColorSpace;
	exports.LinearToneMapping = LinearToneMapping;
	exports.Loader = Loader;
	exports.LoaderUtils = LoaderUtils;
	exports.LoadingManager = LoadingManager;
	exports.LoopOnce = LoopOnce;
	exports.LoopPingPong = LoopPingPong;
	exports.LoopRepeat = LoopRepeat;
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
	exports.LuminanceFormat = LuminanceFormat;
	exports.MOUSE = MOUSE;
	exports.Material = Material;
	exports.MaterialLoader = MaterialLoader;
	exports.MathUtils = MathUtils;
	exports.Matrix3 = Matrix3;
	exports.Matrix4 = Matrix4;
	exports.MaxEquation = MaxEquation;
	exports.Mesh = Mesh;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.MeshDepthMaterial = MeshDepthMaterial;
	exports.MeshDistanceMaterial = MeshDistanceMaterial;
	exports.MeshLambertMaterial = MeshLambertMaterial;
	exports.MeshMatcapMaterial = MeshMatcapMaterial;
	exports.MeshNormalMaterial = MeshNormalMaterial;
	exports.MeshPhongMaterial = MeshPhongMaterial;
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
	exports.MeshStandardMaterial = MeshStandardMaterial;
	exports.MeshToonMaterial = MeshToonMaterial;
	exports.MinEquation = MinEquation;
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
	exports.MixOperation = MixOperation;
	exports.MultiplyBlending = MultiplyBlending;
	exports.MultiplyOperation = MultiplyOperation;
	exports.NearestFilter = NearestFilter;
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
	exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
	exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
	exports.NeverDepth = NeverDepth;
	exports.NeverStencilFunc = NeverStencilFunc;
	exports.NoBlending = NoBlending;
	exports.NoColorSpace = NoColorSpace;
	exports.NoToneMapping = NoToneMapping;
	exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
	exports.NormalBlending = NormalBlending;
	exports.NotEqualDepth = NotEqualDepth;
	exports.NotEqualStencilFunc = NotEqualStencilFunc;
	exports.NumberKeyframeTrack = NumberKeyframeTrack;
	exports.Object3D = Object3D;
	exports.ObjectLoader = ObjectLoader;
	exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
	exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
	exports.OctahedronGeometry = OctahedronGeometry;
	exports.OneFactor = OneFactor;
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
	exports.OrthographicCamera = OrthographicCamera;
	exports.PCFShadowMap = PCFShadowMap;
	exports.PCFSoftShadowMap = PCFSoftShadowMap;
	exports.PMREMGenerator = PMREMGenerator;
	exports.Path = Path;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.Plane = Plane;
	exports.PlaneBufferGeometry = PlaneBufferGeometry;
	exports.PlaneGeometry = PlaneGeometry;
	exports.PlaneHelper = PlaneHelper;
	exports.PointLight = PointLight;
	exports.PointLightHelper = PointLightHelper;
	exports.Points = Points;
	exports.PointsMaterial = PointsMaterial;
	exports.PolarGridHelper = PolarGridHelper;
	exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
	exports.PolyhedronGeometry = PolyhedronGeometry;
	exports.PositionalAudio = PositionalAudio;
	exports.PropertyBinding = PropertyBinding;
	exports.PropertyMixer = PropertyMixer;
	exports.QuadraticBezierCurve = QuadraticBezierCurve;
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
	exports.Quaternion = Quaternion;
	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
	exports.RED_GREEN_RGTC2_Format = RED_GREEN_RGTC2_Format;
	exports.RED_RGTC1_Format = RED_RGTC1_Format;
	exports.REVISION = REVISION;
	exports.RGBADepthPacking = RGBADepthPacking;
	exports.RGBAFormat = RGBAFormat;
	exports.RGBAIntegerFormat = RGBAIntegerFormat;
	exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
	exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
	exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
	exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
	exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
	exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
	exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
	exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
	exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
	exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
	exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
	exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
	exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
	exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
	exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
	exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
	exports.RGB_ETC1_Format = RGB_ETC1_Format;
	exports.RGB_ETC2_Format = RGB_ETC2_Format;
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
	exports.RGFormat = RGFormat;
	exports.RGIntegerFormat = RGIntegerFormat;
	exports.RawShaderMaterial = RawShaderMaterial;
	exports.Ray = Ray;
	exports.Raycaster = Raycaster;
	exports.RectAreaLight = RectAreaLight;
	exports.RedFormat = RedFormat;
	exports.RedIntegerFormat = RedIntegerFormat;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.RepeatWrapping = RepeatWrapping;
	exports.ReplaceStencilOp = ReplaceStencilOp;
	exports.ReverseSubtractEquation = ReverseSubtractEquation;
	exports.RingBufferGeometry = RingBufferGeometry;
	exports.RingGeometry = RingGeometry;
	exports.SIGNED_RED_GREEN_RGTC2_Format = SIGNED_RED_GREEN_RGTC2_Format;
	exports.SIGNED_RED_RGTC1_Format = SIGNED_RED_RGTC1_Format;
	exports.SRGBColorSpace = SRGBColorSpace;
	exports.Scene = Scene;
	exports.ShaderChunk = ShaderChunk;
	exports.ShaderLib = ShaderLib;
	exports.ShaderMaterial = ShaderMaterial;
	exports.ShadowMaterial = ShadowMaterial;
	exports.Shape = Shape;
	exports.ShapeBufferGeometry = ShapeBufferGeometry;
	exports.ShapeGeometry = ShapeGeometry;
	exports.ShapePath = ShapePath;
	exports.ShapeUtils = ShapeUtils;
	exports.ShortType = ShortType;
	exports.Skeleton = Skeleton;
	exports.SkeletonHelper = SkeletonHelper;
	exports.SkinnedMesh = SkinnedMesh;
	exports.Source = Source;
	exports.Sphere = Sphere;
	exports.SphereBufferGeometry = SphereBufferGeometry;
	exports.SphereGeometry = SphereGeometry;
	exports.Spherical = Spherical;
	exports.SphericalHarmonics3 = SphericalHarmonics3;
	exports.SplineCurve = SplineCurve;
	exports.SpotLight = SpotLight;
	exports.SpotLightHelper = SpotLightHelper;
	exports.Sprite = Sprite;
	exports.SpriteMaterial = SpriteMaterial;
	exports.SrcAlphaFactor = SrcAlphaFactor;
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
	exports.SrcColorFactor = SrcColorFactor;
	exports.StaticCopyUsage = StaticCopyUsage;
	exports.StaticDrawUsage = StaticDrawUsage;
	exports.StaticReadUsage = StaticReadUsage;
	exports.StereoCamera = StereoCamera;
	exports.StreamCopyUsage = StreamCopyUsage;
	exports.StreamDrawUsage = StreamDrawUsage;
	exports.StreamReadUsage = StreamReadUsage;
	exports.StringKeyframeTrack = StringKeyframeTrack;
	exports.SubtractEquation = SubtractEquation;
	exports.SubtractiveBlending = SubtractiveBlending;
	exports.TOUCH = TOUCH;
	exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
	exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
	exports.TetrahedronGeometry = TetrahedronGeometry;
	exports.Texture = Texture;
	exports.TextureLoader = TextureLoader;
	exports.TorusBufferGeometry = TorusBufferGeometry;
	exports.TorusGeometry = TorusGeometry;
	exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
	exports.TorusKnotGeometry = TorusKnotGeometry;
	exports.Triangle = Triangle;
	exports.TriangleFanDrawMode = TriangleFanDrawMode;
	exports.TriangleStripDrawMode = TriangleStripDrawMode;
	exports.TrianglesDrawMode = TrianglesDrawMode;
	exports.TubeBufferGeometry = TubeBufferGeometry;
	exports.TubeGeometry = TubeGeometry;
	exports.TwoPassDoubleSide = TwoPassDoubleSide;
	exports.UVMapping = UVMapping;
	exports.Uint16BufferAttribute = Uint16BufferAttribute;
	exports.Uint32BufferAttribute = Uint32BufferAttribute;
	exports.Uint8BufferAttribute = Uint8BufferAttribute;
	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
	exports.Uniform = Uniform;
	exports.UniformsGroup = UniformsGroup;
	exports.UniformsLib = UniformsLib;
	exports.UniformsUtils = UniformsUtils;
	exports.UnsignedByteType = UnsignedByteType;
	exports.UnsignedInt248Type = UnsignedInt248Type;
	exports.UnsignedIntType = UnsignedIntType;
	exports.UnsignedShort4444Type = UnsignedShort4444Type;
	exports.UnsignedShort5551Type = UnsignedShort5551Type;
	exports.UnsignedShortType = UnsignedShortType;
	exports.VSMShadowMap = VSMShadowMap;
	exports.Vector2 = Vector2;
	exports.Vector3 = Vector3;
	exports.Vector4 = Vector4;
	exports.VectorKeyframeTrack = VectorKeyframeTrack;
	exports.VideoTexture = VideoTexture;
	exports.WebGL1Renderer = WebGL1Renderer;
	exports.WebGL3DRenderTarget = WebGL3DRenderTarget;
	exports.WebGLArrayRenderTarget = WebGLArrayRenderTarget;
	exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
	exports.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;
	exports.WebGLRenderTarget = WebGLRenderTarget;
	exports.WebGLRenderer = WebGLRenderer;
	exports.WebGLUtils = WebGLUtils;
	exports.WireframeGeometry = WireframeGeometry;
	exports.WrapAroundEnding = WrapAroundEnding;
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
	exports.ZeroFactor = ZeroFactor;
	exports.ZeroSlopeEnding = ZeroSlopeEnding;
	exports.ZeroStencilOp = ZeroStencilOp;
	exports._SRGBAFormat = _SRGBAFormat;
	exports.sRGBEncoding = sRGBEncoding;
}));
! function(e, t) {
	"object" == typeof exports && "undefined" != typeof module ? module.exports = t(require("three"), require("gsap")) : "function" == typeof define && define.amd ? define(["three", "gsap"], t) : (e || self).hoverEffect = t(e.THREE, e.gsap)
}(this, function(e, t) {
	function n(e) {
		return e && "object" == typeof e && "default" in e ? e : {
			default: e
		}
	}

	function i(e) {
		if (e && e.__esModule) return e;
		var t = Object.create(null);
		return e && Object.keys(e).forEach(function(n) {
			if ("default" !== n) {
				var i = Object.getOwnPropertyDescriptor(e, n);
				Object.defineProperty(t, n, i.get ? i : {
					enumerable: !0,
					get: function() {
						return e[n]
					}
				})
			}
		}), t.default = e, t
	}
	var r = /*#__PURE__*/ i(e),
		o = /*#__PURE__*/ n(t);
	return function(e) {
		function t() {
			for (var e = 0; e < arguments.length; e++)
				if (void 0 !== arguments[e]) return arguments[e]
		}
		var n = e.parent,
			trig = e.trigger,
			i = e.displacementImage,
			a = e.image1,
			s = e.image2,
			f = t(e.imagesRatio, 1),
			d = t(e.intensity1, e.intensity, 1),
			l = t(e.intensity2, e.intensity, 1),
			u = t(e.angle, Math.PI / 4),
			c = t(e.angle1, u),
			v = t(e.angle2, 3 * -u),
			m = t(e.speedIn, e.speed, 1.6),
			p = t(e.speedOut, e.speed, 1.2),
			g = t(e.hover, !0),
			h = t(e.easing, "expo.out"),
			y = t(e.video, !1);
		if (n)
			if (a && s && i) {
				var F = new r.Scene,
					x = new r.OrthographicCamera(n.offsetWidth / -2, n.offsetWidth / 2, n.offsetHeight / 2, n.offsetHeight / -2, 1, 1e3);
				x.position.z = 1;
				var w = new r.WebGLRenderer({
					antialias: !1,
					alpha: !0
				});
				w.setPixelRatio(2), w.setClearColor(16777215, 0), w.setSize(n.offsetWidth, n.offsetHeight), n.appendChild(w.domElement);
				var L = function() {
						w.render(F, x)
					},
					b = new r.TextureLoader;
				b.crossOrigin = "";
				var H, E, W = b.load(i, L);
				if (W.magFilter = W.minFilter = r.LinearFilter, y) {
					! function e() {
						requestAnimationFrame(e), w.render(F, x)
					}(), (y = document.createElement("video")).autoplay = !0, y.loop = !0, y.muted = !0, y.src = a, y.load();
					var V = document.createElement("video");
					V.autoplay = !0, V.loop = !0, V.muted = !0, V.src = s, V.load();
					var P = new r.VideoTexture(y),
						M = new r.VideoTexture(V);
					P.magFilter = M.magFilter = r.LinearFilter, P.minFilter = M.minFilter = r.LinearFilter, V.addEventListener("loadeddata", function() {
						V.play(), (M = new r.VideoTexture(V)).magFilter = r.LinearFilter, M.minFilter = r.LinearFilter, R.uniforms.texture2.value = M
					}, !1), y.addEventListener("loadeddata", function() {
						y.play(), (P = new r.VideoTexture(y)).magFilter = r.LinearFilter, P.minFilter = r.LinearFilter, R.uniforms.texture1.value = P
					}, !1)
				} else P = b.load(a, L), M = b.load(s, L), P.magFilter = M.magFilter = r.LinearFilter, P.minFilter = M.minFilter = r.LinearFilter;
				var O = f;
				n.offsetHeight / n.offsetWidth < O ? (H = 1, E = n.offsetHeight / n.offsetWidth / O) : (H = n.offsetWidth / n.offsetHeight * O, E = 1);
				var R = new r.ShaderMaterial({
						uniforms: {
							intensity1: {
								type: "f",
								value: d
							},
							intensity2: {
								type: "f",
								value: l
							},
							dispFactor: {
								type: "f",
								value: 0
							},
							angle1: {
								type: "f",
								value: c
							},
							angle2: {
								type: "f",
								value: v
							},
							texture1: {
								type: "t",
								value: P
							},
							texture2: {
								type: "t",
								value: M
							},
							disp: {
								type: "t",
								value: W
							},
							res: {
								type: "vec4",
								value: new r.Vector4(n.offsetWidth, n.offsetHeight, H, E)
							},
							dpr: {
								type: "f",
								value: window.devicePixelRatio
							}
						},
						vertexShader: "\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n",
						fragmentShader: "\nvarying vec2 vUv;\n\nuniform float dispFactor;\nuniform float dpr;\nuniform sampler2D disp;\n\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nuniform float angle1;\nuniform float angle2;\nuniform float intensity1;\nuniform float intensity2;\nuniform vec4 res;\nuniform vec2 parent;\n\nmat2 getRotM(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, -s, s, c);\n}\n\nvoid main() {\n  vec4 disp = texture2D(disp, vUv);\n  vec2 dispVec = vec2(disp.r, disp.g);\n\n  vec2 uv = 0.5 * gl_FragCoord.xy / (res.xy) ;\n  vec2 myUV = (uv - vec2(0.5))*res.zw + vec2(0.5);\n\n\n  vec2 distortedPosition1 = myUV + getRotM(angle1) * dispVec * intensity1 * dispFactor;\n  vec2 distortedPosition2 = myUV + getRotM(angle2) * dispVec * intensity2 * (1.0 - dispFactor);\n  vec4 _texture1 = texture2D(texture1, distortedPosition1);\n  vec4 _texture2 = texture2D(texture2, distortedPosition2);\n  gl_FragColor = mix(_texture1, _texture2, dispFactor);\n}\n",
						transparent: !0,
						opacity: 1
					}),
					U = new r.PlaneGeometry(n.offsetWidth, n.offsetHeight, 1),
					_ = new r.Mesh(U, R);
				F.add(_), g && (trig.addEventListener("mouseenter", C), trig.addEventListener("touchstart", C), trig.addEventListener("mouseleave", D), trig.addEventListener("touchend", D)), window.addEventListener("resize", function(e) {
					n.offsetHeight / n.offsetWidth < O ? (H = 1, E = n.offsetHeight / n.offsetWidth / O) : (H = n.offsetWidth / n.offsetHeight * O, E = 1), _.material.uniforms.res.value = new r.Vector4(n.offsetWidth, n.offsetHeight, H, E), w.setSize(n.offsetWidth, n.offsetHeight), L()
				}), this.next = C, this.previous = D
			} else console.warn("One or more images are missing");
		else console.warn("Parent missing");

		function C() {
			o.default.to(R.uniforms.dispFactor, {
				duration: m,
				value: 1,
				ease: h,
				onUpdate: L,
				onComplete: L
			})
		}

		function D() {
			o.default.to(R.uniforms.dispFactor, {
				duration: p,
				value: 0,
				ease: h,
				onUpdate: L,
				onComplete: L
			})
		}
	}
});
//# sourceMappingURL=hover-effect.umd.js.map
/**

 * Swiper 8.4.2

 * Most modern mobile touch slider and framework with hardware accelerated transitions

 * https://swiperjs.com

 *

 * Copyright 2014-2022 Vladimir Kharlampidi

 *

 * Released under the MIT License

 *

 * Released on: September 15, 2022

 */
(function(global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Swiper = factory());
})(this, (function() {
	'use strict';
	/**

	 * SSR Window 4.0.2

	 * Better handling for window object in SSR environment

	 * https://github.com/nolimits4web/ssr-window

	 *

	 * Copyright 2021, Vladimir Kharlampidi

	 *

	 * Licensed under MIT

	 *

	 * Released on: December 13, 2021

	 */
	/* eslint-disable no-param-reassign */
	function isObject$1(obj) {
		return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
	}

	function extend$1(target, src) {
		if (target === void 0) {
			target = {};
		}
		if (src === void 0) {
			src = {};
		}
		Object.keys(src).forEach(key => {
			if (typeof target[key] === 'undefined') target[key] = src[key];
			else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {
				extend$1(target[key], src[key]);
			}
		});
	}
	const ssrDocument = {
		body: {},
		addEventListener() {},
		removeEventListener() {},
		activeElement: {
			blur() {},
			nodeName: ''
		},
		querySelector() {
			return null;
		},
		querySelectorAll() {
			return [];
		},
		getElementById() {
			return null;
		},
		createEvent() {
			return {
				initEvent() {}
			};
		},
		createElement() {
			return {
				children: [],
				childNodes: [],
				style: {},
				setAttribute() {},
				getElementsByTagName() {
					return [];
				}
			};
		},
		createElementNS() {
			return {};
		},
		importNode() {
			return null;
		},
		location: {
			hash: '',
			host: '',
			hostname: '',
			href: '',
			origin: '',
			pathname: '',
			protocol: '',
			search: ''
		}
	};

	function getDocument() {
		const doc = typeof document !== 'undefined' ? document : {};
		extend$1(doc, ssrDocument);
		return doc;
	}
	const ssrWindow = {
		document: ssrDocument,
		navigator: {
			userAgent: ''
		},
		location: {
			hash: '',
			host: '',
			hostname: '',
			href: '',
			origin: '',
			pathname: '',
			protocol: '',
			search: ''
		},
		history: {
			replaceState() {},
			pushState() {},
			go() {},
			back() {}
		},
		CustomEvent: function CustomEvent() {
			return this;
		},
		addEventListener() {},
		removeEventListener() {},
		getComputedStyle() {
			return {
				getPropertyValue() {
					return '';
				}
			};
		},
		Image() {},
		Date() {},
		screen: {},
		setTimeout() {},
		clearTimeout() {},
		matchMedia() {
			return {};
		},
		requestAnimationFrame(callback) {
			if (typeof setTimeout === 'undefined') {
				callback();
				return null;
			}
			return setTimeout(callback, 0);
		},
		cancelAnimationFrame(id) {
			if (typeof setTimeout === 'undefined') {
				return;
			}
			clearTimeout(id);
		}
	};

	function getWindow() {
		const win = typeof window !== 'undefined' ? window : {};
		extend$1(win, ssrWindow);
		return win;
	}
	/**

	 * Dom7 4.0.4

	 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API

	 * https://framework7.io/docs/dom7.html

	 *

	 * Copyright 2022, Vladimir Kharlampidi

	 *

	 * Licensed under MIT

	 *

	 * Released on: January 11, 2022

	 */
	/* eslint-disable no-proto */
	function makeReactive(obj) {
		const proto = obj.__proto__;
		Object.defineProperty(obj, '__proto__', {
			get() {
				return proto;
			},
			set(value) {
				proto.__proto__ = value;
			}
		});
	}
	class Dom7 extends Array {
		constructor(items) {
			if (typeof items === 'number') {
				super(items);
			} else {
				super(...(items || []));
				makeReactive(this);
			}
		}
	}

	function arrayFlat(arr) {
		if (arr === void 0) {
			arr = [];
		}
		const res = [];
		arr.forEach(el => {
			if (Array.isArray(el)) {
				res.push(...arrayFlat(el));
			} else {
				res.push(el);
			}
		});
		return res;
	}

	function arrayFilter(arr, callback) {
		return Array.prototype.filter.call(arr, callback);
	}

	function arrayUnique(arr) {
		const uniqueArray = [];
		for (let i = 0; i < arr.length; i += 1) {
			if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
		}
		return uniqueArray;
	}

	function qsa(selector, context) {
		if (typeof selector !== 'string') {
			return [selector];
		}
		const a = [];
		const res = context.querySelectorAll(selector);
		for (let i = 0; i < res.length; i += 1) {
			a.push(res[i]);
		}
		return a;
	}

	function $(selector, context) {
		const window = getWindow();
		const document = getDocument();
		let arr = [];
		if (!context && selector instanceof Dom7) {
			return selector;
		}
		if (!selector) {
			return new Dom7(arr);
		}
		if (typeof selector === 'string') {
			const html = selector.trim();
			if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
				let toCreate = 'div';
				if (html.indexOf('<li') === 0) toCreate = 'ul';
				if (html.indexOf('<tr') === 0) toCreate = 'tbody';
				if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
				if (html.indexOf('<tbody') === 0) toCreate = 'table';
				if (html.indexOf('<option') === 0) toCreate = 'select';
				const tempParent = document.createElement(toCreate);
				tempParent.innerHTML = html;
				for (let i = 0; i < tempParent.childNodes.length; i += 1) {
					arr.push(tempParent.childNodes[i]);
				}
			} else {
				arr = qsa(selector.trim(), context || document);
			} // arr = qsa(selector, document);
		} else if (selector.nodeType || selector === window || selector === document) {
			arr.push(selector);
		} else if (Array.isArray(selector)) {
			if (selector instanceof Dom7) return selector;
			arr = selector;
		}
		return new Dom7(arrayUnique(arr));
	}
	$.fn = Dom7.prototype; // eslint-disable-next-line
	function addClass() {
		for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
			classes[_key] = arguments[_key];
		}
		const classNames = arrayFlat(classes.map(c => c.split(' ')));
		this.forEach(el => {
			el.classList.add(...classNames);
		});
		return this;
	}

	function removeClass() {
		for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			classes[_key2] = arguments[_key2];
		}
		const classNames = arrayFlat(classes.map(c => c.split(' ')));
		this.forEach(el => {
			el.classList.remove(...classNames);
		});
		return this;
	}

	function toggleClass() {
		for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
			classes[_key3] = arguments[_key3];
		}
		const classNames = arrayFlat(classes.map(c => c.split(' ')));
		this.forEach(el => {
			classNames.forEach(className => {
				el.classList.toggle(className);
			});
		});
	}

	function hasClass() {
		for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
			classes[_key4] = arguments[_key4];
		}
		const classNames = arrayFlat(classes.map(c => c.split(' ')));
		return arrayFilter(this, el => {
			return classNames.filter(className => el.classList.contains(className)).length > 0;
		}).length > 0;
	}

	function attr(attrs, value) {
		if (arguments.length === 1 && typeof attrs === 'string') {
			// Get attr
			if (this[0]) return this[0].getAttribute(attrs);
			return undefined;
		} // Set attrs
		for (let i = 0; i < this.length; i += 1) {
			if (arguments.length === 2) {
				// String
				this[i].setAttribute(attrs, value);
			} else {
				// Object
				for (const attrName in attrs) {
					this[i][attrName] = attrs[attrName];
					this[i].setAttribute(attrName, attrs[attrName]);
				}
			}
		}
		return this;
	}

	function removeAttr(attr) {
		for (let i = 0; i < this.length; i += 1) {
			this[i].removeAttribute(attr);
		}
		return this;
	}

	function transform(transform) {
		for (let i = 0; i < this.length; i += 1) {
			this[i].style.transform = transform;
		}
		return this;
	}

	function transition$1(duration) {
		for (let i = 0; i < this.length; i += 1) {
			this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;
		}
		return this;
	}

	function on() {
		for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
			args[_key5] = arguments[_key5];
		}
		let [eventType, targetSelector, listener, capture] = args;
		if (typeof args[1] === 'function') {
			[eventType, listener, capture] = args;
			targetSelector = undefined;
		}
		if (!capture) capture = false;

		function handleLiveEvent(e) {
			const target = e.target;
			if (!target) return;
			const eventData = e.target.dom7EventData || [];
			if (eventData.indexOf(e) < 0) {
				eventData.unshift(e);
			}
			if ($(target).is(targetSelector)) listener.apply(target, eventData);
			else {
				const parents = $(target).parents(); // eslint-disable-line
				for (let k = 0; k < parents.length; k += 1) {
					if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
				}
			}
		}

		function handleEvent(e) {
			const eventData = e && e.target ? e.target.dom7EventData || [] : [];
			if (eventData.indexOf(e) < 0) {
				eventData.unshift(e);
			}
			listener.apply(this, eventData);
		}
		const events = eventType.split(' ');
		let j;
		for (let i = 0; i < this.length; i += 1) {
			const el = this[i];
			if (!targetSelector) {
				for (j = 0; j < events.length; j += 1) {
					const event = events[j];
					if (!el.dom7Listeners) el.dom7Listeners = {};
					if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
					el.dom7Listeners[event].push({
						listener,
						proxyListener: handleEvent
					});
					el.addEventListener(event, handleEvent, capture);
				}
			} else {
				// Live events
				for (j = 0; j < events.length; j += 1) {
					const event = events[j];
					if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
					if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
					el.dom7LiveListeners[event].push({
						listener,
						proxyListener: handleLiveEvent
					});
					el.addEventListener(event, handleLiveEvent, capture);
				}
			}
		}
		return this;
	}

	function off() {
		for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
			args[_key6] = arguments[_key6];
		}
		let [eventType, targetSelector, listener, capture] = args;
		if (typeof args[1] === 'function') {
			[eventType, listener, capture] = args;
			targetSelector = undefined;
		}
		if (!capture) capture = false;
		const events = eventType.split(' ');
		for (let i = 0; i < events.length; i += 1) {
			const event = events[i];
			for (let j = 0; j < this.length; j += 1) {
				const el = this[j];
				let handlers;
				if (!targetSelector && el.dom7Listeners) {
					handlers = el.dom7Listeners[event];
				} else if (targetSelector && el.dom7LiveListeners) {
					handlers = el.dom7LiveListeners[event];
				}
				if (handlers && handlers.length) {
					for (let k = handlers.length - 1; k >= 0; k -= 1) {
						const handler = handlers[k];
						if (listener && handler.listener === listener) {
							el.removeEventListener(event, handler.proxyListener, capture);
							handlers.splice(k, 1);
						} else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
							el.removeEventListener(event, handler.proxyListener, capture);
							handlers.splice(k, 1);
						} else if (!listener) {
							el.removeEventListener(event, handler.proxyListener, capture);
							handlers.splice(k, 1);
						}
					}
				}
			}
		}
		return this;
	}

	function trigger() {
		const window = getWindow();
		for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
			args[_key9] = arguments[_key9];
		}
		const events = args[0].split(' ');
		const eventData = args[1];
		for (let i = 0; i < events.length; i += 1) {
			const event = events[i];
			for (let j = 0; j < this.length; j += 1) {
				const el = this[j];
				if (window.CustomEvent) {
					const evt = new window.CustomEvent(event, {
						detail: eventData,
						bubbles: true,
						cancelable: true
					});
					el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
					el.dispatchEvent(evt);
					el.dom7EventData = [];
					delete el.dom7EventData;
				}
			}
		}
		return this;
	}

	function transitionEnd$1(callback) {
		const dom = this;

		function fireCallBack(e) {
			if (e.target !== this) return;
			callback.call(this, e);
			dom.off('transitionend', fireCallBack);
		}
		if (callback) {
			dom.on('transitionend', fireCallBack);
		}
		return this;
	}

	function outerWidth(includeMargins) {
		if (this.length > 0) {
			if (includeMargins) {
				const styles = this.styles();
				return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
			}
			return this[0].offsetWidth;
		}
		return null;
	}

	function outerHeight(includeMargins) {
		if (this.length > 0) {
			if (includeMargins) {
				const styles = this.styles();
				return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
			}
			return this[0].offsetHeight;
		}
		return null;
	}

	function offset() {
		if (this.length > 0) {
			const window = getWindow();
			const document = getDocument();
			const el = this[0];
			const box = el.getBoundingClientRect();
			const body = document.body;
			const clientTop = el.clientTop || body.clientTop || 0;
			const clientLeft = el.clientLeft || body.clientLeft || 0;
			const scrollTop = el === window ? window.scrollY : el.scrollTop;
			const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
			return {
				top: box.top + scrollTop - clientTop,
				left: box.left + scrollLeft - clientLeft
			};
		}
		return null;
	}

	function styles() {
		const window = getWindow();
		if (this[0]) return window.getComputedStyle(this[0], null);
		return {};
	}

	function css(props, value) {
		const window = getWindow();
		let i;
		if (arguments.length === 1) {
			if (typeof props === 'string') {
				// .css('width')
				if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
			} else {
				// .css({ width: '100px' })
				for (i = 0; i < this.length; i += 1) {
					for (const prop in props) {
						this[i].style[prop] = props[prop];
					}
				}
				return this;
			}
		}
		if (arguments.length === 2 && typeof props === 'string') {
			// .css('width', '100px')
			for (i = 0; i < this.length; i += 1) {
				this[i].style[props] = value;
			}
			return this;
		}
		return this;
	}

	function each(callback) {
		if (!callback) return this;
		this.forEach((el, index) => {
			callback.apply(el, [el, index]);
		});
		return this;
	}

	function filter(callback) {
		const result = arrayFilter(this, callback);
		return $(result);
	}

	function html(html) {
		if (typeof html === 'undefined') {
			return this[0] ? this[0].innerHTML : null;
		}
		for (let i = 0; i < this.length; i += 1) {
			this[i].innerHTML = html;
		}
		return this;
	}

	function text(text) {
		if (typeof text === 'undefined') {
			return this[0] ? this[0].textContent.trim() : null;
		}
		for (let i = 0; i < this.length; i += 1) {
			this[i].textContent = text;
		}
		return this;
	}

	function is(selector) {
		const window = getWindow();
		const document = getDocument();
		const el = this[0];
		let compareWith;
		let i;
		if (!el || typeof selector === 'undefined') return false;
		if (typeof selector === 'string') {
			if (el.matches) return el.matches(selector);
			if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
			if (el.msMatchesSelector) return el.msMatchesSelector(selector);
			compareWith = $(selector);
			for (i = 0; i < compareWith.length; i += 1) {
				if (compareWith[i] === el) return true;
			}
			return false;
		}
		if (selector === document) {
			return el === document;
		}
		if (selector === window) {
			return el === window;
		}
		if (selector.nodeType || selector instanceof Dom7) {
			compareWith = selector.nodeType ? [selector] : selector;
			for (i = 0; i < compareWith.length; i += 1) {
				if (compareWith[i] === el) return true;
			}
			return false;
		}
		return false;
	}

	function index() {
		let child = this[0];
		let i;
		if (child) {
			i = 0; // eslint-disable-next-line
			while ((child = child.previousSibling) !== null) {
				if (child.nodeType === 1) i += 1;
			}
			return i;
		}
		return undefined;
	}

	function eq(index) {
		if (typeof index === 'undefined') return this;
		const length = this.length;
		if (index > length - 1) {
			return $([]);
		}
		if (index < 0) {
			const returnIndex = length + index;
			if (returnIndex < 0) return $([]);
			return $([this[returnIndex]]);
		}
		return $([this[index]]);
	}

	function append() {
		let newChild;
		const document = getDocument();
		for (let k = 0; k < arguments.length; k += 1) {
			newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];
			for (let i = 0; i < this.length; i += 1) {
				if (typeof newChild === 'string') {
					const tempDiv = document.createElement('div');
					tempDiv.innerHTML = newChild;
					while (tempDiv.firstChild) {
						this[i].appendChild(tempDiv.firstChild);
					}
				} else if (newChild instanceof Dom7) {
					for (let j = 0; j < newChild.length; j += 1) {
						this[i].appendChild(newChild[j]);
					}
				} else {
					this[i].appendChild(newChild);
				}
			}
		}
		return this;
	}

	function prepend(newChild) {
		const document = getDocument();
		let i;
		let j;
		for (i = 0; i < this.length; i += 1) {
			if (typeof newChild === 'string') {
				const tempDiv = document.createElement('div');
				tempDiv.innerHTML = newChild;
				for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
					this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
				}
			} else if (newChild instanceof Dom7) {
				for (j = 0; j < newChild.length; j += 1) {
					this[i].insertBefore(newChild[j], this[i].childNodes[0]);
				}
			} else {
				this[i].insertBefore(newChild, this[i].childNodes[0]);
			}
		}
		return this;
	}

	function next(selector) {
		if (this.length > 0) {
			if (selector) {
				if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
					return $([this[0].nextElementSibling]);
				}
				return $([]);
			}
			if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
			return $([]);
		}
		return $([]);
	}

	function nextAll(selector) {
		const nextEls = [];
		let el = this[0];
		if (!el) return $([]);
		while (el.nextElementSibling) {
			const next = el.nextElementSibling; // eslint-disable-line
			if (selector) {
				if ($(next).is(selector)) nextEls.push(next);
			} else nextEls.push(next);
			el = next;
		}
		return $(nextEls);
	}

	function prev(selector) {
		if (this.length > 0) {
			const el = this[0];
			if (selector) {
				if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
					return $([el.previousElementSibling]);
				}
				return $([]);
			}
			if (el.previousElementSibling) return $([el.previousElementSibling]);
			return $([]);
		}
		return $([]);
	}

	function prevAll(selector) {
		const prevEls = [];
		let el = this[0];
		if (!el) return $([]);
		while (el.previousElementSibling) {
			const prev = el.previousElementSibling; // eslint-disable-line
			if (selector) {
				if ($(prev).is(selector)) prevEls.push(prev);
			} else prevEls.push(prev);
			el = prev;
		}
		return $(prevEls);
	}

	function parent(selector) {
		const parents = []; // eslint-disable-line
		for (let i = 0; i < this.length; i += 1) {
			if (this[i].parentNode !== null) {
				if (selector) {
					if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
				} else {
					parents.push(this[i].parentNode);
				}
			}
		}
		return $(parents);
	}

	function parents(selector) {
		const parents = []; // eslint-disable-line
		for (let i = 0; i < this.length; i += 1) {
			let parent = this[i].parentNode; // eslint-disable-line
			while (parent) {
				if (selector) {
					if ($(parent).is(selector)) parents.push(parent);
				} else {
					parents.push(parent);
				}
				parent = parent.parentNode;
			}
		}
		return $(parents);
	}

	function closest(selector) {
		let closest = this; // eslint-disable-line
		if (typeof selector === 'undefined') {
			return $([]);
		}
		if (!closest.is(selector)) {
			closest = closest.parents(selector).eq(0);
		}
		return closest;
	}

	function find(selector) {
		const foundElements = [];
		for (let i = 0; i < this.length; i += 1) {
			const found = this[i].querySelectorAll(selector);
			for (let j = 0; j < found.length; j += 1) {
				foundElements.push(found[j]);
			}
		}
		return $(foundElements);
	}

	function children(selector) {
		const children = []; // eslint-disable-line
		for (let i = 0; i < this.length; i += 1) {
			const childNodes = this[i].children;
			for (let j = 0; j < childNodes.length; j += 1) {
				if (!selector || $(childNodes[j]).is(selector)) {
					children.push(childNodes[j]);
				}
			}
		}
		return $(children);
	}

	function remove() {
		for (let i = 0; i < this.length; i += 1) {
			if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
		}
		return this;
	}
	const Methods = {
		addClass,
		removeClass,
		hasClass,
		toggleClass,
		attr,
		removeAttr,
		transform,
		transition: transition$1,
		on,
		off,
		trigger,
		transitionEnd: transitionEnd$1,
		outerWidth,
		outerHeight,
		styles,
		offset,
		css,
		each,
		html,
		text,
		is,
		index,
		eq,
		append,
		prepend,
		next,
		nextAll,
		prev,
		prevAll,
		parent,
		parents,
		closest,
		find,
		children,
		filter,
		remove
	};
	Object.keys(Methods).forEach(methodName => {
		Object.defineProperty($.fn, methodName, {
			value: Methods[methodName],
			writable: true
		});
	});

	function deleteProps(obj) {
		const object = obj;
		Object.keys(object).forEach(key => {
			try {
				object[key] = null;
			} catch (e) { // no getter for object
			}
			try {
				delete object[key];
			} catch (e) { // something got wrong
			}
		});
	}

	function nextTick(callback, delay) {
		if (delay === void 0) {
			delay = 0;
		}
		return setTimeout(callback, delay);
	}

	function now() {
		return Date.now();
	}

	function getComputedStyle$1(el) {
		const window = getWindow();
		let style;
		if (window.getComputedStyle) {
			style = window.getComputedStyle(el, null);
		}
		if (!style && el.currentStyle) {
			style = el.currentStyle;
		}
		if (!style) {
			style = el.style;
		}
		return style;
	}

	function getTranslate(el, axis) {
		if (axis === void 0) {
			axis = 'x';
		}
		const window = getWindow();
		let matrix;
		let curTransform;
		let transformMatrix;
		const curStyle = getComputedStyle$1(el);
		if (window.WebKitCSSMatrix) {
			curTransform = curStyle.transform || curStyle.webkitTransform;
			if (curTransform.split(',').length > 6) {
				curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
			} // Some old versions of Webkit choke when 'none' is passed; pass
			// empty string instead in this case
			transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
		} else {
			transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
			matrix = transformMatrix.toString().split(',');
		}
		if (axis === 'x') {
			// Latest Chrome and webkits Fix
			if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
			else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
			else curTransform = parseFloat(matrix[4]);
		}
		if (axis === 'y') {
			// Latest Chrome and webkits Fix
			if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
			else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
			else curTransform = parseFloat(matrix[5]);
		}
		return curTransform || 0;
	}

	function isObject(o) {
		return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
	}

	function isNode(node) {
		// eslint-disable-next-line
		if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
			return node instanceof HTMLElement;
		}
		return node && (node.nodeType === 1 || node.nodeType === 11);
	}

	function extend() {
		const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
		const noExtend = ['__proto__', 'constructor', 'prototype'];
		for (let i = 1; i < arguments.length; i += 1) {
			const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];
			if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
				const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
				for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
					const nextKey = keysArray[nextIndex];
					const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
					if (desc !== undefined && desc.enumerable) {
						if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
							if (nextSource[nextKey].__swiper__) {
								to[nextKey] = nextSource[nextKey];
							} else {
								extend(to[nextKey], nextSource[nextKey]);
							}
						} else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
							to[nextKey] = {};
							if (nextSource[nextKey].__swiper__) {
								to[nextKey] = nextSource[nextKey];
							} else {
								extend(to[nextKey], nextSource[nextKey]);
							}
						} else {
							to[nextKey] = nextSource[nextKey];
						}
					}
				}
			}
		}
		return to;
	}

	function setCSSProperty(el, varName, varValue) {
		el.style.setProperty(varName, varValue);
	}

	function animateCSSModeScroll(_ref) {
		let {
			swiper,
			targetPosition,
			side
		} = _ref;
		const window = getWindow();
		const startPosition = -swiper.translate;
		let startTime = null;
		let time;
		const duration = swiper.params.speed;
		swiper.wrapperEl.style.scrollSnapType = 'none';
		window.cancelAnimationFrame(swiper.cssModeFrameID);
		const dir = targetPosition > startPosition ? 'next' : 'prev';
		const isOutOfBound = (current, target) => {
			return dir === 'next' && current >= target || dir === 'prev' && current <= target;
		};
		const animate = () => {
			time = new Date().getTime();
			if (startTime === null) {
				startTime = time;
			}
			const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
			const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
			let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
			if (isOutOfBound(currentPosition, targetPosition)) {
				currentPosition = targetPosition;
			}
			swiper.wrapperEl.scrollTo({
				[side]: currentPosition
			});
			if (isOutOfBound(currentPosition, targetPosition)) {
				swiper.wrapperEl.style.overflow = 'hidden';
				swiper.wrapperEl.style.scrollSnapType = '';
				setTimeout(() => {
					swiper.wrapperEl.style.overflow = '';
					swiper.wrapperEl.scrollTo({
						[side]: currentPosition
					});
				});
				window.cancelAnimationFrame(swiper.cssModeFrameID);
				return;
			}
			swiper.cssModeFrameID = window.requestAnimationFrame(animate);
		};
		animate();
	}
	let support;

	function calcSupport() {
		const window = getWindow();
		const document = getDocument();
		return {
			smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
			touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
			passiveListener: function checkPassiveListener() {
				let supportsPassive = false;
				try {
					const opts = Object.defineProperty({}, 'passive', {
						// eslint-disable-next-line
						get() {
							supportsPassive = true;
						}
					});
					window.addEventListener('testPassiveListener', null, opts);
				} catch (e) { // No support
				}
				return supportsPassive;
			}(),
			gestures: function checkGestures() {
				return 'ongesturestart' in window;
			}()
		};
	}

	function getSupport() {
		if (!support) {
			support = calcSupport();
		}
		return support;
	}
	let deviceCached;

	function calcDevice(_temp) {
		let {
			userAgent
		} = _temp === void 0 ? {} : _temp;
		const support = getSupport();
		const window = getWindow();
		const platform = window.navigator.platform;
		const ua = userAgent || window.navigator.userAgent;
		const device = {
			ios: false,
			android: false
		};
		const screenWidth = window.screen.width;
		const screenHeight = window.screen.height;
		const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
		let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
		const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
		const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
		const windows = platform === 'Win32';
		let macos = platform === 'MacIntel'; // iPadOs 13 fix
		const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
		if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
			ipad = ua.match(/(Version)\/([\d.]+)/);
			if (!ipad) ipad = [0, 1, '13_0_0'];
			macos = false;
		} // Android
		if (android && !windows) {
			device.os = 'android';
			device.android = true;
		}
		if (ipad || iphone || ipod) {
			device.os = 'ios';
			device.ios = true;
		} // Export object
		return device;
	}

	function getDevice(overrides) {
		if (overrides === void 0) {
			overrides = {};
		}
		if (!deviceCached) {
			deviceCached = calcDevice(overrides);
		}
		return deviceCached;
	}
	let browser;

	function calcBrowser() {
		const window = getWindow();

		function isSafari() {
			const ua = window.navigator.userAgent.toLowerCase();
			return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
		}
		return {
			isSafari: isSafari(),
			isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
		};
	}

	function getBrowser() {
		if (!browser) {
			browser = calcBrowser();
		}
		return browser;
	}

	function Resize(_ref) {
		let {
			swiper,
			on,
			emit
		} = _ref;
		const window = getWindow();
		let observer = null;
		let animationFrame = null;
		const resizeHandler = () => {
			if (!swiper || swiper.destroyed || !swiper.initialized) return;
			emit('beforeResize');
			emit('resize');
		};
		const createObserver = () => {
			if (!swiper || swiper.destroyed || !swiper.initialized) return;
			observer = new ResizeObserver(entries => {
				animationFrame = window.requestAnimationFrame(() => {
					const {
						width,
						height
					} = swiper;
					let newWidth = width;
					let newHeight = height;
					entries.forEach(_ref2 => {
						let {
							contentBoxSize,
							contentRect,
							target
						} = _ref2;
						if (target && target !== swiper.el) return;
						newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
						newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
					});
					if (newWidth !== width || newHeight !== height) {
						resizeHandler();
					}
				});
			});
			observer.observe(swiper.el);
		};
		const removeObserver = () => {
			if (animationFrame) {
				window.cancelAnimationFrame(animationFrame);
			}
			if (observer && observer.unobserve && swiper.el) {
				observer.unobserve(swiper.el);
				observer = null;
			}
		};
		const orientationChangeHandler = () => {
			if (!swiper || swiper.destroyed || !swiper.initialized) return;
			emit('orientationchange');
		};
		on('init', () => {
			if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
				createObserver();
				return;
			}
			window.addEventListener('resize', resizeHandler);
			window.addEventListener('orientationchange', orientationChangeHandler);
		});
		on('destroy', () => {
			removeObserver();
			window.removeEventListener('resize', resizeHandler);
			window.removeEventListener('orientationchange', orientationChangeHandler);
		});
	}

	function Observer(_ref) {
		let {
			swiper,
			extendParams,
			on,
			emit
		} = _ref;
		const observers = [];
		const window = getWindow();
		const attach = function(target, options) {
			if (options === void 0) {
				options = {};
			}
			const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
			const observer = new ObserverFunc(mutations => {
				// The observerUpdate event should only be triggered
				// once despite the number of mutations.  Additional
				// triggers are redundant and are very costly
				if (mutations.length === 1) {
					emit('observerUpdate', mutations[0]);
					return;
				}
				const observerUpdate = function observerUpdate() {
					emit('observerUpdate', mutations[0]);
				};
				if (window.requestAnimationFrame) {
					window.requestAnimationFrame(observerUpdate);
				} else {
					window.setTimeout(observerUpdate, 0);
				}
			});
			observer.observe(target, {
				attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
				childList: typeof options.childList === 'undefined' ? true : options.childList,
				characterData: typeof options.characterData === 'undefined' ? true : options.characterData
			});
			observers.push(observer);
		};
		const init = () => {
			if (!swiper.params.observer) return;
			if (swiper.params.observeParents) {
				const containerParents = swiper.$el.parents();
				for (let i = 0; i < containerParents.length; i += 1) {
					attach(containerParents[i]);
				}
			} // Observe container
			attach(swiper.$el[0], {
				childList: swiper.params.observeSlideChildren
			}); // Observe wrapper
			attach(swiper.$wrapperEl[0], {
				attributes: false
			});
		};
		const destroy = () => {
			observers.forEach(observer => {
				observer.disconnect();
			});
			observers.splice(0, observers.length);
		};
		extendParams({
			observer: false,
			observeParents: false,
			observeSlideChildren: false
		});
		on('init', init);
		on('destroy', destroy);
	}
	/* eslint-disable no-underscore-dangle */
	var eventsEmitter = {
		on(events, handler, priority) {
			const self = this;
			if (!self.eventsListeners || self.destroyed) return self;
			if (typeof handler !== 'function') return self;
			const method = priority ? 'unshift' : 'push';
			events.split(' ').forEach(event => {
				if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
				self.eventsListeners[event][method](handler);
			});
			return self;
		},
		once(events, handler, priority) {
			const self = this;
			if (!self.eventsListeners || self.destroyed) return self;
			if (typeof handler !== 'function') return self;

			function onceHandler() {
				self.off(events, onceHandler);
				if (onceHandler.__emitterProxy) {
					delete onceHandler.__emitterProxy;
				}
				for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}
				handler.apply(self, args);
			}
			onceHandler.__emitterProxy = handler;
			return self.on(events, onceHandler, priority);
		},
		onAny(handler, priority) {
			const self = this;
			if (!self.eventsListeners || self.destroyed) return self;
			if (typeof handler !== 'function') return self;
			const method = priority ? 'unshift' : 'push';
			if (self.eventsAnyListeners.indexOf(handler) < 0) {
				self.eventsAnyListeners[method](handler);
			}
			return self;
		},
		offAny(handler) {
			const self = this;
			if (!self.eventsListeners || self.destroyed) return self;
			if (!self.eventsAnyListeners) return self;
			const index = self.eventsAnyListeners.indexOf(handler);
			if (index >= 0) {
				self.eventsAnyListeners.splice(index, 1);
			}
			return self;
		},
		off(events, handler) {
			const self = this;
			if (!self.eventsListeners || self.destroyed) return self;
			if (!self.eventsListeners) return self;
			events.split(' ').forEach(event => {
				if (typeof handler === 'undefined') {
					self.eventsListeners[event] = [];
				} else if (self.eventsListeners[event]) {
					self.eventsListeners[event].forEach((eventHandler, index) => {
						if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
							self.eventsListeners[event].splice(index, 1);
						}
					});
				}
			});
			return self;
		},
		emit() {
			const self = this;
			if (!self.eventsListeners || self.destroyed) return self;
			if (!self.eventsListeners) return self;
			let events;
			let data;
			let context;
			for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				args[_key2] = arguments[_key2];
			}
			if (typeof args[0] === 'string' || Array.isArray(args[0])) {
				events = args[0];
				data = args.slice(1, args.length);
				context = self;
			} else {
				events = args[0].events;
				data = args[0].data;
				context = args[0].context || self;
			}
			data.unshift(context);
			const eventsArray = Array.isArray(events) ? events : events.split(' ');
			eventsArray.forEach(event => {
				if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
					self.eventsAnyListeners.forEach(eventHandler => {
						eventHandler.apply(context, [event, ...data]);
					});
				}
				if (self.eventsListeners && self.eventsListeners[event]) {
					self.eventsListeners[event].forEach(eventHandler => {
						eventHandler.apply(context, data);
					});
				}
			});
			return self;
		}
	};

	function updateSize() {
		const swiper = this;
		let width;
		let height;
		const $el = swiper.$el;
		if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
			width = swiper.params.width;
		} else {
			width = $el[0].clientWidth;
		}
		if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
			height = swiper.params.height;
		} else {
			height = $el[0].clientHeight;
		}
		if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
			return;
		} // Subtract paddings
		width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
		height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
		if (Number.isNaN(width)) width = 0;
		if (Number.isNaN(height)) height = 0;
		Object.assign(swiper, {
			width,
			height,
			size: swiper.isHorizontal() ? width : height
		});
	}

	function updateSlides() {
		const swiper = this;

		function getDirectionLabel(property) {
			if (swiper.isHorizontal()) {
				return property;
			} // prettier-ignore
			return {
				'width': 'height',
				'margin-top': 'margin-left',
				'margin-bottom ': 'margin-right',
				'margin-left': 'margin-top',
				'margin-right': 'margin-bottom',
				'padding-left': 'padding-top',
				'padding-right': 'padding-bottom',
				'marginRight': 'marginBottom'
			} [property];
		}

		function getDirectionPropertyValue(node, label) {
			return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
		}
		const params = swiper.params;
		const {
			$wrapperEl,
			size: swiperSize,
			rtlTranslate: rtl,
			wrongRTL
		} = swiper;
		const isVirtual = swiper.virtual && params.virtual.enabled;
		const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
		const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
		const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
		let snapGrid = [];
		const slidesGrid = [];
		const slidesSizesGrid = [];
		let offsetBefore = params.slidesOffsetBefore;
		if (typeof offsetBefore === 'function') {
			offsetBefore = params.slidesOffsetBefore.call(swiper);
		}
		let offsetAfter = params.slidesOffsetAfter;
		if (typeof offsetAfter === 'function') {
			offsetAfter = params.slidesOffsetAfter.call(swiper);
		}
		const previousSnapGridLength = swiper.snapGrid.length;
		const previousSlidesGridLength = swiper.slidesGrid.length;
		let spaceBetween = params.spaceBetween;
		let slidePosition = -offsetBefore;
		let prevSlideSize = 0;
		let index = 0;
		if (typeof swiperSize === 'undefined') {
			return;
		}
		if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
			spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
		}
		swiper.virtualSize = -spaceBetween; // reset margins
		if (rtl) slides.css({
			marginLeft: '',
			marginBottom: '',
			marginTop: ''
		});
		else slides.css({
			marginRight: '',
			marginBottom: '',
			marginTop: ''
		}); // reset cssMode offsets
		if (params.centeredSlides && params.cssMode) {
			setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');
			setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');
		}
		const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
		if (gridEnabled) {
			swiper.grid.initSlides(slidesLength);
		} // Calc slides
		let slideSize;
		const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
			return typeof params.breakpoints[key].slidesPerView !== 'undefined';
		}).length > 0;
		for (let i = 0; i < slidesLength; i += 1) {
			slideSize = 0;
			const slide = slides.eq(i);
			if (gridEnabled) {
				swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
			}
			if (slide.css('display') === 'none') continue; // eslint-disable-line
			if (params.slidesPerView === 'auto') {
				if (shouldResetSlideSize) {
					slides[i].style[getDirectionLabel('width')] = ``;
				}
				const slideStyles = getComputedStyle(slide[0]);
				const currentTransform = slide[0].style.transform;
				const currentWebKitTransform = slide[0].style.webkitTransform;
				if (currentTransform) {
					slide[0].style.transform = 'none';
				}
				if (currentWebKitTransform) {
					slide[0].style.webkitTransform = 'none';
				}
				if (params.roundLengths) {
					slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
				} else {
					// eslint-disable-next-line
					const width = getDirectionPropertyValue(slideStyles, 'width');
					const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
					const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
					const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
					const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
					const boxSizing = slideStyles.getPropertyValue('box-sizing');
					if (boxSizing && boxSizing === 'border-box') {
						slideSize = width + marginLeft + marginRight;
					} else {
						const {
							clientWidth,
							offsetWidth
						} = slide[0];
						slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
					}
				}
				if (currentTransform) {
					slide[0].style.transform = currentTransform;
				}
				if (currentWebKitTransform) {
					slide[0].style.webkitTransform = currentWebKitTransform;
				}
				if (params.roundLengths) slideSize = Math.floor(slideSize);
			} else {
				slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
				if (params.roundLengths) slideSize = Math.floor(slideSize);
				if (slides[i]) {
					slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
				}
			}
			if (slides[i]) {
				slides[i].swiperSlideSize = slideSize;
			}
			slidesSizesGrid.push(slideSize);
			if (params.centeredSlides) {
				slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
				if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
				if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
				if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
				if (params.roundLengths) slidePosition = Math.floor(slidePosition);
				if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
				slidesGrid.push(slidePosition);
			} else {
				if (params.roundLengths) slidePosition = Math.floor(slidePosition);
				if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
				slidesGrid.push(slidePosition);
				slidePosition = slidePosition + slideSize + spaceBetween;
			}
			swiper.virtualSize += slideSize + spaceBetween;
			prevSlideSize = slideSize;
			index += 1;
		}
		swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
		if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
			$wrapperEl.css({
				width: `${swiper.virtualSize + params.spaceBetween}px`
			});
		}
		if (params.setWrapperSize) {
			$wrapperEl.css({
				[getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`
			});
		}
		if (gridEnabled) {
			swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
		} // Remove last grid elements depending on width
		if (!params.centeredSlides) {
			const newSlidesGrid = [];
			for (let i = 0; i < snapGrid.length; i += 1) {
				let slidesGridItem = snapGrid[i];
				if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
				if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
					newSlidesGrid.push(slidesGridItem);
				}
			}
			snapGrid = newSlidesGrid;
			if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
				snapGrid.push(swiper.virtualSize - swiperSize);
			}
		}
		if (snapGrid.length === 0) snapGrid = [0];
		if (params.spaceBetween !== 0) {
			const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
			slides.filter((_, slideIndex) => {
				if (!params.cssMode) return true;
				if (slideIndex === slides.length - 1) {
					return false;
				}
				return true;
			}).css({
				[key]: `${spaceBetween}px`
			});
		}
		if (params.centeredSlides && params.centeredSlidesBounds) {
			let allSlidesSize = 0;
			slidesSizesGrid.forEach(slideSizeValue => {
				allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
			});
			allSlidesSize -= params.spaceBetween;
			const maxSnap = allSlidesSize - swiperSize;
			snapGrid = snapGrid.map(snap => {
				if (snap < 0) return -offsetBefore;
				if (snap > maxSnap) return maxSnap + offsetAfter;
				return snap;
			});
		}
		if (params.centerInsufficientSlides) {
			let allSlidesSize = 0;
			slidesSizesGrid.forEach(slideSizeValue => {
				allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
			});
			allSlidesSize -= params.spaceBetween;
			if (allSlidesSize < swiperSize) {
				const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
				snapGrid.forEach((snap, snapIndex) => {
					snapGrid[snapIndex] = snap - allSlidesOffset;
				});
				slidesGrid.forEach((snap, snapIndex) => {
					slidesGrid[snapIndex] = snap + allSlidesOffset;
				});
			}
		}
		Object.assign(swiper, {
			slides,
			snapGrid,
			slidesGrid,
			slidesSizesGrid
		});
		if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
			setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
			setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
			const addToSnapGrid = -swiper.snapGrid[0];
			const addToSlidesGrid = -swiper.slidesGrid[0];
			swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
			swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
		}
		if (slidesLength !== previousSlidesLength) {
			swiper.emit('slidesLengthChange');
		}
		if (snapGrid.length !== previousSnapGridLength) {
			if (swiper.params.watchOverflow) swiper.checkOverflow();
			swiper.emit('snapGridLengthChange');
		}
		if (slidesGrid.length !== previousSlidesGridLength) {
			swiper.emit('slidesGridLengthChange');
		}
		if (params.watchSlidesProgress) {
			swiper.updateSlidesOffset();
		}
		if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
			const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
			const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);
			if (slidesLength <= params.maxBackfaceHiddenSlides) {
				if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);
			} else if (hasClassBackfaceClassAdded) {
				swiper.$el.removeClass(backFaceHiddenClass);
			}
		}
	}

	function updateAutoHeight(speed) {
		const swiper = this;
		const activeSlides = [];
		const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
		let newHeight = 0;
		let i;
		if (typeof speed === 'number') {
			swiper.setTransition(speed);
		} else if (speed === true) {
			swiper.setTransition(swiper.params.speed);
		}
		const getSlideByIndex = index => {
			if (isVirtual) {
				return swiper.slides.filter(el => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index)[0];
			}
			return swiper.slides.eq(index)[0];
		}; // Find slides currently in view
		if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
			if (swiper.params.centeredSlides) {
				(swiper.visibleSlides || $([])).each(slide => {
					activeSlides.push(slide);
				});
			} else {
				for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
					const index = swiper.activeIndex + i;
					if (index > swiper.slides.length && !isVirtual) break;
					activeSlides.push(getSlideByIndex(index));
				}
			}
		} else {
			activeSlides.push(getSlideByIndex(swiper.activeIndex));
		} // Find new height from highest slide in view
		for (i = 0; i < activeSlides.length; i += 1) {
			if (typeof activeSlides[i] !== 'undefined') {
				const height = activeSlides[i].offsetHeight;
				newHeight = height > newHeight ? height : newHeight;
			}
		} // Update Height
		if (newHeight || newHeight === 0) swiper.$wrapperEl.css('height', `${newHeight}px`);
	}

	function updateSlidesOffset() {
		const swiper = this;
		const slides = swiper.slides;
		for (let i = 0; i < slides.length; i += 1) {
			slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
		}
	}

	function updateSlidesProgress(translate) {
		if (translate === void 0) {
			translate = this && this.translate || 0;
		}
		const swiper = this;
		const params = swiper.params;
		const {
			slides,
			rtlTranslate: rtl,
			snapGrid
		} = swiper;
		if (slides.length === 0) return;
		if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
		let offsetCenter = -translate;
		if (rtl) offsetCenter = translate; // Visible Slides
		slides.removeClass(params.slideVisibleClass);
		swiper.visibleSlidesIndexes = [];
		swiper.visibleSlides = [];
		for (let i = 0; i < slides.length; i += 1) {
			const slide = slides[i];
			let slideOffset = slide.swiperSlideOffset;
			if (params.cssMode && params.centeredSlides) {
				slideOffset -= slides[0].swiperSlideOffset;
			}
			const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
			const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
			const slideBefore = -(offsetCenter - slideOffset);
			const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
			const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
			if (isVisible) {
				swiper.visibleSlides.push(slide);
				swiper.visibleSlidesIndexes.push(i);
				slides.eq(i).addClass(params.slideVisibleClass);
			}
			slide.progress = rtl ? -slideProgress : slideProgress;
			slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
		}
		swiper.visibleSlides = $(swiper.visibleSlides);
	}

	function updateProgress(translate) {
		const swiper = this;
		if (typeof translate === 'undefined') {
			const multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line
			translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
		}
		const params = swiper.params;
		const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
		let {
			progress,
			isBeginning,
			isEnd
		} = swiper;
		const wasBeginning = isBeginning;
		const wasEnd = isEnd;
		if (translatesDiff === 0) {
			progress = 0;
			isBeginning = true;
			isEnd = true;
		} else {
			progress = (translate - swiper.minTranslate()) / translatesDiff;
			isBeginning = progress <= 0;
			isEnd = progress >= 1;
		}
		Object.assign(swiper, {
			progress,
			isBeginning,
			isEnd
		});
		if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
		if (isBeginning && !wasBeginning) {
			swiper.emit('reachBeginning toEdge');
		}
		if (isEnd && !wasEnd) {
			swiper.emit('reachEnd toEdge');
		}
		if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
			swiper.emit('fromEdge');
		}
		swiper.emit('progress', progress);
	}

	function updateSlidesClasses() {
		const swiper = this;
		const {
			slides,
			params,
			$wrapperEl,
			activeIndex,
			realIndex
		} = swiper;
		const isVirtual = swiper.virtual && params.virtual.enabled;
		slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
		let activeSlide;
		if (isVirtual) {
			activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
		} else {
			activeSlide = slides.eq(activeIndex);
		} // Active classes
		activeSlide.addClass(params.slideActiveClass);
		if (params.loop) {
			// Duplicate to all looped slides
			if (activeSlide.hasClass(params.slideDuplicateClass)) {
				$wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
			} else {
				$wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
			}
		} // Next Slide
		let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
		if (params.loop && nextSlide.length === 0) {
			nextSlide = slides.eq(0);
			nextSlide.addClass(params.slideNextClass);
		} // Prev Slide
		let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
		if (params.loop && prevSlide.length === 0) {
			prevSlide = slides.eq(-1);
			prevSlide.addClass(params.slidePrevClass);
		}
		if (params.loop) {
			// Duplicate to all looped slides
			if (nextSlide.hasClass(params.slideDuplicateClass)) {
				$wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
			} else {
				$wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
			}
			if (prevSlide.hasClass(params.slideDuplicateClass)) {
				$wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
			} else {
				$wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
			}
		}
		swiper.emitSlidesClasses();
	}

	function updateActiveIndex(newActiveIndex) {
		const swiper = this;
		const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
		const {
			slidesGrid,
			snapGrid,
			params,
			activeIndex: previousIndex,
			realIndex: previousRealIndex,
			snapIndex: previousSnapIndex
		} = swiper;
		let activeIndex = newActiveIndex;
		let snapIndex;
		if (typeof activeIndex === 'undefined') {
			for (let i = 0; i < slidesGrid.length; i += 1) {
				if (typeof slidesGrid[i + 1] !== 'undefined') {
					if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
						activeIndex = i;
					} else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
						activeIndex = i + 1;
					}
				} else if (translate >= slidesGrid[i]) {
					activeIndex = i;
				}
			} // Normalize slideIndex
			if (params.normalizeSlideIndex) {
				if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
			}
		}
		if (snapGrid.indexOf(translate) >= 0) {
			snapIndex = snapGrid.indexOf(translate);
		} else {
			const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
			snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
		}
		if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
		if (activeIndex === previousIndex) {
			if (snapIndex !== previousSnapIndex) {
				swiper.snapIndex = snapIndex;
				swiper.emit('snapIndexChange');
			}
			return;
		} // Get real index
		const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
		Object.assign(swiper, {
			snapIndex,
			realIndex,
			previousIndex,
			activeIndex
		});
		swiper.emit('activeIndexChange');
		swiper.emit('snapIndexChange');
		if (previousRealIndex !== realIndex) {
			swiper.emit('realIndexChange');
		}
		if (swiper.initialized || swiper.params.runCallbacksOnInit) {
			swiper.emit('slideChange');
		}
	}

	function updateClickedSlide(e) {
		const swiper = this;
		const params = swiper.params;
		const slide = $(e).closest(`.${params.slideClass}`)[0];
		let slideFound = false;
		let slideIndex;
		if (slide) {
			for (let i = 0; i < swiper.slides.length; i += 1) {
				if (swiper.slides[i] === slide) {
					slideFound = true;
					slideIndex = i;
					break;
				}
			}
		}
		if (slide && slideFound) {
			swiper.clickedSlide = slide;
			if (swiper.virtual && swiper.params.virtual.enabled) {
				swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
			} else {
				swiper.clickedIndex = slideIndex;
			}
		} else {
			swiper.clickedSlide = undefined;
			swiper.clickedIndex = undefined;
			return;
		}
		if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
			swiper.slideToClickedSlide();
		}
	}
	var update = {
		updateSize,
		updateSlides,
		updateAutoHeight,
		updateSlidesOffset,
		updateSlidesProgress,
		updateProgress,
		updateSlidesClasses,
		updateActiveIndex,
		updateClickedSlide
	};

	function getSwiperTranslate(axis) {
		if (axis === void 0) {
			axis = this.isHorizontal() ? 'x' : 'y';
		}
		const swiper = this;
		const {
			params,
			rtlTranslate: rtl,
			translate,
			$wrapperEl
		} = swiper;
		if (params.virtualTranslate) {
			return rtl ? -translate : translate;
		}
		if (params.cssMode) {
			return translate;
		}
		let currentTranslate = getTranslate($wrapperEl[0], axis);
		if (rtl) currentTranslate = -currentTranslate;
		return currentTranslate || 0;
	}

	function setTranslate(translate, byController) {
		const swiper = this;
		const {
			rtlTranslate: rtl,
			params,
			$wrapperEl,
			wrapperEl,
			progress
		} = swiper;
		let x = 0;
		let y = 0;
		const z = 0;
		if (swiper.isHorizontal()) {
			x = rtl ? -translate : translate;
		} else {
			y = translate;
		}
		if (params.roundLengths) {
			x = Math.floor(x);
			y = Math.floor(y);
		}
		if (params.cssMode) {
			wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
		} else if (!params.virtualTranslate) {
			$wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
		}
		swiper.previousTranslate = swiper.translate;
		swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress
		let newProgress;
		const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
		if (translatesDiff === 0) {
			newProgress = 0;
		} else {
			newProgress = (translate - swiper.minTranslate()) / translatesDiff;
		}
		if (newProgress !== progress) {
			swiper.updateProgress(translate);
		}
		swiper.emit('setTranslate', swiper.translate, byController);
	}

	function minTranslate() {
		return -this.snapGrid[0];
	}

	function maxTranslate() {
		return -this.snapGrid[this.snapGrid.length - 1];
	}

	function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
		if (translate === void 0) {
			translate = 0;
		}
		if (speed === void 0) {
			speed = this.params.speed;
		}
		if (runCallbacks === void 0) {
			runCallbacks = true;
		}
		if (translateBounds === void 0) {
			translateBounds = true;
		}
		const swiper = this;
		const {
			params,
			wrapperEl
		} = swiper;
		if (swiper.animating && params.preventInteractionOnTransition) {
			return false;
		}
		const minTranslate = swiper.minTranslate();
		const maxTranslate = swiper.maxTranslate();
		let newTranslate;
		if (translateBounds && translate > minTranslate) newTranslate = minTranslate;
		else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;
		else newTranslate = translate; // Update progress
		swiper.updateProgress(newTranslate);
		if (params.cssMode) {
			const isH = swiper.isHorizontal();
			if (speed === 0) {
				wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
			} else {
				if (!swiper.support.smoothScroll) {
					animateCSSModeScroll({
						swiper,
						targetPosition: -newTranslate,
						side: isH ? 'left' : 'top'
					});
					return true;
				}
				wrapperEl.scrollTo({
					[isH ? 'left' : 'top']: -newTranslate,
					behavior: 'smooth'
				});
			}
			return true;
		}
		if (speed === 0) {
			swiper.setTransition(0);
			swiper.setTranslate(newTranslate);
			if (runCallbacks) {
				swiper.emit('beforeTransitionStart', speed, internal);
				swiper.emit('transitionEnd');
			}
		} else {
			swiper.setTransition(speed);
			swiper.setTranslate(newTranslate);
			if (runCallbacks) {
				swiper.emit('beforeTransitionStart', speed, internal);
				swiper.emit('transitionStart');
			}
			if (!swiper.animating) {
				swiper.animating = true;
				if (!swiper.onTranslateToWrapperTransitionEnd) {
					swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
						if (!swiper || swiper.destroyed) return;
						if (e.target !== this) return;
						swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
						swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
						swiper.onTranslateToWrapperTransitionEnd = null;
						delete swiper.onTranslateToWrapperTransitionEnd;
						if (runCallbacks) {
							swiper.emit('transitionEnd');
						}
					};
				}
				swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
				swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
			}
		}
		return true;
	}
	var translate = {
		getTranslate: getSwiperTranslate,
		setTranslate,
		minTranslate,
		maxTranslate,
		translateTo
	};

	function setTransition(duration, byController) {
		const swiper = this;
		if (!swiper.params.cssMode) {
			swiper.$wrapperEl.transition(duration);
		}
		swiper.emit('setTransition', duration, byController);
	}

	function transitionEmit(_ref) {
		let {
			swiper,
			runCallbacks,
			direction,
			step
		} = _ref;
		const {
			activeIndex,
			previousIndex
		} = swiper;
		let dir = direction;
		if (!dir) {
			if (activeIndex > previousIndex) dir = 'next';
			else if (activeIndex < previousIndex) dir = 'prev';
			else dir = 'reset';
		}
		swiper.emit(`transition${step}`);
		if (runCallbacks && activeIndex !== previousIndex) {
			if (dir === 'reset') {
				swiper.emit(`slideResetTransition${step}`);
				return;
			}
			swiper.emit(`slideChangeTransition${step}`);
			if (dir === 'next') {
				swiper.emit(`slideNextTransition${step}`);
			} else {
				swiper.emit(`slidePrevTransition${step}`);
			}
		}
	}

	function transitionStart(runCallbacks, direction) {
		if (runCallbacks === void 0) {
			runCallbacks = true;
		}
		const swiper = this;
		const {
			params
		} = swiper;
		if (params.cssMode) return;
		if (params.autoHeight) {
			swiper.updateAutoHeight();
		}
		transitionEmit({
			swiper,
			runCallbacks,
			direction,
			step: 'Start'
		});
	}

	function transitionEnd(runCallbacks, direction) {
		if (runCallbacks === void 0) {
			runCallbacks = true;
		}
		const swiper = this;
		const {
			params
		} = swiper;
		swiper.animating = false;
		if (params.cssMode) return;
		swiper.setTransition(0);
		transitionEmit({
			swiper,
			runCallbacks,
			direction,
			step: 'End'
		});
	}
	var transition = {
		setTransition,
		transitionStart,
		transitionEnd
	};

	function slideTo(index, speed, runCallbacks, internal, initial) {
		if (index === void 0) {
			index = 0;
		}
		if (speed === void 0) {
			speed = this.params.speed;
		}
		if (runCallbacks === void 0) {
			runCallbacks = true;
		}
		if (typeof index !== 'number' && typeof index !== 'string') {
			throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
		}
		if (typeof index === 'string') {
			/**

			 * The `index` argument converted from `string` to `number`.

			 * @type {number}

			 */
			const indexAsNumber = parseInt(index, 10);
			/**

			 * Determines whether the `index` argument is a valid `number`

			 * after being converted from the `string` type.

			 * @type {boolean}

			 */
			const isValidNumber = isFinite(indexAsNumber);
			if (!isValidNumber) {
				throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
			} // Knowing that the converted `index` is a valid number,
			// we can update the original argument's value.
			index = indexAsNumber;
		}
		const swiper = this;
		let slideIndex = index;
		if (slideIndex < 0) slideIndex = 0;
		const {
			params,
			snapGrid,
			slidesGrid,
			previousIndex,
			activeIndex,
			rtlTranslate: rtl,
			wrapperEl,
			enabled
		} = swiper;
		if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
			return false;
		}
		const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
		let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
		if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
		const translate = -snapGrid[snapIndex]; // Normalize slideIndex
		if (params.normalizeSlideIndex) {
			for (let i = 0; i < slidesGrid.length; i += 1) {
				const normalizedTranslate = -Math.floor(translate * 100);
				const normalizedGrid = Math.floor(slidesGrid[i] * 100);
				const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
				if (typeof slidesGrid[i + 1] !== 'undefined') {
					if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
						slideIndex = i;
					} else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
						slideIndex = i + 1;
					}
				} else if (normalizedTranslate >= normalizedGrid) {
					slideIndex = i;
				}
			}
		} // Directions locks
		if (swiper.initialized && slideIndex !== activeIndex) {
			if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
				return false;
			}
			if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
				if ((activeIndex || 0) !== slideIndex) return false;
			}
		}
		if (slideIndex !== (previousIndex || 0) && runCallbacks) {
			swiper.emit('beforeSlideChangeStart');
		} // Update progress
		swiper.updateProgress(translate);
		let direction;
		if (slideIndex > activeIndex) direction = 'next';
		else if (slideIndex < activeIndex) direction = 'prev';
		else direction = 'reset'; // Update Index
		if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
			swiper.updateActiveIndex(slideIndex); // Update Height
			if (params.autoHeight) {
				swiper.updateAutoHeight();
			}
			swiper.updateSlidesClasses();
			if (params.effect !== 'slide') {
				swiper.setTranslate(translate);
			}
			if (direction !== 'reset') {
				swiper.transitionStart(runCallbacks, direction);
				swiper.transitionEnd(runCallbacks, direction);
			}
			return false;
		}
		if (params.cssMode) {
			const isH = swiper.isHorizontal();
			const t = rtl ? translate : -translate;
			if (speed === 0) {
				const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
				if (isVirtual) {
					swiper.wrapperEl.style.scrollSnapType = 'none';
					swiper._immediateVirtual = true;
				}
				wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
				if (isVirtual) {
					requestAnimationFrame(() => {
						swiper.wrapperEl.style.scrollSnapType = '';
						swiper._swiperImmediateVirtual = false;
					});
				}
			} else {
				if (!swiper.support.smoothScroll) {
					animateCSSModeScroll({
						swiper,
						targetPosition: t,
						side: isH ? 'left' : 'top'
					});
					return true;
				}
				wrapperEl.scrollTo({
					[isH ? 'left' : 'top']: t,
					behavior: 'smooth'
				});
			}
			return true;
		}
		swiper.setTransition(speed);
		swiper.setTranslate(translate);
		swiper.updateActiveIndex(slideIndex);
		swiper.updateSlidesClasses();
		swiper.emit('beforeTransitionStart', speed, internal);
		swiper.transitionStart(runCallbacks, direction);
		if (speed === 0) {
			swiper.transitionEnd(runCallbacks, direction);
		} else if (!swiper.animating) {
			swiper.animating = true;
			if (!swiper.onSlideToWrapperTransitionEnd) {
				swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
					if (!swiper || swiper.destroyed) return;
					if (e.target !== this) return;
					swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
					swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
					swiper.onSlideToWrapperTransitionEnd = null;
					delete swiper.onSlideToWrapperTransitionEnd;
					swiper.transitionEnd(runCallbacks, direction);
				};
			}
			swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
			swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
		}
		return true;
	}

	function slideToLoop(index, speed, runCallbacks, internal) {
		if (index === void 0) {
			index = 0;
		}
		if (speed === void 0) {
			speed = this.params.speed;
		}
		if (runCallbacks === void 0) {
			runCallbacks = true;
		}
		if (typeof index === 'string') {
			/**

			 * The `index` argument converted from `string` to `number`.

			 * @type {number}

			 */
			const indexAsNumber = parseInt(index, 10);
			/**

			 * Determines whether the `index` argument is a valid `number`

			 * after being converted from the `string` type.

			 * @type {boolean}

			 */
			const isValidNumber = isFinite(indexAsNumber);
			if (!isValidNumber) {
				throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
			} // Knowing that the converted `index` is a valid number,
			// we can update the original argument's value.
			index = indexAsNumber;
		}
		const swiper = this;
		let newIndex = index;
		if (swiper.params.loop) {
			newIndex += swiper.loopedSlides;
		}
		return swiper.slideTo(newIndex, speed, runCallbacks, internal);
	}
	/* eslint no-unused-vars: "off" */
	function slideNext(speed, runCallbacks, internal) {
		if (speed === void 0) {
			speed = this.params.speed;
		}
		if (runCallbacks === void 0) {
			runCallbacks = true;
		}
		const swiper = this;
		const {
			animating,
			enabled,
			params
		} = swiper;
		if (!enabled) return swiper;
		let perGroup = params.slidesPerGroup;
		if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
			perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
		}
		const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
		if (params.loop) {
			if (animating && params.loopPreventsSlide) return false;
			swiper.loopFix(); // eslint-disable-next-line
			swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
		}
		if (params.rewind && swiper.isEnd) {
			return swiper.slideTo(0, speed, runCallbacks, internal);
		}
		return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
	}
	/* eslint no-unused-vars: "off" */
	function slidePrev(speed, runCallbacks, internal) {
		if (speed === void 0) {
			speed = this.params.speed;
		}
		if (runCallbacks === void 0) {
			runCallbacks = true;
		}
		const swiper = this;
		const {
			params,
			animating,
			snapGrid,
			slidesGrid,
			rtlTranslate,
			enabled
		} = swiper;
		if (!enabled) return swiper;
		if (params.loop) {
			if (animating && params.loopPreventsSlide) return false;
			swiper.loopFix(); // eslint-disable-next-line
			swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
		}
		const translate = rtlTranslate ? swiper.translate : -swiper.translate;

		function normalize(val) {
			if (val < 0) return -Math.floor(Math.abs(val));
			return Math.floor(val);
		}
		const normalizedTranslate = normalize(translate);
		const normalizedSnapGrid = snapGrid.map(val => normalize(val));
		let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
		if (typeof prevSnap === 'undefined' && params.cssMode) {
			let prevSnapIndex;
			snapGrid.forEach((snap, snapIndex) => {
				if (normalizedTranslate >= snap) {
					// prevSnap = snap;
					prevSnapIndex = snapIndex;
				}
			});
			if (typeof prevSnapIndex !== 'undefined') {
				prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
			}
		}
		let prevIndex = 0;
		if (typeof prevSnap !== 'undefined') {
			prevIndex = slidesGrid.indexOf(prevSnap);
			if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
			if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
				prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
				prevIndex = Math.max(prevIndex, 0);
			}
		}
		if (params.rewind && swiper.isBeginning) {
			const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
			return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
		}
		return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
	}
	/* eslint no-unused-vars: "off" */
	function slideReset(speed, runCallbacks, internal) {
		if (speed === void 0) {
			speed = this.params.speed;
		}
		if (runCallbacks === void 0) {
			runCallbacks = true;
		}
		const swiper = this;
		return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
	}
	/* eslint no-unused-vars: "off" */
	function slideToClosest(speed, runCallbacks, internal, threshold) {
		if (speed === void 0) {
			speed = this.params.speed;
		}
		if (runCallbacks === void 0) {
			runCallbacks = true;
		}
		if (threshold === void 0) {
			threshold = 0.5;
		}
		const swiper = this;
		let index = swiper.activeIndex;
		const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
		const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
		const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
		if (translate >= swiper.snapGrid[snapIndex]) {
			// The current translate is on or after the current snap index, so the choice
			// is between the current index and the one after it.
			const currentSnap = swiper.snapGrid[snapIndex];
			const nextSnap = swiper.snapGrid[snapIndex + 1];
			if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
				index += swiper.params.slidesPerGroup;
			}
		} else {
			// The current translate is before the current snap index, so the choice
			// is between the current index and the one before it.
			const prevSnap = swiper.snapGrid[snapIndex - 1];
			const currentSnap = swiper.snapGrid[snapIndex];
			if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
				index -= swiper.params.slidesPerGroup;
			}
		}
		index = Math.max(index, 0);
		index = Math.min(index, swiper.slidesGrid.length - 1);
		return swiper.slideTo(index, speed, runCallbacks, internal);
	}

	function slideToClickedSlide() {
		const swiper = this;
		const {
			params,
			$wrapperEl
		} = swiper;
		const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
		let slideToIndex = swiper.clickedIndex;
		let realIndex;
		if (params.loop) {
			if (swiper.animating) return;
			realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
			if (params.centeredSlides) {
				if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
					swiper.loopFix();
					slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
					nextTick(() => {
						swiper.slideTo(slideToIndex);
					});
				} else {
					swiper.slideTo(slideToIndex);
				}
			} else if (slideToIndex > swiper.slides.length - slidesPerView) {
				swiper.loopFix();
				slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
				nextTick(() => {
					swiper.slideTo(slideToIndex);
				});
			} else {
				swiper.slideTo(slideToIndex);
			}
		} else {
			swiper.slideTo(slideToIndex);
		}
	}
	var slide = {
		slideTo,
		slideToLoop,
		slideNext,
		slidePrev,
		slideReset,
		slideToClosest,
		slideToClickedSlide
	};

	function loopCreate() {
		const swiper = this;
		const document = getDocument();
		const {
			params,
			$wrapperEl
		} = swiper; // Remove duplicated slides
		const $selector = $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;
		$selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
		let slides = $selector.children(`.${params.slideClass}`);
		if (params.loopFillGroupWithBlank) {
			const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
			if (blankSlidesNum !== params.slidesPerGroup) {
				for (let i = 0; i < blankSlidesNum; i += 1) {
					const blankNode = $(document.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
					$selector.append(blankNode);
				}
				slides = $selector.children(`.${params.slideClass}`);
			}
		}
		if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
		swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
		swiper.loopedSlides += params.loopAdditionalSlides;
		if (swiper.loopedSlides > slides.length && swiper.params.loopedSlidesLimit) {
			swiper.loopedSlides = slides.length;
		}
		const prependSlides = [];
		const appendSlides = [];
		slides.each((el, index) => {
			const slide = $(el);
			slide.attr('data-swiper-slide-index', index);
		});
		for (let i = 0; i < swiper.loopedSlides; i += 1) {
			const index = i - Math.floor(i / slides.length) * slides.length;
			appendSlides.push(slides.eq(index)[0]);
			prependSlides.unshift(slides.eq(slides.length - index - 1)[0]);
		}
		for (let i = 0; i < appendSlides.length; i += 1) {
			$selector.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
		}
		for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
			$selector.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
		}
	}

	function loopFix() {
		const swiper = this;
		swiper.emit('beforeLoopFix');
		const {
			activeIndex,
			slides,
			loopedSlides,
			allowSlidePrev,
			allowSlideNext,
			snapGrid,
			rtlTranslate: rtl
		} = swiper;
		let newIndex;
		swiper.allowSlidePrev = true;
		swiper.allowSlideNext = true;
		const snapTranslate = -snapGrid[activeIndex];
		const diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding
		if (activeIndex < loopedSlides) {
			newIndex = slides.length - loopedSlides * 3 + activeIndex;
			newIndex += loopedSlides;
			const slideChanged = swiper.slideTo(newIndex, 0, false, true);
			if (slideChanged && diff !== 0) {
				swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
			}
		} else if (activeIndex >= slides.length - loopedSlides) {
			// Fix For Positive Oversliding
			newIndex = -slides.length + activeIndex + loopedSlides;
			newIndex += loopedSlides;
			const slideChanged = swiper.slideTo(newIndex, 0, false, true);
			if (slideChanged && diff !== 0) {
				swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
			}
		}
		swiper.allowSlidePrev = allowSlidePrev;
		swiper.allowSlideNext = allowSlideNext;
		swiper.emit('loopFix');
	}

	function loopDestroy() {
		const swiper = this;
		const {
			$wrapperEl,
			params,
			slides
		} = swiper;
		$wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
		slides.removeAttr('data-swiper-slide-index');
	}
	var loop = {
		loopCreate,
		loopFix,
		loopDestroy
	};

	function setGrabCursor(moving) {
		const swiper = this;
		if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
		const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
		el.style.cursor = 'move';
		el.style.cursor = moving ? 'grabbing' : 'grab';
	}

	function unsetGrabCursor() {
		const swiper = this;
		if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
			return;
		}
		swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
	}
	var grabCursor = {
		setGrabCursor,
		unsetGrabCursor
	};

	function closestElement(selector, base) {
		if (base === void 0) {
			base = this;
		}

		function __closestFrom(el) {
			if (!el || el === getDocument() || el === getWindow()) return null;
			if (el.assignedSlot) el = el.assignedSlot;
			const found = el.closest(selector);
			if (!found && !el.getRootNode) {
				return null;
			}
			return found || __closestFrom(el.getRootNode().host);
		}
		return __closestFrom(base);
	}

	function onTouchStart(event) {
		const swiper = this;
		const document = getDocument();
		const window = getWindow();
		const data = swiper.touchEventsData;
		const {
			params,
			touches,
			enabled
		} = swiper;
		if (!enabled) return;
		if (swiper.animating && params.preventInteractionOnTransition) {
			return;
		}
		if (!swiper.animating && params.cssMode && params.loop) {
			swiper.loopFix();
		}
		let e = event;
		if (e.originalEvent) e = e.originalEvent;
		let $targetEl = $(e.target);
		if (params.touchEventsTarget === 'wrapper') {
			if (!$targetEl.closest(swiper.wrapperEl).length) return;
		}
		data.isTouchEvent = e.type === 'touchstart';
		if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
		if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
		if (data.isTouched && data.isMoved) return; // change target el for shadow root component
		const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== ''; // eslint-disable-next-line
		const eventPath = event.composedPath ? event.composedPath() : event.path;
		if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
			$targetEl = $(eventPath[0]);
		}
		const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
		const isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element
		if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, $targetEl[0]) : $targetEl.closest(noSwipingSelector)[0])) {
			swiper.allowClick = true;
			return;
		}
		if (params.swipeHandler) {
			if (!$targetEl.closest(params.swipeHandler)[0]) return;
		}
		touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
		touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
		const startX = touches.currentX;
		const startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore
		const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
		const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
		if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
			if (edgeSwipeDetection === 'prevent') {
				event.preventDefault();
			} else {
				return;
			}
		}
		Object.assign(data, {
			isTouched: true,
			isMoved: false,
			allowTouchCallbacks: true,
			isScrolling: undefined,
			startMoving: undefined
		});
		touches.startX = startX;
		touches.startY = startY;
		data.touchStartTime = now();
		swiper.allowClick = true;
		swiper.updateSize();
		swiper.swipeDirection = undefined;
		if (params.threshold > 0) data.allowThresholdMove = false;
		if (e.type !== 'touchstart') {
			let preventDefault = true;
			if ($targetEl.is(data.focusableElements)) {
				preventDefault = false;
				if ($targetEl[0].nodeName === 'SELECT') {
					data.isTouched = false;
				}
			}
			if (document.activeElement && $(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
				document.activeElement.blur();
			}
			const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
			if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
				e.preventDefault();
			}
		}
		if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
			swiper.freeMode.onTouchStart();
		}
		swiper.emit('touchStart', e);
	}

	function onTouchMove(event) {
		const document = getDocument();
		const swiper = this;
		const data = swiper.touchEventsData;
		const {
			params,
			touches,
			rtlTranslate: rtl,
			enabled
		} = swiper;
		if (!enabled) return;
		let e = event;
		if (e.originalEvent) e = e.originalEvent;
		if (!data.isTouched) {
			if (data.startMoving && data.isScrolling) {
				swiper.emit('touchMoveOpposite', e);
			}
			return;
		}
		if (data.isTouchEvent && e.type !== 'touchmove') return;
		const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
		const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
		const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;
		if (e.preventedByNestedSwiper) {
			touches.startX = pageX;
			touches.startY = pageY;
			return;
		}
		if (!swiper.allowTouchMove) {
			if (!$(e.target).is(data.focusableElements)) {
				swiper.allowClick = false;
			}
			if (data.isTouched) {
				Object.assign(touches, {
					startX: pageX,
					startY: pageY,
					currentX: pageX,
					currentY: pageY
				});
				data.touchStartTime = now();
			}
			return;
		}
		if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
			if (swiper.isVertical()) {
				// Vertical
				if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
					data.isTouched = false;
					data.isMoved = false;
					return;
				}
			} else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
				return;
			}
		}
		if (data.isTouchEvent && document.activeElement) {
			if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {
				data.isMoved = true;
				swiper.allowClick = false;
				return;
			}
		}
		if (data.allowTouchCallbacks) {
			swiper.emit('touchMove', e);
		}
		if (e.targetTouches && e.targetTouches.length > 1) return;
		touches.currentX = pageX;
		touches.currentY = pageY;
		const diffX = touches.currentX - touches.startX;
		const diffY = touches.currentY - touches.startY;
		if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
		if (typeof data.isScrolling === 'undefined') {
			let touchAngle;
			if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
				data.isScrolling = false;
			} else {
				// eslint-disable-next-line
				if (diffX * diffX + diffY * diffY >= 25) {
					touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
					data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
				}
			}
		}
		if (data.isScrolling) {
			swiper.emit('touchMoveOpposite', e);
		}
		if (typeof data.startMoving === 'undefined') {
			if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
				data.startMoving = true;
			}
		}
		if (data.isScrolling) {
			data.isTouched = false;
			return;
		}
		if (!data.startMoving) {
			return;
		}
		swiper.allowClick = false;
		if (!params.cssMode && e.cancelable) {
			e.preventDefault();
		}
		if (params.touchMoveStopPropagation && !params.nested) {
			e.stopPropagation();
		}
		if (!data.isMoved) {
			if (params.loop && !params.cssMode) {
				swiper.loopFix();
			}
			data.startTranslate = swiper.getTranslate();
			swiper.setTransition(0);
			if (swiper.animating) {
				swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
			}
			data.allowMomentumBounce = false; // Grab Cursor
			if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
				swiper.setGrabCursor(true);
			}
			swiper.emit('sliderFirstMove', e);
		}
		swiper.emit('sliderMove', e);
		data.isMoved = true;
		let diff = swiper.isHorizontal() ? diffX : diffY;
		touches.diff = diff;
		diff *= params.touchRatio;
		if (rtl) diff = -diff;
		swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
		data.currentTranslate = diff + data.startTranslate;
		let disableParentSwiper = true;
		let resistanceRatio = params.resistanceRatio;
		if (params.touchReleaseOnEdges) {
			resistanceRatio = 0;
		}
		if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
			disableParentSwiper = false;
			if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
		} else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
			disableParentSwiper = false;
			if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
		}
		if (disableParentSwiper) {
			e.preventedByNestedSwiper = true;
		} // Directions locks
		if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
			data.currentTranslate = data.startTranslate;
		}
		if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
			data.currentTranslate = data.startTranslate;
		}
		if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
			data.currentTranslate = data.startTranslate;
		} // Threshold
		if (params.threshold > 0) {
			if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
				if (!data.allowThresholdMove) {
					data.allowThresholdMove = true;
					touches.startX = touches.currentX;
					touches.startY = touches.currentY;
					data.currentTranslate = data.startTranslate;
					touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
					return;
				}
			} else {
				data.currentTranslate = data.startTranslate;
				return;
			}
		}
		if (!params.followFinger || params.cssMode) return; // Update active index in free mode
		if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
			swiper.updateActiveIndex();
			swiper.updateSlidesClasses();
		}
		if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
			swiper.freeMode.onTouchMove();
		} // Update progress
		swiper.updateProgress(data.currentTranslate); // Update translate
		swiper.setTranslate(data.currentTranslate);
	}

	function onTouchEnd(event) {
		const swiper = this;
		const data = swiper.touchEventsData;
		const {
			params,
			touches,
			rtlTranslate: rtl,
			slidesGrid,
			enabled
		} = swiper;
		if (!enabled) return;
		let e = event;
		if (e.originalEvent) e = e.originalEvent;
		if (data.allowTouchCallbacks) {
			swiper.emit('touchEnd', e);
		}
		data.allowTouchCallbacks = false;
		if (!data.isTouched) {
			if (data.isMoved && params.grabCursor) {
				swiper.setGrabCursor(false);
			}
			data.isMoved = false;
			data.startMoving = false;
			return;
		} // Return Grab Cursor
		if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
			swiper.setGrabCursor(false);
		} // Time diff
		const touchEndTime = now();
		const timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click
		if (swiper.allowClick) {
			const pathTree = e.path || e.composedPath && e.composedPath();
			swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
			swiper.emit('tap click', e);
			if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
				swiper.emit('doubleTap doubleClick', e);
			}
		}
		data.lastClickTime = now();
		nextTick(() => {
			if (!swiper.destroyed) swiper.allowClick = true;
		});
		if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
			data.isTouched = false;
			data.isMoved = false;
			data.startMoving = false;
			return;
		}
		data.isTouched = false;
		data.isMoved = false;
		data.startMoving = false;
		let currentPos;
		if (params.followFinger) {
			currentPos = rtl ? swiper.translate : -swiper.translate;
		} else {
			currentPos = -data.currentTranslate;
		}
		if (params.cssMode) {
			return;
		}
		if (swiper.params.freeMode && params.freeMode.enabled) {
			swiper.freeMode.onTouchEnd({
				currentPos
			});
			return;
		} // Find current slide
		let stopIndex = 0;
		let groupSize = swiper.slidesSizesGrid[0];
		for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
			const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
			if (typeof slidesGrid[i + increment] !== 'undefined') {
				if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
					stopIndex = i;
					groupSize = slidesGrid[i + increment] - slidesGrid[i];
				}
			} else if (currentPos >= slidesGrid[i]) {
				stopIndex = i;
				groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
			}
		}
		let rewindFirstIndex = null;
		let rewindLastIndex = null;
		if (params.rewind) {
			if (swiper.isBeginning) {
				rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
			} else if (swiper.isEnd) {
				rewindFirstIndex = 0;
			}
		} // Find current slide size
		const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
		const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
		if (timeDiff > params.longSwipesMs) {
			// Long touches
			if (!params.longSwipes) {
				swiper.slideTo(swiper.activeIndex);
				return;
			}
			if (swiper.swipeDirection === 'next') {
				if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
				else swiper.slideTo(stopIndex);
			}
			if (swiper.swipeDirection === 'prev') {
				if (ratio > 1 - params.longSwipesRatio) {
					swiper.slideTo(stopIndex + increment);
				} else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
					swiper.slideTo(rewindLastIndex);
				} else {
					swiper.slideTo(stopIndex);
				}
			}
		} else {
			// Short swipes
			if (!params.shortSwipes) {
				swiper.slideTo(swiper.activeIndex);
				return;
			}
			const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
			if (!isNavButtonTarget) {
				if (swiper.swipeDirection === 'next') {
					swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
				}
				if (swiper.swipeDirection === 'prev') {
					swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
				}
			} else if (e.target === swiper.navigation.nextEl) {
				swiper.slideTo(stopIndex + increment);
			} else {
				swiper.slideTo(stopIndex);
			}
		}
	}

	function onResize() {
		const swiper = this;
		const {
			params,
			el
		} = swiper;
		if (el && el.offsetWidth === 0) return; // Breakpoints
		if (params.breakpoints) {
			swiper.setBreakpoint();
		} // Save locks
		const {
			allowSlideNext,
			allowSlidePrev,
			snapGrid
		} = swiper; // Disable locks on resize
		swiper.allowSlideNext = true;
		swiper.allowSlidePrev = true;
		swiper.updateSize();
		swiper.updateSlides();
		swiper.updateSlidesClasses();
		if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
			swiper.slideTo(swiper.slides.length - 1, 0, false, true);
		} else {
			swiper.slideTo(swiper.activeIndex, 0, false, true);
		}
		if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
			swiper.autoplay.run();
		} // Return locks after resize
		swiper.allowSlidePrev = allowSlidePrev;
		swiper.allowSlideNext = allowSlideNext;
		if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
			swiper.checkOverflow();
		}
	}

	function onClick(e) {
		const swiper = this;
		if (!swiper.enabled) return;
		if (!swiper.allowClick) {
			if (swiper.params.preventClicks) e.preventDefault();
			if (swiper.params.preventClicksPropagation && swiper.animating) {
				e.stopPropagation();
				e.stopImmediatePropagation();
			}
		}
	}

	function onScroll() {
		const swiper = this;
		const {
			wrapperEl,
			rtlTranslate,
			enabled
		} = swiper;
		if (!enabled) return;
		swiper.previousTranslate = swiper.translate;
		if (swiper.isHorizontal()) {
			swiper.translate = -wrapperEl.scrollLeft;
		} else {
			swiper.translate = -wrapperEl.scrollTop;
		} // eslint-disable-next-line
		if (swiper.translate === 0) swiper.translate = 0;
		swiper.updateActiveIndex();
		swiper.updateSlidesClasses();
		let newProgress;
		const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
		if (translatesDiff === 0) {
			newProgress = 0;
		} else {
			newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
		}
		if (newProgress !== swiper.progress) {
			swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
		}
		swiper.emit('setTranslate', swiper.translate, false);
	}
	let dummyEventAttached = false;

	function dummyEventListener() {}
	const events = (swiper, method) => {
		const document = getDocument();
		const {
			params,
			touchEvents,
			el,
			wrapperEl,
			device,
			support
		} = swiper;
		const capture = !!params.nested;
		const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
		const swiperMethod = method; // Touch Events
		if (!support.touch) {
			el[domMethod](touchEvents.start, swiper.onTouchStart, false);
			document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
			document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
		} else {
			const passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
				passive: true,
				capture: false
			} : false;
			el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
			el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
				passive: false,
				capture
			} : capture);
			el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);
			if (touchEvents.cancel) {
				el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
			}
		} // Prevent Links Clicks
		if (params.preventClicks || params.preventClicksPropagation) {
			el[domMethod]('click', swiper.onClick, true);
		}
		if (params.cssMode) {
			wrapperEl[domMethod]('scroll', swiper.onScroll);
		} // Resize handler
		if (params.updateOnWindowResize) {
			swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
		} else {
			swiper[swiperMethod]('observerUpdate', onResize, true);
		}
	};

	function attachEvents() {
		const swiper = this;
		const document = getDocument();
		const {
			params,
			support
		} = swiper;
		swiper.onTouchStart = onTouchStart.bind(swiper);
		swiper.onTouchMove = onTouchMove.bind(swiper);
		swiper.onTouchEnd = onTouchEnd.bind(swiper);
		if (params.cssMode) {
			swiper.onScroll = onScroll.bind(swiper);
		}
		swiper.onClick = onClick.bind(swiper);
		if (support.touch && !dummyEventAttached) {
			document.addEventListener('touchstart', dummyEventListener);
			dummyEventAttached = true;
		}
		events(swiper, 'on');
	}

	function detachEvents() {
		const swiper = this;
		events(swiper, 'off');
	}
	var events$1 = {
		attachEvents,
		detachEvents
	};
	const isGridEnabled = (swiper, params) => {
		return swiper.grid && params.grid && params.grid.rows > 1;
	};

	function setBreakpoint() {
		const swiper = this;
		const {
			activeIndex,
			initialized,
			loopedSlides = 0,
			params,
			$el
		} = swiper;
		const breakpoints = params.breakpoints;
		if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters
		const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
		if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
		const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
		const breakpointParams = breakpointOnlyParams || swiper.originalParams;
		const wasMultiRow = isGridEnabled(swiper, params);
		const isMultiRow = isGridEnabled(swiper, breakpointParams);
		const wasEnabled = params.enabled;
		if (wasMultiRow && !isMultiRow) {
			$el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
			swiper.emitContainerClasses();
		} else if (!wasMultiRow && isMultiRow) {
			$el.addClass(`${params.containerModifierClass}grid`);
			if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
				$el.addClass(`${params.containerModifierClass}grid-column`);
			}
			swiper.emitContainerClasses();
		} // Toggle navigation, pagination, scrollbar
		['navigation', 'pagination', 'scrollbar'].forEach(prop => {
			const wasModuleEnabled = params[prop] && params[prop].enabled;
			const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
			if (wasModuleEnabled && !isModuleEnabled) {
				swiper[prop].disable();
			}
			if (!wasModuleEnabled && isModuleEnabled) {
				swiper[prop].enable();
			}
		});
		const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
		const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
		if (directionChanged && initialized) {
			swiper.changeDirection();
		}
		extend(swiper.params, breakpointParams);
		const isEnabled = swiper.params.enabled;
		Object.assign(swiper, {
			allowTouchMove: swiper.params.allowTouchMove,
			allowSlideNext: swiper.params.allowSlideNext,
			allowSlidePrev: swiper.params.allowSlidePrev
		});
		if (wasEnabled && !isEnabled) {
			swiper.disable();
		} else if (!wasEnabled && isEnabled) {
			swiper.enable();
		}
		swiper.currentBreakpoint = breakpoint;
		swiper.emit('_beforeBreakpoint', breakpointParams);
		if (needsReLoop && initialized) {
			swiper.loopDestroy();
			swiper.loopCreate();
			swiper.updateSlides();
			swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
		}
		swiper.emit('breakpoint', breakpointParams);
	}

	function getBreakpoint(breakpoints, base, containerEl) {
		if (base === void 0) {
			base = 'window';
		}
		if (!breakpoints || base === 'container' && !containerEl) return undefined;
		let breakpoint = false;
		const window = getWindow();
		const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
		const points = Object.keys(breakpoints).map(point => {
			if (typeof point === 'string' && point.indexOf('@') === 0) {
				const minRatio = parseFloat(point.substr(1));
				const value = currentHeight * minRatio;
				return {
					value,
					point
				};
			}
			return {
				value: point,
				point
			};
		});
		points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
		for (let i = 0; i < points.length; i += 1) {
			const {
				point,
				value
			} = points[i];
			if (base === 'window') {
				if (window.matchMedia(`(min-width: ${value}px)`).matches) {
					breakpoint = point;
				}
			} else if (value <= containerEl.clientWidth) {
				breakpoint = point;
			}
		}
		return breakpoint || 'max';
	}
	var breakpoints = {
		setBreakpoint,
		getBreakpoint
	};

	function prepareClasses(entries, prefix) {
		const resultClasses = [];
		entries.forEach(item => {
			if (typeof item === 'object') {
				Object.keys(item).forEach(classNames => {
					if (item[classNames]) {
						resultClasses.push(prefix + classNames);
					}
				});
			} else if (typeof item === 'string') {
				resultClasses.push(prefix + item);
			}
		});
		return resultClasses;
	}

	function addClasses() {
		const swiper = this;
		const {
			classNames,
			params,
			rtl,
			$el,
			device,
			support
		} = swiper; // prettier-ignore
		const suffixes = prepareClasses(['initialized', params.direction, {
			'pointer-events': !support.touch
		}, {
			'free-mode': swiper.params.freeMode && params.freeMode.enabled
		}, {
			'autoheight': params.autoHeight
		}, {
			'rtl': rtl
		}, {
			'grid': params.grid && params.grid.rows > 1
		}, {
			'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
		}, {
			'android': device.android
		}, {
			'ios': device.ios
		}, {
			'css-mode': params.cssMode
		}, {
			'centered': params.cssMode && params.centeredSlides
		}, {
			'watch-progress': params.watchSlidesProgress
		}], params.containerModifierClass);
		classNames.push(...suffixes);
		$el.addClass([...classNames].join(' '));
		swiper.emitContainerClasses();
	}

	function removeClasses() {
		const swiper = this;
		const {
			$el,
			classNames
		} = swiper;
		$el.removeClass(classNames.join(' '));
		swiper.emitContainerClasses();
	}
	var classes = {
		addClasses,
		removeClasses
	};

	function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
		const window = getWindow();
		let image;

		function onReady() {
			if (callback) callback();
		}
		const isPicture = $(imageEl).parent('picture')[0];
		if (!isPicture && (!imageEl.complete || !checkForComplete)) {
			if (src) {
				image = new window.Image();
				image.onload = onReady;
				image.onerror = onReady;
				if (sizes) {
					image.sizes = sizes;
				}
				if (srcset) {
					image.srcset = srcset;
				}
				if (src) {
					image.src = src;
				}
			} else {
				onReady();
			}
		} else {
			// image already loaded...
			onReady();
		}
	}

	function preloadImages() {
		const swiper = this;
		swiper.imagesToLoad = swiper.$el.find('img');

		function onReady() {
			if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
			if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
			if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
				if (swiper.params.updateOnImagesReady) swiper.update();
				swiper.emit('imagesReady');
			}
		}
		for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
			const imageEl = swiper.imagesToLoad[i];
			swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
		}
	}
	var images = {
		loadImage,
		preloadImages
	};

	function checkOverflow() {
		const swiper = this;
		const {
			isLocked: wasLocked,
			params
		} = swiper;
		const {
			slidesOffsetBefore
		} = params;
		if (slidesOffsetBefore) {
			const lastSlideIndex = swiper.slides.length - 1;
			const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
			swiper.isLocked = swiper.size > lastSlideRightEdge;
		} else {
			swiper.isLocked = swiper.snapGrid.length === 1;
		}
		if (params.allowSlideNext === true) {
			swiper.allowSlideNext = !swiper.isLocked;
		}
		if (params.allowSlidePrev === true) {
			swiper.allowSlidePrev = !swiper.isLocked;
		}
		if (wasLocked && wasLocked !== swiper.isLocked) {
			swiper.isEnd = false;
		}
		if (wasLocked !== swiper.isLocked) {
			swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
		}
	}
	var checkOverflow$1 = {
		checkOverflow
	};
	var defaults = {
		init: true,
		direction: 'horizontal',
		touchEventsTarget: 'wrapper',
		initialSlide: 0,
		speed: 300,
		cssMode: false,
		updateOnWindowResize: true,
		resizeObserver: true,
		nested: false,
		createElements: false,
		enabled: true,
		focusableElements: 'input, select, option, textarea, button, video, label',
		// Overrides
		width: null,
		height: null,
		//
		preventInteractionOnTransition: false,
		// ssr
		userAgent: null,
		url: null,
		// To support iOS's swipe-to-go-back gesture (when being used in-app).
		edgeSwipeDetection: false,
		edgeSwipeThreshold: 20,
		// Autoheight
		autoHeight: false,
		// Set wrapper width
		setWrapperSize: false,
		// Virtual Translate
		virtualTranslate: false,
		// Effects
		effect: 'slide',
		// 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
		// Breakpoints
		breakpoints: undefined,
		breakpointsBase: 'window',
		// Slides grid
		spaceBetween: 0,
		slidesPerView: 1,
		slidesPerGroup: 1,
		slidesPerGroupSkip: 0,
		slidesPerGroupAuto: false,
		centeredSlides: false,
		centeredSlidesBounds: false,
		slidesOffsetBefore: 0,
		// in px
		slidesOffsetAfter: 0,
		// in px
		normalizeSlideIndex: true,
		centerInsufficientSlides: false,
		// Disable swiper and hide navigation when container not overflow
		watchOverflow: true,
		// Round length
		roundLengths: false,
		// Touches
		touchRatio: 1,
		touchAngle: 45,
		simulateTouch: true,
		shortSwipes: true,
		longSwipes: true,
		longSwipesRatio: 0.5,
		longSwipesMs: 300,
		followFinger: true,
		allowTouchMove: true,
		threshold: 0,
		touchMoveStopPropagation: false,
		touchStartPreventDefault: true,
		touchStartForcePreventDefault: false,
		touchReleaseOnEdges: false,
		// Unique Navigation Elements
		uniqueNavElements: true,
		// Resistance
		resistance: true,
		resistanceRatio: 0.85,
		// Progress
		watchSlidesProgress: false,
		// Cursor
		grabCursor: false,
		// Clicks
		preventClicks: true,
		preventClicksPropagation: true,
		slideToClickedSlide: false,
		// Images
		preloadImages: true,
		updateOnImagesReady: true,
		// loop
		loop: false,
		loopAdditionalSlides: 0,
		loopedSlides: null,
		loopedSlidesLimit: true,
		loopFillGroupWithBlank: false,
		loopPreventsSlide: true,
		// rewind
		rewind: false,
		// Swiping/no swiping
		allowSlidePrev: true,
		allowSlideNext: true,
		swipeHandler: null,
		// '.swipe-handler',
		noSwiping: true,
		noSwipingClass: 'swiper-no-swiping',
		noSwipingSelector: null,
		// Passive Listeners
		passiveListeners: true,
		maxBackfaceHiddenSlides: 10,
		// NS
		containerModifierClass: 'swiper-',
		// NEW
		slideClass: 'swiper-slide',
		slideBlankClass: 'swiper-slide-invisible-blank',
		slideActiveClass: 'swiper-slide-active',
		slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
		slideVisibleClass: 'swiper-slide-visible',
		slideDuplicateClass: 'swiper-slide-duplicate',
		slideNextClass: 'swiper-slide-next',
		slideDuplicateNextClass: 'swiper-slide-duplicate-next',
		slidePrevClass: 'swiper-slide-prev',
		slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
		wrapperClass: 'swiper-wrapper',
		// Callbacks
		runCallbacksOnInit: true,
		// Internals
		_emitClasses: false
	};

	function moduleExtendParams(params, allModulesParams) {
		return function extendParams(obj) {
			if (obj === void 0) {
				obj = {};
			}
			const moduleParamName = Object.keys(obj)[0];
			const moduleParams = obj[moduleParamName];
			if (typeof moduleParams !== 'object' || moduleParams === null) {
				extend(allModulesParams, obj);
				return;
			}
			if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
				params[moduleParamName] = {
					auto: true
				};
			}
			if (!(moduleParamName in params && 'enabled' in moduleParams)) {
				extend(allModulesParams, obj);
				return;
			}
			if (params[moduleParamName] === true) {
				params[moduleParamName] = {
					enabled: true
				};
			}
			if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
				params[moduleParamName].enabled = true;
			}
			if (!params[moduleParamName]) params[moduleParamName] = {
				enabled: false
			};
			extend(allModulesParams, obj);
		};
	}
	/* eslint no-param-reassign: "off" */
	const prototypes = {
		eventsEmitter,
		update,
		translate,
		transition,
		slide,
		loop,
		grabCursor,
		events: events$1,
		breakpoints,
		checkOverflow: checkOverflow$1,
		classes,
		images
	};
	const extendedDefaults = {};
	class Swiper {
		constructor() {
			let el;
			let params;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
				params = args[0];
			} else {
				[el, params] = args;
			}
			if (!params) params = {};
			params = extend({}, params);
			if (el && !params.el) params.el = el;
			if (params.el && $(params.el).length > 1) {
				const swipers = [];
				$(params.el).each(containerEl => {
					const newParams = extend({}, params, {
						el: containerEl
					});
					swipers.push(new Swiper(newParams));
				}); // eslint-disable-next-line no-constructor-return
				return swipers;
			} // Swiper Instance
			const swiper = this;
			swiper.__swiper__ = true;
			swiper.support = getSupport();
			swiper.device = getDevice({
				userAgent: params.userAgent
			});
			swiper.browser = getBrowser();
			swiper.eventsListeners = {};
			swiper.eventsAnyListeners = [];
			swiper.modules = [...swiper.__modules__];
			if (params.modules && Array.isArray(params.modules)) {
				swiper.modules.push(...params.modules);
			}
			const allModulesParams = {};
			swiper.modules.forEach(mod => {
				mod({
					swiper,
					extendParams: moduleExtendParams(params, allModulesParams),
					on: swiper.on.bind(swiper),
					once: swiper.once.bind(swiper),
					off: swiper.off.bind(swiper),
					emit: swiper.emit.bind(swiper)
				});
			}); // Extend defaults with modules params
			const swiperParams = extend({}, defaults, allModulesParams); // Extend defaults with passed params
			swiper.params = extend({}, swiperParams, extendedDefaults, params);
			swiper.originalParams = extend({}, swiper.params);
			swiper.passedParams = extend({}, params); // add event listeners
			if (swiper.params && swiper.params.on) {
				Object.keys(swiper.params.on).forEach(eventName => {
					swiper.on(eventName, swiper.params.on[eventName]);
				});
			}
			if (swiper.params && swiper.params.onAny) {
				swiper.onAny(swiper.params.onAny);
			} // Save Dom lib
			swiper.$ = $; // Extend Swiper
			Object.assign(swiper, {
				enabled: swiper.params.enabled,
				el,
				// Classes
				classNames: [],
				// Slides
				slides: $(),
				slidesGrid: [],
				snapGrid: [],
				slidesSizesGrid: [],
				// isDirection
				isHorizontal() {
					return swiper.params.direction === 'horizontal';
				},
				isVertical() {
					return swiper.params.direction === 'vertical';
				},
				// Indexes
				activeIndex: 0,
				realIndex: 0,
				//
				isBeginning: true,
				isEnd: false,
				// Props
				translate: 0,
				previousTranslate: 0,
				progress: 0,
				velocity: 0,
				animating: false,
				// Locks
				allowSlideNext: swiper.params.allowSlideNext,
				allowSlidePrev: swiper.params.allowSlidePrev,
				// Touch Events
				touchEvents: function touchEvents() {
					const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
					const desktop = ['pointerdown', 'pointermove', 'pointerup'];
					swiper.touchEventsTouch = {
						start: touch[0],
						move: touch[1],
						end: touch[2],
						cancel: touch[3]
					};
					swiper.touchEventsDesktop = {
						start: desktop[0],
						move: desktop[1],
						end: desktop[2]
					};
					return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
				}(),
				touchEventsData: {
					isTouched: undefined,
					isMoved: undefined,
					allowTouchCallbacks: undefined,
					touchStartTime: undefined,
					isScrolling: undefined,
					currentTranslate: undefined,
					startTranslate: undefined,
					allowThresholdMove: undefined,
					// Form elements to match
					focusableElements: swiper.params.focusableElements,
					// Last click time
					lastClickTime: now(),
					clickTimeout: undefined,
					// Velocities
					velocities: [],
					allowMomentumBounce: undefined,
					isTouchEvent: undefined,
					startMoving: undefined
				},
				// Clicks
				allowClick: true,
				// Touches
				allowTouchMove: swiper.params.allowTouchMove,
				touches: {
					startX: 0,
					startY: 0,
					currentX: 0,
					currentY: 0,
					diff: 0
				},
				// Images
				imagesToLoad: [],
				imagesLoaded: 0
			});
			swiper.emit('_swiper'); // Init
			if (swiper.params.init) {
				swiper.init();
			} // Return app instance
			// eslint-disable-next-line no-constructor-return
			return swiper;
		}
		enable() {
			const swiper = this;
			if (swiper.enabled) return;
			swiper.enabled = true;
			if (swiper.params.grabCursor) {
				swiper.setGrabCursor();
			}
			swiper.emit('enable');
		}
		disable() {
			const swiper = this;
			if (!swiper.enabled) return;
			swiper.enabled = false;
			if (swiper.params.grabCursor) {
				swiper.unsetGrabCursor();
			}
			swiper.emit('disable');
		}
		setProgress(progress, speed) {
			const swiper = this;
			progress = Math.min(Math.max(progress, 0), 1);
			const min = swiper.minTranslate();
			const max = swiper.maxTranslate();
			const current = (max - min) * progress + min;
			swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
			swiper.updateActiveIndex();
			swiper.updateSlidesClasses();
		}
		emitContainerClasses() {
			const swiper = this;
			if (!swiper.params._emitClasses || !swiper.el) return;
			const cls = swiper.el.className.split(' ').filter(className => {
				return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
			});
			swiper.emit('_containerClasses', cls.join(' '));
		}
		getSlideClasses(slideEl) {
			const swiper = this;
			if (swiper.destroyed) return '';
			return slideEl.className.split(' ').filter(className => {
				return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
			}).join(' ');
		}
		emitSlidesClasses() {
			const swiper = this;
			if (!swiper.params._emitClasses || !swiper.el) return;
			const updates = [];
			swiper.slides.each(slideEl => {
				const classNames = swiper.getSlideClasses(slideEl);
				updates.push({
					slideEl,
					classNames
				});
				swiper.emit('_slideClass', slideEl, classNames);
			});
			swiper.emit('_slideClasses', updates);
		}
		slidesPerViewDynamic(view, exact) {
			if (view === void 0) {
				view = 'current';
			}
			if (exact === void 0) {
				exact = false;
			}
			const swiper = this;
			const {
				params,
				slides,
				slidesGrid,
				slidesSizesGrid,
				size: swiperSize,
				activeIndex
			} = swiper;
			let spv = 1;
			if (params.centeredSlides) {
				let slideSize = slides[activeIndex].swiperSlideSize;
				let breakLoop;
				for (let i = activeIndex + 1; i < slides.length; i += 1) {
					if (slides[i] && !breakLoop) {
						slideSize += slides[i].swiperSlideSize;
						spv += 1;
						if (slideSize > swiperSize) breakLoop = true;
					}
				}
				for (let i = activeIndex - 1; i >= 0; i -= 1) {
					if (slides[i] && !breakLoop) {
						slideSize += slides[i].swiperSlideSize;
						spv += 1;
						if (slideSize > swiperSize) breakLoop = true;
					}
				}
			} else {
				// eslint-disable-next-line
				if (view === 'current') {
					for (let i = activeIndex + 1; i < slides.length; i += 1) {
						const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
						if (slideInView) {
							spv += 1;
						}
					}
				} else {
					// previous
					for (let i = activeIndex - 1; i >= 0; i -= 1) {
						const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
						if (slideInView) {
							spv += 1;
						}
					}
				}
			}
			return spv;
		}
		update() {
			const swiper = this;
			if (!swiper || swiper.destroyed) return;
			const {
				snapGrid,
				params
			} = swiper; // Breakpoints
			if (params.breakpoints) {
				swiper.setBreakpoint();
			}
			swiper.updateSize();
			swiper.updateSlides();
			swiper.updateProgress();
			swiper.updateSlidesClasses();

			function setTranslate() {
				const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
				const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
				swiper.setTranslate(newTranslate);
				swiper.updateActiveIndex();
				swiper.updateSlidesClasses();
			}
			let translated;
			if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
				setTranslate();
				if (swiper.params.autoHeight) {
					swiper.updateAutoHeight();
				}
			} else {
				if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
					translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
				} else {
					translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
				}
				if (!translated) {
					setTranslate();
				}
			}
			if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
				swiper.checkOverflow();
			}
			swiper.emit('update');
		}
		changeDirection(newDirection, needUpdate) {
			if (needUpdate === void 0) {
				needUpdate = true;
			}
			const swiper = this;
			const currentDirection = swiper.params.direction;
			if (!newDirection) {
				// eslint-disable-next-line
				newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
			}
			if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
				return swiper;
			}
			swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
			swiper.emitContainerClasses();
			swiper.params.direction = newDirection;
			swiper.slides.each(slideEl => {
				if (newDirection === 'vertical') {
					slideEl.style.width = '';
				} else {
					slideEl.style.height = '';
				}
			});
			swiper.emit('changeDirection');
			if (needUpdate) swiper.update();
			return swiper;
		}
		changeLanguageDirection(direction) {
			const swiper = this;
			if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;
			swiper.rtl = direction === 'rtl';
			swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;
			if (swiper.rtl) {
				swiper.$el.addClass(`${swiper.params.containerModifierClass}rtl`);
				swiper.el.dir = 'rtl';
			} else {
				swiper.$el.removeClass(`${swiper.params.containerModifierClass}rtl`);
				swiper.el.dir = 'ltr';
			}
			swiper.update();
		}
		mount(el) {
			const swiper = this;
			if (swiper.mounted) return true; // Find el
			const $el = $(el || swiper.params.el);
			el = $el[0];
			if (!el) {
				return false;
			}
			el.swiper = swiper;
			const getWrapperSelector = () => {
				return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
			};
			const getWrapper = () => {
				if (el && el.shadowRoot && el.shadowRoot.querySelector) {
					const res = $(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items
					res.children = options => $el.children(options);
					return res;
				}
				if (!$el.children) {
					return $($el).children(getWrapperSelector());
				}
				return $el.children(getWrapperSelector());
			}; // Find Wrapper
			let $wrapperEl = getWrapper();
			if ($wrapperEl.length === 0 && swiper.params.createElements) {
				const document = getDocument();
				const wrapper = document.createElement('div');
				$wrapperEl = $(wrapper);
				wrapper.className = swiper.params.wrapperClass;
				$el.append(wrapper);
				$el.children(`.${swiper.params.slideClass}`).each(slideEl => {
					$wrapperEl.append(slideEl);
				});
			}
			Object.assign(swiper, {
				$el,
				el,
				$wrapperEl,
				wrapperEl: $wrapperEl[0],
				mounted: true,
				// RTL
				rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
				rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
				wrongRTL: $wrapperEl.css('display') === '-webkit-box'
			});
			return true;
		}
		init(el) {
			const swiper = this;
			if (swiper.initialized) return swiper;
			const mounted = swiper.mount(el);
			if (mounted === false) return swiper;
			swiper.emit('beforeInit'); // Set breakpoint
			if (swiper.params.breakpoints) {
				swiper.setBreakpoint();
			} // Add Classes
			swiper.addClasses(); // Create loop
			if (swiper.params.loop) {
				swiper.loopCreate();
			} // Update size
			swiper.updateSize(); // Update slides
			swiper.updateSlides();
			if (swiper.params.watchOverflow) {
				swiper.checkOverflow();
			} // Set Grab Cursor
			if (swiper.params.grabCursor && swiper.enabled) {
				swiper.setGrabCursor();
			}
			if (swiper.params.preloadImages) {
				swiper.preloadImages();
			} // Slide To Initial Slide
			if (swiper.params.loop) {
				swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
			} else {
				swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
			} // Attach events
			swiper.attachEvents(); // Init Flag
			swiper.initialized = true; // Emit
			swiper.emit('init');
			swiper.emit('afterInit');
			return swiper;
		}
		destroy(deleteInstance, cleanStyles) {
			if (deleteInstance === void 0) {
				deleteInstance = true;
			}
			if (cleanStyles === void 0) {
				cleanStyles = true;
			}
			const swiper = this;
			const {
				params,
				$el,
				$wrapperEl,
				slides
			} = swiper;
			if (typeof swiper.params === 'undefined' || swiper.destroyed) {
				return null;
			}
			swiper.emit('beforeDestroy'); // Init Flag
			swiper.initialized = false; // Detach events
			swiper.detachEvents(); // Destroy loop
			if (params.loop) {
				swiper.loopDestroy();
			} // Cleanup styles
			if (cleanStyles) {
				swiper.removeClasses();
				$el.removeAttr('style');
				$wrapperEl.removeAttr('style');
				if (slides && slides.length) {
					slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
				}
			}
			swiper.emit('destroy'); // Detach emitter events
			Object.keys(swiper.eventsListeners).forEach(eventName => {
				swiper.off(eventName);
			});
			if (deleteInstance !== false) {
				swiper.$el[0].swiper = null;
				deleteProps(swiper);
			}
			swiper.destroyed = true;
			return null;
		}
		static extendDefaults(newDefaults) {
			extend(extendedDefaults, newDefaults);
		}
		static get extendedDefaults() {
			return extendedDefaults;
		}
		static get defaults() {
			return defaults;
		}
		static installModule(mod) {
			if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
			const modules = Swiper.prototype.__modules__;
			if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
				modules.push(mod);
			}
		}
		static use(module) {
			if (Array.isArray(module)) {
				module.forEach(m => Swiper.installModule(m));
				return Swiper;
			}
			Swiper.installModule(module);
			return Swiper;
		}
	}
	Object.keys(prototypes).forEach(prototypeGroup => {
		Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
			Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
		});
	});
	Swiper.use([Resize, Observer]);

	function Virtual(_ref) {
		let {
			swiper,
			extendParams,
			on,
			emit
		} = _ref;
		extendParams({
			virtual: {
				enabled: false,
				slides: [],
				cache: true,
				renderSlide: null,
				renderExternal: null,
				renderExternalUpdate: true,
				addSlidesBefore: 0,
				addSlidesAfter: 0
			}
		});
		let cssModeTimeout;
		swiper.virtual = {
			cache: {},
			from: undefined,
			to: undefined,
			slides: [],
			offset: 0,
			slidesGrid: []
		};

		function renderSlide(slide, index) {
			const params = swiper.params.virtual;
			if (params.cache && swiper.virtual.cache[index]) {
				return swiper.virtual.cache[index];
			}
			const $slideEl = params.renderSlide ? $(params.renderSlide.call(swiper, slide, index)) : $(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`);
			if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
			if (params.cache) swiper.virtual.cache[index] = $slideEl;
			return $slideEl;
		}

		function update(force) {
			const {
				slidesPerView,
				slidesPerGroup,
				centeredSlides
			} = swiper.params;
			const {
				addSlidesBefore,
				addSlidesAfter
			} = swiper.params.virtual;
			const {
				from: previousFrom,
				to: previousTo,
				slides,
				slidesGrid: previousSlidesGrid,
				offset: previousOffset
			} = swiper.virtual;
			if (!swiper.params.cssMode) {
				swiper.updateActiveIndex();
			}
			const activeIndex = swiper.activeIndex || 0;
			let offsetProp;
			if (swiper.rtlTranslate) offsetProp = 'right';
			else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
			let slidesAfter;
			let slidesBefore;
			if (centeredSlides) {
				slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
				slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
			} else {
				slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
				slidesBefore = slidesPerGroup + addSlidesBefore;
			}
			const from = Math.max((activeIndex || 0) - slidesBefore, 0);
			const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
			const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
			Object.assign(swiper.virtual, {
				from,
				to,
				offset,
				slidesGrid: swiper.slidesGrid
			});

			function onRendered() {
				swiper.updateSlides();
				swiper.updateProgress();
				swiper.updateSlidesClasses();
				if (swiper.lazy && swiper.params.lazy.enabled) {
					swiper.lazy.load();
				}
				emit('virtualUpdate');
			}
			if (previousFrom === from && previousTo === to && !force) {
				if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
					swiper.slides.css(offsetProp, `${offset}px`);
				}
				swiper.updateProgress();
				emit('virtualUpdate');
				return;
			}
			if (swiper.params.virtual.renderExternal) {
				swiper.params.virtual.renderExternal.call(swiper, {
					offset,
					from,
					to,
					slides: function getSlides() {
						const slidesToRender = [];
						for (let i = from; i <= to; i += 1) {
							slidesToRender.push(slides[i]);
						}
						return slidesToRender;
					}()
				});
				if (swiper.params.virtual.renderExternalUpdate) {
					onRendered();
				} else {
					emit('virtualUpdate');
				}
				return;
			}
			const prependIndexes = [];
			const appendIndexes = [];
			if (force) {
				swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
			} else {
				for (let i = previousFrom; i <= previousTo; i += 1) {
					if (i < from || i > to) {
						swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
					}
				}
			}
			for (let i = 0; i < slides.length; i += 1) {
				if (i >= from && i <= to) {
					if (typeof previousTo === 'undefined' || force) {
						appendIndexes.push(i);
					} else {
						if (i > previousTo) appendIndexes.push(i);
						if (i < previousFrom) prependIndexes.push(i);
					}
				}
			}
			appendIndexes.forEach(index => {
				swiper.$wrapperEl.append(renderSlide(slides[index], index));
			});
			prependIndexes.sort((a, b) => b - a).forEach(index => {
				swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
			});
			swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
			onRendered();
		}

		function appendSlide(slides) {
			if (typeof slides === 'object' && 'length' in slides) {
				for (let i = 0; i < slides.length; i += 1) {
					if (slides[i]) swiper.virtual.slides.push(slides[i]);
				}
			} else {
				swiper.virtual.slides.push(slides);
			}
			update(true);
		}

		function prependSlide(slides) {
			const activeIndex = swiper.activeIndex;
			let newActiveIndex = activeIndex + 1;
			let numberOfNewSlides = 1;
			if (Array.isArray(slides)) {
				for (let i = 0; i < slides.length; i += 1) {
					if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
				}
				newActiveIndex = activeIndex + slides.length;
				numberOfNewSlides = slides.length;
			} else {
				swiper.virtual.slides.unshift(slides);
			}
			if (swiper.params.virtual.cache) {
				const cache = swiper.virtual.cache;
				const newCache = {};
				Object.keys(cache).forEach(cachedIndex => {
					const $cachedEl = cache[cachedIndex];
					const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');
					if (cachedElIndex) {
						$cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);
					}
					newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
				});
				swiper.virtual.cache = newCache;
			}
			update(true);
			swiper.slideTo(newActiveIndex, 0);
		}

		function removeSlide(slidesIndexes) {
			if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
			let activeIndex = swiper.activeIndex;
			if (Array.isArray(slidesIndexes)) {
				for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
					swiper.virtual.slides.splice(slidesIndexes[i], 1);
					if (swiper.params.virtual.cache) {
						delete swiper.virtual.cache[slidesIndexes[i]];
					}
					if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
					activeIndex = Math.max(activeIndex, 0);
				}
			} else {
				swiper.virtual.slides.splice(slidesIndexes, 1);
				if (swiper.params.virtual.cache) {
					delete swiper.virtual.cache[slidesIndexes];
				}
				if (slidesIndexes < activeIndex) activeIndex -= 1;
				activeIndex = Math.max(activeIndex, 0);
			}
			update(true);
			swiper.slideTo(activeIndex, 0);
		}

		function removeAllSlides() {
			swiper.virtual.slides = [];
			if (swiper.params.virtual.cache) {
				swiper.virtual.cache = {};
			}
			update(true);
			swiper.slideTo(0, 0);
		}
		on('beforeInit', () => {
			if (!swiper.params.virtual.enabled) return;
			swiper.virtual.slides = swiper.params.virtual.slides;
			swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
			swiper.params.watchSlidesProgress = true;
			swiper.originalParams.watchSlidesProgress = true;
			if (!swiper.params.initialSlide) {
				update();
			}
		});
		on('setTranslate', () => {
			if (!swiper.params.virtual.enabled) return;
			if (swiper.params.cssMode && !swiper._immediateVirtual) {
				clearTimeout(cssModeTimeout);
				cssModeTimeout = setTimeout(() => {
					update();
				}, 100);
			} else {
				update();
			}
		});
		on('init update resize', () => {
			if (!swiper.params.virtual.enabled) return;
			if (swiper.params.cssMode) {
				setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);
			}
		});
		Object.assign(swiper.virtual, {
			appendSlide,
			prependSlide,
			removeSlide,
			removeAllSlides,
			update
		});
	}
	/* eslint-disable consistent-return */
	function Keyboard(_ref) {
		let {
			swiper,
			extendParams,
			on,
			emit
		} = _ref;
		const document = getDocument();
		const window = getWindow();
		swiper.keyboard = {
			enabled: false
		};
		extendParams({
			keyboard: {
				enabled: false,
				onlyInViewport: true,
				pageUpDown: true
			}
		});

		function handle(event) {
			if (!swiper.enabled) return;
			const {
				rtlTranslate: rtl
			} = swiper;
			let e = event;
			if (e.originalEvent) e = e.originalEvent; // jquery fix
			const kc = e.keyCode || e.charCode;
			const pageUpDown = swiper.params.keyboard.pageUpDown;
			const isPageUp = pageUpDown && kc === 33;
			const isPageDown = pageUpDown && kc === 34;
			const isArrowLeft = kc === 37;
			const isArrowRight = kc === 39;
			const isArrowUp = kc === 38;
			const isArrowDown = kc === 40; // Directions locks
			if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
				return false;
			}
			if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
				return false;
			}
			if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
				return undefined;
			}
			if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
				return undefined;
			}
			if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
				let inView = false; // Check that swiper should be inside of visible area of window
				if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
					return undefined;
				}
				const $el = swiper.$el;
				const swiperWidth = $el[0].clientWidth;
				const swiperHeight = $el[0].clientHeight;
				const windowWidth = window.innerWidth;
				const windowHeight = window.innerHeight;
				const swiperOffset = swiper.$el.offset();
				if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
				const swiperCoord = [
					[swiperOffset.left, swiperOffset.top],
					[swiperOffset.left + swiperWidth, swiperOffset.top],
					[swiperOffset.left, swiperOffset.top + swiperHeight],
					[swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]
				];
				for (let i = 0; i < swiperCoord.length; i += 1) {
					const point = swiperCoord[i];
					if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
						if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line
						inView = true;
					}
				}
				if (!inView) return undefined;
			}
			if (swiper.isHorizontal()) {
				if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
					if (e.preventDefault) e.preventDefault();
					else e.returnValue = false;
				}
				if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
				if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
			} else {
				if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
					if (e.preventDefault) e.preventDefault();
					else e.returnValue = false;
				}
				if (isPageDown || isArrowDown) swiper.slideNext();
				if (isPageUp || isArrowUp) swiper.slidePrev();
			}
			emit('keyPress', kc);
			return undefined;
		}

		function enable() {
			if (swiper.keyboard.enabled) return;
			$(document).on('keydown', handle);
			swiper.keyboard.enabled = true;
		}

		function disable() {
			if (!swiper.keyboard.enabled) return;
			$(document).off('keydown', handle);
			swiper.keyboard.enabled = false;
		}
		on('init', () => {
			if (swiper.params.keyboard.enabled) {
				enable();
			}
		});
		on('destroy', () => {
			if (swiper.keyboard.enabled) {
				disable();
			}
		});
		Object.assign(swiper.keyboard, {
			enable,
			disable
		});
	}
	/* eslint-disable consistent-return */
	function Mousewheel(_ref) {
		let {
			swiper,
			extendParams,
			on,
			emit
		} = _ref;
		const window = getWindow();
		extendParams({
			mousewheel: {
				enabled: false,
				releaseOnEdges: false,
				invert: false,
				forceToAxis: false,
				sensitivity: 1,
				eventsTarget: 'container',
				thresholdDelta: null,
				thresholdTime: null
			}
		});
		swiper.mousewheel = {
			enabled: false
		};
		let timeout;
		let lastScrollTime = now();
		let lastEventBeforeSnap;
		const recentWheelEvents = [];

		function normalize(e) {
			// Reasonable defaults
			const PIXEL_STEP = 10;
			const LINE_HEIGHT = 40;
			const PAGE_HEIGHT = 800;
			let sX = 0;
			let sY = 0; // spinX, spinY
			let pX = 0;
			let pY = 0; // pixelX, pixelY
			// Legacy
			if ('detail' in e) {
				sY = e.detail;
			}
			if ('wheelDelta' in e) {
				sY = -e.wheelDelta / 120;
			}
			if ('wheelDeltaY' in e) {
				sY = -e.wheelDeltaY / 120;
			}
			if ('wheelDeltaX' in e) {
				sX = -e.wheelDeltaX / 120;
			} // side scrolling on FF with DOMMouseScroll
			if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
				sX = sY;
				sY = 0;
			}
			pX = sX * PIXEL_STEP;
			pY = sY * PIXEL_STEP;
			if ('deltaY' in e) {
				pY = e.deltaY;
			}
			if ('deltaX' in e) {
				pX = e.deltaX;
			}
			if (e.shiftKey && !pX) {
				// if user scrolls with shift he wants horizontal scroll
				pX = pY;
				pY = 0;
			}
			if ((pX || pY) && e.deltaMode) {
				if (e.deltaMode === 1) {
					// delta in LINE units
					pX *= LINE_HEIGHT;
					pY *= LINE_HEIGHT;
				} else {
					// delta in PAGE units
					pX *= PAGE_HEIGHT;
					pY *= PAGE_HEIGHT;
				}
			} // Fall-back if spin cannot be determined
			if (pX && !sX) {
				sX = pX < 1 ? -1 : 1;
			}
			if (pY && !sY) {
				sY = pY < 1 ? -1 : 1;
			}
			return {
				spinX: sX,
				spinY: sY,
				pixelX: pX,
				pixelY: pY
			};
		}

		function handleMouseEnter() {
			if (!swiper.enabled) return;
			swiper.mouseEntered = true;
		}

		function handleMouseLeave() {
			if (!swiper.enabled) return;
			swiper.mouseEntered = false;
		}

		function animateSlider(newEvent) {
			if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
				// Prevent if delta of wheel scroll delta is below configured threshold
				return false;
			}
			if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
				// Prevent if time between scrolls is below configured threshold
				return false;
			} // If the movement is NOT big enough and
			// if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
			//   Don't go any further (avoid insignificant scroll movement).
			if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
				// Return false as a default
				return true;
			} // If user is scrolling towards the end:
			//   If the slider hasn't hit the latest slide or
			//   if the slider is a loop and
			//   if the slider isn't moving right now:
			//     Go to next slide and
			//     emit a scroll event.
			// Else (the user is scrolling towards the beginning) and
			// if the slider hasn't hit the first slide or
			// if the slider is a loop and
			// if the slider isn't moving right now:
			//   Go to prev slide and
			//   emit a scroll event.
			if (newEvent.direction < 0) {
				if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
					swiper.slideNext();
					emit('scroll', newEvent.raw);
				}
			} else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
				swiper.slidePrev();
				emit('scroll', newEvent.raw);
			} // If you got here is because an animation has been triggered so store the current time
			lastScrollTime = new window.Date().getTime(); // Return false as a default
			return false;
		}

		function releaseScroll(newEvent) {
			const params = swiper.params.mousewheel;
			if (newEvent.direction < 0) {
				if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
					// Return true to animate scroll on edges
					return true;
				}
			} else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
				// Return true to animate scroll on edges
				return true;
			}
			return false;
		}

		function handle(event) {
			let e = event;
			let disableParentSwiper = true;
			if (!swiper.enabled) return;
			const params = swiper.params.mousewheel;
			if (swiper.params.cssMode) {
				e.preventDefault();
			}
			let target = swiper.$el;
			if (swiper.params.mousewheel.eventsTarget !== 'container') {
				target = $(swiper.params.mousewheel.eventsTarget);
			}
			if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;
			if (e.originalEvent) e = e.originalEvent; // jquery fix
			let delta = 0;
			const rtlFactor = swiper.rtlTranslate ? -1 : 1;
			const data = normalize(e);
			if (params.forceToAxis) {
				if (swiper.isHorizontal()) {
					if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;
					else return true;
				} else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;
				else return true;
			} else {
				delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
			}
			if (delta === 0) return true;
			if (params.invert) delta = -delta; // Get the scroll positions
			let positions = swiper.getTranslate() + delta * params.sensitivity;
			if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
			if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:
			//     the disableParentSwiper will be true.
			// When loop is false:
			//     if the scroll positions is not on edge,
			//     then the disableParentSwiper will be true.
			//     if the scroll on edge positions,
			//     then the disableParentSwiper will be false.
			disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
			if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
			if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
				// Register the new event in a variable which stores the relevant data
				const newEvent = {
					time: now(),
					delta: Math.abs(delta),
					direction: Math.sign(delta),
					raw: event
				}; // Keep the most recent events
				if (recentWheelEvents.length >= 2) {
					recentWheelEvents.shift(); // only store the last N events
				}
				const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
				recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:
				//   If direction has changed or
				//   if the scroll is quicker than the previous one:
				//     Animate the slider.
				// Else (this is the first time the wheel is moved):
				//     Animate the slider.
				if (prevEvent) {
					if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
						animateSlider(newEvent);
					}
				} else {
					animateSlider(newEvent);
				} // If it's time to release the scroll:
				//   Return now so you don't hit the preventDefault.
				if (releaseScroll(newEvent)) {
					return true;
				}
			} else {
				// Freemode or scrollContainer:
				// If we recently snapped after a momentum scroll, then ignore wheel events
				// to give time for the deceleration to finish. Stop ignoring after 500 msecs
				// or if it's a new scroll (larger delta or inverse sign as last event before
				// an end-of-momentum snap).
				const newEvent = {
					time: now(),
					delta: Math.abs(delta),
					direction: Math.sign(delta)
				};
				const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
				if (!ignoreWheelEvents) {
					lastEventBeforeSnap = undefined;
					if (swiper.params.loop) {
						swiper.loopFix();
					}
					let position = swiper.getTranslate() + delta * params.sensitivity;
					const wasBeginning = swiper.isBeginning;
					const wasEnd = swiper.isEnd;
					if (position >= swiper.minTranslate()) position = swiper.minTranslate();
					if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
					swiper.setTransition(0);
					swiper.setTranslate(position);
					swiper.updateProgress();
					swiper.updateActiveIndex();
					swiper.updateSlidesClasses();
					if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
						swiper.updateSlidesClasses();
					}
					if (swiper.params.freeMode.sticky) {
						// When wheel scrolling starts with sticky (aka snap) enabled, then detect
						// the end of a momentum scroll by storing recent (N=15?) wheel events.
						// 1. do all N events have decreasing or same (absolute value) delta?
						// 2. did all N events arrive in the last M (M=500?) msecs?
						// 3. does the earliest event have an (absolute value) delta that's
						//    at least P (P=1?) larger than the most recent event's delta?
						// 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
						// If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
						// Snap immediately and ignore remaining wheel events in this scroll.
						// See comment above for "remaining wheel events in this scroll" determination.
						// If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
						clearTimeout(timeout);
						timeout = undefined;
						if (recentWheelEvents.length >= 15) {
							recentWheelEvents.shift(); // only store the last N events
						}
						const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
						const firstEvent = recentWheelEvents[0];
						recentWheelEvents.push(newEvent);
						if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
							// Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
							recentWheelEvents.splice(0);
						} else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
							// We're at the end of the deceleration of a momentum scroll, so there's no need
							// to wait for more events. Snap ASAP on the next tick.
							// Also, because there's some remaining momentum we'll bias the snap in the
							// direction of the ongoing scroll because it's better UX for the scroll to snap
							// in the same direction as the scroll instead of reversing to snap.  Therefore,
							// if it's already scrolled more than 20% in the current direction, keep going.
							const snapToThreshold = delta > 0 ? 0.8 : 0.2;
							lastEventBeforeSnap = newEvent;
							recentWheelEvents.splice(0);
							timeout = nextTick(() => {
								swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
							}, 0); // no delay; move on next tick
						}
						if (!timeout) {
							// if we get here, then we haven't detected the end of a momentum scroll, so
							// we'll consider a scroll "complete" when there haven't been any wheel events
							// for 500ms.
							timeout = nextTick(() => {
								const snapToThreshold = 0.5;
								lastEventBeforeSnap = newEvent;
								recentWheelEvents.splice(0);
								swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
							}, 500);
						}
					} // Emit event
					if (!ignoreWheelEvents) emit('scroll', e); // Stop autoplay
					if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions
					if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
				}
			}
			if (e.preventDefault) e.preventDefault();
			else e.returnValue = false;
			return false;
		}

		function events(method) {
			let target = swiper.$el;
			if (swiper.params.mousewheel.eventsTarget !== 'container') {
				target = $(swiper.params.mousewheel.eventsTarget);
			}
			target[method]('mouseenter', handleMouseEnter);
			target[method]('mouseleave', handleMouseLeave);
			target[method]('wheel', handle);
		}

		function enable() {
			if (swiper.params.cssMode) {
				swiper.wrapperEl.removeEventListener('wheel', handle);
				return true;
			}
			if (swiper.mousewheel.enabled) return false;
			events('on');
			swiper.mousewheel.enabled = true;
			return true;
		}

		function disable() {
			if (swiper.params.cssMode) {
				swiper.wrapperEl.addEventListener(event, handle);
				return true;
			}
			if (!swiper.mousewheel.enabled) return false;
			events('off');
			swiper.mousewheel.enabled = false;
			return true;
		}
		on('init', () => {
			if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
				disable();
			}
			if (swiper.params.mousewheel.enabled) enable();
		});
		on('destroy', () => {
			if (swiper.params.cssMode) {
				enable();
			}
			if (swiper.mousewheel.enabled) disable();
		});
		Object.assign(swiper.mousewheel, {
			enable,
			disable
		});
	}

	function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
		const document = getDocument();
		if (swiper.params.createElements) {
			Object.keys(checkProps).forEach(key => {
				if (!params[key] && params.auto === true) {
					let element = swiper.$el.children(`.${checkProps[key]}`)[0];
					if (!element) {
						element = document.createElement('div');
						element.className = checkProps[key];
						swiper.$el.append(element);
					}
					params[key] = element;
					originalParams[key] = element;
				}
			});
		}
		return params;
	}

	function Navigation(_ref) {
		let {
			swiper,
			extendParams,
			on,
			emit
		} = _ref;
		extendParams({
			navigation: {
				nextEl: null,
				prevEl: null,
				hideOnClick: false,
				disabledClass: 'swiper-button-disabled',
				hiddenClass: 'swiper-button-hidden',
				lockClass: 'swiper-button-lock',
				navigationDisabledClass: 'swiper-navigation-disabled'
			}
		});
		swiper.navigation = {
			nextEl: null,
			$nextEl: null,
			prevEl: null,
			$prevEl: null
		};

		function getEl(el) {
			let $el;
			if (el) {
				$el = $(el);
				if (swiper.params.uniqueNavElements && typeof el === 'string' && $el.length > 1 && swiper.$el.find(el).length === 1) {
					$el = swiper.$el.find(el);
				}
			}
			return $el;
		}

		function toggleEl($el, disabled) {
			const params = swiper.params.navigation;
			if ($el && $el.length > 0) {
				$el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);
				if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;
				if (swiper.params.watchOverflow && swiper.enabled) {
					$el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
				}
			}
		}

		function update() {
			// Update Navigation Buttons
			if (swiper.params.loop) return;
			const {
				$nextEl,
				$prevEl
			} = swiper.navigation;
			toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
			toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
		}

		function onPrevClick(e) {
			e.preventDefault();
			if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
			swiper.slidePrev();
			emit('navigationPrev');
		}

		function onNextClick(e) {
			e.preventDefault();
			if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
			swiper.slideNext();
			emit('navigationNext');
		}

		function init() {
			const params = swiper.params.navigation;
			swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
				nextEl: 'swiper-button-next',
				prevEl: 'swiper-button-prev'
			});
			if (!(params.nextEl || params.prevEl)) return;
			const $nextEl = getEl(params.nextEl);
			const $prevEl = getEl(params.prevEl);
			if ($nextEl && $nextEl.length > 0) {
				$nextEl.on('click', onNextClick);
			}
			if ($prevEl && $prevEl.length > 0) {
				$prevEl.on('click', onPrevClick);
			}
			Object.assign(swiper.navigation, {
				$nextEl,
				nextEl: $nextEl && $nextEl[0],
				$prevEl,
				prevEl: $prevEl && $prevEl[0]
			});
			if (!swiper.enabled) {
				if ($nextEl) $nextEl.addClass(params.lockClass);
				if ($prevEl) $prevEl.addClass(params.lockClass);
			}
		}

		function destroy() {
			const {
				$nextEl,
				$prevEl
			} = swiper.navigation;
			if ($nextEl && $nextEl.length) {
				$nextEl.off('click', onNextClick);
				$nextEl.removeClass(swiper.params.navigation.disabledClass);
			}
			if ($prevEl && $prevEl.length) {
				$prevEl.off('click', onPrevClick);
				$prevEl.removeClass(swiper.params.navigation.disabledClass);
			}
		}
		on('init', () => {
			if (swiper.params.navigation.enabled === false) {
				// eslint-disable-next-line
				disable();
			} else {
				init();
				update();
			}
		});
		on('toEdge fromEdge lock unlock', () => {
			update();
		});
		on('destroy', () => {
			destroy();
		});
		on('enable disable', () => {
			const {
				$nextEl,
				$prevEl
			} = swiper.navigation;
			if ($nextEl) {
				$nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
			}
			if ($prevEl) {
				$prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
			}
		});
		on('click', (_s, e) => {
			const {
				$nextEl,
				$prevEl
			} = swiper.navigation;
			const targetEl = e.target;
			if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {
				if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
				let isHidden;
				if ($nextEl) {
					isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
				} else if ($prevEl) {
					isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
				}
				if (isHidden === true) {
					emit('navigationShow');
				} else {
					emit('navigationHide');
				}
				if ($nextEl) {
					$nextEl.toggleClass(swiper.params.navigation.hiddenClass);
				}
				if ($prevEl) {
					$prevEl.toggleClass(swiper.params.navigation.hiddenClass);
				}
			}
		});
		const enable = () => {
			swiper.$el.removeClass(swiper.params.navigation.navigationDisabledClass);
			init();
			update();
		};
		const disable = () => {
			swiper.$el.addClass(swiper.params.navigation.navigationDisabledClass);
			destroy();
		};
		Object.assign(swiper.navigation, {
			enable,
			disable,
			update,
			init,
			destroy
		});
	}

	function classesToSelector(classes) {
		if (classes === void 0) {
			classes = '';
		}
		return `.${classes.trim().replace(/([\.:!\/])/g, '\\$1') // eslint-disable-line

  .replace(/ /g, '.')}`;
	}

	function Pagination(_ref) {
		let {
			swiper,
			extendParams,
			on,
			emit
		} = _ref;
		const pfx = 'swiper-pagination';
		extendParams({
			pagination: {
				el: null,
				bulletElement: 'span',
				clickable: false,
				hideOnClick: false,
				renderBullet: null,
				renderProgressbar: null,
				renderFraction: null,
				renderCustom: null,
				progressbarOpposite: false,
				type: 'bullets',
				// 'bullets' or 'progressbar' or 'fraction' or 'custom'
				dynamicBullets: false,
				dynamicMainBullets: 1,
				formatFractionCurrent: number => number,
				formatFractionTotal: number => number,
				bulletClass: `${pfx}-bullet`,
				bulletActiveClass: `${pfx}-bullet-active`,
				modifierClass: `${pfx}-`,
				currentClass: `${pfx}-current`,
				totalClass: `${pfx}-total`,
				hiddenClass: `${pfx}-hidden`,
				progressbarFillClass: `${pfx}-progressbar-fill`,
				progressbarOppositeClass: `${pfx}-progressbar-opposite`,
				clickableClass: `${pfx}-clickable`,
				lockClass: `${pfx}-lock`,
				horizontalClass: `${pfx}-horizontal`,
				verticalClass: `${pfx}-vertical`,
				paginationDisabledClass: `${pfx}-disabled`
			}
		});
		swiper.pagination = {
			el: null,
			$el: null,
			bullets: []
		};
		let bulletSize;
		let dynamicBulletIndex = 0;

		function isPaginationDisabled() {
			return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
		}

		function setSideBullets($bulletEl, position) {
			const {
				bulletActiveClass
			} = swiper.params.pagination;
			$bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
		}

		function update() {
			// Render || Update Pagination bullets/items
			const rtl = swiper.rtl;
			const params = swiper.params.pagination;
			if (isPaginationDisabled()) return;
			const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
			const $el = swiper.pagination.$el; // Current/Total
			let current;
			const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
			if (swiper.params.loop) {
				current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
				if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
					current -= slidesLength - swiper.loopedSlides * 2;
				}
				if (current > total - 1) current -= total;
				if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
			} else if (typeof swiper.snapIndex !== 'undefined') {
				current = swiper.snapIndex;
			} else {
				current = swiper.activeIndex || 0;
			} // Types
			if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
				const bullets = swiper.pagination.bullets;
				let firstIndex;
				let lastIndex;
				let midIndex;
				if (params.dynamicBullets) {
					bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
					$el.css(swiper.isHorizontal() ? 'width' : 'height', `${bulletSize * (params.dynamicMainBullets + 4)}px`);
					if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
						dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);
						if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
							dynamicBulletIndex = params.dynamicMainBullets - 1;
						} else if (dynamicBulletIndex < 0) {
							dynamicBulletIndex = 0;
						}
					}
					firstIndex = Math.max(current - dynamicBulletIndex, 0);
					lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
					midIndex = (lastIndex + firstIndex) / 2;
				}
				bullets.removeClass(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`).join(' '));
				if ($el.length > 1) {
					bullets.each(bullet => {
						const $bullet = $(bullet);
						const bulletIndex = $bullet.index();
						if (bulletIndex === current) {
							$bullet.addClass(params.bulletActiveClass);
						}
						if (params.dynamicBullets) {
							if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
								$bullet.addClass(`${params.bulletActiveClass}-main`);
							}
							if (bulletIndex === firstIndex) {
								setSideBullets($bullet, 'prev');
							}
							if (bulletIndex === lastIndex) {
								setSideBullets($bullet, 'next');
							}
						}
					});
				} else {
					const $bullet = bullets.eq(current);
					const bulletIndex = $bullet.index();
					$bullet.addClass(params.bulletActiveClass);
					if (params.dynamicBullets) {
						const $firstDisplayedBullet = bullets.eq(firstIndex);
						const $lastDisplayedBullet = bullets.eq(lastIndex);
						for (let i = firstIndex; i <= lastIndex; i += 1) {
							bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
						}
						if (swiper.params.loop) {
							if (bulletIndex >= bullets.length) {
								for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
									bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
								}
								bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
							} else {
								setSideBullets($firstDisplayedBullet, 'prev');
								setSideBullets($lastDisplayedBullet, 'next');
							}
						} else {
							setSideBullets($firstDisplayedBullet, 'prev');
							setSideBullets($lastDisplayedBullet, 'next');
						}
					}
				}
				if (params.dynamicBullets) {
					const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
					const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
					const offsetProp = rtl ? 'right' : 'left';
					bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
				}
			}
			if (params.type === 'fraction') {
				$el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
				$el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
			}
			if (params.type === 'progressbar') {
				let progressbarDirection;
				if (params.progressbarOpposite) {
					progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
				} else {
					progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
				}
				const scale = (current + 1) / total;
				let scaleX = 1;
				let scaleY = 1;
				if (progressbarDirection === 'horizontal') {
					scaleX = scale;
				} else {
					scaleY = scale;
				}
				$el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
			}
			if (params.type === 'custom' && params.renderCustom) {
				$el.html(params.renderCustom(swiper, current + 1, total));
				emit('paginationRender', $el[0]);
			} else {
				emit('paginationUpdate', $el[0]);
			}
			if (swiper.params.watchOverflow && swiper.enabled) {
				$el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
			}
		}

		function render() {
			// Render Container
			const params = swiper.params.pagination;
			if (isPaginationDisabled()) return;
			const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
			const $el = swiper.pagination.$el;
			let paginationHTML = '';
			if (params.type === 'bullets') {
				let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
				if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
					numberOfBullets = slidesLength;
				}
				for (let i = 0; i < numberOfBullets; i += 1) {
					if (params.renderBullet) {
						paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
					} else {
						paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
					}
				}
				$el.html(paginationHTML);
				swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
			}
			if (params.type === 'fraction') {
				if (params.renderFraction) {
					paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
				} else {
					paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
				}
				$el.html(paginationHTML);
			}
			if (params.type === 'progressbar') {
				if (params.renderProgressbar) {
					paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
				} else {
					paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
				}
				$el.html(paginationHTML);
			}
			if (params.type !== 'custom') {
				emit('paginationRender', swiper.pagination.$el[0]);
			}
		}

		function init() {
			swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
				el: 'swiper-pagination'
			});
			const params = swiper.params.pagination;
			if (!params.el) return;
			let $el = $(params.el);
			if ($el.length === 0) return;
			if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
				$el = swiper.$el.find(params.el); // check if it belongs to another nested Swiper
				if ($el.length > 1) {
					$el = $el.filter(el => {
						if ($(el).parents('.swiper')[0] !== swiper.el) return false;
						return true;
					});
				}
			}
			if (params.type === 'bullets' && params.clickable) {
				$el.addClass(params.clickableClass);
			}
			$el.addClass(params.modifierClass + params.type);
			$el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
			if (params.type === 'bullets' && params.dynamicBullets) {
				$el.addClass(`${params.modifierClass}${params.type}-dynamic`);
				dynamicBulletIndex = 0;
				if (params.dynamicMainBullets < 1) {
					params.dynamicMainBullets = 1;
				}
			}
			if (params.type === 'progressbar' && params.progressbarOpposite) {
				$el.addClass(params.progressbarOppositeClass);
			}
			if (params.clickable) {
				$el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
					e.preventDefault();
					let index = $(this).index() * swiper.params.slidesPerGroup;
					if (swiper.params.loop) index += swiper.loopedSlides;
					swiper.slideTo(index);
				});
			}
			Object.assign(swiper.pagination, {
				$el,
				el: $el[0]
			});
			if (!swiper.enabled) {
				$el.addClass(params.lockClass);
			}
		}

		function destroy() {
			const params = swiper.params.pagination;
			if (isPaginationDisabled()) return;
			const $el = swiper.pagination.$el;
			$el.removeClass(params.hiddenClass);
			$el.removeClass(params.modifierClass + params.type);
			$el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
			if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
			if (params.clickable) {
				$el.off('click', classesToSelector(params.bulletClass));
			}
		}
		on('init', () => {
			if (swiper.params.pagination.enabled === false) {
				// eslint-disable-next-line
				disable();
			} else {
				init();
				render();
				update();
			}
		});
		on('activeIndexChange', () => {
			if (swiper.params.loop) {
				update();
			} else if (typeof swiper.snapIndex === 'undefined') {
				update();
			}
		});
		on('snapIndexChange', () => {
			if (!swiper.params.loop) {
				update();
			}
		});
		on('slidesLengthChange', () => {
			if (swiper.params.loop) {
				render();
				update();
			}
		});
		on('snapGridLengthChange', () => {
			if (!swiper.params.loop) {
				render();
				update();
			}
		});
		on('destroy', () => {
			destroy();
		});
		on('enable disable', () => {
			const {
				$el
			} = swiper.pagination;
			if ($el) {
				$el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
			}
		});
		on('lock unlock', () => {
			update();
		});
		on('click', (_s, e) => {
			const targetEl = e.target;
			const {
				$el
			} = swiper.pagination;
			if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el && $el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
				if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
				const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);
				if (isHidden === true) {
					emit('paginationShow');
				} else {
					emit('paginationHide');
				}
				$el.toggleClass(swiper.params.pagination.hiddenClass);
			}
		});
		const enable = () => {
			swiper.$el.removeClass(swiper.params.pagination.paginationDisabledClass);
			if (swiper.pagination.$el) {
				swiper.pagination.$el.removeClass(swiper.params.pagination.paginationDisabledClass);
			}
			init();
			render();
			update();
		};
		const disable = () => {
			swiper.$el.addClass(swiper.params.pagination.paginationDisabledClass);
			if (swiper.pagination.$el) {
				swiper.pagination.$el.addClass(swiper.params.pagination.paginationDisabledClass);
			}
			destroy();
		};
		Object.assign(swiper.pagination, {
			enable,
			disable,
			render,
			update,
			init,
			destroy
		});
	}

	function Scrollbar(_ref) {
		let {
			swiper,
			extendParams,
			on,
			emit
		} = _ref;
		const document = getDocument();
		let isTouched = false;
		let timeout = null;
		let dragTimeout = null;
		let dragStartPos;
		let dragSize;
		let trackSize;
		let divider;
		extendParams({
			scrollbar: {
				el: null,
				dragSize: 'auto',
				hide: false,
				draggable: false,
				snapOnRelease: true,
				lockClass: 'swiper-scrollbar-lock',
				dragClass: 'swiper-scrollbar-drag',
				scrollbarDisabledClass: 'swiper-scrollbar-disabled',
				horizontalClass: `swiper-scrollbar-horizontal`,
				verticalClass: `swiper-scrollbar-vertical`
			}
		});
		swiper.scrollbar = {
			el: null,
			dragEl: null,
			$el: null,
			$dragEl: null
		};

		function setTranslate() {
			if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
			const {
				scrollbar,
				rtlTranslate: rtl,
				progress
			} = swiper;
			const {
				$dragEl,
				$el
			} = scrollbar;
			const params = swiper.params.scrollbar;
			let newSize = dragSize;
			let newPos = (trackSize - dragSize) * progress;
			if (rtl) {
				newPos = -newPos;
				if (newPos > 0) {
					newSize = dragSize - newPos;
					newPos = 0;
				} else if (-newPos + dragSize > trackSize) {
					newSize = trackSize + newPos;
				}
			} else if (newPos < 0) {
				newSize = dragSize + newPos;
				newPos = 0;
			} else if (newPos + dragSize > trackSize) {
				newSize = trackSize - newPos;
			}
			if (swiper.isHorizontal()) {
				$dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
				$dragEl[0].style.width = `${newSize}px`;
			} else {
				$dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
				$dragEl[0].style.height = `${newSize}px`;
			}
			if (params.hide) {
				clearTimeout(timeout);
				$el[0].style.opacity = 1;
				timeout = setTimeout(() => {
					$el[0].style.opacity = 0;
					$el.transition(400);
				}, 1000);
			}
		}

		function setTransition(duration) {
			if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
			swiper.scrollbar.$dragEl.transition(duration);
		}

		function updateSize() {
			if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
			const {
				scrollbar
			} = swiper;
			const {
				$dragEl,
				$el
			} = scrollbar;
			$dragEl[0].style.width = '';
			$dragEl[0].style.height = '';
			trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
			divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
			if (swiper.params.scrollbar.dragSize === 'auto') {
				dragSize = trackSize * divider;
			} else {
				dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
			}
			if (swiper.isHorizontal()) {
				$dragEl[0].style.width = `${dragSize}px`;
			} else {
				$dragEl[0].style.height = `${dragSize}px`;
			}
			if (divider >= 1) {
				$el[0].style.display = 'none';
			} else {
				$el[0].style.display = '';
			}
			if (swiper.params.scrollbar.hide) {
				$el[0].style.opacity = 0;
			}
			if (swiper.params.watchOverflow && swiper.enabled) {
				scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
			}
		}

		function getPointerPosition(e) {
			if (swiper.isHorizontal()) {
				return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
			}
			return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
		}

		function setDragPosition(e) {
			const {
				scrollbar,
				rtlTranslate: rtl
			} = swiper;
			const {
				$el
			} = scrollbar;
			let positionRatio;
			positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
			positionRatio = Math.max(Math.min(positionRatio, 1), 0);
			if (rtl) {
				positionRatio = 1 - positionRatio;
			}
			const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
			swiper.updateProgress(position);
			swiper.setTranslate(position);
			swiper.updateActiveIndex();
			swiper.updateSlidesClasses();
		}

		function onDragStart(e) {
			const params = swiper.params.scrollbar;
			const {
				scrollbar,
				$wrapperEl
			} = swiper;
			const {
				$el,
				$dragEl
			} = scrollbar;
			isTouched = true;
			dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
			e.preventDefault();
			e.stopPropagation();
			$wrapperEl.transition(100);
			$dragEl.transition(100);
			setDragPosition(e);
			clearTimeout(dragTimeout);
			$el.transition(0);
			if (params.hide) {
				$el.css('opacity', 1);
			}
			if (swiper.params.cssMode) {
				swiper.$wrapperEl.css('scroll-snap-type', 'none');
			}
			emit('scrollbarDragStart', e);
		}

		function onDragMove(e) {
			const {
				scrollbar,
				$wrapperEl
			} = swiper;
			const {
				$el,
				$dragEl
			} = scrollbar;
			if (!isTouched) return;
			if (e.preventDefault) e.preventDefault();
			else e.returnValue = false;
			setDragPosition(e);
			$wrapperEl.transition(0);
			$el.transition(0);
			$dragEl.transition(0);
			emit('scrollbarDragMove', e);
		}

		function onDragEnd(e) {
			const params = swiper.params.scrollbar;
			const {
				scrollbar,
				$wrapperEl
			} = swiper;
			const {
				$el
			} = scrollbar;
			if (!isTouched) return;
			isTouched = false;
			if (swiper.params.cssMode) {
				swiper.$wrapperEl.css('scroll-snap-type', '');
				$wrapperEl.transition('');
			}
			if (params.hide) {
				clearTimeout(dragTimeout);
				dragTimeout = nextTick(() => {
					$el.css('opacity', 0);
					$el.transition(400);
				}, 1000);
			}
			emit('scrollbarDragEnd', e);
			if (params.snapOnRelease) {
				swiper.slideToClosest();
			}
		}

		function events(method) {
			const {
				scrollbar,
				touchEventsTouch,
				touchEventsDesktop,
				params,
				support
			} = swiper;
			const $el = scrollbar.$el;
			if (!$el) return;
			const target = $el[0];
			const activeListener = support.passiveListener && params.passiveListeners ? {
				passive: false,
				capture: false
			} : false;
			const passiveListener = support.passiveListener && params.passiveListeners ? {
				passive: true,
				capture: false
			} : false;
			if (!target) return;
			const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
			if (!support.touch) {
				target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
				document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
				document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
			} else {
				target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
				target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
				target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
			}
		}

		function enableDraggable() {
			if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
			events('on');
		}

		function disableDraggable() {
			if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
			events('off');
		}

		function init() {
			const {
				scrollbar,
				$el: $swiperEl
			} = swiper;
			swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
				el: 'swiper-scrollbar'
			});
			const params = swiper.params.scrollbar;
			if (!params.el) return;
			let $el = $(params.el);
			if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
				$el = $swiperEl.find(params.el);
			}
			$el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
			let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
			if ($dragEl.length === 0) {
				$dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
				$el.append($dragEl);
			}
			Object.assign(scrollbar, {
				$el,
				el: $el[0],
				$dragEl,
				dragEl: $dragEl[0]
			});
			if (params.draggable) {
				enableDraggable();
			}
			if ($el) {
				$el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
			}
		}

		function destroy() {
			const params = swiper.params.scrollbar;
			const $el = swiper.scrollbar.$el;
			if ($el) {
				$el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
			}
			disableDraggable();
		}
		on('init', () => {
			if (swiper.params.scrollbar.enabled === false) {
				// eslint-disable-next-line
				disable();
			} else {
				init();
				updateSize();
				setTranslate();
			}
		});
		on('update resize observerUpdate lock unlock', () => {
			updateSize();
		});
		on('setTranslate', () => {
			setTranslate();
		});
		on('setTransition', (_s, duration) => {
			setTransition(duration);
		});
		on('enable disable', () => {
			const {
				$el
			} = swiper.scrollbar;
			if ($el) {
				$el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
			}
		});
		on('destroy', () => {
			destroy();
		});
		const enable = () => {
			swiper.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass);
			if (swiper.scrollbar.$el) {
				swiper.scrollbar.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass);
			}
			init();
			updateSize();
			setTranslate();
		};
		const disable = () => {
			swiper.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass);
			if (swiper.scrollbar.$el) {
				swiper.scrollbar.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass);
			}
			destroy();
		};
		Object.assign(swiper.scrollbar, {
			enable,
			disable,
			updateSize,
			setTranslate,
			init,
			destroy
		});
	}

	function Parallax(_ref) {
		let {
			swiper,
			extendParams,
			on
		} = _ref;
		extendParams({
			parallax: {
				enabled: false
			}
		});
		const setTransform = (el, progress) => {
			const {
				rtl
			} = swiper;
			const $el = $(el);
			const rtlFactor = rtl ? -1 : 1;
			const p = $el.attr('data-swiper-parallax') || '0';
			let x = $el.attr('data-swiper-parallax-x');
			let y = $el.attr('data-swiper-parallax-y');
			const scale = $el.attr('data-swiper-parallax-scale');
			const opacity = $el.attr('data-swiper-parallax-opacity');
			if (x || y) {
				x = x || '0';
				y = y || '0';
			} else if (swiper.isHorizontal()) {
				x = p;
				y = '0';
			} else {
				y = p;
				x = '0';
			}
			if (x.indexOf('%') >= 0) {
				x = `${parseInt(x, 10) * progress * rtlFactor}%`;
			} else {
				x = `${x * progress * rtlFactor}px`;
			}
			if (y.indexOf('%') >= 0) {
				y = `${parseInt(y, 10) * progress}%`;
			} else {
				y = `${y * progress}px`;
			}
			if (typeof opacity !== 'undefined' && opacity !== null) {
				const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
				$el[0].style.opacity = currentOpacity;
			}
			if (typeof scale === 'undefined' || scale === null) {
				$el.transform(`translate3d(${x}, ${y}, 0px)`);
			} else {
				const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
				$el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
			}
		};
		const setTranslate = () => {
			const {
				$el,
				slides,
				progress,
				snapGrid
			} = swiper;
			$el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
				setTransform(el, progress);
			});
			slides.each((slideEl, slideIndex) => {
				let slideProgress = slideEl.progress;
				if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
					slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
				}
				slideProgress = Math.min(Math.max(slideProgress, -1), 1);
				$(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
					setTransform(el, slideProgress);
				});
			});
		};
		const setTransition = function(duration) {
			if (duration === void 0) {
				duration = swiper.params.speed;
			}
			const {
				$el
			} = swiper;
			$el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(parallaxEl => {
				const $parallaxEl = $(parallaxEl);
				let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
				if (duration === 0) parallaxDuration = 0;
				$parallaxEl.transition(parallaxDuration);
			});
		};
		on('beforeInit', () => {
			if (!swiper.params.parallax.enabled) return;
			swiper.params.watchSlidesProgress = true;
			swiper.originalParams.watchSlidesProgress = true;
		});
		on('init', () => {
			if (!swiper.params.parallax.enabled) return;
			setTranslate();
		});
		on('setTranslate', () => {
			if (!swiper.params.parallax.enabled) return;
			setTranslate();
		});
		on('setTransition', (_swiper, duration) => {
			if (!swiper.params.parallax.enabled) return;
			setTransition(duration);
		});
	}

	function Zoom(_ref) {
		let {
			swiper,
			extendParams,
			on,
			emit
		} = _ref;
		const window = getWindow();
		extendParams({
			zoom: {
				enabled: false,
				maxRatio: 3,
				minRatio: 1,
				toggle: true,
				containerClass: 'swiper-zoom-container',
				zoomedSlideClass: 'swiper-slide-zoomed'
			}
		});
		swiper.zoom = {
			enabled: false
		};
		let currentScale = 1;
		let isScaling = false;
		let gesturesEnabled;
		let fakeGestureTouched;
		let fakeGestureMoved;
		const gesture = {
			$slideEl: undefined,
			slideWidth: undefined,
			slideHeight: undefined,
			$imageEl: undefined,
			$imageWrapEl: undefined,
			maxRatio: 3
		};
		const image = {
			isTouched: undefined,
			isMoved: undefined,
			currentX: undefined,
			currentY: undefined,
			minX: undefined,
			minY: undefined,
			maxX: undefined,
			maxY: undefined,
			width: undefined,
			height: undefined,
			startX: undefined,
			startY: undefined,
			touchesStart: {},
			touchesCurrent: {}
		};
		const velocity = {
			x: undefined,
			y: undefined,
			prevPositionX: undefined,
			prevPositionY: undefined,
			prevTime: undefined
		};
		let scale = 1;
		Object.defineProperty(swiper.zoom, 'scale', {
			get() {
				return scale;
			},
			set(value) {
				if (scale !== value) {
					const imageEl = gesture.$imageEl ? gesture.$imageEl[0] : undefined;
					const slideEl = gesture.$slideEl ? gesture.$slideEl[0] : undefined;
					emit('zoomChange', value, imageEl, slideEl);
				}
				scale = value;
			}
		});

		function getDistanceBetweenTouches(e) {
			if (e.targetTouches.length < 2) return 1;
			const x1 = e.targetTouches[0].pageX;
			const y1 = e.targetTouches[0].pageY;
			const x2 = e.targetTouches[1].pageX;
			const y2 = e.targetTouches[1].pageY;
			const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
			return distance;
		} // Events
		function onGestureStart(e) {
			const support = swiper.support;
			const params = swiper.params.zoom;
			fakeGestureTouched = false;
			fakeGestureMoved = false;
			if (!support.gestures) {
				if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
					return;
				}
				fakeGestureTouched = true;
				gesture.scaleStart = getDistanceBetweenTouches(e);
			}
			if (!gesture.$slideEl || !gesture.$slideEl.length) {
				gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
				if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
				gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
				gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
				gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
				if (gesture.$imageWrapEl.length === 0) {
					gesture.$imageEl = undefined;
					return;
				}
			}
			if (gesture.$imageEl) {
				gesture.$imageEl.transition(0);
			}
			isScaling = true;
		}

		function onGestureChange(e) {
			const support = swiper.support;
			const params = swiper.params.zoom;
			const zoom = swiper.zoom;
			if (!support.gestures) {
				if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
					return;
				}
				fakeGestureMoved = true;
				gesture.scaleMove = getDistanceBetweenTouches(e);
			}
			if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
				if (e.type === 'gesturechange') onGestureStart(e);
				return;
			}
			if (support.gestures) {
				zoom.scale = e.scale * currentScale;
			} else {
				zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
			}
			if (zoom.scale > gesture.maxRatio) {
				zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
			}
			if (zoom.scale < params.minRatio) {
				zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
			}
			gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
		}

		function onGestureEnd(e) {
			const device = swiper.device;
			const support = swiper.support;
			const params = swiper.params.zoom;
			const zoom = swiper.zoom;
			if (!support.gestures) {
				if (!fakeGestureTouched || !fakeGestureMoved) {
					return;
				}
				if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !device.android) {
					return;
				}
				fakeGestureTouched = false;
				fakeGestureMoved = false;
			}
			if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
			zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
			gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
			currentScale = zoom.scale;
			isScaling = false;
			if (zoom.scale === 1) gesture.$slideEl = undefined;
		}

		function onTouchStart(e) {
			const device = swiper.device;
			if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
			if (image.isTouched) return;
			if (device.android && e.cancelable) e.preventDefault();
			image.isTouched = true;
			image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
			image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
		}

		function onTouchMove(e) {
			const zoom = swiper.zoom;
			if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
			swiper.allowClick = false;
			if (!image.isTouched || !gesture.$slideEl) return;
			if (!image.isMoved) {
				image.width = gesture.$imageEl[0].offsetWidth;
				image.height = gesture.$imageEl[0].offsetHeight;
				image.startX = getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
				image.startY = getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
				gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
				gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
				gesture.$imageWrapEl.transition(0);
			} // Define if we need image drag
			const scaledWidth = image.width * zoom.scale;
			const scaledHeight = image.height * zoom.scale;
			if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
			image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
			image.maxX = -image.minX;
			image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
			image.maxY = -image.minY;
			image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
			image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
			if (!image.isMoved && !isScaling) {
				if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
					image.isTouched = false;
					return;
				}
				if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
					image.isTouched = false;
					return;
				}
			}
			if (e.cancelable) {
				e.preventDefault();
			}
			e.stopPropagation();
			image.isMoved = true;
			image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
			image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;
			if (image.currentX < image.minX) {
				image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
			}
			if (image.currentX > image.maxX) {
				image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
			}
			if (image.currentY < image.minY) {
				image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
			}
			if (image.currentY > image.maxY) {
				image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
			} // Velocity
			if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
			if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
			if (!velocity.prevTime) velocity.prevTime = Date.now();
			velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
			velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
			if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
			if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
			velocity.prevPositionX = image.touchesCurrent.x;
			velocity.prevPositionY = image.touchesCurrent.y;
			velocity.prevTime = Date.now();
			gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
		}

		function onTouchEnd() {
			const zoom = swiper.zoom;
			if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
			if (!image.isTouched || !image.isMoved) {
				image.isTouched = false;
				image.isMoved = false;
				return;
			}
			image.isTouched = false;
			image.isMoved = false;
			let momentumDurationX = 300;
			let momentumDurationY = 300;
			const momentumDistanceX = velocity.x * momentumDurationX;
			const newPositionX = image.currentX + momentumDistanceX;
			const momentumDistanceY = velocity.y * momentumDurationY;
			const newPositionY = image.currentY + momentumDistanceY; // Fix duration
			if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
			if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
			const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
			image.currentX = newPositionX;
			image.currentY = newPositionY; // Define if we need image drag
			const scaledWidth = image.width * zoom.scale;
			const scaledHeight = image.height * zoom.scale;
			image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
			image.maxX = -image.minX;
			image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
			image.maxY = -image.minY;
			image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
			image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
			gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
		}

		function onTransitionEnd() {
			const zoom = swiper.zoom;
			if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
				if (gesture.$imageEl) {
					gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
				}
				if (gesture.$imageWrapEl) {
					gesture.$imageWrapEl.transform('translate3d(0,0,0)');
				}
				zoom.scale = 1;
				currentScale = 1;
				gesture.$slideEl = undefined;
				gesture.$imageEl = undefined;
				gesture.$imageWrapEl = undefined;
			}
		}

		function zoomIn(e) {
			const zoom = swiper.zoom;
			const params = swiper.params.zoom;
			if (!gesture.$slideEl) {
				if (e && e.target) {
					gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
				}
				if (!gesture.$slideEl) {
					if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
						gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
					} else {
						gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
					}
				}
				gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
				gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
			}
			if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;
			if (swiper.params.cssMode) {
				swiper.wrapperEl.style.overflow = 'hidden';
				swiper.wrapperEl.style.touchAction = 'none';
			}
			gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);
			let touchX;
			let touchY;
			let offsetX;
			let offsetY;
			let diffX;
			let diffY;
			let translateX;
			let translateY;
			let imageWidth;
			let imageHeight;
			let scaledWidth;
			let scaledHeight;
			let translateMinX;
			let translateMinY;
			let translateMaxX;
			let translateMaxY;
			let slideWidth;
			let slideHeight;
			if (typeof image.touchesStart.x === 'undefined' && e) {
				touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
				touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
			} else {
				touchX = image.touchesStart.x;
				touchY = image.touchesStart.y;
			}
			zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
			currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
			if (e) {
				slideWidth = gesture.$slideEl[0].offsetWidth;
				slideHeight = gesture.$slideEl[0].offsetHeight;
				offsetX = gesture.$slideEl.offset().left + window.scrollX;
				offsetY = gesture.$slideEl.offset().top + window.scrollY;
				diffX = offsetX + slideWidth / 2 - touchX;
				diffY = offsetY + slideHeight / 2 - touchY;
				imageWidth = gesture.$imageEl[0].offsetWidth;
				imageHeight = gesture.$imageEl[0].offsetHeight;
				scaledWidth = imageWidth * zoom.scale;
				scaledHeight = imageHeight * zoom.scale;
				translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
				translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
				translateMaxX = -translateMinX;
				translateMaxY = -translateMinY;
				translateX = diffX * zoom.scale;
				translateY = diffY * zoom.scale;
				if (translateX < translateMinX) {
					translateX = translateMinX;
				}
				if (translateX > translateMaxX) {
					translateX = translateMaxX;
				}
				if (translateY < translateMinY) {
					translateY = translateMinY;
				}
				if (translateY > translateMaxY) {
					translateY = translateMaxY;
				}
			} else {
				translateX = 0;
				translateY = 0;
			}
			gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
			gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
		}

		function zoomOut() {
			const zoom = swiper.zoom;
			const params = swiper.params.zoom;
			if (!gesture.$slideEl) {
				if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
					gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
				} else {
					gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
				}
				gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
				gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
			}
			if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;
			if (swiper.params.cssMode) {
				swiper.wrapperEl.style.overflow = '';
				swiper.wrapperEl.style.touchAction = '';
			}
			zoom.scale = 1;
			currentScale = 1;
			gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
			gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
			gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
			gesture.$slideEl = undefined;
		} // Toggle Zoom
		function zoomToggle(e) {
			const zoom = swiper.zoom;
			if (zoom.scale && zoom.scale !== 1) {
				// Zoom Out
				zoomOut();
			} else {
				// Zoom In
				zoomIn(e);
			}
		}

		function getListeners() {
			const support = swiper.support;
			const passiveListener = swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners ? {
				passive: true,
				capture: false
			} : false;
			const activeListenerWithCapture = support.passiveListener ? {
				passive: false,
				capture: true
			} : true;
			return {
				passiveListener,
				activeListenerWithCapture
			};
		}

		function getSlideSelector() {
			return `.${swiper.params.slideClass}`;
		}

		function toggleGestures(method) {
			const {
				passiveListener
			} = getListeners();
			const slideSelector = getSlideSelector();
			swiper.$wrapperEl[method]('gesturestart', slideSelector, onGestureStart, passiveListener);
			swiper.$wrapperEl[method]('gesturechange', slideSelector, onGestureChange, passiveListener);
			swiper.$wrapperEl[method]('gestureend', slideSelector, onGestureEnd, passiveListener);
		}

		function enableGestures() {
			if (gesturesEnabled) return;
			gesturesEnabled = true;
			toggleGestures('on');
		}

		function disableGestures() {
			if (!gesturesEnabled) return;
			gesturesEnabled = false;
			toggleGestures('off');
		} // Attach/Detach Events
		function enable() {
			const zoom = swiper.zoom;
			if (zoom.enabled) return;
			zoom.enabled = true;
			const support = swiper.support;
			const {
				passiveListener,
				activeListenerWithCapture
			} = getListeners();
			const slideSelector = getSlideSelector(); // Scale image
			if (support.gestures) {
				swiper.$wrapperEl.on(swiper.touchEvents.start, enableGestures, passiveListener);
				swiper.$wrapperEl.on(swiper.touchEvents.end, disableGestures, passiveListener);
			} else if (swiper.touchEvents.start === 'touchstart') {
				swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
				swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
				swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);
				if (swiper.touchEvents.cancel) {
					swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
				}
			} // Move image
			swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove, activeListenerWithCapture);
		}

		function disable() {
			const zoom = swiper.zoom;
			if (!zoom.enabled) return;
			const support = swiper.support;
			zoom.enabled = false;
			const {
				passiveListener,
				activeListenerWithCapture
			} = getListeners();
			const slideSelector = getSlideSelector(); // Scale image
			if (support.gestures) {
				swiper.$wrapperEl.off(swiper.touchEvents.start, enableGestures, passiveListener);
				swiper.$wrapperEl.off(swiper.touchEvents.end, disableGestures, passiveListener);
			} else if (swiper.touchEvents.start === 'touchstart') {
				swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
				swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
				swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);
				if (swiper.touchEvents.cancel) {
					swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
				}
			} // Move image
			swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove, activeListenerWithCapture);
		}
		on('init', () => {
			if (swiper.params.zoom.enabled) {
				enable();
			}
		});
		on('destroy', () => {
			disable();
		});
		on('touchStart', (_s, e) => {
			if (!swiper.zoom.enabled) return;
			onTouchStart(e);
		});
		on('touchEnd', (_s, e) => {
			if (!swiper.zoom.enabled) return;
			onTouchEnd();
		});
		on('doubleTap', (_s, e) => {
			if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
				zoomToggle(e);
			}
		});
		on('transitionEnd', () => {
			if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
				onTransitionEnd();
			}
		});
		on('slideChange', () => {
			if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
				onTransitionEnd();
			}
		});
		Object.assign(swiper.zoom, {
			enable,
			disable,
			in: zoomIn,
			out: zoomOut,
			toggle: zoomToggle
		});
	}

	function Lazy(_ref) {
		let {
			swiper,
			extendParams,
			on,
			emit
		} = _ref;
		extendParams({
			lazy: {
				checkInView: false,
				enabled: false,
				loadPrevNext: false,
				loadPrevNextAmount: 1,
				loadOnTransitionStart: false,
				scrollingElement: '',
				elementClass: 'swiper-lazy',
				loadingClass: 'swiper-lazy-loading',
				loadedClass: 'swiper-lazy-loaded',
				preloaderClass: 'swiper-lazy-preloader'
			}
		});
		swiper.lazy = {};
		let scrollHandlerAttached = false;
		let initialImageLoaded = false;

		function loadInSlide(index, loadInDuplicate) {
			if (loadInDuplicate === void 0) {
				loadInDuplicate = true;
			}
			const params = swiper.params.lazy;
			if (typeof index === 'undefined') return;
			if (swiper.slides.length === 0) return;
			const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
			const $slideEl = isVirtual ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`) : swiper.slides.eq(index);
			const $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
			if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
				$images.push($slideEl[0]);
			}
			if ($images.length === 0) return;
			$images.each(imageEl => {
				const $imageEl = $(imageEl);
				$imageEl.addClass(params.loadingClass);
				const background = $imageEl.attr('data-background');
				const src = $imageEl.attr('data-src');
				const srcset = $imageEl.attr('data-srcset');
				const sizes = $imageEl.attr('data-sizes');
				const $pictureEl = $imageEl.parent('picture');
				swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, () => {
					if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;
					if (background) {
						$imageEl.css('background-image', `url("${background}")`);
						$imageEl.removeAttr('data-background');
					} else {
						if (srcset) {
							$imageEl.attr('srcset', srcset);
							$imageEl.removeAttr('data-srcset');
						}
						if (sizes) {
							$imageEl.attr('sizes', sizes);
							$imageEl.removeAttr('data-sizes');
						}
						if ($pictureEl.length) {
							$pictureEl.children('source').each(sourceEl => {
								const $source = $(sourceEl);
								if ($source.attr('data-srcset')) {
									$source.attr('srcset', $source.attr('data-srcset'));
									$source.removeAttr('data-srcset');
								}
							});
						}
						if (src) {
							$imageEl.attr('src', src);
							$imageEl.removeAttr('data-src');
						}
					}
					$imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
					$slideEl.find(`.${params.preloaderClass}`).remove();
					if (swiper.params.loop && loadInDuplicate) {
						const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
						if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
							const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
							loadInSlide(originalSlide.index(), false);
						} else {
							const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
							loadInSlide(duplicatedSlide.index(), false);
						}
					}
					emit('lazyImageReady', $slideEl[0], $imageEl[0]);
					if (swiper.params.autoHeight) {
						swiper.updateAutoHeight();
					}
				});
				emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
			});
		}

		function load() {
			const {
				$wrapperEl,
				params: swiperParams,
				slides,
				activeIndex
			} = swiper;
			const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
			const params = swiperParams.lazy;
			let slidesPerView = swiperParams.slidesPerView;
			if (slidesPerView === 'auto') {
				slidesPerView = 0;
			}

			function slideExist(index) {
				if (isVirtual) {
					if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`).length) {
						return true;
					}
				} else if (slides[index]) return true;
				return false;
			}

			function slideIndex(slideEl) {
				if (isVirtual) {
					return $(slideEl).attr('data-swiper-slide-index');
				}
				return $(slideEl).index();
			}
			if (!initialImageLoaded) initialImageLoaded = true;
			if (swiper.params.watchSlidesProgress) {
				$wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each(slideEl => {
					const index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
					loadInSlide(index);
				});
			} else if (slidesPerView > 1) {
				for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
					if (slideExist(i)) loadInSlide(i);
				}
			} else {
				loadInSlide(activeIndex);
			}
			if (params.loadPrevNext) {
				if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
					const amount = params.loadPrevNextAmount;
					const spv = Math.ceil(slidesPerView);
					const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
					const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides
					for (let i = activeIndex + spv; i < maxIndex; i += 1) {
						if (slideExist(i)) loadInSlide(i);
					} // Prev Slides
					for (let i = minIndex; i < activeIndex; i += 1) {
						if (slideExist(i)) loadInSlide(i);
					}
				} else {
					const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
					if (nextSlide.length > 0) loadInSlide(slideIndex(nextSlide));
					const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
					if (prevSlide.length > 0) loadInSlide(slideIndex(prevSlide));
				}
			}
		}

		function checkInViewOnLoad() {
			const window = getWindow();
			if (!swiper || swiper.destroyed) return;
			const $scrollElement = swiper.params.lazy.scrollingElement ? $(swiper.params.lazy.scrollingElement) : $(window);
			const isWindow = $scrollElement[0] === window;
			const scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;
			const scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;
			const swiperOffset = swiper.$el.offset();
			const {
				rtlTranslate: rtl
			} = swiper;
			let inView = false;
			if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
			const swiperCoord = [
				[swiperOffset.left, swiperOffset.top],
				[swiperOffset.left + swiper.width, swiperOffset.top],
				[swiperOffset.left, swiperOffset.top + swiper.height],
				[swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]
			];
			for (let i = 0; i < swiperCoord.length; i += 1) {
				const point = swiperCoord[i];
				if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
					if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line
					inView = true;
				}
			}
			const passiveListener = swiper.touchEvents.start === 'touchstart' && swiper.support.passiveListener && swiper.params.passiveListeners ? {
				passive: true,
				capture: false
			} : false;
			if (inView) {
				load();
				$scrollElement.off('scroll', checkInViewOnLoad, passiveListener);
			} else if (!scrollHandlerAttached) {
				scrollHandlerAttached = true;
				$scrollElement.on('scroll', checkInViewOnLoad, passiveListener);
			}
		}
		on('beforeInit', () => {
			if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
				swiper.params.preloadImages = false;
			}
		});
		on('init', () => {
			if (swiper.params.lazy.enabled) {
				if (swiper.params.lazy.checkInView) {
					checkInViewOnLoad();
				} else {
					load();
				}
			}
		});
		on('scroll', () => {
			if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.freeMode.sticky) {
				load();
			}
		});
		on('scrollbarDragMove resize _freeModeNoMomentumRelease', () => {
			if (swiper.params.lazy.enabled) {
				if (swiper.params.lazy.checkInView) {
					checkInViewOnLoad();
				} else {
					load();
				}
			}
		});
		on('transitionStart', () => {
			if (swiper.params.lazy.enabled) {
				if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded) {
					if (swiper.params.lazy.checkInView) {
						checkInViewOnLoad();
					} else {
						load();
					}
				}
			}
		});
		on('transitionEnd', () => {
			if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
				if (swiper.params.lazy.checkInView) {
					checkInViewOnLoad();
				} else {
					load();
				}
			}
		});
		on('slideChange', () => {
			const {
				lazy,
				cssMode,
				watchSlidesProgress,
				touchReleaseOnEdges,
				resistanceRatio
			} = swiper.params;
			if (lazy.enabled && (cssMode || watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0))) {
				load();
			}
		});
		on('destroy', () => {
			if (!swiper.$el) return;
			swiper.$el.find(`.${swiper.params.lazy.loadingClass}`).removeClass(swiper.params.lazy.loadingClass);
		});
		Object.assign(swiper.lazy, {
			load,
			loadInSlide
		});
	}
	/* eslint no-bitwise: ["error", { "allow": [">>"] }] */
	function Controller(_ref) {
		let {
			swiper,
			extendParams,
			on
		} = _ref;
		extendParams({
			controller: {
				control: undefined,
				inverse: false,
				by: 'slide' // or 'container'
			}
		});
		swiper.controller = {
			control: undefined
		};

		function LinearSpline(x, y) {
			const binarySearch = function search() {
				let maxIndex;
				let minIndex;
				let guess;
				return (array, val) => {
					minIndex = -1;
					maxIndex = array.length;
					while (maxIndex - minIndex > 1) {
						guess = maxIndex + minIndex >> 1;
						if (array[guess] <= val) {
							minIndex = guess;
						} else {
							maxIndex = guess;
						}
					}
					return maxIndex;
				};
			}();
			this.x = x;
			this.y = y;
			this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
			// (x1,y1) is the known point before given value,
			// (x3,y3) is the known point after given value.
			let i1;
			let i3;
			this.interpolate = function interpolate(x2) {
				if (!x2) return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):
				i3 = binarySearch(this.x, x2);
				i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
				// y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
				return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
			};
			return this;
		} // xxx: for now i will just save one spline function to to
		function getInterpolateFunction(c) {
			if (!swiper.controller.spline) {
				swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
			}
		}

		function setTranslate(_t, byController) {
			const controlled = swiper.controller.control;
			let multiplier;
			let controlledTranslate;
			const Swiper = swiper.constructor;

			function setControlledTranslate(c) {
				// this will create an Interpolate function based on the snapGrids
				// x is the Grid of the scrolled scroller and y will be the controlled scroller
				// it makes sense to create this only once and recall it for the interpolation
				// the function does a lot of value caching for performance
				const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
				if (swiper.params.controller.by === 'slide') {
					getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
					// but it did not work out
					controlledTranslate = -swiper.controller.spline.interpolate(-translate);
				}
				if (!controlledTranslate || swiper.params.controller.by === 'container') {
					multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
					controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
				}
				if (swiper.params.controller.inverse) {
					controlledTranslate = c.maxTranslate() - controlledTranslate;
				}
				c.updateProgress(controlledTranslate);
				c.setTranslate(controlledTranslate, swiper);
				c.updateActiveIndex();
				c.updateSlidesClasses();
			}
			if (Array.isArray(controlled)) {
				for (let i = 0; i < controlled.length; i += 1) {
					if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
						setControlledTranslate(controlled[i]);
					}
				}
			} else if (controlled instanceof Swiper && byController !== controlled) {
				setControlledTranslate(controlled);
			}
		}

		function setTransition(duration, byController) {
			const Swiper = swiper.constructor;
			const controlled = swiper.controller.control;
			let i;

			function setControlledTransition(c) {
				c.setTransition(duration, swiper);
				if (duration !== 0) {
					c.transitionStart();
					if (c.params.autoHeight) {
						nextTick(() => {
							c.updateAutoHeight();
						});
					}
					c.$wrapperEl.transitionEnd(() => {
						if (!controlled) return;
						if (c.params.loop && swiper.params.controller.by === 'slide') {
							c.loopFix();
						}
						c.transitionEnd();
					});
				}
			}
			if (Array.isArray(controlled)) {
				for (i = 0; i < controlled.length; i += 1) {
					if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
						setControlledTransition(controlled[i]);
					}
				}
			} else if (controlled instanceof Swiper && byController !== controlled) {
				setControlledTransition(controlled);
			}
		}

		function removeSpline() {
			if (!swiper.controller.control) return;
			if (swiper.controller.spline) {
				swiper.controller.spline = undefined;
				delete swiper.controller.spline;
			}
		}
		on('beforeInit', () => {
			swiper.controller.control = swiper.params.controller.control;
		});
		on('update', () => {
			removeSpline();
		});
		on('resize', () => {
			removeSpline();
		});
		on('observerUpdate', () => {
			removeSpline();
		});
		on('setTranslate', (_s, translate, byController) => {
			if (!swiper.controller.control) return;
			swiper.controller.setTranslate(translate, byController);
		});
		on('setTransition', (_s, duration, byController) => {
			if (!swiper.controller.control) return;
			swiper.controller.setTransition(duration, byController);
		});
		Object.assign(swiper.controller, {
			setTranslate,
			setTransition
		});
	}

	function A11y(_ref) {
		let {
			swiper,
			extendParams,
			on
		} = _ref;
		extendParams({
			a11y: {
				enabled: true,
				notificationClass: 'swiper-notification',
				prevSlideMessage: 'Previous slide',
				nextSlideMessage: 'Next slide',
				firstSlideMessage: 'This is the first slide',
				lastSlideMessage: 'This is the last slide',
				paginationBulletMessage: 'Go to slide {{index}}',
				slideLabelMessage: '{{index}} / {{slidesLength}}',
				containerMessage: null,
				containerRoleDescriptionMessage: null,
				itemRoleDescriptionMessage: null,
				slideRole: 'group',
				id: null
			}
		});
		swiper.a11y = {
			clicked: false
		};
		let liveRegion = null;

		function notify(message) {
			const notification = liveRegion;
			if (notification.length === 0) return;
			notification.html('');
			notification.html(message);
		}

		function getRandomNumber(size) {
			if (size === void 0) {
				size = 16;
			}
			const randomChar = () => Math.round(16 * Math.random()).toString(16);
			return 'x'.repeat(size).replace(/x/g, randomChar);
		}

		function makeElFocusable($el) {
			$el.attr('tabIndex', '0');
		}

		function makeElNotFocusable($el) {
			$el.attr('tabIndex', '-1');
		}

		function addElRole($el, role) {
			$el.attr('role', role);
		}

		function addElRoleDescription($el, description) {
			$el.attr('aria-roledescription', description);
		}

		function addElControls($el, controls) {
			$el.attr('aria-controls', controls);
		}

		function addElLabel($el, label) {
			$el.attr('aria-label', label);
		}

		function addElId($el, id) {
			$el.attr('id', id);
		}

		function addElLive($el, live) {
			$el.attr('aria-live', live);
		}

		function disableEl($el) {
			$el.attr('aria-disabled', true);
		}

		function enableEl($el) {
			$el.attr('aria-disabled', false);
		}

		function onEnterOrSpaceKey(e) {
			if (e.keyCode !== 13 && e.keyCode !== 32) return;
			const params = swiper.params.a11y;
			const $targetEl = $(e.target);
			if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
				if (!(swiper.isEnd && !swiper.params.loop)) {
					swiper.slideNext();
				}
				if (swiper.isEnd) {
					notify(params.lastSlideMessage);
				} else {
					notify(params.nextSlideMessage);
				}
			}
			if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
				if (!(swiper.isBeginning && !swiper.params.loop)) {
					swiper.slidePrev();
				}
				if (swiper.isBeginning) {
					notify(params.firstSlideMessage);
				} else {
					notify(params.prevSlideMessage);
				}
			}
			if (swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))) {
				$targetEl[0].click();
			}
		}

		function updateNavigation() {
			if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
			const {
				$nextEl,
				$prevEl
			} = swiper.navigation;
			if ($prevEl && $prevEl.length > 0) {
				if (swiper.isBeginning) {
					disableEl($prevEl);
					makeElNotFocusable($prevEl);
				} else {
					enableEl($prevEl);
					makeElFocusable($prevEl);
				}
			}
			if ($nextEl && $nextEl.length > 0) {
				if (swiper.isEnd) {
					disableEl($nextEl);
					makeElNotFocusable($nextEl);
				} else {
					enableEl($nextEl);
					makeElFocusable($nextEl);
				}
			}
		}

		function hasPagination() {
			return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
		}

		function hasClickablePagination() {
			return hasPagination() && swiper.params.pagination.clickable;
		}

		function updatePagination() {
			const params = swiper.params.a11y;
			if (!hasPagination()) return;
			swiper.pagination.bullets.each(bulletEl => {
				const $bulletEl = $(bulletEl);
				if (swiper.params.pagination.clickable) {
					makeElFocusable($bulletEl);
					if (!swiper.params.pagination.renderBullet) {
						addElRole($bulletEl, 'button');
						addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
					}
				}
				if ($bulletEl.is(`.${swiper.params.pagination.bulletActiveClass}`)) {
					$bulletEl.attr('aria-current', 'true');
				} else {
					$bulletEl.removeAttr('aria-current');
				}
			});
		}
		const initNavEl = ($el, wrapperId, message) => {
			makeElFocusable($el);
			if ($el[0].tagName !== 'BUTTON') {
				addElRole($el, 'button');
				$el.on('keydown', onEnterOrSpaceKey);
			}
			addElLabel($el, message);
			addElControls($el, wrapperId);
		};
		const handlePointerDown = () => {
			swiper.a11y.clicked = true;
		};
		const handlePointerUp = () => {
			swiper.a11y.clicked = false;
		};
		const handleFocus = e => {
			if (swiper.a11y.clicked) return;
			const slideEl = e.target.closest(`.${swiper.params.slideClass}`);
			if (!slideEl || !swiper.slides.includes(slideEl)) return;
			const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
			const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
			if (isActive || isVisible) return;
			if (swiper.isHorizontal()) {
				swiper.el.scrollLeft = 0;
			} else {
				swiper.el.scrollTop = 0;
			}
			swiper.slideTo(swiper.slides.indexOf(slideEl), 0);
		};
		const initSlides = () => {
			const params = swiper.params.a11y;
			if (params.itemRoleDescriptionMessage) {
				addElRoleDescription($(swiper.slides), params.itemRoleDescriptionMessage);
			}
			if (params.slideRole) {
				addElRole($(swiper.slides), params.slideRole);
			}
			const slidesLength = swiper.params.loop ? swiper.slides.filter(el => !el.classList.contains(swiper.params.slideDuplicateClass)).length : swiper.slides.length;
			if (params.slideLabelMessage) {
				swiper.slides.each((slideEl, index) => {
					const $slideEl = $(slideEl);
					const slideIndex = swiper.params.loop ? parseInt($slideEl.attr('data-swiper-slide-index'), 10) : index;
					const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
					addElLabel($slideEl, ariaLabelMessage);
				});
			}
		};
		const init = () => {
			const params = swiper.params.a11y;
			swiper.$el.append(liveRegion); // Container
			const $containerEl = swiper.$el;
			if (params.containerRoleDescriptionMessage) {
				addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
			}
			if (params.containerMessage) {
				addElLabel($containerEl, params.containerMessage);
			} // Wrapper
			const $wrapperEl = swiper.$wrapperEl;
			const wrapperId = params.id || $wrapperEl.attr('id') || `swiper-wrapper-${getRandomNumber(16)}`;
			const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
			addElId($wrapperEl, wrapperId);
			addElLive($wrapperEl, live); // Slide
			initSlides(); // Navigation
			let $nextEl;
			let $prevEl;
			if (swiper.navigation && swiper.navigation.$nextEl) {
				$nextEl = swiper.navigation.$nextEl;
			}
			if (swiper.navigation && swiper.navigation.$prevEl) {
				$prevEl = swiper.navigation.$prevEl;
			}
			if ($nextEl && $nextEl.length) {
				initNavEl($nextEl, wrapperId, params.nextSlideMessage);
			}
			if ($prevEl && $prevEl.length) {
				initNavEl($prevEl, wrapperId, params.prevSlideMessage);
			} // Pagination
			if (hasClickablePagination()) {
				swiper.pagination.$el.on('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
			} // Tab focus
			swiper.$el.on('focus', handleFocus, true);
			swiper.$el.on('pointerdown', handlePointerDown, true);
			swiper.$el.on('pointerup', handlePointerUp, true);
		};

		function destroy() {
			if (liveRegion && liveRegion.length > 0) liveRegion.remove();
			let $nextEl;
			let $prevEl;
			if (swiper.navigation && swiper.navigation.$nextEl) {
				$nextEl = swiper.navigation.$nextEl;
			}
			if (swiper.navigation && swiper.navigation.$prevEl) {
				$prevEl = swiper.navigation.$prevEl;
			}
			if ($nextEl) {
				$nextEl.off('keydown', onEnterOrSpaceKey);
			}
			if ($prevEl) {
				$prevEl.off('keydown', onEnterOrSpaceKey);
			} // Pagination
			if (hasClickablePagination()) {
				swiper.pagination.$el.off('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
			} // Tab focus
			swiper.$el.off('focus', handleFocus, true);
			swiper.$el.off('pointerdown', handlePointerDown, true);
			swiper.$el.off('pointerup', handlePointerUp, true);
		}
		on('beforeInit', () => {
			liveRegion = $(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`);
		});
		on('afterInit', () => {
			if (!swiper.params.a11y.enabled) return;
			init();
		});
		on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {
			if (!swiper.params.a11y.enabled) return;
			initSlides();
		});
		on('fromEdge toEdge afterInit lock unlock', () => {
			if (!swiper.params.a11y.enabled) return;
			updateNavigation();
		});
		on('paginationUpdate', () => {
			if (!swiper.params.a11y.enabled) return;
			updatePagination();
		});
		on('destroy', () => {
			if (!swiper.params.a11y.enabled) return;
			destroy();
		});
	}

	function History(_ref) {
		let {
			swiper,
			extendParams,
			on
		} = _ref;
		extendParams({
			history: {
				enabled: false,
				root: '',
				replaceState: false,
				key: 'slides',
				keepQuery: false
			}
		});
		let initialized = false;
		let paths = {};
		const slugify = text => {
			return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
		};
		const getPathValues = urlOverride => {
			const window = getWindow();
			let location;
			if (urlOverride) {
				location = new URL(urlOverride);
			} else {
				location = window.location;
			}
			const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');
			const total = pathArray.length;
			const key = pathArray[total - 2];
			const value = pathArray[total - 1];
			return {
				key,
				value
			};
		};
		const setHistory = (key, index) => {
			const window = getWindow();
			if (!initialized || !swiper.params.history.enabled) return;
			let location;
			if (swiper.params.url) {
				location = new URL(swiper.params.url);
			} else {
				location = window.location;
			}
			const slide = swiper.slides.eq(index);
			let value = slugify(slide.attr('data-history'));
			if (swiper.params.history.root.length > 0) {
				let root = swiper.params.history.root;
				if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
				value = `${root}/${key}/${value}`;
			} else if (!location.pathname.includes(key)) {
				value = `${key}/${value}`;
			}
			if (swiper.params.history.keepQuery) {
				value += location.search;
			}
			const currentState = window.history.state;
			if (currentState && currentState.value === value) {
				return;
			}
			if (swiper.params.history.replaceState) {
				window.history.replaceState({
					value
				}, null, value);
			} else {
				window.history.pushState({
					value
				}, null, value);
			}
		};
		const scrollToSlide = (speed, value, runCallbacks) => {
			if (value) {
				for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
					const slide = swiper.slides.eq(i);
					const slideHistory = slugify(slide.attr('data-history'));
					if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
						const index = slide.index();
						swiper.slideTo(index, speed, runCallbacks);
					}
				}
			} else {
				swiper.slideTo(0, speed, runCallbacks);
			}
		};
		const setHistoryPopState = () => {
			paths = getPathValues(swiper.params.url);
			scrollToSlide(swiper.params.speed, paths.value, false);
		};
		const init = () => {
			const window = getWindow();
			if (!swiper.params.history) return;
			if (!window.history || !window.history.pushState) {
				swiper.params.history.enabled = false;
				swiper.params.hashNavigation.enabled = true;
				return;
			}
			initialized = true;
			paths = getPathValues(swiper.params.url);
			if (!paths.key && !paths.value) return;
			scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
			if (!swiper.params.history.replaceState) {
				window.addEventListener('popstate', setHistoryPopState);
			}
		};
		const destroy = () => {
			const window = getWindow();
			if (!swiper.params.history.replaceState) {
				window.removeEventListener('popstate', setHistoryPopState);
			}
		};
		on('init', () => {
			if (swiper.params.history.enabled) {
				init();
			}
		});
		on('destroy', () => {
			if (swiper.params.history.enabled) {
				destroy();
			}
		});
		on('transitionEnd _freeModeNoMomentumRelease', () => {
			if (initialized) {
				setHistory(swiper.params.history.key, swiper.activeIndex);
			}
		});
		on('slideChange', () => {
			if (initialized && swiper.params.cssMode) {
				setHistory(swiper.params.history.key, swiper.activeIndex);
			}
		});
	}

	function HashNavigation(_ref) {
		let {
			swiper,
			extendParams,
			emit,
			on
		} = _ref;
		let initialized = false;
		const document = getDocument();
		const window = getWindow();
		extendParams({
			hashNavigation: {
				enabled: false,
				replaceState: false,
				watchState: false
			}
		});
		const onHashChange = () => {
			emit('hashChange');
			const newHash = document.location.hash.replace('#', '');
			const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
			if (newHash !== activeSlideHash) {
				const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index();
				if (typeof newIndex === 'undefined') return;
				swiper.slideTo(newIndex);
			}
		};
		const setHash = () => {
			if (!initialized || !swiper.params.hashNavigation.enabled) return;
			if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
				window.history.replaceState(null, null, `#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || '');
				emit('hashSet');
			} else {
				const slide = swiper.slides.eq(swiper.activeIndex);
				const hash = slide.attr('data-hash') || slide.attr('data-history');
				document.location.hash = hash || '';
				emit('hashSet');
			}
		};
		const init = () => {
			if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
			initialized = true;
			const hash = document.location.hash.replace('#', '');
			if (hash) {
				const speed = 0;
				for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
					const slide = swiper.slides.eq(i);
					const slideHash = slide.attr('data-hash') || slide.attr('data-history');
					if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
						const index = slide.index();
						swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
					}
				}
			}
			if (swiper.params.hashNavigation.watchState) {
				$(window).on('hashchange', onHashChange);
			}
		};
		const destroy = () => {
			if (swiper.params.hashNavigation.watchState) {
				$(window).off('hashchange', onHashChange);
			}
		};
		on('init', () => {
			if (swiper.params.hashNavigation.enabled) {
				init();
			}
		});
		on('destroy', () => {
			if (swiper.params.hashNavigation.enabled) {
				destroy();
			}
		});
		on('transitionEnd _freeModeNoMomentumRelease', () => {
			if (initialized) {
				setHash();
			}
		});
		on('slideChange', () => {
			if (initialized && swiper.params.cssMode) {
				setHash();
			}
		});
	}
	/* eslint no-underscore-dangle: "off" */
	function Autoplay(_ref) {
		let {
			swiper,
			extendParams,
			on,
			emit
		} = _ref;
		let timeout;
		swiper.autoplay = {
			running: false,
			paused: false
		};
		extendParams({
			autoplay: {
				enabled: false,
				delay: 3000,
				waitForTransition: true,
				disableOnInteraction: true,
				stopOnLastSlide: false,
				reverseDirection: false,
				pauseOnMouseEnter: false
			}
		});

		function run() {
			if (!swiper.size) {
				swiper.autoplay.running = false;
				swiper.autoplay.paused = false;
				return;
			}
			const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
			let delay = swiper.params.autoplay.delay;
			if ($activeSlideEl.attr('data-swiper-autoplay')) {
				delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
			}
			clearTimeout(timeout);
			timeout = nextTick(() => {
				let autoplayResult;
				if (swiper.params.autoplay.reverseDirection) {
					if (swiper.params.loop) {
						swiper.loopFix();
						autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
						emit('autoplay');
					} else if (!swiper.isBeginning) {
						autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
						emit('autoplay');
					} else if (!swiper.params.autoplay.stopOnLastSlide) {
						autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
						emit('autoplay');
					} else {
						stop();
					}
				} else if (swiper.params.loop) {
					swiper.loopFix();
					autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
					emit('autoplay');
				} else if (!swiper.isEnd) {
					autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
					emit('autoplay');
				} else if (!swiper.params.autoplay.stopOnLastSlide) {
					autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
					emit('autoplay');
				} else {
					stop();
				}
				if (swiper.params.cssMode && swiper.autoplay.running) run();
				else if (autoplayResult === false) {
					run();
				}
			}, delay);
		}

		function start() {
			if (typeof timeout !== 'undefined') return false;
			if (swiper.autoplay.running) return false;
			swiper.autoplay.running = true;
			emit('autoplayStart');
			run();
			return true;
		}

		function stop() {
			if (!swiper.autoplay.running) return false;
			if (typeof timeout === 'undefined') return false;
			if (timeout) {
				clearTimeout(timeout);
				timeout = undefined;
			}
			swiper.autoplay.running = false;
			emit('autoplayStop');
			return true;
		}

		function pause(speed) {
			if (!swiper.autoplay.running) return;
			if (swiper.autoplay.paused) return;
			if (timeout) clearTimeout(timeout);
			swiper.autoplay.paused = true;
			if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
				swiper.autoplay.paused = false;
				run();
			} else {
				['transitionend', 'webkitTransitionEnd'].forEach(event => {
					swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
				});
			}
		}

		function onVisibilityChange() {
			const document = getDocument();
			if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
				pause();
			}
			if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
				run();
				swiper.autoplay.paused = false;
			}
		}

		function onTransitionEnd(e) {
			if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
			if (e.target !== swiper.$wrapperEl[0]) return;
			['transitionend', 'webkitTransitionEnd'].forEach(event => {
				swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
			});
			swiper.autoplay.paused = false;
			if (!swiper.autoplay.running) {
				stop();
			} else {
				run();
			}
		}

		function onMouseEnter() {
			if (swiper.params.autoplay.disableOnInteraction) {
				stop();
			} else {
				emit('autoplayPause');
				pause();
			}
			['transitionend', 'webkitTransitionEnd'].forEach(event => {
				swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
			});
		}

		function onMouseLeave() {
			if (swiper.params.autoplay.disableOnInteraction) {
				return;
			}
			swiper.autoplay.paused = false;
			emit('autoplayResume');
			run();
		}

		function attachMouseEvents() {
			if (swiper.params.autoplay.pauseOnMouseEnter) {
				swiper.$el.on('mouseenter', onMouseEnter);
				swiper.$el.on('mouseleave', onMouseLeave);
			}
		}

		function detachMouseEvents() {
			swiper.$el.off('mouseenter', onMouseEnter);
			swiper.$el.off('mouseleave', onMouseLeave);
		}
		on('init', () => {
			if (swiper.params.autoplay.enabled) {
				start();
				const document = getDocument();
				document.addEventListener('visibilitychange', onVisibilityChange);
				attachMouseEvents();
			}
		});
		on('beforeTransitionStart', (_s, speed, internal) => {
			if (swiper.autoplay.running) {
				if (internal || !swiper.params.autoplay.disableOnInteraction) {
					swiper.autoplay.pause(speed);
				} else {
					stop();
				}
			}
		});
		on('sliderFirstMove', () => {
			if (swiper.autoplay.running) {
				if (swiper.params.autoplay.disableOnInteraction) {
					stop();
				} else {
					pause();
				}
			}
		});
		on('touchEnd', () => {
			if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
				run();
			}
		});
		on('destroy', () => {
			detachMouseEvents();
			if (swiper.autoplay.running) {
				stop();
			}
			const document = getDocument();
			document.removeEventListener('visibilitychange', onVisibilityChange);
		});
		Object.assign(swiper.autoplay, {
			pause,
			run,
			start,
			stop
		});
	}

	function Thumb(_ref) {
		let {
			swiper,
			extendParams,
			on
		} = _ref;
		extendParams({
			thumbs: {
				swiper: null,
				multipleActiveThumbs: true,
				autoScrollOffset: 0,
				slideThumbActiveClass: 'swiper-slide-thumb-active',
				thumbsContainerClass: 'swiper-thumbs'
			}
		});
		let initialized = false;
		let swiperCreated = false;
		swiper.thumbs = {
			swiper: null
		};

		function onThumbClick() {
			const thumbsSwiper = swiper.thumbs.swiper;
			if (!thumbsSwiper || thumbsSwiper.destroyed) return;
			const clickedIndex = thumbsSwiper.clickedIndex;
			const clickedSlide = thumbsSwiper.clickedSlide;
			if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
			if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
			let slideToIndex;
			if (thumbsSwiper.params.loop) {
				slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
			} else {
				slideToIndex = clickedIndex;
			}
			if (swiper.params.loop) {
				let currentIndex = swiper.activeIndex;
				if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
					swiper.loopFix(); // eslint-disable-next-line
					swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
					currentIndex = swiper.activeIndex;
				}
				const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
				const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
				if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;
				else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;
				else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;
				else slideToIndex = prevIndex;
			}
			swiper.slideTo(slideToIndex);
		}

		function init() {
			const {
				thumbs: thumbsParams
			} = swiper.params;
			if (initialized) return false;
			initialized = true;
			const SwiperClass = swiper.constructor;
			if (thumbsParams.swiper instanceof SwiperClass) {
				swiper.thumbs.swiper = thumbsParams.swiper;
				Object.assign(swiper.thumbs.swiper.originalParams, {
					watchSlidesProgress: true,
					slideToClickedSlide: false
				});
				Object.assign(swiper.thumbs.swiper.params, {
					watchSlidesProgress: true,
					slideToClickedSlide: false
				});
			} else if (isObject(thumbsParams.swiper)) {
				const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
				Object.assign(thumbsSwiperParams, {
					watchSlidesProgress: true,
					slideToClickedSlide: false
				});
				swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
				swiperCreated = true;
			}
			swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
			swiper.thumbs.swiper.on('tap', onThumbClick);
			return true;
		}

		function update(initial) {
			const thumbsSwiper = swiper.thumbs.swiper;
			if (!thumbsSwiper || thumbsSwiper.destroyed) return;
			const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView; // Activate thumbs
			let thumbsToActivate = 1;
			const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
			if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
				thumbsToActivate = swiper.params.slidesPerView;
			}
			if (!swiper.params.thumbs.multipleActiveThumbs) {
				thumbsToActivate = 1;
			}
			thumbsToActivate = Math.floor(thumbsToActivate);
			thumbsSwiper.slides.removeClass(thumbActiveClass);
			if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
				for (let i = 0; i < thumbsToActivate; i += 1) {
					thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`).addClass(thumbActiveClass);
				}
			} else {
				for (let i = 0; i < thumbsToActivate; i += 1) {
					thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
				}
			}
			const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
			const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
			if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
				let currentThumbsIndex = thumbsSwiper.activeIndex;
				let newThumbsIndex;
				let direction;
				if (thumbsSwiper.params.loop) {
					if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
						thumbsSwiper.loopFix(); // eslint-disable-next-line
						thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
						currentThumbsIndex = thumbsSwiper.activeIndex;
					} // Find actual thumbs index to slide to
					const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
					const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
					if (typeof prevThumbsIndex === 'undefined') {
						newThumbsIndex = nextThumbsIndex;
					} else if (typeof nextThumbsIndex === 'undefined') {
						newThumbsIndex = prevThumbsIndex;
					} else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
						newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
					} else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
						newThumbsIndex = nextThumbsIndex;
					} else {
						newThumbsIndex = prevThumbsIndex;
					}
					direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
				} else {
					newThumbsIndex = swiper.realIndex;
					direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
				}
				if (useOffset) {
					newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
				}
				if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
					if (thumbsSwiper.params.centeredSlides) {
						if (newThumbsIndex > currentThumbsIndex) {
							newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
						} else {
							newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
						}
					} else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1);
					thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
				}
			}
		}
		on('beforeInit', () => {
			const {
				thumbs
			} = swiper.params;
			if (!thumbs || !thumbs.swiper) return;
			init();
			update(true);
		});
		on('slideChange update resize observerUpdate', () => {
			update();
		});
		on('setTransition', (_s, duration) => {
			const thumbsSwiper = swiper.thumbs.swiper;
			if (!thumbsSwiper || thumbsSwiper.destroyed) return;
			thumbsSwiper.setTransition(duration);
		});
		on('beforeDestroy', () => {
			const thumbsSwiper = swiper.thumbs.swiper;
			if (!thumbsSwiper || thumbsSwiper.destroyed) return;
			if (swiperCreated) {
				thumbsSwiper.destroy();
			}
		});
		Object.assign(swiper.thumbs, {
			init,
			update
		});
	}

	function freeMode(_ref) {
		let {
			swiper,
			extendParams,
			emit,
			once
		} = _ref;
		extendParams({
			freeMode: {
				enabled: false,
				momentum: true,
				momentumRatio: 1,
				momentumBounce: true,
				momentumBounceRatio: 1,
				momentumVelocityRatio: 1,
				sticky: false,
				minimumVelocity: 0.02
			}
		});

		function onTouchStart() {
			const translate = swiper.getTranslate();
			swiper.setTranslate(translate);
			swiper.setTransition(0);
			swiper.touchEventsData.velocities.length = 0;
			swiper.freeMode.onTouchEnd({
				currentPos: swiper.rtl ? swiper.translate : -swiper.translate
			});
		}

		function onTouchMove() {
			const {
				touchEventsData: data,
				touches
			} = swiper; // Velocity
			if (data.velocities.length === 0) {
				data.velocities.push({
					position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
					time: data.touchStartTime
				});
			}
			data.velocities.push({
				position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
				time: now()
			});
		}

		function onTouchEnd(_ref2) {
			let {
				currentPos
			} = _ref2;
			const {
				params,
				$wrapperEl,
				rtlTranslate: rtl,
				snapGrid,
				touchEventsData: data
			} = swiper; // Time diff
			const touchEndTime = now();
			const timeDiff = touchEndTime - data.touchStartTime;
			if (currentPos < -swiper.minTranslate()) {
				swiper.slideTo(swiper.activeIndex);
				return;
			}
			if (currentPos > -swiper.maxTranslate()) {
				if (swiper.slides.length < snapGrid.length) {
					swiper.slideTo(snapGrid.length - 1);
				} else {
					swiper.slideTo(swiper.slides.length - 1);
				}
				return;
			}
			if (params.freeMode.momentum) {
				if (data.velocities.length > 1) {
					const lastMoveEvent = data.velocities.pop();
					const velocityEvent = data.velocities.pop();
					const distance = lastMoveEvent.position - velocityEvent.position;
					const time = lastMoveEvent.time - velocityEvent.time;
					swiper.velocity = distance / time;
					swiper.velocity /= 2;
					if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
						swiper.velocity = 0;
					} // this implies that the user stopped moving a finger then released.
					// There would be no events with distance zero, so the last event is stale.
					if (time > 150 || now() - lastMoveEvent.time > 300) {
						swiper.velocity = 0;
					}
				} else {
					swiper.velocity = 0;
				}
				swiper.velocity *= params.freeMode.momentumVelocityRatio;
				data.velocities.length = 0;
				let momentumDuration = 1000 * params.freeMode.momentumRatio;
				const momentumDistance = swiper.velocity * momentumDuration;
				let newPosition = swiper.translate + momentumDistance;
				if (rtl) newPosition = -newPosition;
				let doBounce = false;
				let afterBouncePosition;
				const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
				let needsLoopFix;
				if (newPosition < swiper.maxTranslate()) {
					if (params.freeMode.momentumBounce) {
						if (newPosition + swiper.maxTranslate() < -bounceAmount) {
							newPosition = swiper.maxTranslate() - bounceAmount;
						}
						afterBouncePosition = swiper.maxTranslate();
						doBounce = true;
						data.allowMomentumBounce = true;
					} else {
						newPosition = swiper.maxTranslate();
					}
					if (params.loop && params.centeredSlides) needsLoopFix = true;
				} else if (newPosition > swiper.minTranslate()) {
					if (params.freeMode.momentumBounce) {
						if (newPosition - swiper.minTranslate() > bounceAmount) {
							newPosition = swiper.minTranslate() + bounceAmount;
						}
						afterBouncePosition = swiper.minTranslate();
						doBounce = true;
						data.allowMomentumBounce = true;
					} else {
						newPosition = swiper.minTranslate();
					}
					if (params.loop && params.centeredSlides) needsLoopFix = true;
				} else if (params.freeMode.sticky) {
					let nextSlide;
					for (let j = 0; j < snapGrid.length; j += 1) {
						if (snapGrid[j] > -newPosition) {
							nextSlide = j;
							break;
						}
					}
					if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
						newPosition = snapGrid[nextSlide];
					} else {
						newPosition = snapGrid[nextSlide - 1];
					}
					newPosition = -newPosition;
				}
				if (needsLoopFix) {
					once('transitionEnd', () => {
						swiper.loopFix();
					});
				} // Fix duration
				if (swiper.velocity !== 0) {
					if (rtl) {
						momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
					} else {
						momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
					}
					if (params.freeMode.sticky) {
						// If freeMode.sticky is active and the user ends a swipe with a slow-velocity
						// event, then durations can be 20+ seconds to slide one (or zero!) slides.
						// It's easy to see this when simulating touch with mouse events. To fix this,
						// limit single-slide swipes to the default slide duration. This also has the
						// nice side effect of matching slide speed if the user stopped moving before
						// lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
						// For faster swipes, also apply limits (albeit higher ones).
						const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
						const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
						if (moveDistance < currentSlideSize) {
							momentumDuration = params.speed;
						} else if (moveDistance < 2 * currentSlideSize) {
							momentumDuration = params.speed * 1.5;
						} else {
							momentumDuration = params.speed * 2.5;
						}
					}
				} else if (params.freeMode.sticky) {
					swiper.slideToClosest();
					return;
				}
				if (params.freeMode.momentumBounce && doBounce) {
					swiper.updateProgress(afterBouncePosition);
					swiper.setTransition(momentumDuration);
					swiper.setTranslate(newPosition);
					swiper.transitionStart(true, swiper.swipeDirection);
					swiper.animating = true;
					$wrapperEl.transitionEnd(() => {
						if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
						emit('momentumBounce');
						swiper.setTransition(params.speed);
						setTimeout(() => {
							swiper.setTranslate(afterBouncePosition);
							$wrapperEl.transitionEnd(() => {
								if (!swiper || swiper.destroyed) return;
								swiper.transitionEnd();
							});
						}, 0);
					});
				} else if (swiper.velocity) {
					emit('_freeModeNoMomentumRelease');
					swiper.updateProgress(newPosition);
					swiper.setTransition(momentumDuration);
					swiper.setTranslate(newPosition);
					swiper.transitionStart(true, swiper.swipeDirection);
					if (!swiper.animating) {
						swiper.animating = true;
						$wrapperEl.transitionEnd(() => {
							if (!swiper || swiper.destroyed) return;
							swiper.transitionEnd();
						});
					}
				} else {
					swiper.updateProgress(newPosition);
				}
				swiper.updateActiveIndex();
				swiper.updateSlidesClasses();
			} else if (params.freeMode.sticky) {
				swiper.slideToClosest();
				return;
			} else if (params.freeMode) {
				emit('_freeModeNoMomentumRelease');
			}
			if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
				swiper.updateProgress();
				swiper.updateActiveIndex();
				swiper.updateSlidesClasses();
			}
		}
		Object.assign(swiper, {
			freeMode: {
				onTouchStart,
				onTouchMove,
				onTouchEnd
			}
		});
	}

	function Grid(_ref) {
		let {
			swiper,
			extendParams
		} = _ref;
		extendParams({
			grid: {
				rows: 1,
				fill: 'column'
			}
		});
		let slidesNumberEvenToRows;
		let slidesPerRow;
		let numFullColumns;
		const initSlides = slidesLength => {
			const {
				slidesPerView
			} = swiper.params;
			const {
				rows,
				fill
			} = swiper.params.grid;
			slidesPerRow = slidesNumberEvenToRows / rows;
			numFullColumns = Math.floor(slidesLength / rows);
			if (Math.floor(slidesLength / rows) === slidesLength / rows) {
				slidesNumberEvenToRows = slidesLength;
			} else {
				slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
			}
			if (slidesPerView !== 'auto' && fill === 'row') {
				slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
			}
		};
		const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {
			const {
				slidesPerGroup,
				spaceBetween
			} = swiper.params;
			const {
				rows,
				fill
			} = swiper.params.grid; // Set slides order
			let newSlideOrderIndex;
			let column;
			let row;
			if (fill === 'row' && slidesPerGroup > 1) {
				const groupIndex = Math.floor(i / (slidesPerGroup * rows));
				const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
				const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
				row = Math.floor(slideIndexInGroup / columnsInGroup);
				column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
				newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
				slide.css({
					'-webkit-order': newSlideOrderIndex,
					order: newSlideOrderIndex
				});
			} else if (fill === 'column') {
				column = Math.floor(i / rows);
				row = i - column * rows;
				if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
					row += 1;
					if (row >= rows) {
						row = 0;
						column += 1;
					}
				}
			} else {
				row = Math.floor(i / slidesPerRow);
				column = i - row * slidesPerRow;
			}
			slide.css(getDirectionLabel('margin-top'), row !== 0 ? spaceBetween && `${spaceBetween}px` : '');
		};
		const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {
			const {
				spaceBetween,
				centeredSlides,
				roundLengths
			} = swiper.params;
			const {
				rows
			} = swiper.params.grid;
			swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
			swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
			swiper.$wrapperEl.css({
				[getDirectionLabel('width')]: `${swiper.virtualSize + spaceBetween}px`
			});
			if (centeredSlides) {
				snapGrid.splice(0, snapGrid.length);
				const newSlidesGrid = [];
				for (let i = 0; i < snapGrid.length; i += 1) {
					let slidesGridItem = snapGrid[i];
					if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
					if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
				}
				snapGrid.push(...newSlidesGrid);
			}
		};
		swiper.grid = {
			initSlides,
			updateSlide,
			updateWrapperSize
		};
	}

	function appendSlide(slides) {
		const swiper = this;
		const {
			$wrapperEl,
			params
		} = swiper;
		if (params.loop) {
			swiper.loopDestroy();
		}
		if (typeof slides === 'object' && 'length' in slides) {
			for (let i = 0; i < slides.length; i += 1) {
				if (slides[i]) $wrapperEl.append(slides[i]);
			}
		} else {
			$wrapperEl.append(slides);
		}
		if (params.loop) {
			swiper.loopCreate();
		}
		if (!params.observer) {
			swiper.update();
		}
	}

	function prependSlide(slides) {
		const swiper = this;
		const {
			params,
			$wrapperEl,
			activeIndex
		} = swiper;
		if (params.loop) {
			swiper.loopDestroy();
		}
		let newActiveIndex = activeIndex + 1;
		if (typeof slides === 'object' && 'length' in slides) {
			for (let i = 0; i < slides.length; i += 1) {
				if (slides[i]) $wrapperEl.prepend(slides[i]);
			}
			newActiveIndex = activeIndex + slides.length;
		} else {
			$wrapperEl.prepend(slides);
		}
		if (params.loop) {
			swiper.loopCreate();
		}
		if (!params.observer) {
			swiper.update();
		}
		swiper.slideTo(newActiveIndex, 0, false);
	}

	function addSlide(index, slides) {
		const swiper = this;
		const {
			$wrapperEl,
			params,
			activeIndex
		} = swiper;
		let activeIndexBuffer = activeIndex;
		if (params.loop) {
			activeIndexBuffer -= swiper.loopedSlides;
			swiper.loopDestroy();
			swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
		}
		const baseLength = swiper.slides.length;
		if (index <= 0) {
			swiper.prependSlide(slides);
			return;
		}
		if (index >= baseLength) {
			swiper.appendSlide(slides);
			return;
		}
		let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
		const slidesBuffer = [];
		for (let i = baseLength - 1; i >= index; i -= 1) {
			const currentSlide = swiper.slides.eq(i);
			currentSlide.remove();
			slidesBuffer.unshift(currentSlide);
		}
		if (typeof slides === 'object' && 'length' in slides) {
			for (let i = 0; i < slides.length; i += 1) {
				if (slides[i]) $wrapperEl.append(slides[i]);
			}
			newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
		} else {
			$wrapperEl.append(slides);
		}
		for (let i = 0; i < slidesBuffer.length; i += 1) {
			$wrapperEl.append(slidesBuffer[i]);
		}
		if (params.loop) {
			swiper.loopCreate();
		}
		if (!params.observer) {
			swiper.update();
		}
		if (params.loop) {
			swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
		} else {
			swiper.slideTo(newActiveIndex, 0, false);
		}
	}

	function removeSlide(slidesIndexes) {
		const swiper = this;
		const {
			params,
			$wrapperEl,
			activeIndex
		} = swiper;
		let activeIndexBuffer = activeIndex;
		if (params.loop) {
			activeIndexBuffer -= swiper.loopedSlides;
			swiper.loopDestroy();
			swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
		}
		let newActiveIndex = activeIndexBuffer;
		let indexToRemove;
		if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
			for (let i = 0; i < slidesIndexes.length; i += 1) {
				indexToRemove = slidesIndexes[i];
				if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
				if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
			}
			newActiveIndex = Math.max(newActiveIndex, 0);
		} else {
			indexToRemove = slidesIndexes;
			if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
			if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
			newActiveIndex = Math.max(newActiveIndex, 0);
		}
		if (params.loop) {
			swiper.loopCreate();
		}
		if (!params.observer) {
			swiper.update();
		}
		if (params.loop) {
			swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
		} else {
			swiper.slideTo(newActiveIndex, 0, false);
		}
	}

	function removeAllSlides() {
		const swiper = this;
		const slidesIndexes = [];
		for (let i = 0; i < swiper.slides.length; i += 1) {
			slidesIndexes.push(i);
		}
		swiper.removeSlide(slidesIndexes);
	}

	function Manipulation(_ref) {
		let {
			swiper
		} = _ref;
		Object.assign(swiper, {
			appendSlide: appendSlide.bind(swiper),
			prependSlide: prependSlide.bind(swiper),
			addSlide: addSlide.bind(swiper),
			removeSlide: removeSlide.bind(swiper),
			removeAllSlides: removeAllSlides.bind(swiper)
		});
	}

	function effectInit(params) {
		const {
			effect,
			swiper,
			on,
			setTranslate,
			setTransition,
			overwriteParams,
			perspective,
			recreateShadows,
			getEffectParams
		} = params;
		on('beforeInit', () => {
			if (swiper.params.effect !== effect) return;
			swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
			if (perspective && perspective()) {
				swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
			}
			const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
			Object.assign(swiper.params, overwriteParamsResult);
			Object.assign(swiper.originalParams, overwriteParamsResult);
		});
		on('setTranslate', () => {
			if (swiper.params.effect !== effect) return;
			setTranslate();
		});
		on('setTransition', (_s, duration) => {
			if (swiper.params.effect !== effect) return;
			setTransition(duration);
		});
		on('transitionEnd', () => {
			if (swiper.params.effect !== effect) return;
			if (recreateShadows) {
				if (!getEffectParams || !getEffectParams().slideShadows) return; // remove shadows
				swiper.slides.each(slideEl => {
					const $slideEl = swiper.$(slideEl);
					$slideEl.find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').remove();
				}); // create new one
				recreateShadows();
			}
		});
		let requireUpdateOnVirtual;
		on('virtualUpdate', () => {
			if (swiper.params.effect !== effect) return;
			if (!swiper.slides.length) {
				requireUpdateOnVirtual = true;
			}
			requestAnimationFrame(() => {
				if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
					setTranslate();
					requireUpdateOnVirtual = false;
				}
			});
		});
	}

	function effectTarget(effectParams, $slideEl) {
		if (effectParams.transformEl) {
			return $slideEl.find(effectParams.transformEl).css({
				'backface-visibility': 'hidden',
				'-webkit-backface-visibility': 'hidden'
			});
		}
		return $slideEl;
	}

	function effectVirtualTransitionEnd(_ref) {
		let {
			swiper,
			duration,
			transformEl,
			allSlides
		} = _ref;
		const {
			slides,
			activeIndex,
			$wrapperEl
		} = swiper;
		if (swiper.params.virtualTranslate && duration !== 0) {
			let eventTriggered = false;
			let $transitionEndTarget;
			if (allSlides) {
				$transitionEndTarget = transformEl ? slides.find(transformEl) : slides;
			} else {
				$transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);
			}
			$transitionEndTarget.transitionEnd(() => {
				if (eventTriggered) return;
				if (!swiper || swiper.destroyed) return;
				eventTriggered = true;
				swiper.animating = false;
				const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
				for (let i = 0; i < triggerEvents.length; i += 1) {
					$wrapperEl.trigger(triggerEvents[i]);
				}
			});
		}
	}

	function EffectFade(_ref) {
		let {
			swiper,
			extendParams,
			on
		} = _ref;
		extendParams({
			fadeEffect: {
				crossFade: false,
				transformEl: null
			}
		});
		const setTranslate = () => {
			const {
				slides
			} = swiper;
			const params = swiper.params.fadeEffect;
			for (let i = 0; i < slides.length; i += 1) {
				const $slideEl = swiper.slides.eq(i);
				const offset = $slideEl[0].swiperSlideOffset;
				let tx = -offset;
				if (!swiper.params.virtualTranslate) tx -= swiper.translate;
				let ty = 0;
				if (!swiper.isHorizontal()) {
					ty = tx;
					tx = 0;
				}
				const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
				const $targetEl = effectTarget(params, $slideEl);
				$targetEl.css({
					opacity: slideOpacity
				}).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
			}
		};
		const setTransition = duration => {
			const {
				transformEl
			} = swiper.params.fadeEffect;
			const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
			$transitionElements.transition(duration);
			effectVirtualTransitionEnd({
				swiper,
				duration,
				transformEl,
				allSlides: true
			});
		};
		effectInit({
			effect: 'fade',
			swiper,
			on,
			setTranslate,
			setTransition,
			overwriteParams: () => ({
				slidesPerView: 1,
				slidesPerGroup: 1,
				watchSlidesProgress: true,
				spaceBetween: 0,
				virtualTranslate: !swiper.params.cssMode
			})
		});
	}

	function EffectCube(_ref) {
		let {
			swiper,
			extendParams,
			on
		} = _ref;
		extendParams({
			cubeEffect: {
				slideShadows: true,
				shadow: true,
				shadowOffset: 20,
				shadowScale: 0.94
			}
		});
		const createSlideShadows = ($slideEl, progress, isHorizontal) => {
			let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
			let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
			if (shadowBefore.length === 0) {
				shadowBefore = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
				$slideEl.append(shadowBefore);
			}
			if (shadowAfter.length === 0) {
				shadowAfter = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
				$slideEl.append(shadowAfter);
			}
			if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
			if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
		};
		const recreateShadows = () => {
			// create new ones
			const isHorizontal = swiper.isHorizontal();
			swiper.slides.each(slideEl => {
				const progress = Math.max(Math.min(slideEl.progress, 1), -1);
				createSlideShadows($(slideEl), progress, isHorizontal);
			});
		};
		const setTranslate = () => {
			const {
				$el,
				$wrapperEl,
				slides,
				width: swiperWidth,
				height: swiperHeight,
				rtlTranslate: rtl,
				size: swiperSize,
				browser
			} = swiper;
			const params = swiper.params.cubeEffect;
			const isHorizontal = swiper.isHorizontal();
			const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
			let wrapperRotate = 0;
			let $cubeShadowEl;
			if (params.shadow) {
				if (isHorizontal) {
					$cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
					if ($cubeShadowEl.length === 0) {
						$cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
						$wrapperEl.append($cubeShadowEl);
					}
					$cubeShadowEl.css({
						height: `${swiperWidth}px`
					});
				} else {
					$cubeShadowEl = $el.find('.swiper-cube-shadow');
					if ($cubeShadowEl.length === 0) {
						$cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
						$el.append($cubeShadowEl);
					}
				}
			}
			for (let i = 0; i < slides.length; i += 1) {
				const $slideEl = slides.eq(i);
				let slideIndex = i;
				if (isVirtual) {
					slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
				}
				let slideAngle = slideIndex * 90;
				let round = Math.floor(slideAngle / 360);
				if (rtl) {
					slideAngle = -slideAngle;
					round = Math.floor(-slideAngle / 360);
				}
				const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
				let tx = 0;
				let ty = 0;
				let tz = 0;
				if (slideIndex % 4 === 0) {
					tx = -round * 4 * swiperSize;
					tz = 0;
				} else if ((slideIndex - 1) % 4 === 0) {
					tx = 0;
					tz = -round * 4 * swiperSize;
				} else if ((slideIndex - 2) % 4 === 0) {
					tx = swiperSize + round * 4 * swiperSize;
					tz = swiperSize;
				} else if ((slideIndex - 3) % 4 === 0) {
					tx = -swiperSize;
					tz = 3 * swiperSize + swiperSize * 4 * round;
				}
				if (rtl) {
					tx = -tx;
				}
				if (!isHorizontal) {
					ty = tx;
					tx = 0;
				}
				const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
				if (progress <= 1 && progress > -1) {
					wrapperRotate = slideIndex * 90 + progress * 90;
					if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
				}
				$slideEl.transform(transform);
				if (params.slideShadows) {
					createSlideShadows($slideEl, progress, isHorizontal);
				}
			}
			$wrapperEl.css({
				'-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
				'transform-origin': `50% 50% -${swiperSize / 2}px`
			});
			if (params.shadow) {
				if (isHorizontal) {
					$cubeShadowEl.transform(`translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
				} else {
					const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
					const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
					const scale1 = params.shadowScale;
					const scale2 = params.shadowScale / multiplier;
					const offset = params.shadowOffset;
					$cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
				}
			}
			const zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;
			$wrapperEl.transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
			$wrapperEl[0].style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);
		};
		const setTransition = duration => {
			const {
				$el,
				slides
			} = swiper;
			slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
			if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
				$el.find('.swiper-cube-shadow').transition(duration);
			}
		};
		effectInit({
			effect: 'cube',
			swiper,
			on,
			setTranslate,
			setTransition,
			recreateShadows,
			getEffectParams: () => swiper.params.cubeEffect,
			perspective: () => true,
			overwriteParams: () => ({
				slidesPerView: 1,
				slidesPerGroup: 1,
				watchSlidesProgress: true,
				resistanceRatio: 0,
				spaceBetween: 0,
				centeredSlides: false,
				virtualTranslate: true
			})
		});
	}

	function createShadow(params, $slideEl, side) {
		const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;
		const $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;
		let $shadowEl = $shadowContainer.children(`.${shadowClass}`);
		if (!$shadowEl.length) {
			$shadowEl = $(`<div class="swiper-slide-shadow${side ? `-${side}` : ''}"></div>`);
			$shadowContainer.append($shadowEl);
		}
		return $shadowEl;
	}

	function EffectFlip(_ref) {
		let {
			swiper,
			extendParams,
			on
		} = _ref;
		extendParams({
			flipEffect: {
				slideShadows: true,
				limitRotation: true,
				transformEl: null
			}
		});
		const createSlideShadows = ($slideEl, progress, params) => {
			let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
			let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
			if (shadowBefore.length === 0) {
				shadowBefore = createShadow(params, $slideEl, swiper.isHorizontal() ? 'left' : 'top');
			}
			if (shadowAfter.length === 0) {
				shadowAfter = createShadow(params, $slideEl, swiper.isHorizontal() ? 'right' : 'bottom');
			}
			if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
			if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
		};
		const recreateShadows = () => {
			// Set shadows
			const params = swiper.params.flipEffect;
			swiper.slides.each(slideEl => {
				const $slideEl = $(slideEl);
				let progress = $slideEl[0].progress;
				if (swiper.params.flipEffect.limitRotation) {
					progress = Math.max(Math.min(slideEl.progress, 1), -1);
				}
				createSlideShadows($slideEl, progress, params);
			});
		};
		const setTranslate = () => {
			const {
				slides,
				rtlTranslate: rtl
			} = swiper;
			const params = swiper.params.flipEffect;
			for (let i = 0; i < slides.length; i += 1) {
				const $slideEl = slides.eq(i);
				let progress = $slideEl[0].progress;
				if (swiper.params.flipEffect.limitRotation) {
					progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
				}
				const offset = $slideEl[0].swiperSlideOffset;
				const rotate = -180 * progress;
				let rotateY = rotate;
				let rotateX = 0;
				let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
				let ty = 0;
				if (!swiper.isHorizontal()) {
					ty = tx;
					tx = 0;
					rotateX = -rotateY;
					rotateY = 0;
				} else if (rtl) {
					rotateY = -rotateY;
				}
				$slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
				if (params.slideShadows) {
					createSlideShadows($slideEl, progress, params);
				}
				const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
				const $targetEl = effectTarget(params, $slideEl);
				$targetEl.transform(transform);
			}
		};
		const setTransition = duration => {
			const {
				transformEl
			} = swiper.params.flipEffect;
			const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
			$transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
			effectVirtualTransitionEnd({
				swiper,
				duration,
				transformEl
			});
		};
		effectInit({
			effect: 'flip',
			swiper,
			on,
			setTranslate,
			setTransition,
			recreateShadows,
			getEffectParams: () => swiper.params.flipEffect,
			perspective: () => true,
			overwriteParams: () => ({
				slidesPerView: 1,
				slidesPerGroup: 1,
				watchSlidesProgress: true,
				spaceBetween: 0,
				virtualTranslate: !swiper.params.cssMode
			})
		});
	}

	function EffectCoverflow(_ref) {
		let {
			swiper,
			extendParams,
			on
		} = _ref;
		extendParams({
			coverflowEffect: {
				rotate: 50,
				stretch: 0,
				depth: 100,
				scale: 1,
				modifier: 1,
				slideShadows: true,
				transformEl: null
			}
		});
		const setTranslate = () => {
			const {
				width: swiperWidth,
				height: swiperHeight,
				slides,
				slidesSizesGrid
			} = swiper;
			const params = swiper.params.coverflowEffect;
			const isHorizontal = swiper.isHorizontal();
			const transform = swiper.translate;
			const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
			const rotate = isHorizontal ? params.rotate : -params.rotate;
			const translate = params.depth; // Each slide offset from center
			for (let i = 0, length = slides.length; i < length; i += 1) {
				const $slideEl = slides.eq(i);
				const slideSize = slidesSizesGrid[i];
				const slideOffset = $slideEl[0].swiperSlideOffset;
				const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
				const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;
				let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
				let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; // var rotateZ = 0
				let translateZ = -translate * Math.abs(offsetMultiplier);
				let stretch = params.stretch; // Allow percentage to make a relative stretch for responsive sliders
				if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
					stretch = parseFloat(params.stretch) / 100 * slideSize;
				}
				let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
				let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
				let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier); // Fix for ultra small values
				if (Math.abs(translateX) < 0.001) translateX = 0;
				if (Math.abs(translateY) < 0.001) translateY = 0;
				if (Math.abs(translateZ) < 0.001) translateZ = 0;
				if (Math.abs(rotateY) < 0.001) rotateY = 0;
				if (Math.abs(rotateX) < 0.001) rotateX = 0;
				if (Math.abs(scale) < 0.001) scale = 0;
				const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;
				const $targetEl = effectTarget(params, $slideEl);
				$targetEl.transform(slideTransform);
				$slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
				if (params.slideShadows) {
					// Set shadows
					let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
					let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
					if ($shadowBeforeEl.length === 0) {
						$shadowBeforeEl = createShadow(params, $slideEl, isHorizontal ? 'left' : 'top');
					}
					if ($shadowAfterEl.length === 0) {
						$shadowAfterEl = createShadow(params, $slideEl, isHorizontal ? 'right' : 'bottom');
					}
					if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
					if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
				}
			}
		};
		const setTransition = duration => {
			const {
				transformEl
			} = swiper.params.coverflowEffect;
			const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
			$transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
		};
		effectInit({
			effect: 'coverflow',
			swiper,
			on,
			setTranslate,
			setTransition,
			perspective: () => true,
			overwriteParams: () => ({
				watchSlidesProgress: true
			})
		});
	}

	function EffectCreative(_ref) {
		let {
			swiper,
			extendParams,
			on
		} = _ref;
		extendParams({
			creativeEffect: {
				transformEl: null,
				limitProgress: 1,
				shadowPerProgress: false,
				progressMultiplier: 1,
				perspective: true,
				prev: {
					translate: [0, 0, 0],
					rotate: [0, 0, 0],
					opacity: 1,
					scale: 1
				},
				next: {
					translate: [0, 0, 0],
					rotate: [0, 0, 0],
					opacity: 1,
					scale: 1
				}
			}
		});
		const getTranslateValue = value => {
			if (typeof value === 'string') return value;
			return `${value}px`;
		};
		const setTranslate = () => {
			const {
				slides,
				$wrapperEl,
				slidesSizesGrid
			} = swiper;
			const params = swiper.params.creativeEffect;
			const {
				progressMultiplier: multiplier
			} = params;
			const isCenteredSlides = swiper.params.centeredSlides;
			if (isCenteredSlides) {
				const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
				$wrapperEl.transform(`translateX(calc(50% - ${margin}px))`);
			}
			for (let i = 0; i < slides.length; i += 1) {
				const $slideEl = slides.eq(i);
				const slideProgress = $slideEl[0].progress;
				const progress = Math.min(Math.max($slideEl[0].progress, -params.limitProgress), params.limitProgress);
				let originalProgress = progress;
				if (!isCenteredSlides) {
					originalProgress = Math.min(Math.max($slideEl[0].originalProgress, -params.limitProgress), params.limitProgress);
				}
				const offset = $slideEl[0].swiperSlideOffset;
				const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
				const r = [0, 0, 0];
				let custom = false;
				if (!swiper.isHorizontal()) {
					t[1] = t[0];
					t[0] = 0;
				}
				let data = {
					translate: [0, 0, 0],
					rotate: [0, 0, 0],
					scale: 1,
					opacity: 1
				};
				if (progress < 0) {
					data = params.next;
					custom = true;
				} else if (progress > 0) {
					data = params.prev;
					custom = true;
				} // set translate
				t.forEach((value, index) => {
					t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
				}); // set rotates
				r.forEach((value, index) => {
					r[index] = data.rotate[index] * Math.abs(progress * multiplier);
				});
				$slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
				const translateString = t.join(', ');
				const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;
				const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
				const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
				const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`; // Set shadows
				if (custom && data.shadow || !custom) {
					let $shadowEl = $slideEl.children('.swiper-slide-shadow');
					if ($shadowEl.length === 0 && data.shadow) {
						$shadowEl = createShadow(params, $slideEl);
					}
					if ($shadowEl.length) {
						const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
						$shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
					}
				}
				const $targetEl = effectTarget(params, $slideEl);
				$targetEl.transform(transform).css({
					opacity: opacityString
				});
				if (data.origin) {
					$targetEl.css('transform-origin', data.origin);
				}
			}
		};
		const setTransition = duration => {
			const {
				transformEl
			} = swiper.params.creativeEffect;
			const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
			$transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
			effectVirtualTransitionEnd({
				swiper,
				duration,
				transformEl,
				allSlides: true
			});
		};
		effectInit({
			effect: 'creative',
			swiper,
			on,
			setTranslate,
			setTransition,
			perspective: () => swiper.params.creativeEffect.perspective,
			overwriteParams: () => ({
				watchSlidesProgress: true,
				virtualTranslate: !swiper.params.cssMode
			})
		});
	}

	function EffectCards(_ref) {
		let {
			swiper,
			extendParams,
			on
		} = _ref;
		extendParams({
			cardsEffect: {
				slideShadows: true,
				transformEl: null,
				rotate: true,
				perSlideRotate: 2,
				perSlideOffset: 8
			}
		});
		const setTranslate = () => {
			const {
				slides,
				activeIndex
			} = swiper;
			const params = swiper.params.cardsEffect;
			const {
				startTranslate,
				isTouched
			} = swiper.touchEventsData;
			const currentTranslate = swiper.translate;
			for (let i = 0; i < slides.length; i += 1) {
				const $slideEl = slides.eq(i);
				const slideProgress = $slideEl[0].progress;
				const progress = Math.min(Math.max(slideProgress, -4), 4);
				let offset = $slideEl[0].swiperSlideOffset;
				if (swiper.params.centeredSlides && !swiper.params.cssMode) {
					swiper.$wrapperEl.transform(`translateX(${swiper.minTranslate()}px)`);
				}
				if (swiper.params.centeredSlides && swiper.params.cssMode) {
					offset -= slides[0].swiperSlideOffset;
				}
				let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
				let tY = 0;
				const tZ = -100 * Math.abs(progress);
				let scale = 1;
				let rotate = -params.perSlideRotate * progress;
				let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;
				const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
				const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
				const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
				if (isSwipeToNext || isSwipeToPrev) {
					const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
					rotate += -28 * progress * subProgress;
					scale += -0.5 * subProgress;
					tXAdd += 96 * subProgress;
					tY = `${-25 * subProgress * Math.abs(progress)}%`;
				}
				if (progress < 0) {
					// next
					tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;
				} else if (progress > 0) {
					// prev
					tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;
				} else {
					tX = `${tX}px`;
				}
				if (!swiper.isHorizontal()) {
					const prevY = tY;
					tY = tX;
					tX = prevY;
				}
				const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;
				const transform = `

        translate3d(${tX}, ${tY}, ${tZ}px)

        rotateZ(${params.rotate ? rotate : 0}deg)

        scale(${scaleString})

      `;
				if (params.slideShadows) {
					// Set shadows
					let $shadowEl = $slideEl.find('.swiper-slide-shadow');
					if ($shadowEl.length === 0) {
						$shadowEl = createShadow(params, $slideEl);
					}
					if ($shadowEl.length) $shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
				}
				$slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
				const $targetEl = effectTarget(params, $slideEl);
				$targetEl.transform(transform);
			}
		};
		const setTransition = duration => {
			const {
				transformEl
			} = swiper.params.cardsEffect;
			const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
			$transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
			effectVirtualTransitionEnd({
				swiper,
				duration,
				transformEl
			});
		};
		effectInit({
			effect: 'cards',
			swiper,
			on,
			setTranslate,
			setTransition,
			perspective: () => true,
			overwriteParams: () => ({
				watchSlidesProgress: true,
				virtualTranslate: !swiper.params.cssMode
			})
		});
	}
	// Swiper Class
	const modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Lazy, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];
	Swiper.use(modules);
	return Swiper;
}));
//# sourceMappingURL=swiper-bundle.js.map
/**

 * jquery.mask.js

 * @version: v1.14.16

 * @author: Igor Escobar

 *

 * Created by Igor Escobar on 2012-03-10. Please report any bug at github.com/igorescobar/jQuery-Mask-Plugin

 *

 * Copyright (c) 2012 Igor Escobar http://igorescobar.com

 *

 * The MIT License (http://www.opensource.org/licenses/mit-license.php)

 *

 * Permission is hereby granted, free of charge, to any person

 * obtaining a copy of this software and associated documentation

 * files (the "Software"), to deal in the Software without

 * restriction, including without limitation the rights to use,

 * copy, modify, merge, publish, distribute, sublicense, and/or sell

 * copies of the Software, and to permit persons to whom the

 * Software is furnished to do so, subject to the following

 * conditions:

 *

 * The above copyright notice and this permission notice shall be

 * included in all copies or substantial portions of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES

 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT

 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,

 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING

 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR

 * OTHER DEALINGS IN THE SOFTWARE.

 */
/* jshint laxbreak: true */
/* jshint maxcomplexity:17 */
/* global define */
// UMD (Universal Module Definition) patterns for JavaScript modules that work everywhere.
// https://github.com/umdjs/umd/blob/master/templates/jqueryPlugin.js
(function(factory, jQuery, Zepto) {
	if (typeof define === 'function' && define.amd) {
		define(['jquery'], factory);
	} else if (typeof exports === 'object' && typeof Meteor === 'undefined') {
		module.exports = factory(require('jquery'));
	} else {
		factory(jQuery || Zepto);
	}
}(function($) {
	'use strict';
	var Mask = function(el, mask, options) {
		var p = {
			invalid: [],
			getCaret: function() {
				try {
					var sel,
						pos = 0,
						ctrl = el.get(0),
						dSel = document.selection,
						cSelStart = ctrl.selectionStart;
					// IE Support
					if (dSel && navigator.appVersion.indexOf('MSIE 10') === -1) {
						sel = dSel.createRange();
						sel.moveStart('character', -p.val().length);
						pos = sel.text.length;
					}
					// Firefox support
					else if (cSelStart || cSelStart === '0') {
						pos = cSelStart;
					}
					return pos;
				} catch (e) {}
			},
			setCaret: function(pos) {
				try {
					if (el.is(':focus')) {
						var range, ctrl = el.get(0);
						// Firefox, WebKit, etc..
						if (ctrl.setSelectionRange) {
							ctrl.setSelectionRange(pos, pos);
						} else { // IE
							range = ctrl.createTextRange();
							range.collapse(true);
							range.moveEnd('character', pos);
							range.moveStart('character', pos);
							range.select();
						}
					}
				} catch (e) {}
			},
			events: function() {
				el
					.on('keydown.mask', function(e) {
						el.data('mask-keycode', e.keyCode || e.which);
						el.data('mask-previus-value', el.val());
						el.data('mask-previus-caret-pos', p.getCaret());
						p.maskDigitPosMapOld = p.maskDigitPosMap;
					})
					.on($.jMaskGlobals.useInput ? 'input.mask' : 'keyup.mask', p.behaviour)
					.on('paste.mask drop.mask', function() {
						setTimeout(function() {
							el.keydown().keyup();
						}, 100);
					})
					.on('change.mask', function() {
						el.data('changed', true);
					})
					.on('blur.mask', function() {
						if (oldValue !== p.val() && !el.data('changed')) {
							el.trigger('change');
						}
						el.data('changed', false);
					})
					// it's very important that this callback remains in this position
					// otherwhise oldValue it's going to work buggy
					.on('blur.mask', function() {
						oldValue = p.val();
					})
					// select all text on focus
					.on('focus.mask', function(e) {
						if (options.selectOnFocus === true) {
							$(e.target).select();
						}
					})
					// clear the value if it not complete the mask
					.on('focusout.mask', function() {
						if (options.clearIfNotMatch && !regexMask.test(p.val())) {
							p.val('');
						}
					});
			},
			getRegexMask: function() {
				var maskChunks = [],
					translation, pattern, optional, recursive, oRecursive, r;
				for (var i = 0; i < mask.length; i++) {
					translation = jMask.translation[mask.charAt(i)];
					if (translation) {
						pattern = translation.pattern.toString().replace(/.{1}$|^.{1}/g, '');
						optional = translation.optional;
						recursive = translation.recursive;
						if (recursive) {
							maskChunks.push(mask.charAt(i));
							oRecursive = {
								digit: mask.charAt(i),
								pattern: pattern
							};
						} else {
							maskChunks.push(!optional && !recursive ? pattern : (pattern + '?'));
						}
					} else {
						maskChunks.push(mask.charAt(i).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
					}
				}
				r = maskChunks.join('');
				if (oRecursive) {
					r = r.replace(new RegExp('(' + oRecursive.digit + '(.*' + oRecursive.digit + ')?)'), '($1)?')
						.replace(new RegExp(oRecursive.digit, 'g'), oRecursive.pattern);
				}
				return new RegExp(r);
			},
			destroyEvents: function() {
				el.off(['input', 'keydown', 'keyup', 'paste', 'drop', 'blur', 'focusout', ''].join('.mask '));
			},
			val: function(v) {
				var isInput = el.is('input'),
					method = isInput ? 'val' : 'text',
					r;
				if (arguments.length > 0) {
					if (el[method]() !== v) {
						el[method](v);
					}
					r = el;
				} else {
					r = el[method]();
				}
				return r;
			},
			calculateCaretPosition: function(oldVal) {
				var newVal = p.getMasked(),
					caretPosNew = p.getCaret();
				if (oldVal !== newVal) {
					var caretPosOld = el.data('mask-previus-caret-pos') || 0,
						newValL = newVal.length,
						oldValL = oldVal.length,
						maskDigitsBeforeCaret = 0,
						maskDigitsAfterCaret = 0,
						maskDigitsBeforeCaretAll = 0,
						maskDigitsBeforeCaretAllOld = 0,
						i = 0;
					for (i = caretPosNew; i < newValL; i++) {
						if (!p.maskDigitPosMap[i]) {
							break;
						}
						maskDigitsAfterCaret++;
					}
					for (i = caretPosNew - 1; i >= 0; i--) {
						if (!p.maskDigitPosMap[i]) {
							break;
						}
						maskDigitsBeforeCaret++;
					}
					for (i = caretPosNew - 1; i >= 0; i--) {
						if (p.maskDigitPosMap[i]) {
							maskDigitsBeforeCaretAll++;
						}
					}
					for (i = caretPosOld - 1; i >= 0; i--) {
						if (p.maskDigitPosMapOld[i]) {
							maskDigitsBeforeCaretAllOld++;
						}
					}
					// if the cursor is at the end keep it there
					if (caretPosNew > oldValL) {
						caretPosNew = newValL * 10;
					} else if (caretPosOld >= caretPosNew && caretPosOld !== oldValL) {
						if (!p.maskDigitPosMapOld[caretPosNew]) {
							var caretPos = caretPosNew;
							caretPosNew -= maskDigitsBeforeCaretAllOld - maskDigitsBeforeCaretAll;
							caretPosNew -= maskDigitsBeforeCaret;
							if (p.maskDigitPosMap[caretPosNew]) {
								caretPosNew = caretPos;
							}
						}
					} else if (caretPosNew > caretPosOld) {
						caretPosNew += maskDigitsBeforeCaretAll - maskDigitsBeforeCaretAllOld;
						caretPosNew += maskDigitsAfterCaret;
					}
				}
				return caretPosNew;
			},
			behaviour: function(e) {
				e = e || window.event;
				p.invalid = [];
				var keyCode = el.data('mask-keycode');
				if ($.inArray(keyCode, jMask.byPassKeys) === -1) {
					var newVal = p.getMasked(),
						caretPos = p.getCaret(),
						oldVal = el.data('mask-previus-value') || '';
					// this is a compensation to devices/browsers that don't compensate
					// caret positioning the right way
					setTimeout(function() {
						p.setCaret(p.calculateCaretPosition(oldVal));
					}, $.jMaskGlobals.keyStrokeCompensation);
					p.val(newVal);
					p.setCaret(caretPos);
					return p.callbacks(e);
				}
			},
			getMasked: function(skipMaskChars, val) {
				var buf = [],
					value = val === undefined ? p.val() : val + '',
					m = 0,
					maskLen = mask.length,
					v = 0,
					valLen = value.length,
					offset = 1,
					addMethod = 'push',
					resetPos = -1,
					maskDigitCount = 0,
					maskDigitPosArr = [],
					lastMaskChar,
					check;
				if (options.reverse) {
					addMethod = 'unshift';
					offset = -1;
					lastMaskChar = 0;
					m = maskLen - 1;
					v = valLen - 1;
					check = function() {
						return m > -1 && v > -1;
					};
				} else {
					lastMaskChar = maskLen - 1;
					check = function() {
						return m < maskLen && v < valLen;
					};
				}
				var lastUntranslatedMaskChar;
				while (check()) {
					var maskDigit = mask.charAt(m),
						valDigit = value.charAt(v),
						translation = jMask.translation[maskDigit];
					if (translation) {
						if (valDigit.match(translation.pattern)) {
							buf[addMethod](valDigit);
							if (translation.recursive) {
								if (resetPos === -1) {
									resetPos = m;
								} else if (m === lastMaskChar && m !== resetPos) {
									m = resetPos - offset;
								}
								if (lastMaskChar === resetPos) {
									m -= offset;
								}
							}
							m += offset;
						} else if (valDigit === lastUntranslatedMaskChar) {
							// matched the last untranslated (raw) mask character that we encountered
							// likely an insert offset the mask character from the last entry; fall
							// through and only increment v
							maskDigitCount--;
							lastUntranslatedMaskChar = undefined;
						} else if (translation.optional) {
							m += offset;
							v -= offset;
						} else if (translation.fallback) {
							buf[addMethod](translation.fallback);
							m += offset;
							v -= offset;
						} else {
							p.invalid.push({
								p: v,
								v: valDigit,
								e: translation.pattern
							});
						}
						v += offset;
					} else {
						if (!skipMaskChars) {
							buf[addMethod](maskDigit);
						}
						if (valDigit === maskDigit) {
							maskDigitPosArr.push(v);
							v += offset;
						} else {
							lastUntranslatedMaskChar = maskDigit;
							maskDigitPosArr.push(v + maskDigitCount);
							maskDigitCount++;
						}
						m += offset;
					}
				}
				var lastMaskCharDigit = mask.charAt(lastMaskChar);
				if (maskLen === valLen + 1 && !jMask.translation[lastMaskCharDigit]) {
					buf.push(lastMaskCharDigit);
				}
				var newVal = buf.join('');
				p.mapMaskdigitPositions(newVal, maskDigitPosArr, valLen);
				return newVal;
			},
			mapMaskdigitPositions: function(newVal, maskDigitPosArr, valLen) {
				var maskDiff = options.reverse ? newVal.length - valLen : 0;
				p.maskDigitPosMap = {};
				for (var i = 0; i < maskDigitPosArr.length; i++) {
					p.maskDigitPosMap[maskDigitPosArr[i] + maskDiff] = 1;
				}
			},
			callbacks: function(e) {
				var val = p.val(),
					changed = val !== oldValue,
					defaultArgs = [val, e, el, options],
					callback = function(name, criteria, args) {
						if (typeof options[name] === 'function' && criteria) {
							options[name].apply(this, args);
						}
					};
				callback('onChange', changed === true, defaultArgs);
				callback('onKeyPress', changed === true, defaultArgs);
				callback('onComplete', val.length === mask.length, defaultArgs);
				callback('onInvalid', p.invalid.length > 0, [val, e, el, p.invalid, options]);
			}
		};
		el = $(el);
		var jMask = this,
			oldValue = p.val(),
			regexMask;
		mask = typeof mask === 'function' ? mask(p.val(), undefined, el, options) : mask;
		// public methods
		jMask.mask = mask;
		jMask.options = options;
		jMask.remove = function() {
			var caret = p.getCaret();
			if (jMask.options.placeholder) {
				el.removeAttr('placeholder');
			}
			if (el.data('mask-maxlength')) {
				el.removeAttr('maxlength');
			}
			p.destroyEvents();
			p.val(jMask.getCleanVal());
			p.setCaret(caret);
			return el;
		};
		// get value without mask
		jMask.getCleanVal = function() {
			return p.getMasked(true);
		};
		// get masked value without the value being in the input or element
		jMask.getMaskedVal = function(val) {
			return p.getMasked(false, val);
		};
		jMask.init = function(onlyMask) {
			onlyMask = onlyMask || false;
			options = options || {};
			jMask.clearIfNotMatch = $.jMaskGlobals.clearIfNotMatch;
			jMask.byPassKeys = $.jMaskGlobals.byPassKeys;
			jMask.translation = $.extend({}, $.jMaskGlobals.translation, options.translation);
			jMask = $.extend(true, {}, jMask, options);
			regexMask = p.getRegexMask();
			if (onlyMask) {
				p.events();
				p.val(p.getMasked());
			} else {
				if (options.placeholder) {
					el.attr('placeholder', options.placeholder);
				}
				// this is necessary, otherwise if the user submit the form
				// and then press the "back" button, the autocomplete will erase
				// the data. Works fine on IE9+, FF, Opera, Safari.
				if (el.data('mask')) {
					el.attr('autocomplete', 'off');
				}
				// detect if is necessary let the user type freely.
				// for is a lot faster than forEach.
				for (var i = 0, maxlength = true; i < mask.length; i++) {
					var translation = jMask.translation[mask.charAt(i)];
					if (translation && translation.recursive) {
						maxlength = false;
						break;
					}
				}
				if (maxlength) {
					el.attr('maxlength', mask.length).data('mask-maxlength', true);
				}
				p.destroyEvents();
				p.events();
				var caret = p.getCaret();
				p.val(p.getMasked());
				p.setCaret(caret);
			}
		};
		jMask.init(!el.is('input'));
	};
	$.maskWatchers = {};
	var HTMLAttributes = function() {
			var input = $(this),
				options = {},
				prefix = 'data-mask-',
				mask = input.attr('data-mask');
			if (input.attr(prefix + 'reverse')) {
				options.reverse = true;
			}
			if (input.attr(prefix + 'clearifnotmatch')) {
				options.clearIfNotMatch = true;
			}
			if (input.attr(prefix + 'selectonfocus') === 'true') {
				options.selectOnFocus = true;
			}
			if (notSameMaskObject(input, mask, options)) {
				return input.data('mask', new Mask(this, mask, options));
			}
		},
		notSameMaskObject = function(field, mask, options) {
			options = options || {};
			var maskObject = $(field).data('mask'),
				stringify = JSON.stringify,
				value = $(field).val() || $(field).text();
			try {
				if (typeof mask === 'function') {
					mask = mask(value);
				}
				return typeof maskObject !== 'object' || stringify(maskObject.options) !== stringify(options) || maskObject.mask !== mask;
			} catch (e) {}
		},
		eventSupported = function(eventName) {
			var el = document.createElement('div'),
				isSupported;
			eventName = 'on' + eventName;
			isSupported = (eventName in el);
			if (!isSupported) {
				el.setAttribute(eventName, 'return;');
				isSupported = typeof el[eventName] === 'function';
			}
			el = null;
			return isSupported;
		};
	$.fn.mask = function(mask, options) {
		options = options || {};
		var selector = this.selector,
			globals = $.jMaskGlobals,
			interval = globals.watchInterval,
			watchInputs = options.watchInputs || globals.watchInputs,
			maskFunction = function() {
				if (notSameMaskObject(this, mask, options)) {
					return $(this).data('mask', new Mask(this, mask, options));
				}
			};
		$(this).each(maskFunction);
		if (selector && selector !== '' && watchInputs) {
			clearInterval($.maskWatchers[selector]);
			$.maskWatchers[selector] = setInterval(function() {
				$(document).find(selector).each(maskFunction);
			}, interval);
		}
		return this;
	};
	$.fn.masked = function(val) {
		return this.data('mask').getMaskedVal(val);
	};
	$.fn.unmask = function() {
		clearInterval($.maskWatchers[this.selector]);
		delete $.maskWatchers[this.selector];
		return this.each(function() {
			var dataMask = $(this).data('mask');
			if (dataMask) {
				dataMask.remove().removeData('mask');
			}
		});
	};
	$.fn.cleanVal = function() {
		return this.data('mask').getCleanVal();
	};
	$.applyDataMask = function(selector) {
		selector = selector || $.jMaskGlobals.maskElements;
		var $selector = (selector instanceof $) ? selector : $(selector);
		$selector.filter($.jMaskGlobals.dataMaskAttr).each(HTMLAttributes);
	};
	var globals = {
		maskElements: 'input,td,span,div',
		dataMaskAttr: '*[data-mask]',
		dataMask: true,
		watchInterval: 300,
		watchInputs: true,
		keyStrokeCompensation: 10,
		// old versions of chrome dont work great with input event
		useInput: !/Chrome\/[2-4][0-9]|SamsungBrowser/.test(window.navigator.userAgent) && eventSupported('input'),
		watchDataMask: false,
		byPassKeys: [9, 16, 17, 18, 36, 37, 38, 39, 40, 91],
		translation: {
			'0': {
				pattern: /\d/
			},
			'9': {
				pattern: /\d/,
				optional: true
			},
			'#': {
				pattern: /\d/,
				recursive: true
			},
			'A': {
				pattern: /[a-zA-Z0-9]/
			},
			'S': {
				pattern: /[a-zA-Z]/
			}
		}
	};
	$.jMaskGlobals = $.jMaskGlobals || {};
	globals = $.jMaskGlobals = $.extend(true, {}, globals, $.jMaskGlobals);
	// looking for inputs with data-mask attribute
	if (globals.dataMask) {
		$.applyDataMask();
	}
	setInterval(function() {
		if ($.jMaskGlobals.watchDataMask) {
			$.applyDataMask();
		}
	}, globals.watchInterval);
}, window.jQuery, window.Zepto));
// ==================================================
// fancyBox v3.5.7
//
// Licensed GPLv3 for open source use
// or fancyBox Commercial License for commercial use
//
// http://fancyapps.com/fancybox/
// Copyright 2019 fancyApps
//
// ==================================================
(function(window, document, $, undefined) {
	"use strict";
	window.console = window.console || {
		info: function(stuff) {}
	};
	// If there's no jQuery, fancyBox can't work
	// =========================================
	if (!$) {
		return;
	}
	// Check if fancyBox is already initialized
	// ========================================
	if ($.fn.fancybox) {
		console.info("fancyBox already initialized");
		return;
	}
	// Private default settings
	// ========================
	var defaults = {
		// Close existing modals
		// Set this to false if you do not need to stack multiple instances
		closeExisting: false,
		// Enable infinite gallery navigation
		loop: false,
		// Horizontal space between slides
		gutter: 50,
		// Enable keyboard navigation
		keyboard: true,
		// Should allow caption to overlap the content
		preventCaptionOverlap: true,
		// Should display navigation arrows at the screen edges
		arrows: true,
		// Should display counter at the top left corner
		infobar: true,
		// Should display close button (using `btnTpl.smallBtn` template) over the content
		// Can be true, false, "auto"
		// If "auto" - will be automatically enabled for "html", "inline" or "ajax" items
		smallBtn: "auto",
		// Should display toolbar (buttons at the top)
		// Can be true, false, "auto"
		// If "auto" - will be automatically hidden if "smallBtn" is enabled
		toolbar: "auto",
		// What buttons should appear in the top right corner.
		// Buttons will be created using templates from `btnTpl` option
		// and they will be placed into toolbar (class="fancybox-toolbar"` element)
		buttons: [
			"zoom",
			//"share",
			"slideShow",
			//"fullScreen",
			//"download",
			"thumbs",
			"close"
		],
		// Detect "idle" time in seconds
		idleTime: 3,
		// Disable right-click and use simple image protection for images
		protect: false,
		// Shortcut to make content "modal" - disable keyboard navigtion, hide buttons, etc
		modal: false,
		image: {
			// Wait for images to load before displaying
			//   true  - wait for image to load and then display;
			//   false - display thumbnail and load the full-sized image over top,
			//           requires predefined image dimensions (`data-width` and `data-height` attributes)
			preload: false
		},
		ajax: {
			// Object containing settings for ajax request
			settings: {
				// This helps to indicate that request comes from the modal
				// Feel free to change naming
				data: {
					fancybox: true
				}
			}
		},
		iframe: {
			// Iframe template
			tpl: '<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" allowfullscreen="allowfullscreen" allow="autoplay; fullscreen" src=""></iframe>',
			// Preload iframe before displaying it
			// This allows to calculate iframe content width and height
			// (note: Due to "Same Origin Policy", you can't get cross domain data).
			preload: true,
			// Custom CSS styling for iframe wrapping element
			// You can use this to set custom iframe dimensions
			css: {},
			// Iframe tag attributes
			attr: {
				scrolling: "auto"
			}
		},
		// For HTML5 video only
		video: {
			tpl: '<video class="fancybox-video" controls controlsList="nodownload" poster="{{poster}}">' +
				'<source src="{{src}}" type="{{format}}" />' +
				'Sorry, your browser doesn\'t support embedded videos, <a href="{{src}}">download</a> and watch with your favorite video player!' +
				"</video>",
			format: "", // custom video format
			autoStart: true
		},
		// Default content type if cannot be detected automatically
		defaultType: "image",
		// Open/close animation type
		// Possible values:
		//   false            - disable
		//   "zoom"           - zoom images from/to thumbnail
		//   "fade"
		//   "zoom-in-out"
		//
		animationEffect: "zoom",
		// Duration in ms for open/close animation
		animationDuration: 366,
		// Should image change opacity while zooming
		// If opacity is "auto", then opacity will be changed if image and thumbnail have different aspect ratios
		zoomOpacity: "auto",
		// Transition effect between slides
		//
		// Possible values:
		//   false            - disable
		//   "fade'
		//   "slide'
		//   "circular'
		//   "tube'
		//   "zoom-in-out'
		//   "rotate'
		//
		transitionEffect: "fade",
		// Duration in ms for transition animation
		transitionDuration: 366,
		// Custom CSS class for slide element
		slideClass: "",
		// Custom CSS class for layout
		baseClass: "",
		// Base template for layout
		baseTpl: '<div class="fancybox-container" data-lenis-prevent role="dialog" tabindex="-1">' +
			'<div class="fancybox-bg"></div>' +
			'<div class="fancybox-inner">' +
			'<div class="fancybox-infobar"><span data-fancybox-index></span>&nbsp;/&nbsp;<span data-fancybox-count></span></div>' +
			'<div class="fancybox-toolbar">{{buttons}}</div>' +
			'<div class="fancybox-navigation">{{arrows}}</div>' +
			'<div class="fancybox-stage"></div>' +
			'<div class="fancybox-caption"><div class="fancybox-caption__body"></div></div>' +
			"</div>" +
			"</div>",
		// Loading indicator template
		spinnerTpl: '<div class="fancybox-loading"></div>',
		// Error message template
		errorTpl: '<div class="fancybox-error"><p>{{ERROR}}</p></div>',
		btnTpl: {
			download: '<a download data-fancybox-download class="fancybox-button fancybox-button--download" title="{{DOWNLOAD}}" href="javascript:;">' +
				'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.62 17.09V19H5.38v-1.91zm-2.97-6.96L17 11.45l-5 4.87-5-4.87 1.36-1.32 2.68 2.64V5h1.92v7.77z"/></svg>' +
				"</a>",
			zoom: '<button data-fancybox-zoom class="fancybox-button fancybox-button--zoom" title="{{ZOOM}}">' +
				'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.7 17.3l-3-3a5.9 5.9 0 0 0-.6-7.6 5.9 5.9 0 0 0-8.4 0 5.9 5.9 0 0 0 0 8.4 5.9 5.9 0 0 0 7.7.7l3 3a1 1 0 0 0 1.3 0c.4-.5.4-1 0-1.5zM8.1 13.8a4 4 0 0 1 0-5.7 4 4 0 0 1 5.7 0 4 4 0 0 1 0 5.7 4 4 0 0 1-5.7 0z"/></svg>' +
				"</button>",
			close: '<button data-fancybox-close class="fancybox-button fancybox-button--close" title="{{CLOSE}}">' +
				'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 10.6L6.6 5.2 5.2 6.6l5.4 5.4-5.4 5.4 1.4 1.4 5.4-5.4 5.4 5.4 1.4-1.4-5.4-5.4 5.4-5.4-1.4-1.4-5.4 5.4z"/></svg>' +
				"</button>",
			// Arrows
			arrowLeft: '<button data-fancybox-prev class="fancybox-button fancybox-button--arrow_left" title="{{PREV}}">' +
				'<div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.28 15.7l-1.34 1.37L5 12l4.94-5.07 1.34 1.38-2.68 2.72H19v1.94H8.6z"/></svg></div>' +
				"</button>",
			arrowRight: '<button data-fancybox-next class="fancybox-button fancybox-button--arrow_right" title="{{NEXT}}">' +
				'<div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M15.4 12.97l-2.68 2.72 1.34 1.38L19 12l-4.94-5.07-1.34 1.38 2.68 2.72H5v1.94z"/></svg></div>' +
				"</button>",
			// This small close button will be appended to your html/inline/ajax content by default,
			// if "smallBtn" option is not set to false
			smallBtn: '<button type="button" data-fancybox-close class="fancybox-button fancybox-close-small" title="{{CLOSE}}">' +
				'<svg xmlns="http://www.w3.org/2000/svg" version="1" viewBox="0 0 24 24"><path d="M13 12l5-5-1-1-5 5-5-5-1 1 5 5-5 5 1 1 5-5 5 5 1-1z"/></svg>' +
				"</button>"
		},
		// Container is injected into this element
		parentEl: "body",
		// Hide browser vertical scrollbars; use at your own risk
		hideScrollbar: true,
		// Focus handling
		// ==============
		// Try to focus on the first focusable element after opening
		autoFocus: true,
		// Put focus back to active element after closing
		backFocus: true,
		// Do not let user to focus on element outside modal content
		trapFocus: true,
		// Module specific options
		// =======================
		fullScreen: {
			autoStart: false
		},
		// Set `touch: false` to disable panning/swiping
		touch: {
			vertical: true, // Allow to drag content vertically
			momentum: true // Continue movement after releasing mouse/touch when panning
		},
		// Hash value when initializing manually,
		// set `false` to disable hash change
		hash: null,
		// Customize or add new media types
		// Example:
		/*

			media : {

				youtube : {

					params : {

						autoplay : 0

					}

				}

			}

		*/
		media: {},
		slideShow: {
			autoStart: false,
			speed: 3000
		},
		thumbs: {
			autoStart: false, // Display thumbnails on opening
			hideOnClose: true, // Hide thumbnail grid when closing animation starts
			parentEl: ".fancybox-container", // Container is injected into this element
			axis: "y" // Vertical (y) or horizontal (x) scrolling
		},
		// Use mousewheel to navigate gallery
		// If 'auto' - enabled for images only
		wheel: "auto",
		// Callbacks
		//==========
		// See Documentation/API/Events for more information
		// Example:
		/*

			afterShow: function( instance, current ) {

				console.info( 'Clicked element:' );

				console.info( current.opts.$orig );

			}

		*/
		onInit: $.noop, // When instance has been initialized
		beforeLoad: $.noop, // Before the content of a slide is being loaded
		afterLoad: $.noop, // When the content of a slide is done loading
		beforeShow: $.noop, // Before open animation starts
		afterShow: $.noop, // When content is done loading and animating
		beforeClose: $.noop, // Before the instance attempts to close. Return false to cancel the close.
		afterClose: $.noop, // After instance has been closed
		onActivate: $.noop, // When instance is brought to front
		onDeactivate: $.noop, // When other instance has been activated
		// Interaction
		// ===========
		// Use options below to customize taken action when user clicks or double clicks on the fancyBox area,
		// each option can be string or method that returns value.
		//
		// Possible values:
		//   "close"           - close instance
		//   "next"            - move to next gallery item
		//   "nextOrClose"     - move to next gallery item or close if gallery has only one item
		//   "toggleControls"  - show/hide controls
		//   "zoom"            - zoom image (if loaded)
		//   false             - do nothing
		// Clicked on the content
		clickContent: function(current, event) {
			return current.type === "image" ? "zoom" : false;
		},
		// Clicked on the slide
		clickSlide: "close",
		// Clicked on the background (backdrop) element;
		// if you have not changed the layout, then most likely you need to use `clickSlide` option
		clickOutside: "close",
		// Same as previous two, but for double click
		dblclickContent: false,
		dblclickSlide: false,
		dblclickOutside: false,
		// Custom options when mobile device is detected
		// =============================================
		mobile: {
			preventCaptionOverlap: false,
			idleTime: false,
			clickContent: function(current, event) {
				return current.type === "image" ? "toggleControls" : false;
			},
			clickSlide: function(current, event) {
				return current.type === "image" ? "toggleControls" : "close";
			},
			dblclickContent: function(current, event) {
				return current.type === "image" ? "zoom" : false;
			},
			dblclickSlide: function(current, event) {
				return current.type === "image" ? "zoom" : false;
			}
		},
		// Internationalization
		// ====================
		lang: "en",
		i18n: {
			en: {
				CLOSE: "Close",
				NEXT: "Next",
				PREV: "Previous",
				ERROR: "The requested content cannot be loaded. <br/> Please try again later.",
				PLAY_START: "Start slideshow",
				PLAY_STOP: "Pause slideshow",
				FULL_SCREEN: "Full screen",
				THUMBS: "Thumbnails",
				DOWNLOAD: "Download",
				SHARE: "Share",
				ZOOM: "Zoom"
			},
			de: {
				CLOSE: "Schlie&szlig;en",
				NEXT: "Weiter",
				PREV: "Zur&uuml;ck",
				ERROR: "Die angeforderten Daten konnten nicht geladen werden. <br/> Bitte versuchen Sie es sp&auml;ter nochmal.",
				PLAY_START: "Diaschau starten",
				PLAY_STOP: "Diaschau beenden",
				FULL_SCREEN: "Vollbild",
				THUMBS: "Vorschaubilder",
				DOWNLOAD: "Herunterladen",
				SHARE: "Teilen",
				ZOOM: "Vergr&ouml;&szlig;ern"
			}
		}
	};
	// Few useful variables and methods
	// ================================
	var $W = $(window);
	var $D = $(document);
	var called = 0;
	// Check if an object is a jQuery object and not a native JavaScript object
	// ========================================================================
	var isQuery = function(obj) {
		return obj && obj.hasOwnProperty && obj instanceof $;
	};
	// Handle multiple browsers for "requestAnimationFrame" and "cancelAnimationFrame"
	// ===============================================================================
	var requestAFrame = (function() {
		return (
			window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			// if all else fails, use setTimeout
			function(callback) {
				return window.setTimeout(callback, 1000 / 60);
			}
		);
	})();
	var cancelAFrame = (function() {
		return (
			window.cancelAnimationFrame ||
			window.webkitCancelAnimationFrame ||
			window.mozCancelAnimationFrame ||
			window.oCancelAnimationFrame ||
			function(id) {
				window.clearTimeout(id);
			}
		);
	})();
	// Detect the supported transition-end event property name
	// =======================================================
	var transitionEnd = (function() {
		var el = document.createElement("fakeelement"),
			t;
		var transitions = {
			transition: "transitionend",
			OTransition: "oTransitionEnd",
			MozTransition: "transitionend",
			WebkitTransition: "webkitTransitionEnd"
		};
		for (t in transitions) {
			if (el.style[t] !== undefined) {
				return transitions[t];
			}
		}
		return "transitionend";
	})();
	// Force redraw on an element.
	// This helps in cases where the browser doesn't redraw an updated element properly
	// ================================================================================
	var forceRedraw = function($el) {
		return $el && $el.length && $el[0].offsetHeight;
	};
	// Exclude array (`buttons`) options from deep merging
	// ===================================================
	var mergeOpts = function(opts1, opts2) {
		var rez = $.extend(true, {}, opts1, opts2);
		$.each(opts2, function(key, value) {
			if ($.isArray(value)) {
				rez[key] = value;
			}
		});
		return rez;
	};
	// How much of an element is visible in viewport
	// =============================================
	var inViewport = function(elem) {
		var elemCenter, rez;
		if (!elem || elem.ownerDocument !== document) {
			return false;
		}
		$(".fancybox-container").css("pointer-events", "none");
		elemCenter = {
			x: elem.getBoundingClientRect().left + elem.offsetWidth / 2,
			y: elem.getBoundingClientRect().top + elem.offsetHeight / 2
		};
		rez = document.elementFromPoint(elemCenter.x, elemCenter.y) === elem;
		$(".fancybox-container").css("pointer-events", "");
		return rez;
	};
	// Class definition
	// ================
	var FancyBox = function(content, opts, index) {
		var self = this;
		self.opts = mergeOpts({
			index: index
		}, $.fancybox.defaults);
		if ($.isPlainObject(opts)) {
			self.opts = mergeOpts(self.opts, opts);
		}
		if ($.fancybox.isMobile) {
			self.opts = mergeOpts(self.opts, self.opts.mobile);
		}
		self.id = self.opts.id || ++called;
		self.currIndex = parseInt(self.opts.index, 10) || 0;
		self.prevIndex = null;
		self.prevPos = null;
		self.currPos = 0;
		self.firstRun = true;
		// All group items
		self.group = [];
		// Existing slides (for current, next and previous gallery items)
		self.slides = {};
		// Create group elements
		self.addContent(content);
		if (!self.group.length) {
			return;
		}
		self.init();
	};
	$.extend(FancyBox.prototype, {
		// Create DOM structure
		// ====================
		init: function() {
			var self = this,
				firstItem = self.group[self.currIndex],
				firstItemOpts = firstItem.opts,
				$container,
				buttonStr;
			if (firstItemOpts.closeExisting) {
				$.fancybox.close(true);
			}
			// Hide scrollbars
			// ===============
			$("body").addClass("fancybox-active");
			if (
				!$.fancybox.getInstance() &&
				firstItemOpts.hideScrollbar !== false &&
				!$.fancybox.isMobile &&
				document.body.scrollHeight > window.innerHeight
			) {
				$("head").append(
					'<style id="fancybox-style-noscroll" type="text/css">.compensate-for-scrollbar{margin-right:' +
					(window.innerWidth - document.documentElement.clientWidth) +
					"px;}</style>"
				);
				$("body").addClass("compensate-for-scrollbar");
			}
			// Build html markup and set references
			// ====================================
			// Build html code for buttons and insert into main template
			buttonStr = "";
			$.each(firstItemOpts.buttons, function(index, value) {
				buttonStr += firstItemOpts.btnTpl[value] || "";
			});
			// Create markup from base template, it will be initially hidden to
			// avoid unnecessary work like painting while initializing is not complete
			$container = $(
					self.translate(
						self,
						firstItemOpts.baseTpl
						.replace("{{buttons}}", buttonStr)
						.replace("{{arrows}}", firstItemOpts.btnTpl.arrowLeft + firstItemOpts.btnTpl.arrowRight)
					)
				)
				.attr("id", "fancybox-container-" + self.id)
				.addClass(firstItemOpts.baseClass)
				.data("FancyBox", self)
				.appendTo(firstItemOpts.parentEl);
			// Create object holding references to jQuery wrapped nodes
			self.$refs = {
				container: $container
			};
			["bg", "inner", "infobar", "toolbar", "stage", "caption", "navigation"].forEach(function(item) {
				self.$refs[item] = $container.find(".fancybox-" + item);
			});
			self.trigger("onInit");
			// Enable events, deactive previous instances
			self.activate();
			// Build slides, load and reveal content
			self.jumpTo(self.currIndex);
		},
		// Simple i18n support - replaces object keys found in template
		// with corresponding values
		// ============================================================
		translate: function(obj, str) {
			var arr = obj.opts.i18n[obj.opts.lang] || obj.opts.i18n.en;
			return str.replace(/\{\{(\w+)\}\}/g, function(match, n) {
				return arr[n] === undefined ? match : arr[n];
			});
		},
		// Populate current group with fresh content
		// Check if each object has valid type and content
		// ===============================================
		addContent: function(content) {
			var self = this,
				items = $.makeArray(content),
				thumbs;
			$.each(items, function(i, item) {
				var obj = {},
					opts = {},
					$item,
					type,
					found,
					src,
					srcParts;
				// Step 1 - Make sure we have an object
				// ====================================
				if ($.isPlainObject(item)) {
					// We probably have manual usage here, something like
					// $.fancybox.open( [ { src : "image.jpg", type : "image" } ] )
					obj = item;
					opts = item.opts || item;
				} else if ($.type(item) === "object" && $(item).length) {
					// Here we probably have jQuery collection returned by some selector
					$item = $(item);
					// Support attributes like `data-options='{"touch" : false}'` and `data-touch='false'`
					opts = $item.data() || {};
					opts = $.extend(true, {}, opts, opts.options);
					// Here we store clicked element
					opts.$orig = $item;
					obj.src = self.opts.src || opts.src || $item.attr("href");
					// Assume that simple syntax is used, for example:
					//   `$.fancybox.open( $("#test"), {} );`
					if (!obj.type && !obj.src) {
						obj.type = "inline";
						obj.src = item;
					}
				} else {
					// Assume we have a simple html code, for example:
					//   $.fancybox.open( '<div><h1>Hi!</h1></div>' );
					obj = {
						type: "html",
						src: item + ""
					};
				}
				// Each gallery object has full collection of options
				obj.opts = $.extend(true, {}, self.opts, opts);
				// Do not merge buttons array
				if ($.isArray(opts.buttons)) {
					obj.opts.buttons = opts.buttons;
				}
				if ($.fancybox.isMobile && obj.opts.mobile) {
					obj.opts = mergeOpts(obj.opts, obj.opts.mobile);
				}
				// Step 2 - Make sure we have content type, if not - try to guess
				// ==============================================================
				type = obj.type || obj.opts.type;
				src = obj.src || "";
				if (!type && src) {
					if ((found = src.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i))) {
						type = "video";
						if (!obj.opts.video.format) {
							obj.opts.video.format = "video/" + (found[1] === "ogv" ? "ogg" : found[1]);
						}
					} else if (src.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i)) {
						type = "image";
					} else if (src.match(/\.(pdf)((\?|#).*)?$/i)) {
						type = "iframe";
						obj = $.extend(true, obj, {
							contentType: "pdf",
							opts: {
								iframe: {
									preload: false
								}
							}
						});
					} else if (src.charAt(0) === "#") {
						type = "inline";
					}
				}
				if (type) {
					obj.type = type;
				} else {
					self.trigger("objectNeedsType", obj);
				}
				if (!obj.contentType) {
					obj.contentType = $.inArray(obj.type, ["html", "inline", "ajax"]) > -1 ? "html" : obj.type;
				}
				// Step 3 - Some adjustments
				// =========================
				obj.index = self.group.length;
				if (obj.opts.smallBtn == "auto") {
					obj.opts.smallBtn = $.inArray(obj.type, ["html", "inline", "ajax"]) > -1;
				}
				if (obj.opts.toolbar === "auto") {
					obj.opts.toolbar = !obj.opts.smallBtn;
				}
				// Find thumbnail image, check if exists and if is in the viewport
				obj.$thumb = obj.opts.$thumb || null;
				if (obj.opts.$trigger && obj.index === self.opts.index) {
					obj.$thumb = obj.opts.$trigger.find("img:first");
					if (obj.$thumb.length) {
						obj.opts.$orig = obj.opts.$trigger;
					}
				}
				if (!(obj.$thumb && obj.$thumb.length) && obj.opts.$orig) {
					obj.$thumb = obj.opts.$orig.find("img:first");
				}
				if (obj.$thumb && !obj.$thumb.length) {
					obj.$thumb = null;
				}
				obj.thumb = obj.opts.thumb || (obj.$thumb ? obj.$thumb[0].src : null);
				// "caption" is a "special" option, it can be used to customize caption per gallery item
				if ($.type(obj.opts.caption) === "function") {
					obj.opts.caption = obj.opts.caption.apply(item, [self, obj]);
				}
				if ($.type(self.opts.caption) === "function") {
					obj.opts.caption = self.opts.caption.apply(item, [self, obj]);
				}
				// Make sure we have caption as a string or jQuery object
				if (!(obj.opts.caption instanceof $)) {
					obj.opts.caption = obj.opts.caption === undefined ? "" : obj.opts.caption + "";
				}
				// Check if url contains "filter" used to filter the content
				// Example: "ajax.html #something"
				if (obj.type === "ajax") {
					srcParts = src.split(/\s+/, 2);
					if (srcParts.length > 1) {
						obj.src = srcParts.shift();
						obj.opts.filter = srcParts.shift();
					}
				}
				// Hide all buttons and disable interactivity for modal items
				if (obj.opts.modal) {
					obj.opts = $.extend(true, obj.opts, {
						trapFocus: true,
						// Remove buttons
						infobar: 0,
						toolbar: 0,
						smallBtn: 0,
						// Disable keyboard navigation
						keyboard: 0,
						// Disable some modules
						slideShow: 0,
						fullScreen: 0,
						thumbs: 0,
						touch: 0,
						// Disable click event handlers
						clickContent: false,
						clickSlide: false,
						clickOutside: false,
						dblclickContent: false,
						dblclickSlide: false,
						dblclickOutside: false
					});
				}
				// Step 4 - Add processed object to group
				// ======================================
				self.group.push(obj);
			});
			// Update controls if gallery is already opened
			if (Object.keys(self.slides).length) {
				self.updateControls();
				// Update thumbnails, if needed
				thumbs = self.Thumbs;
				if (thumbs && thumbs.isActive) {
					thumbs.create();
					thumbs.focus();
				}
			}
		},
		// Attach an event handler functions for:
		//   - navigation buttons
		//   - browser scrolling, resizing;
		//   - focusing
		//   - keyboard
		//   - detecting inactivity
		// ======================================
		addEvents: function() {
			var self = this;
			self.removeEvents();
			// Make navigation elements clickable
			// ==================================
			self.$refs.container
				.on("click.fb-close", "[data-fancybox-close]", function(e) {
					e.stopPropagation();
					e.preventDefault();
					self.close(e);
				})
				.on("touchstart.fb-prev click.fb-prev", "[data-fancybox-prev]", function(e) {
					e.stopPropagation();
					e.preventDefault();
					self.previous();
				})
				.on("touchstart.fb-next click.fb-next", "[data-fancybox-next]", function(e) {
					e.stopPropagation();
					e.preventDefault();
					self.next();
				})
				.on("click.fb", "[data-fancybox-zoom]", function(e) {
					// Click handler for zoom button
					self[self.isScaledDown() ? "scaleToActual" : "scaleToFit"]();
				});
			// Handle page scrolling and browser resizing
			// ==========================================
			$W.on("orientationchange.fb resize.fb", function(e) {
				if (e && e.originalEvent && e.originalEvent.type === "resize") {
					if (self.requestId) {
						cancelAFrame(self.requestId);
					}
					self.requestId = requestAFrame(function() {
						self.update(e);
					});
				} else {
					if (self.current && self.current.type === "iframe") {
						self.$refs.stage.hide();
					}
					setTimeout(
						function() {
							self.$refs.stage.show();
							self.update(e);
						},
						$.fancybox.isMobile ? 600 : 250
					);
				}
			});
			$D.on("keydown.fb", function(e) {
				var instance = $.fancybox ? $.fancybox.getInstance() : null,
					current = instance.current,
					keycode = e.keyCode || e.which;
				// Trap keyboard focus inside of the modal
				// =======================================
				if (keycode == 9) {
					if (current.opts.trapFocus) {
						self.focus(e);
					}
					return;
				}
				// Enable keyboard navigation
				// ==========================
				if (!current.opts.keyboard || e.ctrlKey || e.altKey || e.shiftKey || $(e.target).is("input,textarea,video,audio,select")) {
					return;
				}
				// Backspace and Esc keys
				if (keycode === 8 || keycode === 27) {
					e.preventDefault();
					self.close(e);
					return;
				}
				// Left arrow and Up arrow
				if (keycode === 37 || keycode === 38) {
					e.preventDefault();
					self.previous();
					return;
				}
				// Righ arrow and Down arrow
				if (keycode === 39 || keycode === 40) {
					e.preventDefault();
					self.next();
					return;
				}
				self.trigger("afterKeydown", e, keycode);
			});
			// Hide controls after some inactivity period
			if (self.group[self.currIndex].opts.idleTime) {
				self.idleSecondsCounter = 0;
				$D.on(
					"mousemove.fb-idle mouseleave.fb-idle mousedown.fb-idle touchstart.fb-idle touchmove.fb-idle scroll.fb-idle keydown.fb-idle",
					function(e) {
						self.idleSecondsCounter = 0;
						if (self.isIdle) {
							self.showControls();
						}
						self.isIdle = false;
					}
				);
				self.idleInterval = window.setInterval(function() {
					self.idleSecondsCounter++;
					if (self.idleSecondsCounter >= self.group[self.currIndex].opts.idleTime && !self.isDragging) {
						self.isIdle = true;
						self.idleSecondsCounter = 0;
						self.hideControls();
					}
				}, 1000);
			}
		},
		// Remove events added by the core
		// ===============================
		removeEvents: function() {
			var self = this;
			$W.off("orientationchange.fb resize.fb");
			$D.off("keydown.fb .fb-idle");
			this.$refs.container.off(".fb-close .fb-prev .fb-next");
			if (self.idleInterval) {
				window.clearInterval(self.idleInterval);
				self.idleInterval = null;
			}
		},
		// Change to previous gallery item
		// ===============================
		previous: function(duration) {
			return this.jumpTo(this.currPos - 1, duration);
		},
		// Change to next gallery item
		// ===========================
		next: function(duration) {
			return this.jumpTo(this.currPos + 1, duration);
		},
		// Switch to selected gallery item
		// ===============================
		jumpTo: function(pos, duration) {
			var self = this,
				groupLen = self.group.length,
				firstRun,
				isMoved,
				loop,
				current,
				previous,
				slidePos,
				stagePos,
				prop,
				diff;
			if (self.isDragging || self.isClosing || (self.isAnimating && self.firstRun)) {
				return;
			}
			// Should loop?
			pos = parseInt(pos, 10);
			loop = self.current ? self.current.opts.loop : self.opts.loop;
			if (!loop && (pos < 0 || pos >= groupLen)) {
				return false;
			}
			// Check if opening for the first time; this helps to speed things up
			firstRun = self.firstRun = !Object.keys(self.slides).length;
			// Create slides
			previous = self.current;
			self.prevIndex = self.currIndex;
			self.prevPos = self.currPos;
			current = self.createSlide(pos);
			if (groupLen > 1) {
				if (loop || current.index < groupLen - 1) {
					self.createSlide(pos + 1);
				}
				if (loop || current.index > 0) {
					self.createSlide(pos - 1);
				}
			}
			self.current = current;
			self.currIndex = current.index;
			self.currPos = current.pos;
			self.trigger("beforeShow", firstRun);
			self.updateControls();
			// Validate duration length
			current.forcedDuration = undefined;
			if ($.isNumeric(duration)) {
				current.forcedDuration = duration;
			} else {
				duration = current.opts[firstRun ? "animationDuration" : "transitionDuration"];
			}
			duration = parseInt(duration, 10);
			// Check if user has swiped the slides or if still animating
			isMoved = self.isMoved(current);
			// Make sure current slide is visible
			current.$slide.addClass("fancybox-slide--current");
			// Fresh start - reveal container, current slide and start loading content
			if (firstRun) {
				if (current.opts.animationEffect && duration) {
					self.$refs.container.css("transition-duration", duration + "ms");
				}
				self.$refs.container.addClass("fancybox-is-open").trigger("focus");
				// Attempt to load content into slide
				// This will later call `afterLoad` -> `revealContent`
				self.loadSlide(current);
				self.preload("image");
				return;
			}
			// Get actual slide/stage positions (before cleaning up)
			slidePos = $.fancybox.getTranslate(previous.$slide);
			stagePos = $.fancybox.getTranslate(self.$refs.stage);
			// Clean up all slides
			$.each(self.slides, function(index, slide) {
				$.fancybox.stop(slide.$slide, true);
			});
			if (previous.pos !== current.pos) {
				previous.isComplete = false;
			}
			previous.$slide.removeClass("fancybox-slide--complete fancybox-slide--current");
			// If slides are out of place, then animate them to correct position
			if (isMoved) {
				// Calculate horizontal swipe distance
				diff = slidePos.left - (previous.pos * slidePos.width + previous.pos * previous.opts.gutter);
				$.each(self.slides, function(index, slide) {
					slide.$slide.removeClass("fancybox-animated").removeClass(function(index, className) {
						return (className.match(/(^|\s)fancybox-fx-\S+/g) || []).join(" ");
					});
					// Make sure that each slide is in equal distance
					// This is mostly needed for freshly added slides, because they are not yet positioned
					var leftPos = slide.pos * slidePos.width + slide.pos * slide.opts.gutter;
					$.fancybox.setTranslate(slide.$slide, {
						top: 0,
						left: leftPos - stagePos.left + diff
					});
					if (slide.pos !== current.pos) {
						slide.$slide.addClass("fancybox-slide--" + (slide.pos > current.pos ? "next" : "previous"));
					}
					// Redraw to make sure that transition will start
					forceRedraw(slide.$slide);
					// Animate the slide
					$.fancybox.animate(
						slide.$slide, {
							top: 0,
							left: (slide.pos - current.pos) * slidePos.width + (slide.pos - current.pos) * slide.opts.gutter
						},
						duration,
						function() {
							slide.$slide
								.css({
									transform: "",
									opacity: ""
								})
								.removeClass("fancybox-slide--next fancybox-slide--previous");
							if (slide.pos === self.currPos) {
								self.complete();
							}
						}
					);
				});
			} else if (duration && current.opts.transitionEffect) {
				// Set transition effect for previously active slide
				prop = "fancybox-animated fancybox-fx-" + current.opts.transitionEffect;
				previous.$slide.addClass("fancybox-slide--" + (previous.pos > current.pos ? "next" : "previous"));
				$.fancybox.animate(
					previous.$slide,
					prop,
					duration,
					function() {
						previous.$slide.removeClass(prop).removeClass("fancybox-slide--next fancybox-slide--previous");
					},
					false
				);
			}
			if (current.isLoaded) {
				self.revealContent(current);
			} else {
				self.loadSlide(current);
			}
			self.preload("image");
		},
		// Create new "slide" element
		// These are gallery items  that are actually added to DOM
		// =======================================================
		createSlide: function(pos) {
			var self = this,
				$slide,
				index;
			index = pos % self.group.length;
			index = index < 0 ? self.group.length + index : index;
			if (!self.slides[pos] && self.group[index]) {
				$slide = $('<div class="fancybox-slide"></div>').appendTo(self.$refs.stage);
				self.slides[pos] = $.extend(true, {}, self.group[index], {
					pos: pos,
					$slide: $slide,
					isLoaded: false
				});
				self.updateSlide(self.slides[pos]);
			}
			return self.slides[pos];
		},
		// Scale image to the actual size of the image;
		// x and y values should be relative to the slide
		// ==============================================
		scaleToActual: function(x, y, duration) {
			var self = this,
				current = self.current,
				$content = current.$content,
				canvasWidth = $.fancybox.getTranslate(current.$slide).width,
				canvasHeight = $.fancybox.getTranslate(current.$slide).height,
				newImgWidth = current.width,
				newImgHeight = current.height,
				imgPos,
				posX,
				posY,
				scaleX,
				scaleY;
			if (self.isAnimating || self.isMoved() || !$content || !(current.type == "image" && current.isLoaded && !current.hasError)) {
				return;
			}
			self.isAnimating = true;
			$.fancybox.stop($content);
			x = x === undefined ? canvasWidth * 0.5 : x;
			y = y === undefined ? canvasHeight * 0.5 : y;
			imgPos = $.fancybox.getTranslate($content);
			imgPos.top -= $.fancybox.getTranslate(current.$slide).top;
			imgPos.left -= $.fancybox.getTranslate(current.$slide).left;
			scaleX = newImgWidth / imgPos.width;
			scaleY = newImgHeight / imgPos.height;
			// Get center position for original image
			posX = canvasWidth * 0.5 - newImgWidth * 0.5;
			posY = canvasHeight * 0.5 - newImgHeight * 0.5;
			// Make sure image does not move away from edges
			if (newImgWidth > canvasWidth) {
				posX = imgPos.left * scaleX - (x * scaleX - x);
				if (posX > 0) {
					posX = 0;
				}
				if (posX < canvasWidth - newImgWidth) {
					posX = canvasWidth - newImgWidth;
				}
			}
			if (newImgHeight > canvasHeight) {
				posY = imgPos.top * scaleY - (y * scaleY - y);
				if (posY > 0) {
					posY = 0;
				}
				if (posY < canvasHeight - newImgHeight) {
					posY = canvasHeight - newImgHeight;
				}
			}
			self.updateCursor(newImgWidth, newImgHeight);
			$.fancybox.animate(
				$content, {
					top: posY,
					left: posX,
					scaleX: scaleX,
					scaleY: scaleY
				},
				duration || 366,
				function() {
					self.isAnimating = false;
				}
			);
			// Stop slideshow
			if (self.SlideShow && self.SlideShow.isActive) {
				self.SlideShow.stop();
			}
		},
		// Scale image to fit inside parent element
		// ========================================
		scaleToFit: function(duration) {
			var self = this,
				current = self.current,
				$content = current.$content,
				end;
			if (self.isAnimating || self.isMoved() || !$content || !(current.type == "image" && current.isLoaded && !current.hasError)) {
				return;
			}
			self.isAnimating = true;
			$.fancybox.stop($content);
			end = self.getFitPos(current);
			self.updateCursor(end.width, end.height);
			$.fancybox.animate(
				$content, {
					top: end.top,
					left: end.left,
					scaleX: end.width / $content.width(),
					scaleY: end.height / $content.height()
				},
				duration || 366,
				function() {
					self.isAnimating = false;
				}
			);
		},
		// Calculate image size to fit inside viewport
		// ===========================================
		getFitPos: function(slide) {
			var self = this,
				$content = slide.$content,
				$slide = slide.$slide,
				width = slide.width || slide.opts.width,
				height = slide.height || slide.opts.height,
				maxWidth,
				maxHeight,
				minRatio,
				aspectRatio,
				rez = {};
			if (!slide.isLoaded || !$content || !$content.length) {
				return false;
			}
			maxWidth = $.fancybox.getTranslate(self.$refs.stage).width;
			maxHeight = $.fancybox.getTranslate(self.$refs.stage).height;
			maxWidth -=
				parseFloat($slide.css("paddingLeft")) +
				parseFloat($slide.css("paddingRight")) +
				parseFloat($content.css("marginLeft")) +
				parseFloat($content.css("marginRight"));
			maxHeight -=
				parseFloat($slide.css("paddingTop")) +
				parseFloat($slide.css("paddingBottom")) +
				parseFloat($content.css("marginTop")) +
				parseFloat($content.css("marginBottom"));
			if (!width || !height) {
				width = maxWidth;
				height = maxHeight;
			}
			minRatio = Math.min(1, maxWidth / width, maxHeight / height);
			width = minRatio * width;
			height = minRatio * height;
			// Adjust width/height to precisely fit into container
			if (width > maxWidth - 0.5) {
				width = maxWidth;
			}
			if (height > maxHeight - 0.5) {
				height = maxHeight;
			}
			if (slide.type === "image") {
				rez.top = Math.floor((maxHeight - height) * 0.5) + parseFloat($slide.css("paddingTop"));
				rez.left = Math.floor((maxWidth - width) * 0.5) + parseFloat($slide.css("paddingLeft"));
			} else if (slide.contentType === "video") {
				// Force aspect ratio for the video
				// "I say the whole world must learn of our peaceful ways… by force!"
				aspectRatio = slide.opts.width && slide.opts.height ? width / height : slide.opts.ratio || 16 / 9;
				if (height > width / aspectRatio) {
					height = width / aspectRatio;
				} else if (width > height * aspectRatio) {
					width = height * aspectRatio;
				}
			}
			rez.width = width;
			rez.height = height;
			return rez;
		},
		// Update content size and position for all slides
		// ==============================================
		update: function(e) {
			var self = this;
			$.each(self.slides, function(key, slide) {
				self.updateSlide(slide, e);
			});
		},
		// Update slide content position and size
		// ======================================
		updateSlide: function(slide, e) {
			var self = this,
				$content = slide && slide.$content,
				width = slide.width || slide.opts.width,
				height = slide.height || slide.opts.height,
				$slide = slide.$slide;
			// First, prevent caption overlap, if needed
			self.adjustCaption(slide);
			// Then resize content to fit inside the slide
			if ($content && (width || height || slide.contentType === "video") && !slide.hasError) {
				$.fancybox.stop($content);
				$.fancybox.setTranslate($content, self.getFitPos(slide));
				if (slide.pos === self.currPos) {
					self.isAnimating = false;
					self.updateCursor();
				}
			}
			// Then some adjustments
			self.adjustLayout(slide);
			if ($slide.length) {
				$slide.trigger("refresh");
				if (slide.pos === self.currPos) {
					self.$refs.toolbar
						.add(self.$refs.navigation.find(".fancybox-button--arrow_right"))
						.toggleClass("compensate-for-scrollbar", $slide.get(0).scrollHeight > $slide.get(0).clientHeight);
				}
			}
			self.trigger("onUpdate", slide, e);
		},
		// Horizontally center slide
		// =========================
		centerSlide: function(duration) {
			var self = this,
				current = self.current,
				$slide = current.$slide;
			if (self.isClosing || !current) {
				return;
			}
			$slide.siblings().css({
				transform: "",
				opacity: ""
			});
			$slide
				.parent()
				.children()
				.removeClass("fancybox-slide--previous fancybox-slide--next");
			$.fancybox.animate(
				$slide, {
					top: 0,
					left: 0,
					opacity: 1
				},
				duration === undefined ? 0 : duration,
				function() {
					// Clean up
					$slide.css({
						transform: "",
						opacity: ""
					});
					if (!current.isComplete) {
						self.complete();
					}
				},
				false
			);
		},
		// Check if current slide is moved (swiped)
		// ========================================
		isMoved: function(slide) {
			var current = slide || this.current,
				slidePos,
				stagePos;
			if (!current) {
				return false;
			}
			stagePos = $.fancybox.getTranslate(this.$refs.stage);
			slidePos = $.fancybox.getTranslate(current.$slide);
			return (
				!current.$slide.hasClass("fancybox-animated") &&
				(Math.abs(slidePos.top - stagePos.top) > 0.5 || Math.abs(slidePos.left - stagePos.left) > 0.5)
			);
		},
		// Update cursor style depending if content can be zoomed
		// ======================================================
		updateCursor: function(nextWidth, nextHeight) {
			var self = this,
				current = self.current,
				$container = self.$refs.container,
				canPan,
				isZoomable;
			if (!current || self.isClosing || !self.Guestures) {
				return;
			}
			$container.removeClass("fancybox-is-zoomable fancybox-can-zoomIn fancybox-can-zoomOut fancybox-can-swipe fancybox-can-pan");
			canPan = self.canPan(nextWidth, nextHeight);
			isZoomable = canPan ? true : self.isZoomable();
			$container.toggleClass("fancybox-is-zoomable", isZoomable);
			$("[data-fancybox-zoom]").prop("disabled", !isZoomable);
			if (canPan) {
				$container.addClass("fancybox-can-pan");
			} else if (
				isZoomable &&
				(current.opts.clickContent === "zoom" || ($.isFunction(current.opts.clickContent) && current.opts.clickContent(current) == "zoom"))
			) {
				$container.addClass("fancybox-can-zoomIn");
			} else if (current.opts.touch && (current.opts.touch.vertical || self.group.length > 1) && current.contentType !== "video") {
				$container.addClass("fancybox-can-swipe");
			}
		},
		// Check if current slide is zoomable
		// ==================================
		isZoomable: function() {
			var self = this,
				current = self.current,
				fitPos;
			// Assume that slide is zoomable if:
			//   - image is still loading
			//   - actual size of the image is smaller than available area
			if (current && !self.isClosing && current.type === "image" && !current.hasError) {
				if (!current.isLoaded) {
					return true;
				}
				fitPos = self.getFitPos(current);
				if (fitPos && (current.width > fitPos.width || current.height > fitPos.height)) {
					return true;
				}
			}
			return false;
		},
		// Check if current image dimensions are smaller than actual
		// =========================================================
		isScaledDown: function(nextWidth, nextHeight) {
			var self = this,
				rez = false,
				current = self.current,
				$content = current.$content;
			if (nextWidth !== undefined && nextHeight !== undefined) {
				rez = nextWidth < current.width && nextHeight < current.height;
			} else if ($content) {
				rez = $.fancybox.getTranslate($content);
				rez = rez.width < current.width && rez.height < current.height;
			}
			return rez;
		},
		// Check if image dimensions exceed parent element
		// ===============================================
		canPan: function(nextWidth, nextHeight) {
			var self = this,
				current = self.current,
				pos = null,
				rez = false;
			if (current.type === "image" && (current.isComplete || (nextWidth && nextHeight)) && !current.hasError) {
				rez = self.getFitPos(current);
				if (nextWidth !== undefined && nextHeight !== undefined) {
					pos = {
						width: nextWidth,
						height: nextHeight
					};
				} else if (current.isComplete) {
					pos = $.fancybox.getTranslate(current.$content);
				}
				if (pos && rez) {
					rez = Math.abs(pos.width - rez.width) > 1.5 || Math.abs(pos.height - rez.height) > 1.5;
				}
			}
			return rez;
		},
		// Load content into the slide
		// ===========================
		loadSlide: function(slide) {
			var self = this,
				type,
				$slide,
				ajaxLoad;
			if (slide.isLoading || slide.isLoaded) {
				return;
			}
			slide.isLoading = true;
			if (self.trigger("beforeLoad", slide) === false) {
				slide.isLoading = false;
				return false;
			}
			type = slide.type;
			$slide = slide.$slide;
			$slide
				.off("refresh")
				.trigger("onReset")
				.addClass(slide.opts.slideClass);
			// Create content depending on the type
			switch (type) {
				case "image":
					self.setImage(slide);
					break;
				case "iframe":
					self.setIframe(slide);
					break;
				case "html":
					self.setContent(slide, slide.src || slide.content);
					break;
				case "video":
					self.setContent(
						slide,
						slide.opts.video.tpl
						.replace(/\{\{src\}\}/gi, slide.src)
						.replace("{{format}}", slide.opts.videoFormat || slide.opts.video.format || "")
						.replace("{{poster}}", slide.thumb || "")
					);
					break;
				case "inline":
					if ($(slide.src).length) {
						self.setContent(slide, $(slide.src));
					} else {
						self.setError(slide);
					}
					break;
				case "ajax":
					self.showLoading(slide);
					ajaxLoad = $.ajax(
						$.extend({}, slide.opts.ajax.settings, {
							url: slide.src,
							success: function(data, textStatus) {
								if (textStatus === "success") {
									self.setContent(slide, data);
								}
							},
							error: function(jqXHR, textStatus) {
								if (jqXHR && textStatus !== "abort") {
									self.setError(slide);
								}
							}
						})
					);
					$slide.one("onReset", function() {
						ajaxLoad.abort();
					});
					break;
				default:
					self.setError(slide);
					break;
			}
			return true;
		},
		// Use thumbnail image, if possible
		// ================================
		setImage: function(slide) {
			var self = this,
				ghost;
			// Check if need to show loading icon
			setTimeout(function() {
				var $img = slide.$image;
				if (!self.isClosing && slide.isLoading && (!$img || !$img.length || !$img[0].complete) && !slide.hasError) {
					self.showLoading(slide);
				}
			}, 50);
			//Check if image has srcset
			self.checkSrcset(slide);
			// This will be wrapper containing both ghost and actual image
			slide.$content = $('<div class="fancybox-content"></div>')
				.addClass("fancybox-is-hidden")
				.appendTo(slide.$slide.addClass("fancybox-slide--image"));
			// If we have a thumbnail, we can display it while actual image is loading
			// Users will not stare at black screen and actual image will appear gradually
			if (slide.opts.preload !== false && slide.opts.width && slide.opts.height && slide.thumb) {
				slide.width = slide.opts.width;
				slide.height = slide.opts.height;
				ghost = document.createElement("img");
				ghost.onerror = function() {
					$(this).remove();
					slide.$ghost = null;
				};
				ghost.onload = function() {
					self.afterLoad(slide);
				};
				slide.$ghost = $(ghost)
					.addClass("fancybox-image")
					.appendTo(slide.$content)
					.attr("src", slide.thumb);
			}
			// Start loading actual image
			self.setBigImage(slide);
		},
		// Check if image has srcset and get the source
		// ============================================
		checkSrcset: function(slide) {
			var srcset = slide.opts.srcset || slide.opts.image.srcset,
				found,
				temp,
				pxRatio,
				windowWidth;
			// If we have "srcset", then we need to find first matching "src" value.
			// This is necessary, because when you set an src attribute, the browser will preload the image
			// before any javascript or even CSS is applied.
			if (srcset) {
				pxRatio = window.devicePixelRatio || 1;
				windowWidth = window.innerWidth * pxRatio;
				temp = srcset.split(",").map(function(el) {
					var ret = {};
					el.trim()
						.split(/\s+/)
						.forEach(function(el, i) {
							var value = parseInt(el.substring(0, el.length - 1), 10);
							if (i === 0) {
								return (ret.url = el);
							}
							if (value) {
								ret.value = value;
								ret.postfix = el[el.length - 1];
							}
						});
					return ret;
				});
				// Sort by value
				temp.sort(function(a, b) {
					return a.value - b.value;
				});
				// Ok, now we have an array of all srcset values
				for (var j = 0; j < temp.length; j++) {
					var el = temp[j];
					if ((el.postfix === "w" && el.value >= windowWidth) || (el.postfix === "x" && el.value >= pxRatio)) {
						found = el;
						break;
					}
				}
				// If not found, take the last one
				if (!found && temp.length) {
					found = temp[temp.length - 1];
				}
				if (found) {
					slide.src = found.url;
					// If we have default width/height values, we can calculate height for matching source
					if (slide.width && slide.height && found.postfix == "w") {
						slide.height = (slide.width / slide.height) * found.value;
						slide.width = found.value;
					}
					slide.opts.srcset = srcset;
				}
			}
		},
		// Create full-size image
		// ======================
		setBigImage: function(slide) {
			var self = this,
				img = document.createElement("img"),
				$img = $(img);
			slide.$image = $img
				.one("error", function() {
					self.setError(slide);
				})
				.one("load", function() {
					var sizes;
					if (!slide.$ghost) {
						self.resolveImageSlideSize(slide, this.naturalWidth, this.naturalHeight);
						self.afterLoad(slide);
					}
					if (self.isClosing) {
						return;
					}
					if (slide.opts.srcset) {
						sizes = slide.opts.sizes;
						if (!sizes || sizes === "auto") {
							sizes =
								(slide.width / slide.height > 1 && $W.width() / $W.height() > 1 ? "100" : Math.round((slide.width / slide.height) * 100)) +
								"vw";
						}
						$img.attr("sizes", sizes).attr("srcset", slide.opts.srcset);
					}
					// Hide temporary image after some delay
					if (slide.$ghost) {
						setTimeout(function() {
							if (slide.$ghost && !self.isClosing) {
								slide.$ghost.hide();
							}
						}, Math.min(300, Math.max(1000, slide.height / 1600)));
					}
					self.hideLoading(slide);
				})
				.addClass("fancybox-image")
				.attr("src", slide.src)
				.appendTo(slide.$content);
			if ((img.complete || img.readyState == "complete") && $img.naturalWidth && $img.naturalHeight) {
				$img.trigger("load");
			} else if (img.error) {
				$img.trigger("error");
			}
		},
		// Computes the slide size from image size and maxWidth/maxHeight
		// ==============================================================
		resolveImageSlideSize: function(slide, imgWidth, imgHeight) {
			var maxWidth = parseInt(slide.opts.width, 10),
				maxHeight = parseInt(slide.opts.height, 10);
			// Sets the default values from the image
			slide.width = imgWidth;
			slide.height = imgHeight;
			if (maxWidth > 0) {
				slide.width = maxWidth;
				slide.height = Math.floor((maxWidth * imgHeight) / imgWidth);
			}
			if (maxHeight > 0) {
				slide.width = Math.floor((maxHeight * imgWidth) / imgHeight);
				slide.height = maxHeight;
			}
		},
		// Create iframe wrapper, iframe and bindings
		// ==========================================
		setIframe: function(slide) {
			var self = this,
				opts = slide.opts.iframe,
				$slide = slide.$slide,
				$iframe;
			slide.$content = $('<div class="fancybox-content' + (opts.preload ? " fancybox-is-hidden" : "") + '"></div>')
				.css(opts.css)
				.appendTo($slide);
			$slide.addClass("fancybox-slide--" + slide.contentType);
			slide.$iframe = $iframe = $(opts.tpl.replace(/\{rnd\}/g, new Date().getTime()))
				.attr(opts.attr)
				.appendTo(slide.$content);
			if (opts.preload) {
				self.showLoading(slide);
				// Unfortunately, it is not always possible to determine if iframe is successfully loaded
				// (due to browser security policy)
				$iframe.on("load.fb error.fb", function(e) {
					this.isReady = 1;
					slide.$slide.trigger("refresh");
					self.afterLoad(slide);
				});
				// Recalculate iframe content size
				// ===============================
				$slide.on("refresh.fb", function() {
					var $content = slide.$content,
						frameWidth = opts.css.width,
						frameHeight = opts.css.height,
						$contents,
						$body;
					if ($iframe[0].isReady !== 1) {
						return;
					}
					try {
						$contents = $iframe.contents();
						$body = $contents.find("body");
					} catch (ignore) {}
					// Calculate content dimensions, if it is accessible
					if ($body && $body.length && $body.children().length) {
						// Avoid scrolling to top (if multiple instances)
						$slide.css("overflow", "visible");
						$content.css({
							width: "100%",
							"max-width": "100%",
							height: "9999px"
						});
						if (frameWidth === undefined) {
							frameWidth = Math.ceil(Math.max($body[0].clientWidth, $body.outerWidth(true)));
						}
						$content.css("width", frameWidth ? frameWidth : "").css("max-width", "");
						if (frameHeight === undefined) {
							frameHeight = Math.ceil(Math.max($body[0].clientHeight, $body.outerHeight(true)));
						}
						$content.css("height", frameHeight ? frameHeight : "");
						$slide.css("overflow", "auto");
					}
					$content.removeClass("fancybox-is-hidden");
				});
			} else {
				self.afterLoad(slide);
			}
			$iframe.attr("src", slide.src);
			// Remove iframe if closing or changing gallery item
			$slide.one("onReset", function() {
				// This helps IE not to throw errors when closing
				try {
					$(this)
						.find("iframe")
						.hide()
						.unbind()
						.attr("src", "//about:blank");
				} catch (ignore) {}
				$(this)
					.off("refresh.fb")
					.empty();
				slide.isLoaded = false;
				slide.isRevealed = false;
			});
		},
		// Wrap and append content to the slide
		// ======================================
		setContent: function(slide, content) {
			var self = this;
			if (self.isClosing) {
				return;
			}
			self.hideLoading(slide);
			if (slide.$content) {
				$.fancybox.stop(slide.$content);
			}
			slide.$slide.empty();
			// If content is a jQuery object, then it will be moved to the slide.
			// The placeholder is created so we will know where to put it back.
			if (isQuery(content) && content.parent().length) {
				// Make sure content is not already moved to fancyBox
				if (content.hasClass("fancybox-content") || content.parent().hasClass("fancybox-content")) {
					content.parents(".fancybox-slide").trigger("onReset");
				}
				// Create temporary element marking original place of the content
				slide.$placeholder = $("<div>")
					.hide()
					.insertAfter(content);
				// Make sure content is visible
				content.css("display", "inline-block");
			} else if (!slide.hasError) {
				// If content is just a plain text, try to convert it to html
				if ($.type(content) === "string") {
					content = $("<div>")
						.append($.trim(content))
						.contents();
				}
				// If "filter" option is provided, then filter content
				if (slide.opts.filter) {
					content = $("<div>")
						.html(content)
						.find(slide.opts.filter);
				}
			}
			slide.$slide.one("onReset", function() {
				// Pause all html5 video/audio
				$(this)
					.find("video,audio")
					.trigger("pause");
				// Put content back
				if (slide.$placeholder) {
					slide.$placeholder.after(content.removeClass("fancybox-content").hide()).remove();
					slide.$placeholder = null;
				}
				// Remove custom close button
				if (slide.$smallBtn) {
					slide.$smallBtn.remove();
					slide.$smallBtn = null;
				}
				// Remove content and mark slide as not loaded
				if (!slide.hasError) {
					$(this).empty();
					slide.isLoaded = false;
					slide.isRevealed = false;
				}
			});
			$(content).appendTo(slide.$slide);
			if ($(content).is("video,audio")) {
				$(content).addClass("fancybox-video");
				$(content).wrap("<div></div>");
				slide.contentType = "video";
				slide.opts.width = slide.opts.width || $(content).attr("width");
				slide.opts.height = slide.opts.height || $(content).attr("height");
			}
			slide.$content = slide.$slide
				.children()
				.filter("div,form,main,video,audio,article,.fancybox-content")
				.first();
			slide.$content.siblings().hide();
			// Re-check if there is a valid content
			// (in some cases, ajax response can contain various elements or plain text)
			if (!slide.$content.length) {
				slide.$content = slide.$slide
					.wrapInner("<div></div>")
					.children()
					.first();
			}
			slide.$content.addClass("fancybox-content");
			slide.$slide.addClass("fancybox-slide--" + slide.contentType);
			self.afterLoad(slide);
		},
		// Display error message
		// =====================
		setError: function(slide) {
			slide.hasError = true;
			slide.$slide
				.trigger("onReset")
				.removeClass("fancybox-slide--" + slide.contentType)
				.addClass("fancybox-slide--error");
			slide.contentType = "html";
			this.setContent(slide, this.translate(slide, slide.opts.errorTpl));
			if (slide.pos === this.currPos) {
				this.isAnimating = false;
			}
		},
		// Show loading icon inside the slide
		// ==================================
		showLoading: function(slide) {
			var self = this;
			slide = slide || self.current;
			if (slide && !slide.$spinner) {
				slide.$spinner = $(self.translate(self, self.opts.spinnerTpl))
					.appendTo(slide.$slide)
					.hide()
					.fadeIn("fast");
			}
		},
		// Remove loading icon from the slide
		// ==================================
		hideLoading: function(slide) {
			var self = this;
			slide = slide || self.current;
			if (slide && slide.$spinner) {
				slide.$spinner.stop().remove();
				delete slide.$spinner;
			}
		},
		// Adjustments after slide content has been loaded
		// ===============================================
		afterLoad: function(slide) {
			var self = this;
			if (self.isClosing) {
				return;
			}
			slide.isLoading = false;
			slide.isLoaded = true;
			self.trigger("afterLoad", slide);
			self.hideLoading(slide);
			// Add small close button
			if (slide.opts.smallBtn && (!slide.$smallBtn || !slide.$smallBtn.length)) {
				slide.$smallBtn = $(self.translate(slide, slide.opts.btnTpl.smallBtn)).appendTo(slide.$content);
			}
			// Disable right click
			if (slide.opts.protect && slide.$content && !slide.hasError) {
				slide.$content.on("contextmenu.fb", function(e) {
					if (e.button == 2) {
						e.preventDefault();
					}
					return true;
				});
				// Add fake element on top of the image
				// This makes a bit harder for user to select image
				if (slide.type === "image") {
					$('<div class="fancybox-spaceball"></div>').appendTo(slide.$content);
				}
			}
			self.adjustCaption(slide);
			self.adjustLayout(slide);
			if (slide.pos === self.currPos) {
				self.updateCursor();
			}
			self.revealContent(slide);
		},
		// Prevent caption overlap,
		// fix css inconsistency across browsers
		// =====================================
		adjustCaption: function(slide) {
			var self = this,
				current = slide || self.current,
				caption = current.opts.caption,
				preventOverlap = current.opts.preventCaptionOverlap,
				$caption = self.$refs.caption,
				$clone,
				captionH = false;
			$caption.toggleClass("fancybox-caption--separate", preventOverlap);
			if (preventOverlap && caption && caption.length) {
				if (current.pos !== self.currPos) {
					$clone = $caption.clone().appendTo($caption.parent());
					$clone
						.children()
						.eq(0)
						.empty()
						.html(caption);
					captionH = $clone.outerHeight(true);
					$clone.empty().remove();
				} else if (self.$caption) {
					captionH = self.$caption.outerHeight(true);
				}
				current.$slide.css("padding-bottom", captionH || "");
			}
		},
		// Simple hack to fix inconsistency across browsers, described here (affects Edge, too):
		// https://bugzilla.mozilla.org/show_bug.cgi?id=748518
		// ====================================================================================
		adjustLayout: function(slide) {
			var self = this,
				current = slide || self.current,
				scrollHeight,
				marginBottom,
				inlinePadding,
				actualPadding;
			if (current.isLoaded && current.opts.disableLayoutFix !== true) {
				current.$content.css("margin-bottom", "");
				// If we would always set margin-bottom for the content,
				// then it would potentially break vertical align
				if (current.$content.outerHeight() > current.$slide.height() + 0.5) {
					inlinePadding = current.$slide[0].style["padding-bottom"];
					actualPadding = current.$slide.css("padding-bottom");
					if (parseFloat(actualPadding) > 0) {
						scrollHeight = current.$slide[0].scrollHeight;
						current.$slide.css("padding-bottom", 0);
						if (Math.abs(scrollHeight - current.$slide[0].scrollHeight) < 1) {
							marginBottom = actualPadding;
						}
						current.$slide.css("padding-bottom", inlinePadding);
					}
				}
				current.$content.css("margin-bottom", marginBottom);
			}
		},
		// Make content visible
		// This method is called right after content has been loaded or
		// user navigates gallery and transition should start
		// ============================================================
		revealContent: function(slide) {
			var self = this,
				$slide = slide.$slide,
				end = false,
				start = false,
				isMoved = self.isMoved(slide),
				isRevealed = slide.isRevealed,
				effect,
				effectClassName,
				duration,
				opacity;
			slide.isRevealed = true;
			effect = slide.opts[self.firstRun ? "animationEffect" : "transitionEffect"];
			duration = slide.opts[self.firstRun ? "animationDuration" : "transitionDuration"];
			duration = parseInt(slide.forcedDuration === undefined ? duration : slide.forcedDuration, 10);
			if (isMoved || slide.pos !== self.currPos || !duration) {
				effect = false;
			}
			// Check if can zoom
			if (effect === "zoom") {
				if (slide.pos === self.currPos && duration && slide.type === "image" && !slide.hasError && (start = self.getThumbPos(slide))) {
					end = self.getFitPos(slide);
				} else {
					effect = "fade";
				}
			}
			// Zoom animation
			// ==============
			if (effect === "zoom") {
				self.isAnimating = true;
				end.scaleX = end.width / start.width;
				end.scaleY = end.height / start.height;
				// Check if we need to animate opacity
				opacity = slide.opts.zoomOpacity;
				if (opacity == "auto") {
					opacity = Math.abs(slide.width / slide.height - start.width / start.height) > 0.1;
				}
				if (opacity) {
					start.opacity = 0.1;
					end.opacity = 1;
				}
				// Draw image at start position
				$.fancybox.setTranslate(slide.$content.removeClass("fancybox-is-hidden"), start);
				forceRedraw(slide.$content);
				// Start animation
				$.fancybox.animate(slide.$content, end, duration, function() {
					self.isAnimating = false;
					self.complete();
				});
				return;
			}
			self.updateSlide(slide);
			// Simply show content if no effect
			// ================================
			if (!effect) {
				slide.$content.removeClass("fancybox-is-hidden");
				if (!isRevealed && isMoved && slide.type === "image" && !slide.hasError) {
					slide.$content.hide().fadeIn("fast");
				}
				if (slide.pos === self.currPos) {
					self.complete();
				}
				return;
			}
			// Prepare for CSS transiton
			// =========================
			$.fancybox.stop($slide);
			//effectClassName = "fancybox-animated fancybox-slide--" + (slide.pos >= self.prevPos ? "next" : "previous") + " fancybox-fx-" + effect;
			effectClassName = "fancybox-slide--" + (slide.pos >= self.prevPos ? "next" : "previous") + " fancybox-animated fancybox-fx-" + effect;
			$slide.addClass(effectClassName).removeClass("fancybox-slide--current"); //.addClass(effectClassName);
			slide.$content.removeClass("fancybox-is-hidden");
			// Force reflow
			forceRedraw($slide);
			if (slide.type !== "image") {
				slide.$content.hide().show(0);
			}
			$.fancybox.animate(
				$slide,
				"fancybox-slide--current",
				duration,
				function() {
					$slide.removeClass(effectClassName).css({
						transform: "",
						opacity: ""
					});
					if (slide.pos === self.currPos) {
						self.complete();
					}
				},
				true
			);
		},
		// Check if we can and have to zoom from thumbnail
		//================================================
		getThumbPos: function(slide) {
			var rez = false,
				$thumb = slide.$thumb,
				thumbPos,
				btw,
				brw,
				bbw,
				blw;
			if (!$thumb || !inViewport($thumb[0])) {
				return false;
			}
			thumbPos = $.fancybox.getTranslate($thumb);
			btw = parseFloat($thumb.css("border-top-width") || 0);
			brw = parseFloat($thumb.css("border-right-width") || 0);
			bbw = parseFloat($thumb.css("border-bottom-width") || 0);
			blw = parseFloat($thumb.css("border-left-width") || 0);
			rez = {
				top: thumbPos.top + btw,
				left: thumbPos.left + blw,
				width: thumbPos.width - brw - blw,
				height: thumbPos.height - btw - bbw,
				scaleX: 1,
				scaleY: 1
			};
			return thumbPos.width > 0 && thumbPos.height > 0 ? rez : false;
		},
		// Final adjustments after current gallery item is moved to position
		// and it`s content is loaded
		// ==================================================================
		complete: function() {
			var self = this,
				current = self.current,
				slides = {},
				$el;
			if (self.isMoved() || !current.isLoaded) {
				return;
			}
			if (!current.isComplete) {
				current.isComplete = true;
				current.$slide.siblings().trigger("onReset");
				self.preload("inline");
				// Trigger any CSS transiton inside the slide
				forceRedraw(current.$slide);
				current.$slide.addClass("fancybox-slide--complete");
				// Remove unnecessary slides
				$.each(self.slides, function(key, slide) {
					if (slide.pos >= self.currPos - 1 && slide.pos <= self.currPos + 1) {
						slides[slide.pos] = slide;
					} else if (slide) {
						$.fancybox.stop(slide.$slide);
						slide.$slide.off().remove();
					}
				});
				self.slides = slides;
			}
			self.isAnimating = false;
			self.updateCursor();
			self.trigger("afterShow");
			// Autoplay first html5 video/audio
			if (!!current.opts.video.autoStart) {
				current.$slide
					.find("video,audio")
					.filter(":visible:first")
					.trigger("play")
					.one("ended", function() {
						if (Document.exitFullscreen) {
							Document.exitFullscreen();
						} else if (this.webkitExitFullscreen) {
							this.webkitExitFullscreen();
						}
						self.next();
					});
			}
			// Try to focus on the first focusable element
			if (current.opts.autoFocus && current.contentType === "html") {
				// Look for the first input with autofocus attribute
				$el = current.$content.find("input[autofocus]:enabled:visible:first");
				if ($el.length) {
					$el.trigger("focus");
				} else {
					self.focus(null, true);
				}
			}
			// Avoid jumping
			current.$slide.scrollTop(0).scrollLeft(0);
		},
		// Preload next and previous slides
		// ================================
		preload: function(type) {
			var self = this,
				prev,
				next;
			if (self.group.length < 2) {
				return;
			}
			next = self.slides[self.currPos + 1];
			prev = self.slides[self.currPos - 1];
			if (prev && prev.type === type) {
				self.loadSlide(prev);
			}
			if (next && next.type === type) {
				self.loadSlide(next);
			}
		},
		// Try to find and focus on the first focusable element
		// ====================================================
		focus: function(e, firstRun) {
			var self = this,
				focusableStr = [
					"a[href]",
					"area[href]",
					'input:not([disabled]):not([type="hidden"]):not([aria-hidden])',
					"select:not([disabled]):not([aria-hidden])",
					"textarea:not([disabled]):not([aria-hidden])",
					"button:not([disabled]):not([aria-hidden])",
					"iframe",
					"object",
					"embed",
					"video",
					"audio",
					"[contenteditable]",
					'[tabindex]:not([tabindex^="-"])'
				].join(","),
				focusableItems,
				focusedItemIndex;
			if (self.isClosing) {
				return;
			}
			if (e || !self.current || !self.current.isComplete) {
				// Focus on any element inside fancybox
				focusableItems = self.$refs.container.find("*:visible");
			} else {
				// Focus inside current slide
				focusableItems = self.current.$slide.find("*:visible" + (firstRun ? ":not(.fancybox-close-small)" : ""));
			}
			focusableItems = focusableItems.filter(focusableStr).filter(function() {
				return $(this).css("visibility") !== "hidden" && !$(this).hasClass("disabled");
			});
			if (focusableItems.length) {
				focusedItemIndex = focusableItems.index(document.activeElement);
				if (e && e.shiftKey) {
					// Back tab
					if (focusedItemIndex < 0 || focusedItemIndex == 0) {
						e.preventDefault();
						focusableItems.eq(focusableItems.length - 1).trigger("focus");
					}
				} else {
					// Outside or Forward tab
					if (focusedItemIndex < 0 || focusedItemIndex == focusableItems.length - 1) {
						if (e) {
							e.preventDefault();
						}
						focusableItems.eq(0).trigger("focus");
					}
				}
			} else {
				self.$refs.container.trigger("focus");
			}
		},
		// Activates current instance - brings container to the front and enables keyboard,
		// notifies other instances about deactivating
		// =================================================================================
		activate: function() {
			var self = this;
			// Deactivate all instances
			$(".fancybox-container").each(function() {
				var instance = $(this).data("FancyBox");
				// Skip self and closing instances
				if (instance && instance.id !== self.id && !instance.isClosing) {
					instance.trigger("onDeactivate");
					instance.removeEvents();
					instance.isVisible = false;
				}
			});
			self.isVisible = true;
			if (self.current || self.isIdle) {
				self.update();
				self.updateControls();
			}
			self.trigger("onActivate");
			self.addEvents();
		},
		// Start closing procedure
		// This will start "zoom-out" animation if needed and clean everything up afterwards
		// =================================================================================
		close: function(e, d) {
			var self = this,
				current = self.current,
				effect,
				duration,
				$content,
				domRect,
				opacity,
				start,
				end;
			var done = function() {
				self.cleanUp(e);
			};
			if (self.isClosing) {
				return false;
			}
			self.isClosing = true;
			// If beforeClose callback prevents closing, make sure content is centered
			if (self.trigger("beforeClose", e) === false) {
				self.isClosing = false;
				requestAFrame(function() {
					self.update();
				});
				return false;
			}
			// Remove all events
			// If there are multiple instances, they will be set again by "activate" method
			self.removeEvents();
			$content = current.$content;
			effect = current.opts.animationEffect;
			duration = $.isNumeric(d) ? d : effect ? current.opts.animationDuration : 0;
			current.$slide.removeClass("fancybox-slide--complete fancybox-slide--next fancybox-slide--previous fancybox-animated");
			if (e !== true) {
				$.fancybox.stop(current.$slide);
			} else {
				effect = false;
			}
			// Remove other slides
			current.$slide
				.siblings()
				.trigger("onReset")
				.remove();
			// Trigger animations
			if (duration) {
				self.$refs.container
					.removeClass("fancybox-is-open")
					.addClass("fancybox-is-closing")
					.css("transition-duration", duration + "ms");
			}
			// Clean up
			self.hideLoading(current);
			self.hideControls(true);
			self.updateCursor();
			// Check if possible to zoom-out
			if (
				effect === "zoom" &&
				!($content && duration && current.type === "image" && !self.isMoved() && !current.hasError && (end = self.getThumbPos(current)))
			) {
				effect = "fade";
			}
			if (effect === "zoom") {
				$.fancybox.stop($content);
				domRect = $.fancybox.getTranslate($content);
				start = {
					top: domRect.top,
					left: domRect.left,
					scaleX: domRect.width / end.width,
					scaleY: domRect.height / end.height,
					width: end.width,
					height: end.height
				};
				// Check if we need to animate opacity
				opacity = current.opts.zoomOpacity;
				if (opacity == "auto") {
					opacity = Math.abs(current.width / current.height - end.width / end.height) > 0.1;
				}
				if (opacity) {
					end.opacity = 0;
				}
				$.fancybox.setTranslate($content, start);
				forceRedraw($content);
				$.fancybox.animate($content, end, duration, done);
				return true;
			}
			if (effect && duration) {
				$.fancybox.animate(
					current.$slide.addClass("fancybox-slide--previous").removeClass("fancybox-slide--current"),
					"fancybox-animated fancybox-fx-" + effect,
					duration,
					done
				);
			} else {
				// If skip animation
				if (e === true) {
					setTimeout(done, duration);
				} else {
					done();
				}
			}
			return true;
		},
		// Final adjustments after removing the instance
		// =============================================
		cleanUp: function(e) {
			var self = this,
				instance,
				$focus = self.current.opts.$orig,
				x,
				y;
			self.current.$slide.trigger("onReset");
			self.$refs.container.empty().remove();
			self.trigger("afterClose", e);
			// Place back focus
			if (!!self.current.opts.backFocus) {
				if (!$focus || !$focus.length || !$focus.is(":visible")) {
					$focus = self.$trigger;
				}
				if ($focus && $focus.length) {
					x = window.scrollX;
					y = window.scrollY;
					$focus.trigger("focus");
					$("html, body")
						.scrollTop(y)
						.scrollLeft(x);
				}
			}
			self.current = null;
			// Check if there are other instances
			instance = $.fancybox.getInstance();
			if (instance) {
				instance.activate();
			} else {
				$("body").removeClass("fancybox-active compensate-for-scrollbar");
				$("#fancybox-style-noscroll").remove();
			}
		},
		// Call callback and trigger an event
		// ==================================
		trigger: function(name, slide) {
			var args = Array.prototype.slice.call(arguments, 1),
				self = this,
				obj = slide && slide.opts ? slide : self.current,
				rez;
			if (obj) {
				args.unshift(obj);
			} else {
				obj = self;
			}
			args.unshift(self);
			if ($.isFunction(obj.opts[name])) {
				rez = obj.opts[name].apply(obj, args);
			}
			if (rez === false) {
				return rez;
			}
			if (name === "afterClose" || !self.$refs) {
				$D.trigger(name + ".fb", args);
			} else {
				self.$refs.container.trigger(name + ".fb", args);
			}
		},
		// Update infobar values, navigation button states and reveal caption
		// ==================================================================
		updateControls: function() {
			var self = this,
				current = self.current,
				index = current.index,
				$container = self.$refs.container,
				$caption = self.$refs.caption,
				caption = current.opts.caption;
			// Recalculate content dimensions
			current.$slide.trigger("refresh");
			// Set caption
			if (caption && caption.length) {
				self.$caption = $caption;
				$caption
					.children()
					.eq(0)
					.html(caption);
			} else {
				self.$caption = null;
			}
			if (!self.hasHiddenControls && !self.isIdle) {
				self.showControls();
			}
			// Update info and navigation elements
			$container.find("[data-fancybox-count]").html(self.group.length);
			$container.find("[data-fancybox-index]").html(index + 1);
			$container.find("[data-fancybox-prev]").prop("disabled", !current.opts.loop && index <= 0);
			$container.find("[data-fancybox-next]").prop("disabled", !current.opts.loop && index >= self.group.length - 1);
			if (current.type === "image") {
				// Re-enable buttons; update download button source
				$container
					.find("[data-fancybox-zoom]")
					.show()
					.end()
					.find("[data-fancybox-download]")
					.attr("href", current.opts.image.src || current.src)
					.show();
			} else if (current.opts.toolbar) {
				$container.find("[data-fancybox-download],[data-fancybox-zoom]").hide();
			}
			// Make sure focus is not on disabled button/element
			if ($(document.activeElement).is(":hidden,[disabled]")) {
				self.$refs.container.trigger("focus");
			}
		},
		// Hide toolbar and caption
		// ========================
		hideControls: function(andCaption) {
			var self = this,
				arr = ["infobar", "toolbar", "nav"];
			if (andCaption || !self.current.opts.preventCaptionOverlap) {
				arr.push("caption");
			}
			this.$refs.container.removeClass(
				arr
				.map(function(i) {
					return "fancybox-show-" + i;
				})
				.join(" ")
			);
			this.hasHiddenControls = true;
		},
		showControls: function() {
			var self = this,
				opts = self.current ? self.current.opts : self.opts,
				$container = self.$refs.container;
			self.hasHiddenControls = false;
			self.idleSecondsCounter = 0;
			$container
				.toggleClass("fancybox-show-toolbar", !!(opts.toolbar && opts.buttons))
				.toggleClass("fancybox-show-infobar", !!(opts.infobar && self.group.length > 1))
				.toggleClass("fancybox-show-caption", !!self.$caption)
				.toggleClass("fancybox-show-nav", !!(opts.arrows && self.group.length > 1))
				.toggleClass("fancybox-is-modal", !!opts.modal);
		},
		// Toggle toolbar and caption
		// ==========================
		toggleControls: function() {
			if (this.hasHiddenControls) {
				this.showControls();
			} else {
				this.hideControls();
			}
		}
	});
	$.fancybox = {
		version: "3.5.7",
		defaults: defaults,
		// Get current instance and execute a command.
		//
		// Examples of usage:
		//
		//   $instance = $.fancybox.getInstance();
		//   $.fancybox.getInstance().jumpTo( 1 );
		//   $.fancybox.getInstance( 'jumpTo', 1 );
		//   $.fancybox.getInstance( function() {
		//       console.info( this.currIndex );
		//   });
		// ======================================================
		getInstance: function(command) {
			var instance = $('.fancybox-container:not(".fancybox-is-closing"):last').data("FancyBox"),
				args = Array.prototype.slice.call(arguments, 1);
			if (instance instanceof FancyBox) {
				if ($.type(command) === "string") {
					instance[command].apply(instance, args);
				} else if ($.type(command) === "function") {
					command.apply(instance, args);
				}
				return instance;
			}
			return false;
		},
		// Create new instance
		// ===================
		open: function(items, opts, index) {
			return new FancyBox(items, opts, index);
		},
		// Close current or all instances
		// ==============================
		close: function(all) {
			var instance = this.getInstance();
			if (instance) {
				instance.close();
				// Try to find and close next instance
				if (all === true) {
					this.close(all);
				}
			}
		},
		// Close all instances and unbind all events
		// =========================================
		destroy: function() {
			this.close(true);
			$D.add("body").off("click.fb-start", "**");
		},
		// Try to detect mobile devices
		// ============================
		isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
		// Detect if 'translate3d' support is available
		// ============================================
		use3d: (function() {
			var div = document.createElement("div");
			return (
				window.getComputedStyle &&
				window.getComputedStyle(div) &&
				window.getComputedStyle(div).getPropertyValue("transform") &&
				!(document.documentMode && document.documentMode < 11)
			);
		})(),
		// Helper function to get current visual state of an element
		// returns array[ top, left, horizontal-scale, vertical-scale, opacity ]
		// =====================================================================
		getTranslate: function($el) {
			var domRect;
			if (!$el || !$el.length) {
				return false;
			}
			domRect = $el[0].getBoundingClientRect();
			return {
				top: domRect.top || 0,
				left: domRect.left || 0,
				width: domRect.width,
				height: domRect.height,
				opacity: parseFloat($el.css("opacity"))
			};
		},
		// Shortcut for setting "translate3d" properties for element
		// Can set be used to set opacity, too
		// ========================================================
		setTranslate: function($el, props) {
			var str = "",
				css = {};
			if (!$el || !props) {
				return;
			}
			if (props.left !== undefined || props.top !== undefined) {
				str =
					(props.left === undefined ? $el.position().left : props.left) +
					"px, " +
					(props.top === undefined ? $el.position().top : props.top) +
					"px";
				if (this.use3d) {
					str = "translate3d(" + str + ", 0px)";
				} else {
					str = "translate(" + str + ")";
				}
			}
			if (props.scaleX !== undefined && props.scaleY !== undefined) {
				str += " scale(" + props.scaleX + ", " + props.scaleY + ")";
			} else if (props.scaleX !== undefined) {
				str += " scaleX(" + props.scaleX + ")";
			}
			if (str.length) {
				css.transform = str;
			}
			if (props.opacity !== undefined) {
				css.opacity = props.opacity;
			}
			if (props.width !== undefined) {
				css.width = props.width;
			}
			if (props.height !== undefined) {
				css.height = props.height;
			}
			return $el.css(css);
		},
		// Simple CSS transition handler
		// =============================
		animate: function($el, to, duration, callback, leaveAnimationName) {
			var self = this,
				from;
			if ($.isFunction(duration)) {
				callback = duration;
				duration = null;
			}
			self.stop($el);
			from = self.getTranslate($el);
			$el.on(transitionEnd, function(e) {
				// Skip events from child elements and z-index change
				if (e && e.originalEvent && (!$el.is(e.originalEvent.target) || e.originalEvent.propertyName == "z-index")) {
					return;
				}
				self.stop($el);
				if ($.isNumeric(duration)) {
					$el.css("transition-duration", "");
				}
				if ($.isPlainObject(to)) {
					if (to.scaleX !== undefined && to.scaleY !== undefined) {
						self.setTranslate($el, {
							top: to.top,
							left: to.left,
							width: from.width * to.scaleX,
							height: from.height * to.scaleY,
							scaleX: 1,
							scaleY: 1
						});
					}
				} else if (leaveAnimationName !== true) {
					$el.removeClass(to);
				}
				if ($.isFunction(callback)) {
					callback(e);
				}
			});
			if ($.isNumeric(duration)) {
				$el.css("transition-duration", duration + "ms");
			}
			// Start animation by changing CSS properties or class name
			if ($.isPlainObject(to)) {
				if (to.scaleX !== undefined && to.scaleY !== undefined) {
					delete to.width;
					delete to.height;
					if ($el.parent().hasClass("fancybox-slide--image")) {
						$el.parent().addClass("fancybox-is-scaling");
					}
				}
				$.fancybox.setTranslate($el, to);
			} else {
				$el.addClass(to);
			}
			// Make sure that `transitionend` callback gets fired
			$el.data(
				"timer",
				setTimeout(function() {
					$el.trigger(transitionEnd);
				}, duration + 33)
			);
		},
		stop: function($el, callCallback) {
			if ($el && $el.length) {
				clearTimeout($el.data("timer"));
				if (callCallback) {
					$el.trigger(transitionEnd);
				}
				$el.off(transitionEnd).css("transition-duration", "");
				$el.parent().removeClass("fancybox-is-scaling");
			}
		}
	};
	// Default click handler for "fancyboxed" links
	// ============================================
	function _run(e, opts) {
		var items = [],
			index = 0,
			$target,
			value,
			instance;
		// Avoid opening multiple times
		if (e && e.isDefaultPrevented()) {
			return;
		}
		e.preventDefault();
		opts = opts || {};
		if (e && e.data) {
			opts = mergeOpts(e.data.options, opts);
		}
		$target = opts.$target || $(e.currentTarget).trigger("blur");
		instance = $.fancybox.getInstance();
		if (instance && instance.$trigger && instance.$trigger.is($target)) {
			return;
		}
		if (opts.selector) {
			items = $(opts.selector);
		} else {
			// Get all related items and find index for clicked one
			value = $target.attr("data-fancybox") || "";
			if (value) {
				items = e.data ? e.data.items : [];
				items = items.length ? items.filter('[data-fancybox="' + value + '"]') : $('[data-fancybox="' + value + '"]');
			} else {
				items = [$target];
			}
		}
		index = $(items).index($target);
		// Sometimes current item can not be found
		if (index < 0) {
			index = 0;
		}
		instance = $.fancybox.open(items, opts, index);
		// Save last active element
		instance.$trigger = $target;
	}
	// Create a jQuery plugin
	// ======================
	$.fn.fancybox = function(options) {
		var selector;
		options = options || {};
		selector = options.selector || false;
		if (selector) {
			// Use body element instead of document so it executes first
			$("body")
				.off("click.fb-start", selector)
				.on("click.fb-start", selector, {
					options: options
				}, _run);
		} else {
			this.off("click.fb-start").on(
				"click.fb-start", {
					items: this,
					options: options
				},
				_run
			);
		}
		return this;
	};
	// Self initializing plugin for all elements having `data-fancybox` attribute
	// ==========================================================================
	$D.on("click.fb-start", "[data-fancybox]", _run);
	// Enable "trigger elements"
	// =========================
	$D.on("click.fb-start", "[data-fancybox-trigger]", function(e) {
		$('[data-fancybox="' + $(this).attr("data-fancybox-trigger") + '"]')
			.eq($(this).attr("data-fancybox-index") || 0)
			.trigger("click.fb-start", {
				$trigger: $(this)
			});
	});
	// Track focus event for better accessibility styling
	// ==================================================
	(function() {
		var buttonStr = ".fancybox-button",
			focusStr = "fancybox-focus",
			$pressed = null;
		$D.on("mousedown mouseup focus blur", buttonStr, function(e) {
			switch (e.type) {
				case "mousedown":
					$pressed = $(this);
					break;
				case "mouseup":
					$pressed = null;
					break;
				case "focusin":
					$(buttonStr).removeClass(focusStr);
					if (!$(this).is($pressed) && !$(this).is("[disabled]")) {
						$(this).addClass(focusStr);
					}
					break;
				case "focusout":
					$(buttonStr).removeClass(focusStr);
					break;
			}
		});
	})();
})(window, document, jQuery);
// ==========================================================================
//
// Media
// Adds additional media type support
//
// ==========================================================================
(function($) {
	"use strict";
	// Object containing properties for each media type
	var defaults = {
		youtube: {
			matcher: /(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(watch\?(.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(.*)|[\w-]{11}|\?listType=(.*)&list=(.*))(.*)/i,
			params: {
				autoplay: 1,
				autohide: 1,
				fs: 1,
				rel: 0,
				hd: 1,
				wmode: "transparent",
				enablejsapi: 1,
				html5: 1
			},
			paramPlace: 8,
			type: "iframe",
			url: "https://www.youtube-nocookie.com/embed/$4",
			thumb: "https://img.youtube.com/vi/$4/hqdefault.jpg"
		},
		vimeo: {
			matcher: /^.+vimeo.com\/(.*\/)?([\d]+)(.*)?/,
			params: {
				autoplay: 1,
				hd: 1,
				show_title: 1,
				show_byline: 1,
				show_portrait: 0,
				fullscreen: 1
			},
			paramPlace: 3,
			type: "iframe",
			url: "//player.vimeo.com/video/$2"
		},
		instagram: {
			matcher: /(instagr\.am|instagram\.com)\/p\/([a-zA-Z0-9_\-]+)\/?/i,
			type: "image",
			url: "//$1/p/$2/media/?size=l"
		},
		// Examples:
		// http://maps.google.com/?ll=48.857995,2.294297&spn=0.007666,0.021136&t=m&z=16
		// https://www.google.com/maps/@37.7852006,-122.4146355,14.65z
		// https://www.google.com/maps/@52.2111123,2.9237542,6.61z?hl=en
		// https://www.google.com/maps/place/Googleplex/@37.4220041,-122.0833494,17z/data=!4m5!3m4!1s0x0:0x6c296c66619367e0!8m2!3d37.4219998!4d-122.0840572
		gmap_place: {
			matcher: /(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(((maps\/(place\/(.*)\/)?\@(.*),(\d+.?\d+?)z))|(\?ll=))(.*)?/i,
			type: "iframe",
			url: function(rez) {
				return (
					"//maps.google." +
					rez[2] +
					"/?ll=" +
					(rez[9] ? rez[9] + "&z=" + Math.floor(rez[10]) + (rez[12] ? rez[12].replace(/^\//, "&") : "") : rez[12] + "").replace(/\?/, "&") +
					"&output=" +
					(rez[12] && rez[12].indexOf("layer=c") > 0 ? "svembed" : "embed")
				);
			}
		},
		// Examples:
		// https://www.google.com/maps/search/Empire+State+Building/
		// https://www.google.com/maps/search/?api=1&query=centurylink+field
		// https://www.google.com/maps/search/?api=1&query=47.5951518,-122.3316393
		gmap_search: {
			matcher: /(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(maps\/search\/)(.*)/i,
			type: "iframe",
			url: function(rez) {
				return "//maps.google." + rez[2] + "/maps?q=" + rez[5].replace("query=", "q=").replace("api=1", "") + "&output=embed";
			}
		}
	};
	// Formats matching url to final form
	var format = function(url, rez, params) {
		if (!url) {
			return;
		}
		params = params || "";
		if ($.type(params) === "object") {
			params = $.param(params, true);
		}
		$.each(rez, function(key, value) {
			url = url.replace("$" + key, value || "");
		});
		if (params.length) {
			url += (url.indexOf("?") > 0 ? "&" : "?") + params;
		}
		return url;
	};
	$(document).on("objectNeedsType.fb", function(e, instance, item) {
		var url = item.src || "",
			type = false,
			media,
			thumb,
			rez,
			params,
			urlParams,
			paramObj,
			provider;
		media = $.extend(true, {}, defaults, item.opts.media);
		// Look for any matching media type
		$.each(media, function(providerName, providerOpts) {
			rez = url.match(providerOpts.matcher);
			if (!rez) {
				return;
			}
			type = providerOpts.type;
			provider = providerName;
			paramObj = {};
			if (providerOpts.paramPlace && rez[providerOpts.paramPlace]) {
				urlParams = rez[providerOpts.paramPlace];
				if (urlParams[0] == "?") {
					urlParams = urlParams.substring(1);
				}
				urlParams = urlParams.split("&");
				for (var m = 0; m < urlParams.length; ++m) {
					var p = urlParams[m].split("=", 2);
					if (p.length == 2) {
						paramObj[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
					}
				}
			}
			params = $.extend(true, {}, providerOpts.params, item.opts[providerName], paramObj);
			url =
				$.type(providerOpts.url) === "function" ? providerOpts.url.call(this, rez, params, item) : format(providerOpts.url, rez, params);
			thumb =
				$.type(providerOpts.thumb) === "function" ? providerOpts.thumb.call(this, rez, params, item) : format(providerOpts.thumb, rez);
			if (providerName === "youtube") {
				url = url.replace(/&t=((\d+)m)?(\d+)s/, function(match, p1, m, s) {
					return "&start=" + ((m ? parseInt(m, 10) * 60 : 0) + parseInt(s, 10));
				});
			} else if (providerName === "vimeo") {
				url = url.replace("&%23", "#");
			}
			return false;
		});
		// If it is found, then change content type and update the url
		if (type) {
			if (!item.opts.thumb && !(item.opts.$thumb && item.opts.$thumb.length)) {
				item.opts.thumb = thumb;
			}
			if (type === "iframe") {
				item.opts = $.extend(true, item.opts, {
					iframe: {
						preload: false,
						attr: {
							scrolling: "no"
						}
					}
				});
			}
			$.extend(item, {
				type: type,
				src: url,
				origSrc: item.src,
				contentSource: provider,
				contentType: type === "image" ? "image" : provider == "gmap_place" || provider == "gmap_search" ? "map" : "video"
			});
		} else if (url) {
			item.type = item.opts.defaultType;
		}
	});
	// Load YouTube/Video API on request to detect when video finished playing
	var VideoAPILoader = {
		youtube: {
			src: "https://www.youtube.com/iframe_api",
			class: "YT",
			loading: false,
			loaded: false
		},
		vimeo: {
			src: "https://player.vimeo.com/api/player.js",
			class: "Vimeo",
			loading: false,
			loaded: false
		},
		load: function(vendor) {
			var _this = this,
				script;
			if (this[vendor].loaded) {
				setTimeout(function() {
					_this.done(vendor);
				});
				return;
			}
			if (this[vendor].loading) {
				return;
			}
			this[vendor].loading = true;
			script = document.createElement("script");
			script.type = "text/javascript";
			script.src = this[vendor].src;
			if (vendor === "youtube") {
				window.onYouTubeIframeAPIReady = function() {
					_this[vendor].loaded = true;
					_this.done(vendor);
				};
			} else {
				script.onload = function() {
					_this[vendor].loaded = true;
					_this.done(vendor);
				};
			}
			document.body.appendChild(script);
		},
		done: function(vendor) {
			var instance, $el, player;
			if (vendor === "youtube") {
				delete window.onYouTubeIframeAPIReady;
			}
			instance = $.fancybox.getInstance();
			if (instance) {
				$el = instance.current.$content.find("iframe");
				if (vendor === "youtube" && YT !== undefined && YT) {
					player = new YT.Player($el.attr("id"), {
						events: {
							onStateChange: function(e) {
								if (e.data == 0) {
									instance.next();
								}
							}
						}
					});
				} else if (vendor === "vimeo" && Vimeo !== undefined && Vimeo) {
					player = new Vimeo.Player($el);
					player.on("ended", function() {
						instance.next();
					});
				}
			}
		}
	};
	$(document).on({
		"afterShow.fb": function(e, instance, current) {
			if (instance.group.length > 1 && (current.contentSource === "youtube" || current.contentSource === "vimeo")) {
				VideoAPILoader.load(current.contentSource);
			}
		}
	});
})(jQuery);
// ==========================================================================
//
// Guestures
// Adds touch guestures, handles click and tap events
//
// ==========================================================================
(function(window, document, $) {
	"use strict";
	var requestAFrame = (function() {
		return (
			window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			// if all else fails, use setTimeout
			function(callback) {
				return window.setTimeout(callback, 1000 / 60);
			}
		);
	})();
	var cancelAFrame = (function() {
		return (
			window.cancelAnimationFrame ||
			window.webkitCancelAnimationFrame ||
			window.mozCancelAnimationFrame ||
			window.oCancelAnimationFrame ||
			function(id) {
				window.clearTimeout(id);
			}
		);
	})();
	var getPointerXY = function(e) {
		var result = [];
		e = e.originalEvent || e || window.e;
		e = e.touches && e.touches.length ? e.touches : e.changedTouches && e.changedTouches.length ? e.changedTouches : [e];
		for (var key in e) {
			if (e[key].pageX) {
				result.push({
					x: e[key].pageX,
					y: e[key].pageY
				});
			} else if (e[key].clientX) {
				result.push({
					x: e[key].clientX,
					y: e[key].clientY
				});
			}
		}
		return result;
	};
	var distance = function(point2, point1, what) {
		if (!point1 || !point2) {
			return 0;
		}
		if (what === "x") {
			return point2.x - point1.x;
		} else if (what === "y") {
			return point2.y - point1.y;
		}
		return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
	};
	var isClickable = function($el) {
		if (
			$el.is('a,area,button,[role="button"],input,label,select,summary,textarea,video,audio,iframe') ||
			$.isFunction($el.get(0).onclick) ||
			$el.data("selectable")
		) {
			return true;
		}
		// Check for attributes like data-fancybox-next or data-fancybox-close
		for (var i = 0, atts = $el[0].attributes, n = atts.length; i < n; i++) {
			if (atts[i].nodeName.substr(0, 14) === "data-fancybox-") {
				return true;
			}
		}
		return false;
	};
	var hasScrollbars = function(el) {
		var overflowY = window.getComputedStyle(el)["overflow-y"],
			overflowX = window.getComputedStyle(el)["overflow-x"],
			vertical = (overflowY === "scroll" || overflowY === "auto") && el.scrollHeight > el.clientHeight,
			horizontal = (overflowX === "scroll" || overflowX === "auto") && el.scrollWidth > el.clientWidth;
		return vertical || horizontal;
	};
	var isScrollable = function($el) {
		var rez = false;
		while (true) {
			rez = hasScrollbars($el.get(0));
			if (rez) {
				break;
			}
			$el = $el.parent();
			if (!$el.length || $el.hasClass("fancybox-stage") || $el.is("body")) {
				break;
			}
		}
		return rez;
	};
	var Guestures = function(instance) {
		var self = this;
		self.instance = instance;
		self.$bg = instance.$refs.bg;
		self.$stage = instance.$refs.stage;
		self.$container = instance.$refs.container;
		self.destroy();
		self.$container.on("touchstart.fb.touch mousedown.fb.touch", $.proxy(self, "ontouchstart"));
	};
	Guestures.prototype.destroy = function() {
		var self = this;
		self.$container.off(".fb.touch");
		$(document).off(".fb.touch");
		if (self.requestId) {
			cancelAFrame(self.requestId);
			self.requestId = null;
		}
		if (self.tapped) {
			clearTimeout(self.tapped);
			self.tapped = null;
		}
	};
	Guestures.prototype.ontouchstart = function(e) {
		var self = this,
			$target = $(e.target),
			instance = self.instance,
			current = instance.current,
			$slide = current.$slide,
			$content = current.$content,
			isTouchDevice = e.type == "touchstart";
		// Do not respond to both (touch and mouse) events
		if (isTouchDevice) {
			self.$container.off("mousedown.fb.touch");
		}
		// Ignore right click
		if (e.originalEvent && e.originalEvent.button == 2) {
			return;
		}
		// Ignore taping on links, buttons, input elements
		if (!$slide.length || !$target.length || isClickable($target) || isClickable($target.parent())) {
			return;
		}
		// Ignore clicks on the scrollbar
		if (!$target.is("img") && e.originalEvent.clientX > $target[0].clientWidth + $target.offset().left) {
			return;
		}
		// Ignore clicks while zooming or closing
		if (!current || instance.isAnimating || current.$slide.hasClass("fancybox-animated")) {
			e.stopPropagation();
			e.preventDefault();
			return;
		}
		self.realPoints = self.startPoints = getPointerXY(e);
		if (!self.startPoints.length) {
			return;
		}
		// Allow other scripts to catch touch event if "touch" is set to false
		if (current.touch) {
			e.stopPropagation();
		}
		self.startEvent = e;
		self.canTap = true;
		self.$target = $target;
		self.$content = $content;
		self.opts = current.opts.touch;
		self.isPanning = false;
		self.isSwiping = false;
		self.isZooming = false;
		self.isScrolling = false;
		self.canPan = instance.canPan();
		self.startTime = new Date().getTime();
		self.distanceX = self.distanceY = self.distance = 0;
		self.canvasWidth = Math.round($slide[0].clientWidth);
		self.canvasHeight = Math.round($slide[0].clientHeight);
		self.contentLastPos = null;
		self.contentStartPos = $.fancybox.getTranslate(self.$content) || {
			top: 0,
			left: 0
		};
		self.sliderStartPos = $.fancybox.getTranslate($slide);
		// Since position will be absolute, but we need to make it relative to the stage
		self.stagePos = $.fancybox.getTranslate(instance.$refs.stage);
		self.sliderStartPos.top -= self.stagePos.top;
		self.sliderStartPos.left -= self.stagePos.left;
		self.contentStartPos.top -= self.stagePos.top;
		self.contentStartPos.left -= self.stagePos.left;
		$(document)
			.off(".fb.touch")
			.on(isTouchDevice ? "touchend.fb.touch touchcancel.fb.touch" : "mouseup.fb.touch mouseleave.fb.touch", $.proxy(self, "ontouchend"))
			.on(isTouchDevice ? "touchmove.fb.touch" : "mousemove.fb.touch", $.proxy(self, "ontouchmove"));
		if ($.fancybox.isMobile) {
			document.addEventListener("scroll", self.onscroll, true);
		}
		// Skip if clicked outside the sliding area
		if (!(self.opts || self.canPan) || !($target.is(self.$stage) || self.$stage.find($target).length)) {
			if ($target.is(".fancybox-image")) {
				e.preventDefault();
			}
			if (!($.fancybox.isMobile && $target.parents(".fancybox-caption").length)) {
				return;
			}
		}
		self.isScrollable = isScrollable($target) || isScrollable($target.parent());
		// Check if element is scrollable and try to prevent default behavior (scrolling)
		if (!($.fancybox.isMobile && self.isScrollable)) {
			e.preventDefault();
		}
		// One finger or mouse click - swipe or pan an image
		if (self.startPoints.length === 1 || current.hasError) {
			if (self.canPan) {
				$.fancybox.stop(self.$content);
				self.isPanning = true;
			} else {
				self.isSwiping = true;
			}
			self.$container.addClass("fancybox-is-grabbing");
		}
		// Two fingers - zoom image
		if (self.startPoints.length === 2 && current.type === "image" && (current.isLoaded || current.$ghost)) {
			self.canTap = false;
			self.isSwiping = false;
			self.isPanning = false;
			self.isZooming = true;
			$.fancybox.stop(self.$content);
			self.centerPointStartX = (self.startPoints[0].x + self.startPoints[1].x) * 0.5 - $(window).scrollLeft();
			self.centerPointStartY = (self.startPoints[0].y + self.startPoints[1].y) * 0.5 - $(window).scrollTop();
			self.percentageOfImageAtPinchPointX = (self.centerPointStartX - self.contentStartPos.left) / self.contentStartPos.width;
			self.percentageOfImageAtPinchPointY = (self.centerPointStartY - self.contentStartPos.top) / self.contentStartPos.height;
			self.startDistanceBetweenFingers = distance(self.startPoints[0], self.startPoints[1]);
		}
	};
	Guestures.prototype.onscroll = function(e) {
		var self = this;
		self.isScrolling = true;
		document.removeEventListener("scroll", self.onscroll, true);
	};
	Guestures.prototype.ontouchmove = function(e) {
		var self = this;
		// Make sure user has not released over iframe or disabled element
		if (e.originalEvent.buttons !== undefined && e.originalEvent.buttons === 0) {
			self.ontouchend(e);
			return;
		}
		if (self.isScrolling) {
			self.canTap = false;
			return;
		}
		self.newPoints = getPointerXY(e);
		if (!(self.opts || self.canPan) || !self.newPoints.length || !self.newPoints.length) {
			return;
		}
		if (!(self.isSwiping && self.isSwiping === true)) {
			e.preventDefault();
		}
		self.distanceX = distance(self.newPoints[0], self.startPoints[0], "x");
		self.distanceY = distance(self.newPoints[0], self.startPoints[0], "y");
		self.distance = distance(self.newPoints[0], self.startPoints[0]);
		// Skip false ontouchmove events (Chrome)
		if (self.distance > 0) {
			if (self.isSwiping) {
				self.onSwipe(e);
			} else if (self.isPanning) {
				self.onPan();
			} else if (self.isZooming) {
				self.onZoom();
			}
		}
	};
	Guestures.prototype.onSwipe = function(e) {
		var self = this,
			instance = self.instance,
			swiping = self.isSwiping,
			left = self.sliderStartPos.left || 0,
			angle;
		// If direction is not yet determined
		if (swiping === true) {
			// We need at least 10px distance to correctly calculate an angle
			if (Math.abs(self.distance) > 10) {
				self.canTap = false;
				if (instance.group.length < 2 && self.opts.vertical) {
					self.isSwiping = "y";
				} else if (instance.isDragging || self.opts.vertical === false || (self.opts.vertical === "auto" && $(window).width() > 800)) {
					self.isSwiping = "x";
				} else {
					angle = Math.abs((Math.atan2(self.distanceY, self.distanceX) * 180) / Math.PI);
					self.isSwiping = angle > 45 && angle < 135 ? "y" : "x";
				}
				if (self.isSwiping === "y" && $.fancybox.isMobile && self.isScrollable) {
					self.isScrolling = true;
					return;
				}
				instance.isDragging = self.isSwiping;
				// Reset points to avoid jumping, because we dropped first swipes to calculate the angle
				self.startPoints = self.newPoints;
				$.each(instance.slides, function(index, slide) {
					var slidePos, stagePos;
					$.fancybox.stop(slide.$slide);
					slidePos = $.fancybox.getTranslate(slide.$slide);
					stagePos = $.fancybox.getTranslate(instance.$refs.stage);
					slide.$slide
						.css({
							transform: "",
							opacity: "",
							"transition-duration": ""
						})
						.removeClass("fancybox-animated")
						.removeClass(function(index, className) {
							return (className.match(/(^|\s)fancybox-fx-\S+/g) || []).join(" ");
						});
					if (slide.pos === instance.current.pos) {
						self.sliderStartPos.top = slidePos.top - stagePos.top;
						self.sliderStartPos.left = slidePos.left - stagePos.left;
					}
					$.fancybox.setTranslate(slide.$slide, {
						top: slidePos.top - stagePos.top,
						left: slidePos.left - stagePos.left
					});
				});
				// Stop slideshow
				if (instance.SlideShow && instance.SlideShow.isActive) {
					instance.SlideShow.stop();
				}
			}
			return;
		}
		// Sticky edges
		if (swiping == "x") {
			if (
				self.distanceX > 0 &&
				(self.instance.group.length < 2 || (self.instance.current.index === 0 && !self.instance.current.opts.loop))
			) {
				left = left + Math.pow(self.distanceX, 0.8);
			} else if (
				self.distanceX < 0 &&
				(self.instance.group.length < 2 ||
					(self.instance.current.index === self.instance.group.length - 1 && !self.instance.current.opts.loop))
			) {
				left = left - Math.pow(-self.distanceX, 0.8);
			} else {
				left = left + self.distanceX;
			}
		}
		self.sliderLastPos = {
			top: swiping == "x" ? 0 : self.sliderStartPos.top + self.distanceY,
			left: left
		};
		if (self.requestId) {
			cancelAFrame(self.requestId);
			self.requestId = null;
		}
		self.requestId = requestAFrame(function() {
			if (self.sliderLastPos) {
				$.each(self.instance.slides, function(index, slide) {
					var pos = slide.pos - self.instance.currPos;
					$.fancybox.setTranslate(slide.$slide, {
						top: self.sliderLastPos.top,
						left: self.sliderLastPos.left + pos * self.canvasWidth + pos * slide.opts.gutter
					});
				});
				self.$container.addClass("fancybox-is-sliding");
			}
		});
	};
	Guestures.prototype.onPan = function() {
		var self = this;
		// Prevent accidental movement (sometimes, when tapping casually, finger can move a bit)
		if (distance(self.newPoints[0], self.realPoints[0]) < ($.fancybox.isMobile ? 10 : 5)) {
			self.startPoints = self.newPoints;
			return;
		}
		self.canTap = false;
		self.contentLastPos = self.limitMovement();
		if (self.requestId) {
			cancelAFrame(self.requestId);
		}
		self.requestId = requestAFrame(function() {
			$.fancybox.setTranslate(self.$content, self.contentLastPos);
		});
	};
	// Make panning sticky to the edges
	Guestures.prototype.limitMovement = function() {
		var self = this;
		var canvasWidth = self.canvasWidth;
		var canvasHeight = self.canvasHeight;
		var distanceX = self.distanceX;
		var distanceY = self.distanceY;
		var contentStartPos = self.contentStartPos;
		var currentOffsetX = contentStartPos.left;
		var currentOffsetY = contentStartPos.top;
		var currentWidth = contentStartPos.width;
		var currentHeight = contentStartPos.height;
		var minTranslateX, minTranslateY, maxTranslateX, maxTranslateY, newOffsetX, newOffsetY;
		if (currentWidth > canvasWidth) {
			newOffsetX = currentOffsetX + distanceX;
		} else {
			newOffsetX = currentOffsetX;
		}
		newOffsetY = currentOffsetY + distanceY;
		// Slow down proportionally to traveled distance
		minTranslateX = Math.max(0, canvasWidth * 0.5 - currentWidth * 0.5);
		minTranslateY = Math.max(0, canvasHeight * 0.5 - currentHeight * 0.5);
		maxTranslateX = Math.min(canvasWidth - currentWidth, canvasWidth * 0.5 - currentWidth * 0.5);
		maxTranslateY = Math.min(canvasHeight - currentHeight, canvasHeight * 0.5 - currentHeight * 0.5);
		//   ->
		if (distanceX > 0 && newOffsetX > minTranslateX) {
			newOffsetX = minTranslateX - 1 + Math.pow(-minTranslateX + currentOffsetX + distanceX, 0.8) || 0;
		}
		//    <-
		if (distanceX < 0 && newOffsetX < maxTranslateX) {
			newOffsetX = maxTranslateX + 1 - Math.pow(maxTranslateX - currentOffsetX - distanceX, 0.8) || 0;
		}
		//   \/
		if (distanceY > 0 && newOffsetY > minTranslateY) {
			newOffsetY = minTranslateY - 1 + Math.pow(-minTranslateY + currentOffsetY + distanceY, 0.8) || 0;
		}
		//   /\
		if (distanceY < 0 && newOffsetY < maxTranslateY) {
			newOffsetY = maxTranslateY + 1 - Math.pow(maxTranslateY - currentOffsetY - distanceY, 0.8) || 0;
		}
		return {
			top: newOffsetY,
			left: newOffsetX
		};
	};
	Guestures.prototype.limitPosition = function(newOffsetX, newOffsetY, newWidth, newHeight) {
		var self = this;
		var canvasWidth = self.canvasWidth;
		var canvasHeight = self.canvasHeight;
		if (newWidth > canvasWidth) {
			newOffsetX = newOffsetX > 0 ? 0 : newOffsetX;
			newOffsetX = newOffsetX < canvasWidth - newWidth ? canvasWidth - newWidth : newOffsetX;
		} else {
			// Center horizontally
			newOffsetX = Math.max(0, canvasWidth / 2 - newWidth / 2);
		}
		if (newHeight > canvasHeight) {
			newOffsetY = newOffsetY > 0 ? 0 : newOffsetY;
			newOffsetY = newOffsetY < canvasHeight - newHeight ? canvasHeight - newHeight : newOffsetY;
		} else {
			// Center vertically
			newOffsetY = Math.max(0, canvasHeight / 2 - newHeight / 2);
		}
		return {
			top: newOffsetY,
			left: newOffsetX
		};
	};
	Guestures.prototype.onZoom = function() {
		var self = this;
		// Calculate current distance between points to get pinch ratio and new width and height
		var contentStartPos = self.contentStartPos;
		var currentWidth = contentStartPos.width;
		var currentHeight = contentStartPos.height;
		var currentOffsetX = contentStartPos.left;
		var currentOffsetY = contentStartPos.top;
		var endDistanceBetweenFingers = distance(self.newPoints[0], self.newPoints[1]);
		var pinchRatio = endDistanceBetweenFingers / self.startDistanceBetweenFingers;
		var newWidth = Math.floor(currentWidth * pinchRatio);
		var newHeight = Math.floor(currentHeight * pinchRatio);
		// This is the translation due to pinch-zooming
		var translateFromZoomingX = (currentWidth - newWidth) * self.percentageOfImageAtPinchPointX;
		var translateFromZoomingY = (currentHeight - newHeight) * self.percentageOfImageAtPinchPointY;
		// Point between the two touches
		var centerPointEndX = (self.newPoints[0].x + self.newPoints[1].x) / 2 - $(window).scrollLeft();
		var centerPointEndY = (self.newPoints[0].y + self.newPoints[1].y) / 2 - $(window).scrollTop();
		// And this is the translation due to translation of the centerpoint
		// between the two fingers
		var translateFromTranslatingX = centerPointEndX - self.centerPointStartX;
		var translateFromTranslatingY = centerPointEndY - self.centerPointStartY;
		// The new offset is the old/current one plus the total translation
		var newOffsetX = currentOffsetX + (translateFromZoomingX + translateFromTranslatingX);
		var newOffsetY = currentOffsetY + (translateFromZoomingY + translateFromTranslatingY);
		var newPos = {
			top: newOffsetY,
			left: newOffsetX,
			scaleX: pinchRatio,
			scaleY: pinchRatio
		};
		self.canTap = false;
		self.newWidth = newWidth;
		self.newHeight = newHeight;
		self.contentLastPos = newPos;
		if (self.requestId) {
			cancelAFrame(self.requestId);
		}
		self.requestId = requestAFrame(function() {
			$.fancybox.setTranslate(self.$content, self.contentLastPos);
		});
	};
	Guestures.prototype.ontouchend = function(e) {
		var self = this;
		var swiping = self.isSwiping;
		var panning = self.isPanning;
		var zooming = self.isZooming;
		var scrolling = self.isScrolling;
		self.endPoints = getPointerXY(e);
		self.dMs = Math.max(new Date().getTime() - self.startTime, 1);
		self.$container.removeClass("fancybox-is-grabbing");
		$(document).off(".fb.touch");
		document.removeEventListener("scroll", self.onscroll, true);
		if (self.requestId) {
			cancelAFrame(self.requestId);
			self.requestId = null;
		}
		self.isSwiping = false;
		self.isPanning = false;
		self.isZooming = false;
		self.isScrolling = false;
		self.instance.isDragging = false;
		if (self.canTap) {
			return self.onTap(e);
		}
		self.speed = 100;
		// Speed in px/ms
		self.velocityX = (self.distanceX / self.dMs) * 0.5;
		self.velocityY = (self.distanceY / self.dMs) * 0.5;
		if (panning) {
			self.endPanning();
		} else if (zooming) {
			self.endZooming();
		} else {
			self.endSwiping(swiping, scrolling);
		}
		return;
	};
	Guestures.prototype.endSwiping = function(swiping, scrolling) {
		var self = this,
			ret = false,
			len = self.instance.group.length,
			distanceX = Math.abs(self.distanceX),
			canAdvance = swiping == "x" && len > 1 && ((self.dMs > 130 && distanceX > 10) || distanceX > 50),
			speedX = 300;
		self.sliderLastPos = null;
		// Close if swiped vertically / navigate if horizontally
		if (swiping == "y" && !scrolling && Math.abs(self.distanceY) > 50) {
			// Continue vertical movement
			$.fancybox.animate(
				self.instance.current.$slide, {
					top: self.sliderStartPos.top + self.distanceY + self.velocityY * 150,
					opacity: 0
				},
				200
			);
			ret = self.instance.close(true, 250);
		} else if (canAdvance && self.distanceX > 0) {
			ret = self.instance.previous(speedX);
		} else if (canAdvance && self.distanceX < 0) {
			ret = self.instance.next(speedX);
		}
		if (ret === false && (swiping == "x" || swiping == "y")) {
			self.instance.centerSlide(200);
		}
		self.$container.removeClass("fancybox-is-sliding");
	};
	// Limit panning from edges
	// ========================
	Guestures.prototype.endPanning = function() {
		var self = this,
			newOffsetX,
			newOffsetY,
			newPos;
		if (!self.contentLastPos) {
			return;
		}
		if (self.opts.momentum === false || self.dMs > 350) {
			newOffsetX = self.contentLastPos.left;
			newOffsetY = self.contentLastPos.top;
		} else {
			// Continue movement
			newOffsetX = self.contentLastPos.left + self.velocityX * 500;
			newOffsetY = self.contentLastPos.top + self.velocityY * 500;
		}
		newPos = self.limitPosition(newOffsetX, newOffsetY, self.contentStartPos.width, self.contentStartPos.height);
		newPos.width = self.contentStartPos.width;
		newPos.height = self.contentStartPos.height;
		$.fancybox.animate(self.$content, newPos, 366);
	};
	Guestures.prototype.endZooming = function() {
		var self = this;
		var current = self.instance.current;
		var newOffsetX, newOffsetY, newPos, reset;
		var newWidth = self.newWidth;
		var newHeight = self.newHeight;
		if (!self.contentLastPos) {
			return;
		}
		newOffsetX = self.contentLastPos.left;
		newOffsetY = self.contentLastPos.top;
		reset = {
			top: newOffsetY,
			left: newOffsetX,
			width: newWidth,
			height: newHeight,
			scaleX: 1,
			scaleY: 1
		};
		// Reset scalex/scaleY values; this helps for perfomance and does not break animation
		$.fancybox.setTranslate(self.$content, reset);
		if (newWidth < self.canvasWidth && newHeight < self.canvasHeight) {
			self.instance.scaleToFit(150);
		} else if (newWidth > current.width || newHeight > current.height) {
			self.instance.scaleToActual(self.centerPointStartX, self.centerPointStartY, 150);
		} else {
			newPos = self.limitPosition(newOffsetX, newOffsetY, newWidth, newHeight);
			$.fancybox.animate(self.$content, newPos, 150);
		}
	};
	Guestures.prototype.onTap = function(e) {
		var self = this;
		var $target = $(e.target);
		var instance = self.instance;
		var current = instance.current;
		var endPoints = (e && getPointerXY(e)) || self.startPoints;
		var tapX = endPoints[0] ? endPoints[0].x - $(window).scrollLeft() - self.stagePos.left : 0;
		var tapY = endPoints[0] ? endPoints[0].y - $(window).scrollTop() - self.stagePos.top : 0;
		var where;
		var process = function(prefix) {
			var action = current.opts[prefix];
			if ($.isFunction(action)) {
				action = action.apply(instance, [current, e]);
			}
			if (!action) {
				return;
			}
			switch (action) {
				case "close":
					instance.close(self.startEvent);
					break;
				case "toggleControls":
					instance.toggleControls();
					break;
				case "next":
					instance.next();
					break;
				case "nextOrClose":
					if (instance.group.length > 1) {
						instance.next();
					} else {
						instance.close(self.startEvent);
					}
					break;
				case "zoom":
					if (current.type == "image" && (current.isLoaded || current.$ghost)) {
						if (instance.canPan()) {
							instance.scaleToFit();
						} else if (instance.isScaledDown()) {
							instance.scaleToActual(tapX, tapY);
						} else if (instance.group.length < 2) {
							instance.close(self.startEvent);
						}
					}
					break;
			}
		};
		// Ignore right click
		if (e.originalEvent && e.originalEvent.button == 2) {
			return;
		}
		// Skip if clicked on the scrollbar
		if (!$target.is("img") && tapX > $target[0].clientWidth + $target.offset().left) {
			return;
		}
		// Check where is clicked
		if ($target.is(".fancybox-bg,.fancybox-inner,.fancybox-outer,.fancybox-container")) {
			where = "Outside";
		} else if ($target.is(".fancybox-slide")) {
			where = "Slide";
		} else if (
			instance.current.$content &&
			instance.current.$content
			.find($target)
			.addBack()
			.filter($target).length
		) {
			where = "Content";
		} else {
			return;
		}
		// Check if this is a double tap
		if (self.tapped) {
			// Stop previously created single tap
			clearTimeout(self.tapped);
			self.tapped = null;
			// Skip if distance between taps is too big
			if (Math.abs(tapX - self.tapX) > 50 || Math.abs(tapY - self.tapY) > 50) {
				return this;
			}
			// OK, now we assume that this is a double-tap
			process("dblclick" + where);
		} else {
			// Single tap will be processed if user has not clicked second time within 300ms
			// or there is no need to wait for double-tap
			self.tapX = tapX;
			self.tapY = tapY;
			if (current.opts["dblclick" + where] && current.opts["dblclick" + where] !== current.opts["click" + where]) {
				self.tapped = setTimeout(function() {
					self.tapped = null;
					if (!instance.isAnimating) {
						process("click" + where);
					}
				}, 500);
			} else {
				process("click" + where);
			}
		}
		return this;
	};
	$(document)
		.on("onActivate.fb", function(e, instance) {
			if (instance && !instance.Guestures) {
				instance.Guestures = new Guestures(instance);
			}
		})
		.on("beforeClose.fb", function(e, instance) {
			if (instance && instance.Guestures) {
				instance.Guestures.destroy();
			}
		});
})(window, document, jQuery);
// ==========================================================================
//
// SlideShow
// Enables slideshow functionality
//
// Example of usage:
// $.fancybox.getInstance().SlideShow.start()
//
// ==========================================================================
(function(document, $) {
	"use strict";
	$.extend(true, $.fancybox.defaults, {
		btnTpl: {
			slideShow: '<button data-fancybox-play class="fancybox-button fancybox-button--play" title="{{PLAY_START}}">' +
				'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6.5 5.4v13.2l11-6.6z"/></svg>' +
				'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.33 5.75h2.2v12.5h-2.2V5.75zm5.15 0h2.2v12.5h-2.2V5.75z"/></svg>' +
				"</button>"
		},
		slideShow: {
			autoStart: false,
			speed: 3000,
			progress: true
		}
	});
	var SlideShow = function(instance) {
		this.instance = instance;
		this.init();
	};
	$.extend(SlideShow.prototype, {
		timer: null,
		isActive: false,
		$button: null,
		init: function() {
			var self = this,
				instance = self.instance,
				opts = instance.group[instance.currIndex].opts.slideShow;
			self.$button = instance.$refs.toolbar.find("[data-fancybox-play]").on("click", function() {
				self.toggle();
			});
			if (instance.group.length < 2 || !opts) {
				self.$button.hide();
			} else if (opts.progress) {
				self.$progress = $('<div class="fancybox-progress"></div>').appendTo(instance.$refs.inner);
			}
		},
		set: function(force) {
			var self = this,
				instance = self.instance,
				current = instance.current;
			// Check if reached last element
			if (current && (force === true || current.opts.loop || instance.currIndex < instance.group.length - 1)) {
				if (self.isActive && current.contentType !== "video") {
					if (self.$progress) {
						$.fancybox.animate(self.$progress.show(), {
							scaleX: 1
						}, current.opts.slideShow.speed);
					}
					self.timer = setTimeout(function() {
						if (!instance.current.opts.loop && instance.current.index == instance.group.length - 1) {
							instance.jumpTo(0);
						} else {
							instance.next();
						}
					}, current.opts.slideShow.speed);
				}
			} else {
				self.stop();
				instance.idleSecondsCounter = 0;
				instance.showControls();
			}
		},
		clear: function() {
			var self = this;
			clearTimeout(self.timer);
			self.timer = null;
			if (self.$progress) {
				self.$progress.removeAttr("style").hide();
			}
		},
		start: function() {
			var self = this,
				current = self.instance.current;
			if (current) {
				self.$button
					.attr("title", (current.opts.i18n[current.opts.lang] || current.opts.i18n.en).PLAY_STOP)
					.removeClass("fancybox-button--play")
					.addClass("fancybox-button--pause");
				self.isActive = true;
				if (current.isComplete) {
					self.set(true);
				}
				self.instance.trigger("onSlideShowChange", true);
			}
		},
		stop: function() {
			var self = this,
				current = self.instance.current;
			self.clear();
			self.$button
				.attr("title", (current.opts.i18n[current.opts.lang] || current.opts.i18n.en).PLAY_START)
				.removeClass("fancybox-button--pause")
				.addClass("fancybox-button--play");
			self.isActive = false;
			self.instance.trigger("onSlideShowChange", false);
			if (self.$progress) {
				self.$progress.removeAttr("style").hide();
			}
		},
		toggle: function() {
			var self = this;
			if (self.isActive) {
				self.stop();
			} else {
				self.start();
			}
		}
	});
	$(document).on({
		"onInit.fb": function(e, instance) {
			if (instance && !instance.SlideShow) {
				instance.SlideShow = new SlideShow(instance);
			}
		},
		"beforeShow.fb": function(e, instance, current, firstRun) {
			var SlideShow = instance && instance.SlideShow;
			if (firstRun) {
				if (SlideShow && current.opts.slideShow.autoStart) {
					SlideShow.start();
				}
			} else if (SlideShow && SlideShow.isActive) {
				SlideShow.clear();
			}
		},
		"afterShow.fb": function(e, instance, current) {
			var SlideShow = instance && instance.SlideShow;
			if (SlideShow && SlideShow.isActive) {
				SlideShow.set();
			}
		},
		"afterKeydown.fb": function(e, instance, current, keypress, keycode) {
			var SlideShow = instance && instance.SlideShow;
			// "P" or Spacebar
			if (SlideShow && current.opts.slideShow && (keycode === 80 || keycode === 32) && !$(document.activeElement).is("button,a,input")) {
				keypress.preventDefault();
				SlideShow.toggle();
			}
		},
		"beforeClose.fb onDeactivate.fb": function(e, instance) {
			var SlideShow = instance && instance.SlideShow;
			if (SlideShow) {
				SlideShow.stop();
			}
		}
	});
	// Page Visibility API to pause slideshow when window is not active
	$(document).on("visibilitychange", function() {
		var instance = $.fancybox.getInstance(),
			SlideShow = instance && instance.SlideShow;
		if (SlideShow && SlideShow.isActive) {
			if (document.hidden) {
				SlideShow.clear();
			} else {
				SlideShow.set();
			}
		}
	});
})(document, jQuery);
// ==========================================================================
//
// FullScreen
// Adds fullscreen functionality
//
// ==========================================================================
(function(document, $) {
	"use strict";
	// Collection of methods supported by user browser
	var fn = (function() {
		var fnMap = [
			["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],
			// new WebKit
			[
				"webkitRequestFullscreen",
				"webkitExitFullscreen",
				"webkitFullscreenElement",
				"webkitFullscreenEnabled",
				"webkitfullscreenchange",
				"webkitfullscreenerror"
			],
			// old WebKit (Safari 5.1)
			[
				"webkitRequestFullScreen",
				"webkitCancelFullScreen",
				"webkitCurrentFullScreenElement",
				"webkitCancelFullScreen",
				"webkitfullscreenchange",
				"webkitfullscreenerror"
			],
			[
				"mozRequestFullScreen",
				"mozCancelFullScreen",
				"mozFullScreenElement",
				"mozFullScreenEnabled",
				"mozfullscreenchange",
				"mozfullscreenerror"
			],
			["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]
		];
		var ret = {};
		for (var i = 0; i < fnMap.length; i++) {
			var val = fnMap[i];
			if (val && val[1] in document) {
				for (var j = 0; j < val.length; j++) {
					ret[fnMap[0][j]] = val[j];
				}
				return ret;
			}
		}
		return false;
	})();
	if (fn) {
		var FullScreen = {
			request: function(elem) {
				elem = elem || document.documentElement;
				elem[fn.requestFullscreen](elem.ALLOW_KEYBOARD_INPUT);
			},
			exit: function() {
				document[fn.exitFullscreen]();
			},
			toggle: function(elem) {
				elem = elem || document.documentElement;
				if (this.isFullscreen()) {
					this.exit();
				} else {
					this.request(elem);
				}
			},
			isFullscreen: function() {
				return Boolean(document[fn.fullscreenElement]);
			},
			enabled: function() {
				return Boolean(document[fn.fullscreenEnabled]);
			}
		};
		$.extend(true, $.fancybox.defaults, {
			btnTpl: {
				fullScreen: '<button data-fancybox-fullscreen class="fancybox-button fancybox-button--fsenter" title="{{FULL_SCREEN}}">' +
					'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>' +
					'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 16h3v3h2v-5H5zm3-8H5v2h5V5H8zm6 11h2v-3h3v-2h-5zm2-11V5h-2v5h5V8z"/></svg>' +
					"</button>"
			},
			fullScreen: {
				autoStart: false
			}
		});
		$(document).on(fn.fullscreenchange, function() {
			var isFullscreen = FullScreen.isFullscreen(),
				instance = $.fancybox.getInstance();
			if (instance) {
				// If image is zooming, then force to stop and reposition properly
				if (instance.current && instance.current.type === "image" && instance.isAnimating) {
					instance.isAnimating = false;
					instance.update(true, true, 0);
					if (!instance.isComplete) {
						instance.complete();
					}
				}
				instance.trigger("onFullscreenChange", isFullscreen);
				instance.$refs.container.toggleClass("fancybox-is-fullscreen", isFullscreen);
				instance.$refs.toolbar
					.find("[data-fancybox-fullscreen]")
					.toggleClass("fancybox-button--fsenter", !isFullscreen)
					.toggleClass("fancybox-button--fsexit", isFullscreen);
			}
		});
	}
	$(document).on({
		"onInit.fb": function(e, instance) {
			var $container;
			if (!fn) {
				instance.$refs.toolbar.find("[data-fancybox-fullscreen]").remove();
				return;
			}
			if (instance && instance.group[instance.currIndex].opts.fullScreen) {
				$container = instance.$refs.container;
				$container.on("click.fb-fullscreen", "[data-fancybox-fullscreen]", function(e) {
					e.stopPropagation();
					e.preventDefault();
					FullScreen.toggle();
				});
				if (instance.opts.fullScreen && instance.opts.fullScreen.autoStart === true) {
					FullScreen.request();
				}
				// Expose API
				instance.FullScreen = FullScreen;
			} else if (instance) {
				instance.$refs.toolbar.find("[data-fancybox-fullscreen]").hide();
			}
		},
		"afterKeydown.fb": function(e, instance, current, keypress, keycode) {
			// "F"
			if (instance && instance.FullScreen && keycode === 70) {
				keypress.preventDefault();
				instance.FullScreen.toggle();
			}
		},
		"beforeClose.fb": function(e, instance) {
			if (instance && instance.FullScreen && instance.$refs.container.hasClass("fancybox-is-fullscreen")) {
				FullScreen.exit();
			}
		}
	});
})(document, jQuery);
// ==========================================================================
//
// Thumbs
// Displays thumbnails in a grid
//
// ==========================================================================
(function(document, $) {
	"use strict";
	var CLASS = "fancybox-thumbs",
		CLASS_ACTIVE = CLASS + "-active";
	// Make sure there are default values
	$.fancybox.defaults = $.extend(
		true, {
			btnTpl: {
				thumbs: '<button data-fancybox-thumbs class="fancybox-button fancybox-button--thumbs" title="{{THUMBS}}">' +
					'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.59 14.59h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76H5.65V5.65z"/></svg>' +
					"</button>"
			},
			thumbs: {
				autoStart: false, // Display thumbnails on opening
				hideOnClose: true, // Hide thumbnail grid when closing animation starts
				parentEl: ".fancybox-container", // Container is injected into this element
				axis: "y" // Vertical (y) or horizontal (x) scrolling
			}
		},
		$.fancybox.defaults
	);
	var FancyThumbs = function(instance) {
		this.init(instance);
	};
	$.extend(FancyThumbs.prototype, {
		$button: null,
		$grid: null,
		$list: null,
		isVisible: false,
		isActive: false,
		init: function(instance) {
			var self = this,
				group = instance.group,
				enabled = 0;
			self.instance = instance;
			self.opts = group[instance.currIndex].opts.thumbs;
			instance.Thumbs = self;
			self.$button = instance.$refs.toolbar.find("[data-fancybox-thumbs]");
			// Enable thumbs if at least two group items have thumbnails
			for (var i = 0, len = group.length; i < len; i++) {
				if (group[i].thumb) {
					enabled++;
				}
				if (enabled > 1) {
					break;
				}
			}
			if (enabled > 1 && !!self.opts) {
				self.$button.removeAttr("style").on("click", function() {
					self.toggle();
				});
				self.isActive = true;
			} else {
				self.$button.hide();
			}
		},
		create: function() {
			var self = this,
				instance = self.instance,
				parentEl = self.opts.parentEl,
				list = [],
				src;
			if (!self.$grid) {
				// Create main element
				self.$grid = $('<div class="' + CLASS + " " + CLASS + "-" + self.opts.axis + '"></div>').appendTo(
					instance.$refs.container
					.find(parentEl)
					.addBack()
					.filter(parentEl)
				);
				// Add "click" event that performs gallery navigation
				self.$grid.on("click", "a", function() {
					instance.jumpTo($(this).attr("data-index"));
				});
			}
			// Build the list
			if (!self.$list) {
				self.$list = $('<div class="' + CLASS + '__list">').appendTo(self.$grid);
			}
			$.each(instance.group, function(i, item) {
				src = item.thumb;
				if (!src && item.type === "image") {
					src = item.src;
				}
				list.push(
					'<a href="javascript:;" tabindex="0" data-index="' +
					i +
					'"' +
					(src && src.length ? ' style="background-image:url(' + src + ')"' : 'class="fancybox-thumbs-missing"') +
					"></a>"
				);
			});
			self.$list[0].innerHTML = list.join("");
			if (self.opts.axis === "x") {
				// Set fixed width for list element to enable horizontal scrolling
				self.$list.width(
					parseInt(self.$grid.css("padding-right"), 10) +
					instance.group.length *
					self.$list
					.children()
					.eq(0)
					.outerWidth(true)
				);
			}
		},
		focus: function(duration) {
			var self = this,
				$list = self.$list,
				$grid = self.$grid,
				thumb,
				thumbPos;
			if (!self.instance.current) {
				return;
			}
			thumb = $list
				.children()
				.removeClass(CLASS_ACTIVE)
				.filter('[data-index="' + self.instance.current.index + '"]')
				.addClass(CLASS_ACTIVE);
			thumbPos = thumb.position();
			// Check if need to scroll to make current thumb visible
			if (self.opts.axis === "y" && (thumbPos.top < 0 || thumbPos.top > $list.height() - thumb.outerHeight())) {
				$list.stop().animate({
						scrollTop: $list.scrollTop() + thumbPos.top
					},
					duration
				);
			} else if (
				self.opts.axis === "x" &&
				(thumbPos.left < $grid.scrollLeft() || thumbPos.left > $grid.scrollLeft() + ($grid.width() - thumb.outerWidth()))
			) {
				$list
					.parent()
					.stop()
					.animate({
							scrollLeft: thumbPos.left
						},
						duration
					);
			}
		},
		update: function() {
			var that = this;
			that.instance.$refs.container.toggleClass("fancybox-show-thumbs", this.isVisible);
			if (that.isVisible) {
				if (!that.$grid) {
					that.create();
				}
				that.instance.trigger("onThumbsShow");
				that.focus(0);
			} else if (that.$grid) {
				that.instance.trigger("onThumbsHide");
			}
			// Update content position
			that.instance.update();
		},
		hide: function() {
			this.isVisible = false;
			this.update();
		},
		show: function() {
			this.isVisible = true;
			this.update();
		},
		toggle: function() {
			this.isVisible = !this.isVisible;
			this.update();
		}
	});
	$(document).on({
		"onInit.fb": function(e, instance) {
			var Thumbs;
			if (instance && !instance.Thumbs) {
				Thumbs = new FancyThumbs(instance);
				if (Thumbs.isActive && Thumbs.opts.autoStart === true) {
					Thumbs.show();
				}
			}
		},
		"beforeShow.fb": function(e, instance, item, firstRun) {
			var Thumbs = instance && instance.Thumbs;
			if (Thumbs && Thumbs.isVisible) {
				Thumbs.focus(firstRun ? 0 : 250);
			}
		},
		"afterKeydown.fb": function(e, instance, current, keypress, keycode) {
			var Thumbs = instance && instance.Thumbs;
			// "G"
			if (Thumbs && Thumbs.isActive && keycode === 71) {
				keypress.preventDefault();
				Thumbs.toggle();
			}
		},
		"beforeClose.fb": function(e, instance) {
			var Thumbs = instance && instance.Thumbs;
			if (Thumbs && Thumbs.isVisible && Thumbs.opts.hideOnClose !== false) {
				Thumbs.$grid.hide();
			}
		}
	});
})(document, jQuery);
//// ==========================================================================
//
// Share
// Displays simple form for sharing current url
//
// ==========================================================================
(function(document, $) {
	"use strict";
	$.extend(true, $.fancybox.defaults, {
		btnTpl: {
			share: '<button data-fancybox-share class="fancybox-button fancybox-button--share" title="{{SHARE}}">' +
				'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M2.55 19c1.4-8.4 9.1-9.8 11.9-9.8V5l7 7-7 6.3v-3.5c-2.8 0-10.5 2.1-11.9 4.2z"/></svg>' +
				"</button>"
		},
		share: {
			url: function(instance, item) {
				return (
					(!instance.currentHash && !(item.type === "inline" || item.type === "html") ? item.origSrc || item.src : false) || window.location
				);
			},
			tpl: '<div class="fancybox-share">' +
				"<h1>{{SHARE}}</h1>" +
				"<p>" +
				'<a class="fancybox-share__button fancybox-share__button--fb" href="https://www.facebook.com/sharer/sharer.php?u={{url}}">' +
				'<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m287 456v-299c0-21 6-35 35-35h38v-63c-7-1-29-3-55-3-54 0-91 33-91 94v306m143-254h-205v72h196" /></svg>' +
				"<span>Facebook</span>" +
				"</a>" +
				'<a class="fancybox-share__button fancybox-share__button--tw" href="https://twitter.com/intent/tweet?url={{url}}&text={{descr}}">' +
				'<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m456 133c-14 7-31 11-47 13 17-10 30-27 37-46-15 10-34 16-52 20-61-62-157-7-141 75-68-3-129-35-169-85-22 37-11 86 26 109-13 0-26-4-37-9 0 39 28 72 65 80-12 3-25 4-37 2 10 33 41 57 77 57-42 30-77 38-122 34 170 111 378-32 359-208 16-11 30-25 41-42z" /></svg>' +
				"<span>Twitter</span>" +
				"</a>" +
				'<a class="fancybox-share__button fancybox-share__button--pt" href="https://www.pinterest.com/pin/create/button/?url={{url}}&description={{descr}}&media={{media}}">' +
				'<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m265 56c-109 0-164 78-164 144 0 39 15 74 47 87 5 2 10 0 12-5l4-19c2-6 1-8-3-13-9-11-15-25-15-45 0-58 43-110 113-110 62 0 96 38 96 88 0 67-30 122-73 122-24 0-42-19-36-44 6-29 20-60 20-81 0-19-10-35-31-35-25 0-44 26-44 60 0 21 7 36 7 36l-30 125c-8 37-1 83 0 87 0 3 4 4 5 2 2-3 32-39 42-75l16-64c8 16 31 29 56 29 74 0 124-67 124-157 0-69-58-132-146-132z" fill="#fff"/></svg>' +
				"<span>Pinterest</span>" +
				"</a>" +
				"</p>" +
				'<p><input class="fancybox-share__input" type="text" value="{{url_raw}}" onclick="select()" /></p>' +
				"</div>"
		}
	});

	function escapeHtml(string) {
		var entityMap = {
			"&": "&amp;",
			"<": "&lt;",
			">": "&gt;",
			'"': "&quot;",
			"'": "&#39;",
			"/": "&#x2F;",
			"`": "&#x60;",
			"=": "&#x3D;"
		};
		return String(string).replace(/[&<>"'`=\/]/g, function(s) {
			return entityMap[s];
		});
	}
	$(document).on("click", "[data-fancybox-share]", function() {
		var instance = $.fancybox.getInstance(),
			current = instance.current || null,
			url,
			tpl;
		if (!current) {
			return;
		}
		if ($.type(current.opts.share.url) === "function") {
			url = current.opts.share.url.apply(current, [instance, current]);
		}
		tpl = current.opts.share.tpl
			.replace(/\{\{media\}\}/g, current.type === "image" ? encodeURIComponent(current.src) : "")
			.replace(/\{\{url\}\}/g, encodeURIComponent(url))
			.replace(/\{\{url_raw\}\}/g, escapeHtml(url))
			.replace(/\{\{descr\}\}/g, instance.$caption ? encodeURIComponent(instance.$caption.text()) : "");
		$.fancybox.open({
			src: instance.translate(instance, tpl),
			type: "html",
			opts: {
				touch: false,
				animationEffect: false,
				afterLoad: function(shareInstance, shareCurrent) {
					// Close self if parent instance is closing
					instance.$refs.container.one("beforeClose.fb", function() {
						shareInstance.close(null, 0);
					});
					// Opening links in a popup window
					shareCurrent.$content.find(".fancybox-share__button").click(function() {
						window.open(this.href, "Share", "width=550, height=450");
						return false;
					});
				},
				mobile: {
					autoFocus: false
				}
			}
		});
	});
})(document, jQuery);
// ==========================================================================
//
// Hash
// Enables linking to each modal
//
// ==========================================================================
(function(window, document, $) {
	"use strict";
	// Simple $.escapeSelector polyfill (for jQuery prior v3)
	if (!$.escapeSelector) {
		$.escapeSelector = function(sel) {
			var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
			var fcssescape = function(ch, asCodePoint) {
				if (asCodePoint) {
					// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
					if (ch === "\0") {
						return "\uFFFD";
					}
					// Control characters and (dependent upon position) numbers get escaped as code points
					return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
				}
				// Other potentially-special ASCII characters get backslash-escaped
				return "\\" + ch;
			};
			return (sel + "").replace(rcssescape, fcssescape);
		};
	}
	// Get info about gallery name and current index from url
	function parseUrl() {
		var hash = window.location.hash.substr(1),
			rez = hash.split("-"),
			index = rez.length > 1 && /^\+?\d+$/.test(rez[rez.length - 1]) ? parseInt(rez.pop(-1), 10) || 1 : 1,
			gallery = rez.join("-");
		return {
			hash: hash,
			/* Index is starting from 1 */
			index: index < 1 ? 1 : index,
			gallery: gallery
		};
	}
	// Trigger click evnt on links to open new fancyBox instance
	function triggerFromUrl(url) {
		if (url.gallery !== "") {
			// If we can find element matching 'data-fancybox' atribute,
			// then triggering click event should start fancyBox
			$("[data-fancybox='" + $.escapeSelector(url.gallery) + "']")
				.eq(url.index - 1)
				.focus()
				.trigger("click.fb-start");
		}
	}
	// Get gallery name from current instance
	function getGalleryID(instance) {
		var opts, ret;
		if (!instance) {
			return false;
		}
		opts = instance.current ? instance.current.opts : instance.opts;
		ret = opts.hash || (opts.$orig ? opts.$orig.data("fancybox") || opts.$orig.data("fancybox-trigger") : "");
		return ret === "" ? false : ret;
	}
	// Start when DOM becomes ready
	$(function() {
		// Check if user has disabled this module
		if ($.fancybox.defaults.hash === false) {
			return;
		}
		// Update hash when opening/closing fancyBox
		$(document).on({
			"onInit.fb": function(e, instance) {
				var url, gallery;
				if (instance.group[instance.currIndex].opts.hash === false) {
					return;
				}
				url = parseUrl();
				gallery = getGalleryID(instance);
				// Make sure gallery start index matches index from hash
				if (gallery && url.gallery && gallery == url.gallery) {
					instance.currIndex = url.index - 1;
				}
			},
			"beforeShow.fb": function(e, instance, current, firstRun) {
				var gallery;
				if (!current || current.opts.hash === false) {
					return;
				}
				// Check if need to update window hash
				gallery = getGalleryID(instance);
				if (!gallery) {
					return;
				}
				// Variable containing last hash value set by fancyBox
				// It will be used to determine if fancyBox needs to close after hash change is detected
				instance.currentHash = gallery + (instance.group.length > 1 ? "-" + (current.index + 1) : "");
				// If current hash is the same (this instance most likely is opened by hashchange), then do nothing
				if (window.location.hash === "#" + instance.currentHash) {
					return;
				}
				if (firstRun && !instance.origHash) {
					instance.origHash = window.location.hash;
				}
				if (instance.hashTimer) {
					clearTimeout(instance.hashTimer);
				}
				// Update hash
				instance.hashTimer = setTimeout(function() {
					if ("replaceState" in window.history) {
						window.history[firstRun ? "pushState" : "replaceState"]({},
							document.title,
							window.location.pathname + window.location.search + "#" + instance.currentHash
						);
						if (firstRun) {
							instance.hasCreatedHistory = true;
						}
					} else {
						window.location.hash = instance.currentHash;
					}
					instance.hashTimer = null;
				}, 300);
			},
			"beforeClose.fb": function(e, instance, current) {
				if (!current || current.opts.hash === false) {
					return;
				}
				clearTimeout(instance.hashTimer);
				// Goto previous history entry
				if (instance.currentHash && instance.hasCreatedHistory) {
					window.history.back();
				} else if (instance.currentHash) {
					if ("replaceState" in window.history) {
						window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (instance.origHash || ""));
					} else {
						window.location.hash = instance.origHash;
					}
				}
				instance.currentHash = null;
			}
		});
		// Check if need to start/close after url has changed
		$(window).on("hashchange.fb", function() {
			var url = parseUrl(),
				fb = null;
			// Find last fancyBox instance that has "hash"
			$.each(
				$(".fancybox-container")
				.get()
				.reverse(),
				function(index, value) {
					var tmp = $(value).data("FancyBox");
					if (tmp && tmp.currentHash) {
						fb = tmp;
						return false;
					}
				}
			);
			if (fb) {
				// Now, compare hash values
				if (fb.currentHash !== url.gallery + "-" + url.index && !(url.index === 1 && fb.currentHash == url.gallery)) {
					fb.currentHash = null;
					fb.close();
				}
			} else if (url.gallery !== "") {
				triggerFromUrl(url);
			}
		});
		// Check current hash and trigger click event on matching element to start fancyBox, if needed
		setTimeout(function() {
			if (!$.fancybox.getInstance()) {
				triggerFromUrl(parseUrl());
			}
		}, 50);
	});
})(window, document, jQuery);
// ==========================================================================
//
// Wheel
// Basic mouse weheel support for gallery navigation
//
// ==========================================================================
(function(document, $) {
	"use strict";
	var prevTime = new Date().getTime();
	$(document).on({
		"onInit.fb": function(e, instance, current) {
			instance.$refs.stage.on("mousewheel DOMMouseScroll wheel MozMousePixelScroll", function(e) {
				var current = instance.current,
					currTime = new Date().getTime();
				if (instance.group.length < 2 || current.opts.wheel === false || (current.opts.wheel === "auto" && current.type !== "image")) {
					return;
				}
				e.preventDefault();
				e.stopPropagation();
				if (current.$slide.hasClass("fancybox-animated")) {
					return;
				}
				e = e.originalEvent || e;
				if (currTime - prevTime < 250) {
					return;
				}
				prevTime = currTime;
				instance[(-e.deltaY || -e.deltaX || e.wheelDelta || -e.detail) < 0 ? "next" : "previous"]();
			});
		}
	});
})(document, jQuery);
/*
 * Cheg UI 3.0.0
 */
const app = {
	settings: {
		winWidth: 0,
		winHeight: 0,
		sbWidth: 0,
		scrollOffset: function() {
			return $('.header').outerHeight();
		},
		scrollPos: 0,
		popupOpened: false,
		scrollLockPos: 0,
		animDuration: 400,
		pageLoaded: false,
		formTitle: '',
		menuOpened: false,
	},
	deviceIs: device.device,
	/*
	 * Checking if matches media query
	 */
	matches(query) {
		return window.matchMedia(`(${query})`).matches
	},
	/*
	 * Scroll to hash on page laod
	 */
	toHash() {
		if (window.location.hash) {
			app.scrollTo(window.location.hash, app.settings.scrollOffset);
		}
	},
	/*
	 * Menu
	 */
	menu: {
		bind() {
			// * Click on burger
			$(document).on('click', '.menu-toggle', function() {
				!app.settings.menuOpened ? app.menu.open() : app.menu.close();
			});
			/*let left = $('.header .ui-sidemenu__link--a');

			left.on('mouseenter', function() {
				if (app.matches('min-width:1101px')) {
					left.removeClass('hover');
					$(this).addClass('hover');
					
					let id = $(this).closest('.ui-sidemenu__item').attr('data-menu');

					$('.header__menu-item').removeClass('active');
					$('.header__menu-item[data-menu="'+id+'"]').addClass('active');
				}
			});

			let current;

			if ($('.header__main-left .ui-sidemenu__link.current').length) {
				current = $('.header__main-left .ui-sidemenu__link--a.current').first();
			} else {
				current = $('.header__main-left .ui-sidemenu__link--a').first();
			}*/
			let left = $('.header .ui-sidemenu__link');
			left.on('mouseenter', function() {
				if (app.matches('min-width:1101px')) {
					let id = $(this).closest('.ui-sidemenu__item').attr('data-menu');
					$('.header__menu-item').removeClass('active');
					$('.header__menu-item[data-menu="' + id + '"]').addClass('active');
				}
			});
			let current;
			if ($('.header__main-left .ui-sidemenu__link.current').length) {
				current = $('.header__main-left .ui-sidemenu__link.current').first();
			} else {
				current = $('.header__main-left .ui-sidemenu__link').first();
			}
			current.trigger('mouseenter');
			$('.header .ui-sidemenu').on('mouseleave', function() {
				//current.trigger('mouseenter');
			});
			$(document).on('click', '.header__menu-arr', function() {
				let item = $(this).closest('.header__menu-item'),
					sub = item.find('.header__menu-sublist');
				if (!item.hasClass('opened')) {
					item.addClass('opened');
					sub.slideDown(400);
				} else {
					item.removeClass('opened');
					sub.slideUp(400);
				}
			});
		},
		// * Open menu
		open() {
			$('.app').addClass('app--menu-opened');
			app.scrollLock();
			app.settings.menuOpened = true;
		},
		// * Close menu
		close() {
			$('.app').removeClass('app--menu-opened');
			app.scrollLock('unlock');
			app.settings.menuOpened = false;
		}
	},
	/*
	 * Animate on scroll
	 */
	onscroll(block) {
		new IntersectionObserver(([el]) => {
			if (el.isIntersecting && !$(el).hasClass('onscroll--in') && app.settings.pageLoaded) {
				setTimeout(function() {
					$(el.target).addClass('onscroll--in');
				}, 300);
				return;
			}
		}, {
			root: document,
			rootMargin: '0px 0px',
			threshold: 0,
		}).observe(block.get(0));
		block.data('onscrollInit', true);
	},
	/*
	 * Scroll
	 */
	scroll: {
		lenis: {},
		inited: false,
		init() {
			let _this = this;
			//gsap.registerPlugin(ScrollTrigger);
			_this.lenis = new Lenis({
				lerp: 0.04
			});
			_this.lenis.on('scroll', (e) => {
				//ScrollTrigger.update();
			});

			function raf(time) {
				_this.lenis.raf(time)
				requestAnimationFrame(raf);
			}
			requestAnimationFrame(raf)
			/*;gsap.ticker.add((time)=>{
				_this.lenis.raf(time * 1000);
			});*/
			_this.inited = true;
		},
	},
	/*
	 * Intro
	 */
	intro(block) {
		let slider = block.find('.intro__slider'),
			sliderS,
			opts = {
				slidesPerView: 1,
				spaceBetween: 0,
				speed: 1000,
				autoplay: {
					delay: 5000,
					disableOnInteraction: false
				},
				loop: true,
				loopedSlides: 1,
				preloadImages: false,
				lazy: {
					checkInView: true,
					loadOnTransitionStart: true,
					loadPrevNext: true,
				},
				watchSlidesProgress: true,
				grabCursor: true,
				init: true,
				pagination: {
					el: block.find('.intro__pages-list').get(0),
					clickable: true,
					bulletActiveClass: 'active',
					renderBullet: function(i, className) {
						return '<button class="intro__pages-item ' + className + '" type="button"></button>';
					}
				}
			};
		sliderS = new Swiper(slider.get(0), opts);
		block.data('introInit', true);
	},
	/*
	 * Sticky sidebar
	 */
	stickySide(block) {
		let sticky = block.find('.ui-layout__side-in');
		$(window).on('resize', function() {
			let stickyHeight = sticky.outerHeight() + 40 + app.settings.scrollOffset();
			if (stickyHeight >= app.settings.winHeight) {
				sticky.addClass('static');
			} else {
				sticky.removeClass('static');
			}
		});
		block.data('stickySideInit', true);
	},
	/*
	 * Masonry fix
	 */
	masonry() {
		$('.ui-masonry__grid').each(function() {
			let block = $(this),
				items = block.find('.ui-masonry__col').length;
			if (items % 2 > 0) {
				block.addClass('fix');
			}
		});
	},
	/*
	 * Distortion
	 */
	distor(block) {
		let opts = JSON.parse(block.attr('data-distor')),
			hover = new hoverEffect({
				parent: block.get(0),
				trigger: block.closest('.distortion-c').get(0),
				intensity: opts.intensity || .3,
				speedIn: opts.speedIn || .7,
				speedOut: opts.speedOut || .7,
				image1: opts.img1,
				image2: opts.img2,
				displacementImage: opts.effect,
				imagesRatio: opts.ratioH / opts.ratioW
			});
		block.removeAttr('data-distor');
		block.data('distorInit', true);
	},
	/*
	 * Info block
	 */
	info(block, i) {
		let items = block.find('.ui-info__imgs-item');
		items.each(function() {
			if ($(this).is('a')) {
				$(this).attr('data-fancybox', `gallery-${i}`);
			}
		});
		if (items.length > 1) {
			items.addClass('swiper-slide')
			items.wrapAll('<div class="swiper-wrapper" />');
			block.find('.ui-info__imgs').append('<div class="ui-info__imgs-dots ui-dots" />');
			let slider = block.find('.ui-info__imgs-list'),
				sliderS,
				opts = {
					slidesPerView: 1,
					spaceBetween: 0,
					speed: 500,
					autoplay: {
						delay: 4000,
						disableOnInteraction: false
					},
					loop: true,
					loopedSlides: 1,
					preloadImages: false,
					lazy: {
						checkInView: true,
						loadOnTransitionStart: true,
						loadPrevNext: true,
					},
					watchSlidesProgress: true,
					grabCursor: true,
					init: true,
					pagination: {
						el: block.find('.ui-dots').get(0),
						clickable: true,
						bulletActiveClass: 'active',
						renderBullet: function(i, className) {
							return '<button class="ui-dots__item ' + className + '" type="button"></button>';
						}
					}
				};
			sliderS = new Swiper(slider.get(0), opts);
		} else {
			items.each(function() {
				let img = $(this).find('img'),
					src = img.attr('data-src');
				img
					.removeClass('swiper-lazy')
					.attr('src', src)
					.removeAttr('data-src');
			});
		}
		block.data('infoInit', true);
	},
	/*
	 * Related
	 */
	related(block) {
		let slider = block.find('.related__slider'),
			sliderS,
			opts = {
				slidesPerView: 'auto',
				spaceBetween: 40,
				speed: 500,
				/*autoplay: {
					delay:4000,
					disableOnInteraction: false
				},*/
				loop: false,
				preloadImages: false,
				lazy: {
					checkInView: true,
					loadOnTransitionStart: true,
					loadPrevNext: true,
				},
				watchSlidesProgress: true,
				grabCursor: true,
				init: true,
				navigation: {
					nextEl: block.find('.ui-arrow--n').get(0),
					prevEl: block.find('.ui-arrow--p').get(0),
				},
				breakpoints: {
					1: {
						spaceBetween: 20,
					},
					1001: {
						spaceBetween: 40,
					}
				}
			};
		sliderS = new Swiper(slider.get(0), opts);
		block.data('relatedInit', true);
	},
	/*
	 * Input masks
	 */
	mask: {
		phone(inp) {
			inp.mask('+7 (000) 000 00 00', {
				placeholder: '+7 (---) --- -- --'
			});
			inp.data('maskInit', true);
		}
	},
};
/*
	
 * Units
	
*/
app.units = {
	vh() {
		$('body').append('<div class="vh-fix" style="position:fixed;width:1px;left:-9999px;top:0;bottom:0;pointer-events:none;opacity:0;visibility:hidden;" />');
		let vh = $('.vh-fix').height() * 0.01;
		$('html').css('--vh', vh + 'px');
		$('.vh-fix').remove();
	},
	contW() {
		let contW = $('.container').not('.container--off').first().width();
		$('html').css('--cont-w-a', contW + 'px');
		$('.container--off').each(function() {
			let w = $(this).width();
			$(this).css('--cont-w-a', w + 'px');
		});
	},
	contOff() {
		let contOff = ($(window).width() - $('.container').not('.container--off').first().width()) / 2;
		$('html').css('--cont-off', contOff + 'px');
		$('.container--off').each(function() {
			let off = ($(window).width() - $(this).width()) / 2;
			$(this).css('--cont-off', off + 'px');
		});
	},
	sb() {
		let div = $('<div style="width:50px;height:50px;overflow:hidden;position:absolute;top:-200px;left:-200px;"><div style="height:100px;"></div>');
		$('.app').append(div);
		let w1 = $('div', div).innerWidth();
		div.css('overflow-y', 'scroll');
		let w2 = $('div', div).innerWidth();
		$(div).remove();
		let bodyHeight = parseInt($('.app').height());
		if (bodyHeight > app.settings.winHeight) {
			app.settings.sbWidth = w1 - w2;
		} else {
			app.settings.sbWidth = 0;
		}
		$('html').css('--sbW', app.settings.sbWidth + 'px');
	},
	all() {
		this.vh();
		this.mobile();
	},
	mobile() {
		this.contW();
		this.contOff();
		this.sb();
	}
}
/*

 * Scroll to element

*/
app.scrollTo = (id, offs, speed) => {
	if ($(id).length) {
		let scrollOffset = offs || 0,
			scrollPos = $(id).offset().top - scrollOffset,
			sp = speed || 500;
		$('html, body').animate({
			scrollTop: scrollPos
		}, sp);
	}
}
/*

 * Tabs

*/
app.tabs = {
	init(tabs) {
		let pref = '.ui-tabs',
			itemSel = pref + '__item',
			btnSel = pref + '__btn',
			items = tabs.find(itemSel),
			btns = tabs.find(btnSel),
			id = tabs.attr('data-tabs'),
			active = '';
		if (!tabs.find(itemSel + '.active').length || tabs.find(itemSel + '.active').length > 1) {
			items.removeClass('active');
			items.first().addClass('active');
		}
		btns.on('click', function() {
			let btn = $(this),
				item = btn.closest(itemSel);
			let tabId = btn.attr('data-tab');
			items
				.removeClass('active');
			$(pref + '-trigger[data-tabs=' + id + '],' + pref + '-content[data-tabs="' + id + '"]')
				.removeClass('active');
			item.addClass('active');
			$(pref + '-trigger[data-tabs=' + id + '][data-tab=' + tabId + '],' + pref + '-content[data-tab="' + tabId + '"]')
				.addClass('active');
			active = tabId;
		});
		tabs.find(itemSel + '.active').find(btnSel).trigger('click');
		tabs.data('tabsInit', true);
	},
	bind() {
		$(document).on('click', '.ui-tabs-trigger', function() {
			$('.ui-tabs[data-tabs=' + $(this).attr('data-tabs') + ']')
				.find('.ui-tabs__btn[data-tab=' + $(this).attr('data-tab') + ']')
				.trigger('click');
			if (app.scroll.inited) {
				app.scroll.lenis.scrollTo('.subs__trigger[data-tab=' + $(this).attr('data-tab') + ']', {
					offset: 70
				});
			} else {
				app.scrollto('[data-tab=' + $(this).attr('data-tab') + ']');
			}
		});
	}
}
/*
 * Expandable blocks
 */
app.expand = (ex) => {
	let pref = 'ui-expand',
		hidd = ex.find('.' + pref + '__hidden'),
		trig = ex.find('.' + pref + '__trigger'),
		trigText = trig.find('.' + pref + '__trigger-text'),
		closedText = trig.attr('data-closed-text'),
		openedText = trig.attr('data-opened-text');
	trigText.text(closedText);
	trig.on('click', function() {
		if (!ex.hasClass('active')) {
			ex.addClass('active');
			hidd.slideDown(400);
			trigText.text(openedText);
		} else {
			ex.removeClass('active');
			hidd.slideUp(400);
			trigText.text(closedText);
		}
	});
	ex.data('expandInit', true);
}
/*

 * Scroll lock

*/
app.scrollLock = (type) => {
	if (type == 'unlock') { // * unlock
		app.deviceIs.ios ? $(window).scrollTop(app.settings.scrollLockPos) : null;
		$('.app').removeClass('app--fixed');
		if (app.scroll.inited) {
			app.scroll.lenis.start();
		}
	} else { // * lock
		app.settings.scrollLockPos = $(window).scrollTop();
		$('.app').addClass('app--fixed');
		if (app.scroll.inited) {
			app.scroll.lenis.stop();
		}
	}
}
/*
 * Popups
 */
app.popups = {
	loaded: [],
	overlay: $('.popups-overlay'),
	bind() {
		let _this = this;
		// * Open popup
		$(document).on('click', '[data-popup]', function() {
			let id = $(this).attr('data-popup');
			if (!$(this).attr('data-popup-video')) {
				_this.open(id, {
					form: $(this).attr('data-popup-form') || '',
					ttl: $(this).attr('data-popup-header') || '',
					text: $(this).attr('data-popup-text') || '',
					btn: $(this).attr('data-popup-btn') || ''
				});
			} else {
				_this.video(id, {
					video: $(this).attr('data-popup-video')
				});
			}
		});
		// * Close popup clicking on cross
		$(document).on('click', '.popup__close, [data-popup-close]', function() {
			_this.close();
		});
		// * Close popup clicking outside popup
		$(document).on('click', '.popup', function(e) {
			if (!$(e.target).closest('.popup__content').length) {
				_this.close();
				e.stopPropagation();
			}
		});
		// * Close popup pressing ESC
		$(document).on('keyup', function(e) {
			if (e.key === 'Escape') {
				if (app.settings.popupOpened) {
					_this.close();
				}
			}
		});
	},
	/*
	 * Open popup
	 */
	open(id, opts) {
		let _this = this;
		if ($('#' + id).length) {
			$('body').addClass('app--popup-opened');
			app.scrollLock();
			$('.popup').removeClass('active');
			let popup = $('.popup#' + id);
			if (popup.attr('data-overlay')) {
				_this.overlay.css('--overlay-color', popup.attr('data-overlay'));
			}
			if (id == 'request') {
				let ttl = opts?.ttl ?
					opts.ttl :
					'Оставить заявку',
					text = opts?.text ?
					opts.text :
					'Оставьте заявку, и&nbsp;наш специалист свяжется с&nbsp;вами в&nbsp;ближайшее время',
					btn = opts?.btn ?
					opts.btn :
					'Отправить';
				popup.find('.popup-head__title').html(ttl);
				popup.find('.popup-head__subtitle').html(text);
				popup.find('.ui-btn__text').html(btn);
			}
			popup.scrollTop(0).addClass('active');
			app.settings.popupOpened = true;
		}
	},
	/*
	 * Open video popup
	 */
	video(id, opts) {
		let _this = this;
		_this.open(id);
		if ($('#' + id).length && opts?.video) {
			let popup = $('.popup#' + id);
			popup
				.find('.popup__video')
				.html(`<iframe src="${opts.video}" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>`);
		}
	},
	/*
	 * Load popup content
	 */
	load(id, url) {
		let _this = this;
		if (!_this.loaded.includes(url)) {
			$('#' + id).find('.popup__load').load(url, function(response, status, xhr) {
				if (status == 'error') {
					$('#' + id).find('.popup__load').html(`Ошибка: ${xhr.status} ${xhr.xhr}`)
				}
			});
			_this.loaded.push(url);
		}
		_this.open(id);
	},
	/*
	 * Close popups
	 */
	close() {
		let _this = this;
		$('.popup').removeClass('active');
		$('.app').removeClass('app--popup-opened');
		setTimeout(function() {
			app.scrollLock('unlock');
			_this.overlay.css('--overlay-color', '');
		}, app.settings.animDuration);
		$('.popup__video').html('');
		app.settings.popupOpened = false;
	},
	/*
	 * TY popup
	 */
	thx(thx) {
		if (!thx) {
			thx = 'thx';
		}
		this.open(thx);
		$('.popup .ui-form').each(function() {
			app.forms.clear($(this));
		});
	},
	/*
	 * Init
	 */
	init(popup) {
		let mod = popup.attr('data-close') ? popup.attr('data-close') : '';
		popup.find('.popup__close-container')
			.prepend(`<div class="ui-crossbtn popup__close ${mod} noselect" />`);
		popup.data('popupsInit', true);
	}
}
/*

 * Waypoints

 */
app.waypoint = (opts) => {
	let _this = this,
		position = 0;
	opts = $.extend({
		position: 0,
		onDown: function() {},
		onUp: function() {}
	}, opts);
	$(window).on('resize', function() {
		if (typeof opts.position == 'function') {
			position = opts.position.call();
		} else {
			position = opts.position;
		}
	}).on('scroll', function() {
		if ($(window).scrollTop() > position) {
			if (typeof opts.onDown == 'function') {
				opts.onDown.call();
			}
		} else {
			if (typeof opts.onUp == 'function') {
				opts.onUp.call();
			}
		}
	}).trigger('resize').trigger('scroll');
}
/*

 * Checking if browser supports webp

 */
function testWebP(callback) {
	let webP = new Image();
	webP.onload = webP.onerror = function() {
		callback(webP.height == 2);
	};
	webP.src = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA";
}
testWebP(function(support) {
	if (support == true) {
		document.querySelector('html').classList.add('_webp');
	} else {
		document.querySelector('html').classList.add('_no-webp');
	}
});
/*
 * Init
 */
app.init = () => {
	// * Units
	app.units.all();
	// * Header
	if ($('.page__top').hasClass('page__top--s')) {
		$('.header').addClass('header--bg');
	} else {
		$('.header').removeClass('header--bg');
	}
	// * Masonry fix
	app.masonry();
	// * Intro
	$('.intro').each(function() {
		if (!$(this).data('introInit')) {
			app.intro($(this));
		}
	});
	// * Tabs
	$('.ui-tabs').not('.custom').each(function() {
		if (!$(this).data('tabsInit')) {
			app.tabs.init($(this));
		}
	});
	app.tabs.bind();
	// * Expandable blocks
	$('.ui-expand').not('.custom').each(function() {
		if (!$(this).data('expandInit')) {
			app.expand($(this));
		}
	});
	// * Popups
	$('.popup').each(function() {
		if (!$(this).data('popupsInit')) {
			app.popups.init($(this));
		}
	});
	app.popups.bind();
	// * Sticky sidebar
	$('.ui-layout__side').each(function() {
		if (!$(this).data('stickySideInit')) {
			app.stickySide($(this));
		}
	});
	// * Distortion
	$('.distortion').each(function() {
		if (!$(this).data('distorInit')) {
			app.distor($(this));
		}
	});
	// * Related
	$('.related').each(function() {
		if (!$(this).data('relatedInit')) {
			app.related($(this));
		}
	});
	// * Info block
	$('.ui-info').each(function(i) {
		if (!$(this).data('infoInit')) {
			app.info($(this), i);
		}
	});
	// * Input masks
	$('input[name="phone"], .phone-input').each(function() {
		if (!$(this).data('maskInit')) {
			app.mask.phone($(this));
		}
	});
	// * Animate on scroll
	$(document).on('app.loaded', function() {
		$('.onscroll').each(function() {
			if ($(this).data('onscrollInit') !== true) {
				app.onscroll($(this));
			}
		});
	});
	// * Scroll to hash on page laod
	app.toHash();
}
app.deviceIs.addClasses(document.documentElement);
$.fancybox.defaults.backFocus = false;
$.fancybox.defaults.hash = false;
$.fancybox.defaults.beforeShow = function() {
	app.scrollLock();
};
$.fancybox.defaults.afterClose = function() {
	app.scrollLock('unlock');
};
(function() {
	app.deviceIs.touch ? $('html').addClass('touch') : $('html').addClass('no-touch');
	app.settings.winWidth = $(window).width();
	app.settings.winHeight = $(window).height();
	app.settings.scrollPos = $(window).scrollTop();
	app.settings.scrollOffset = function() {
		return $('.header').outerHeight();
	};
	// * Init
	app.init();
	// * Menu
	app.menu.bind();
	//app.popups.open('offer');
	$(document).on('click', '.ui-field__legend', function() {
		$(this).closest('.ui-field').find('input, textarea').trigger('focus');
	});
	$(document).on('click', '.ui-layout__menu-btn', function() {
		$(this).closest('.ui-layout__menu').toggleClass('active');
	});
	app.waypoint({
		position: 1,
		onDown: function() {
			$('.app').addClass('app--scrolled');
			$('.header').addClass('header--scrolled');
		},
		onUp: function() {
			$('.app').removeClass('app--scrolled');
			$('.header').removeClass('header--scrolled');
		}
	});
	if (app.deviceIs.desktop) {
		$(window).on('resize', function() {
			app.units.all();
		});
	} else {}
	if (app.deviceIs.mobile || app.deviceIs.tablet) {
		$(window).on('orientationchange', function() {
			app.units.vh();
		}).on('resize', function() {
			app.units.mobile();
		});
	}
	$(window).on('resize', function() {
		app.settings.winWidth = $(window).width();
		app.settings.winHeight = $(window).height();
		app.settings.scrollPos = $(window).scrollTop();
		app.settings.menuOpened ? app.menu.close() : null;
	}).on('scroll', function() {
		app.settings.scrollPos = $(window).scrollTop();
	}).trigger('resize').trigger('scroll');
	// * Scroll to element
	$(document).on('click', 'a[href^="#"], .scrollTo', function(e) {
		e.preventDefault();
		let el = $(this).attr('href') || $(this).attr('data-scrollto-target');
		app.scrollTo(el, app.settings.scrollOffset);
	});
})(jQuery);
$(window).on('load', function() {
	setTimeout(function() {
		// * hide preloader
		$('.preloader').fadeOut(1000, function() {
			$(this).remove();
		});
		$('.app').addClass('app--loaded');
		app.settings.pageLoaded = true;
		$(document).trigger('app.loaded');
		$(window).trigger('scroll');
	}, 300);
	// * Smooth scroll
	if (!app.scroll.inited) {
		app.scroll.init();
	}
});